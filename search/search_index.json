{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CSE 491 Capstone Project Fall 2023","text":""},{"location":"DataCollection/","title":"Group 2 Data Collection","text":""},{"location":"DataCollection/#datacollection-namespace","title":"DataCollection Namespace","text":"<p>The DataCollection namespace provides a set of classes and templates for managing and processing data related to agent actions and positions. This library offers flexibility and ease of use for storing, retrieving, and manipulating data within your C++ applications.</p>"},{"location":"DataCollection/#classes","title":"Classes","text":"<ol> <li>AgentData</li> </ol> <p>The <code>AgentData</code> class represents data collected for an agent, including their name, actions, positions, and associated IDs.</p> <p>Methods:    - <code>StorePositions(cse491::GridPosition pos)</code>: Stores a grid position for the agent.    - <code>StoreAction(std::unordered_map&lt;std::string, size_t&gt; action)</code>: Stores an action for the agent.    - <code>StoreAgentId(int id)</code>: Stores an agent ID associated with an action.    - <code>GetActions() -&gt; std::vector&lt;std::unordered_map&lt;std::string, size_t&gt;&gt;&amp;</code>: Retrieves the stored actions.    - <code>SetActions(const std::vector&lt;std::unordered_map&lt;std::string, size_t&gt;&gt;&amp; newActions)</code>: Sets the stored actions to a new set of actions.    - <code>GetPositionSize() const -&gt; int</code>: Gets the size of the stored grid positions.    - <code>GetAgentIds() const -&gt; std::vector&lt;int&gt;</code>: Gets the agent IDs associated with the stored actions.</p> <ol> <li>DataReceiver\\&lt;T&gt;</li> </ol> <p>The <code>DataReceiver</code> class template provides a generic way to store and retrieve data objects of a specified type.</p> <p>Methods:    - <code>StoreData(T obj)</code>: Stores a data object of type T.    - <code>getStorage() -&gt; std::vector&lt;T&gt;&amp;</code>: Retrieves the stored data objects.</p> <ol> <li>AgentReceiver</li> </ol> <p>The <code>AgentReceiver</code> class extends <code>DataReceiver&lt;AgentData&gt;</code> and provides specific functionality for storing <code>AgentData</code> objects along with grid positions and last action IDs.</p> <p>Methods:    - <code>StoreData(cse491::GridPosition pos, int last_action)</code>: Stores a grid position and last action ID associated with an agent.    - <code>GetPositionSize() -&gt; int</code>: Gets the position size of the last stored <code>AgentData</code> object.    - <code>IsEmpty() -&gt; bool</code>: Checks if the storage is empty.</p>"},{"location":"DataCollection/#usage","title":"Usage","text":"<p>To use the DataCollection namespace in your C++ application, include the appropriate header files and create instances of the classes as needed. Make sure to follow the specific methods and their parameters as outlined in the class descriptions above.</p> <pre><code>#include &lt;DataCollection/AgentData.h&gt;\n#include &lt;DataCollection/DataReceiver.h&gt;\n#include &lt;DataCollection/AgentReceiver.h&gt;\n\n// Example Usage\nDataCollection::AgentData agent;\nagent.StorePositions(cse491::GridPosition(1, 2));\nagent.StoreAction({{\"up\", 1}});\nagent.StoreAgentId(101);\n\nDataCollection::AgentReceiver agentReceiver;\nagentReceiver.StoreData(cse491::GridPosition(3, 4), 102);\nint positionSize = agentReceiver.GetPositionSize();\nbool isEmpty = agentReceiver.IsEmpty();\n</code></pre>"},{"location":"DataCollection/#installation","title":"Installation","text":"<p>To use this library, simply include the necessary header files in your project. Ensure that you have C++11 or later enabled in your compiler settings.</p>"},{"location":"DataCollection/#contributing","title":"Contributing","text":"<p>Feel free to contribute by reporting issues, suggesting features, or submitting pull requests. We welcome any contributions that can improve the functionality, performance, or usability of this library.</p>"},{"location":"DataCollection/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE.md file for details.</p>"},{"location":"Group%201%20-%20README/","title":"Group 1: Agent Library Function Descriptions","text":"<p>Below is a set of classes and functions designed to create multiple different Agents with various functionalities.</p> <p>Path Agent </p> <p>Agent that has a user-defined custom movement pattern passed a sequence to be sequentially applied as the agent is updated</p> <ul> <li> <p>Constructor with <code>std::vector</code></p> <ul> <li>param <code>id</code>: unique agent id</li> <li>param <code>name</code>: name of path agent</li> <li>param <code>offsets</code>: collection of offsets to move the agent <code>PathAgent(size_t id, std::string const&amp; name, std::vector&lt;cse491::GridPosition&gt; &amp;&amp; offsets = {}) : cse491::AgentBase(id, name), offsets_(offsets);</code></li> </ul> </li> <li> <p>Constructor with <code>std::string</code></p> <ul> <li>param <code>id</code>: unique agent id</li> <li>param <code>name</code>: name of path agent</li> <li>param <code>commands</code>: sequence of commands to be interpreted as offsets <code>PathAgent::PathAgent(size_t id, std::string const&amp; name, std::string_view commands) : cse491::AgentBase(id, name), offsets_(str_to_offsets(commands))</code></li> </ul> </li> <li> <p>Initializer</p> <ul> <li>Checks that the agent is able to freely change its own grid location.         Verifies that it can currently index into a valid offset</li> <li>return: <code>true</code> if so; <code>false</code> otherwise. <code>bool PathAgent::Initialize();</code></li> </ul> </li> <li> <p>Select Action</p> <ul> <li>Moves the agent by applying the current offset</li> <li>param <code>WorldGrid</code>: reference grid</li> <li>param <code>type_options_t</code>: type options</li> <li>param <code>item_set_t</code>: set of items</li> <li>param <code>agent_set_t</code>: agent set <code>size_t PathAgent::SelectAction(const WorldGrid &amp; /* grid*/, const type_options_t &amp; /* type_options*/, const item_set_t &amp; /* item_set*/, const agent_set_t &amp; /* agent_set*/)</code></li> </ul> </li> <li> <p>Set Properties with <code>std::vector</code></p> <ul> <li>Assigns the offsets_member to a new series of offsets</li> <li>param <code>offsets</code>: collection of grid positions used as the new offsets</li> <li>param <code>start_index = 0</code>: which offset to start indexing into (beginning by default)</li> <li>return: <code>self</code></li> <li>Attention: throws an <code>std::invalid_argument</code> when an invalid start index is provided <code>PathAgent&amp; PathAgent::SetProperties(std::vector&lt;cse491::GridPosition&gt; &amp;&amp; offsets, size_t start_index = 0)</code></li> </ul> </li> <li> <p>Set properties with <code>std::string</code></p> <ul> <li>Assigns the offsets_ member to a new series of offsets, taking a command string</li> <li>param <code>commands</code>: formatted string of commands used as offsets</li> <li>param <code>start_index = 0</code>: which command to begin indexing into (first command by default)</li> <li>return: <code>self</code></li> <li>Attention: throws an <code>std::invalid_argument</code> when mis-formatted commands an invalid index is provided <code>PathAgent&amp; PathAgent::SetProperties(std::string_view commands, size_t start_index = 0)</code></li> </ul> </li> <li> <p>Helper function for a formatted <code>std::string</code> input</p> <ul> <li>Converts a string to a sequence of offsets</li> <li>This convenience method takes a string with a special formatting that allows one to specify a sequence of inputs in linear directions.</li> <li>The format is [steps[*]] where <code>steps</code> is a positive integer and optional (assumed to be 1 by default) <li>star <code>*</code> represents scaling the movement by <code>steps</code>. Optional, but cannot be used if <code>steps</code> is not provided<ul> <li>if the star is not present, then <code>steps</code> individual offsets are created in the direction <code>direction</code></li> </ul> </li> <li>Example: \"n w 3e 10s 5w x\" should create the sequence of offsets<ul> <li><code>{-1, 0}, {0, 1}, {0, -1}, {0, -1}, {0, -1}, {10, 0}, {0, 5}, {0, 0}</code></li> </ul> </li> <li>param <code>commands</code>: string in a format of sequential directions</li> <li>note: throws an <code>std::invalid_argument</code> when input string is poorly formatted</li> <li>note: this includes when a negative integer is passed as <code>steps</code>. If a zero is used, treated as the default (one)</li> <p><code>static std::vector&lt;cse491::GridPosition&gt; str_to_offsets(std::string_view commands)</code></p> <p>More agents to be documented...</p>"},{"location":"Group_7/","title":"Group 7 : Genetic Programming Agents","text":"<p>authors: Aman, Simon, Rajmeet, Jason</p> <p></p> <p>(Img: Rajmeet, Simon, Jason, Aman) </p>"},{"location":"Group_7/#introduction","title":"Introduction","text":""},{"location":"Group_7/#gp-agent-base-class","title":"GP Agent Base Class","text":""},{"location":"Group_7/#lgp-agent","title":"LGP Agent","text":""},{"location":"Group_7/#cgp-agent","title":"CGP Agent","text":""},{"location":"Group_7/#gp-loop","title":"GP Loop","text":""},{"location":"Group_7/#it-runs-on-my-machine","title":"It runs on my machine","text":"<p>we have used cmake to ensure that our code compiles on all platforms. but.... we have tested our code on the following machines/architectures: - Windows 11 - Windows 10 - Ubuntu 20.04 - HPCC Cluster Centos7 - MacOS Sonoma (ARM) - mlcollard/linux-dev (Docker Container)</p> <p>Tested in the following IDEs: - CLion - VSCode</p> <p>Tested on the following compilers: - gcc 9.3.0 - Apple clang 12.0.0 - LLVM clang 11.0.0</p>"},{"location":"Group_7/#profiled-with-and-optimized-with","title":"Profiled with and optimized with:","text":"<ul> <li> <p>clion profiler / </p> </li> <li> <p>Xcode instruments  </p> </li> <li> <p>intel vtune  </p> </li> <li> <p>very sleepy Didnt deserve a screenshot. /s</p> </li> <li> <p>code coverage in clion   </p> </li> </ul>"},{"location":"Group_7/#sanitized-with","title":"Sanitized with:","text":"<ul> <li>clang sanitizer Memory</li> <li>valgrind</li> <li>gcc sanitizer Memory</li> <li>gcc sanitizer address</li> <li>Used to find and fix memory UB in the code.   </li> </ul>"},{"location":"Group_7/#other-contributions","title":"Other Contributions","text":""},{"location":"Group_7/#easylogging","title":"EasyLogging","text":"<p>Created a logging class that is can be used to log debug messages in debug mode. Teams can be specified to log with different levels of verbosity. This is useful for debugging and profiling.</p>"},{"location":"Group_7/#cmake","title":"CMake","text":"<p>Initial cmake setup for the project. This is useful for cross platform compilation and testing.</p>"},{"location":"Group_7/#serializationusingtinyxml2","title":"serializationUsingTinyXML2","text":"<p>Created and tested a serialization class that can be used to serialize and deserialize objects to and from xml files. This is useful for saving and loading the state of the GP agents. Implemented serialization pattern using tinyxml2 library.</p>"},{"location":"Group_7/#mkdocs-documentation","title":"mkdocs documentation","text":"<p>Created and tested a mkdocs documentation for the project. This is useful for creating a website for the project.</p>"},{"location":"HowToAssembleAMain/","title":"How to Assemble a Main","text":"<p>Once you have your Agents, World, and Interface picked out, it's easy to assemble them into an <code>main()</code> function that you can turn into a working executable.</p> <p>Create the appropriate .cpp file, and follow these steps:</p> <ol> <li>Include all of the modules that you will be using.  In the case of <code>simple_main.cpp</code> this looks like:</li> </ol> <pre><code>#include \"Agents/PacingAgent.hpp\"\n#include \"Interfaces/TrashInterface.hpp\"\n#include \"Worlds/MazeWorld.hpp\"\n</code></pre> <ol> <li>Inside your <code>main()</code> function, start by building your world.  It should look something like:</li> </ol> <pre><code>main() {\n  cse491::MazeWorld world;\n</code></pre> <p>Some world types may be able to take arguments to their constructors, but most probably won't.</p> <ol> <li>Add in your agents using the <code>AddAgent</code> member function, specifying the type of agent with a template argument and the agent's name as a regular argument.  <code>AddAgent</code> will return a reference to the new agent, so you can immediately modify it, such as by setting its position.</li> </ol> <pre><code>  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 1\").SetPosition(3,1);\n  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 2\").SetPosition(6,1);\n</code></pre> <p>Furthermore, AddAgent can take additional parameters to set properties BEFORE configuration is run. For example, if you want to set stats for strength and speed, you could do something like:</p> <pre><code>  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 1\", \"strength\", 1.0, \"speed\", 5.5).SetPosition(3,1);\n  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 2\", \"strength\", 8.6, \"speed\", 1.2).SetPosition(6,1);\n</code></pre> <p>This will allow you to change what you do in agent configuration based on the properties provided.</p> <ol> <li>Add in your interface as a type of agent.  For example:</li> </ol> <pre><code>  world.AddAgent&lt;cse491::TrashInterface&gt;(\"Interface\").SetProperty(\"char\", '@');\n</code></pre> <p>This will set up any \"player\" characters.</p> <ol> <li>Launch the run using <code>world.Run();</code>.</li> </ol>"},{"location":"HowToAssembleAMain/#what-if-i-want-to-collect-extra-data-for-analysis","title":"What if I want to collect extra data for analysis?","text":"<p>If you want to track the agents and the world during a run, you will skip step 5 above and instead manually run the agents and update the world, collecting data as you go.</p> <p>For example, in place of <code>world.Run();</code> you could have:</p> <pre><code>  while (!world.GetRunOver()) {\n    world.RunAgents();\n    world.UpdateWorld();\n    // Collect extra data about the world here!\n  }\n</code></pre> <p>You should have access to all of the basic data in the world; we may need to expand the API to provide access if you don't have everything you need.</p>"},{"location":"HowToAssembleAMain/#compiling-a-main","title":"Compiling a main","text":"<p>By default, any <code>.cpp</code> files in <code>/source/</code> (not in subdirectories) should be automatically detected and compiled with CMake (see <code>HowToCompile.md</code>).</p> <p>If your main requires other source files (i.e., other <code>.cpp</code> files), you will also need to make a <code>.cmake</code> file.  For example, <code>example.cpp</code> would need a <code>example.cmake</code> file. </p> <p>This <code>.cmake</code> file will give you fine-grained control over the compilation process of your main file. To add extra source files, simply add new lines like so: </p> <pre><code>add_source_to_target(${EXE_NAME} \"source/Agents/PathAgent.cpp\")\n</code></pre> <p>The <code>${EXE_NAME}</code> argument should NOT change, as it is a variable from the other CMake infrastructure.  You will, however, need to update the other argument, which a string to the other source file you want to compile and link against. You will need one copy of this line for each source file you need to include. </p>"},{"location":"HowToBuildAWorld/","title":"How to Build A World","text":"<p>When building your own world, the first steps are boilerplate:</p> <ol> <li> <p>Include the WorldBase file If you're in the Worlds/ directory, do this with: <code>#include \"../core/WorldBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your world class, making sure to derive it from <code>WorldBase</code>.  Something like <code>class MYWorld : public WorldBase {</code>, but of course use your world name instead of \"MYWorld\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member variables that your world might use.  Additionally, you need to set up some internal functionality.  Specifically:</p> <ol> <li> <p>Create a enumeration where you will list all of the action types available to an agent.  The first action should always be a \"do nothing\" action and explicitly set to zero.  For example: <code>enum ActionType { REMAIN_STILL=0, MOVE_UP, MOVE_DOWN, MOVE_LEFT, MOVE_RIGHT };</code></p> </li> <li> <p>Add a <code>ConfigAgent</code> function that provides a new agent with a list of the actions that it has available.  For example:</p> </li> </ol> <pre><code>    /// Provide the agent with movement actions.\n    void ConfigAgent(AgentBase &amp; agent) override {\n      agent.AddAction(\"up\", MOVE_UP);\n      agent.AddAction(\"down\", MOVE_DOWN);\n      agent.AddAction(\"left\", MOVE_LEFT);\n      agent.AddAction(\"right\", MOVE_RIGHT);\n    }\n</code></pre> <p>In the public section of the class, you need to build a few more functions:</p> <ol> <li>A default constructor (i.e., <code>MYWorld() { ... }</code>).  You should do any normal set up for this world, including the member variables that you created above.  You should also specify the type options and initialize the <code>main_grid</code> for this world.</li> <li>Specify the type options with the <code>AddCellType</code> function, which is defined in the base class.     <code>AddCellType(\"dirt\", \"Regular ground\", ' ');     AddCellType(\"tree\", \"A tall tree\", '^');     AddCellType(\"river\", \"Flowing water\", '~');</code></li> <li> <p>An easy way to initialize the <code>main_grid</code> is to use the <code>Read()</code> member function on <code>WorldGrid</code> to load the grid from a file.  For example: <code>main_grid.Read(\"../assets/grids/MYWorld.grid\", type_options);</code></p> </li> <li> <p>Add a destructor (i.e., <code>~MYWorld() { ... }</code>).  This function only needs to have a body if you need to clean up one of the member variables you added.</p> </li> <li> <p>Build <code>int DoAction(AgentBase &amp; agent, size_t action_id) override { ... }</code> for your new world.  This function will be run automatically whenever an agent takes an action, specifying both the agent and action involved.</p> </li> </ol> <p>Finally you need to build a main file that initializes this world, add any needed agents (either autonomous agents or interfaces), and run.</p>"},{"location":"HowToBuildAWorld/#member-variables-inherited-from-worldbase","title":"Member variables inherited from <code>WorldBase</code>","text":"<p><code>WorldBase</code> has a lot of boilerplate functionality though almost all of it can be replaced in a derived world.</p> <p>There are five member variables maintained in the world: - <code>WorldGrid main_grid</code> - the \"main\" world that is passed to agents by default.  You may maintain additional grids if you choose, and may decide which one of these is seen by an agent. - <code>type_options_t type_options</code> - a vector of <code>CellType</code> information, which specifies the name of each cell, its description, and an (optional) ASCII symbol associated with it.  The position in this vector it he ID of a cell type. - <code>item_set_t item_set</code> - a vector of pointers to all of the \"items\" in this world.  The world can define and use items however it likes, though they should be type <code>cse491::Entity</code>.  Like agents, items can have arbitrary properties. - <code>agent_set_t agent_set</code> - a vector of all agents currently active in the world. - <code>bool run_over</code> - a value that defaults to false, but if you change it to true the run will terminate at the end of the current iteration.</p>"},{"location":"HowToBuildAWorld/#working-with-properties","title":"Working with properties","text":"<p>Agents can have arbitrarily named properties; worlds can add properties to the agents, and modify the (<code>double</code>) value associated with that property at any time.</p> <p>To add a property, simply give it a value, such as <code>agent.SetProperty(\"property_name\", value)</code> where <code>value</code> is a floating point number (it will default to 0.0 if you don't include it.)  This might be a good way to add \"hit points\" or \"size\" to agents.  You can alter what happens to an agent based on these properties; if an agent's hit points reach zero, you might kill it off.</p> <p>You can always set properties to new values later, or use <code>agent.HasProperty(\"property_name\")</code> to test if an agent has a property or <code>agent.GetProperty(\"property_name\")</code> to read its value.</p> <p>If at any point you want to remove a property, you can do so with <code>agent.RemoveProperty(\"property_name\")</code>.  For example, you might have a property called \"invisible\" that you add to an agent when it vanishes, but you remove when it reappears.</p> <p>For properties that you want agents to always possess, it's probably a good idea to set them in the <code>ConfigAgent()</code> function.</p>"},{"location":"HowToBuildAWorld/#providing-limited-data-to-agents","title":"Providing limited data to agents","text":"<p>Some worlds will want to provide agents with limited data, perhaps only showing rooms that the agent is currently in or items/agents nearby. To do this, the world will be responsible for producing or maintaining the alternate data structures and those are the ones that should be passed to agents when they are called.</p> <p>The default version of the function <code>WorldBase::RunAgents()</code> will use the full information provided in the world, but this is a virtual function.  If you override it in your derived class, you simply need to step through all of the agents and run <code>SelectAction</code> on each with the revised arguments.  (Of course, after each action is selected, make sure to also run <code>DoAction</code> and <code>SetActionResult</code> for each, as per the base class.)</p>"},{"location":"HowToBuildAWorld/#managing-non-agent-activities-in-the-world","title":"Managing non-agent activities in the world","text":"<p>In some worlds, you may want events happening in the background, independent of agents.  For example, crops might grow, seasons might change, or weather might occur. To manage these non-agent events, you simply need to override <code>UpdateWorld()</code> in your derived class.  Every time each agent is run (in the <code>Run()</code> function) UpdateWorld() is then called.  If you need a different balance for <code>UpdateWorld()</code> (perhaps you need it to go after every agent) simply override the Run() function in your derived World class.</p>"},{"location":"HowToBuildAnAgent/","title":"How to Build an Autonomous Agent","text":"<p>When building your own agent, the first steps are boilerplate:</p> <ol> <li> <p>Include the AgentBase file If you're in the Agents/ directory, do this with: <code>#include \"../core/AgentBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your agent class, making sure to derive it from <code>AgentBase</code>.  Something like <code>class MYAgent : public AgentBase {</code>, but of course use your agent name instead of \"MYAgent\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member variables that your agent might use.  Remember that you also have the option of using agent properties (see below) instead of private variables if you want the values to be accessible to other modules.</p> <p>In the public section, you should create:</p> <ol> <li> <p>A constructor and destructor, as needed for your implementation (agents are not required to have any specific code here.)</p> </li> <li> <p>An Initialize function that gets run after the agent has been configured by the world.  This will allow an agent to set itself up based on the actions that were provided by the world.  This function has the format <code>bool Initialize() override {...}</code> and should return <code>false</code> if it detected a problem during initialization (such as a required action name is not available).</p> </li> <li> <p>A <code>SelectAction</code> function that identifies the action that the organism will take. The format for <code>SelectionAction</code> is:</p> </li> </ol> <pre><code>    size_t SelectAction(const WorldGrid &amp; grid,\n                        const type_options_t &amp; type_options,\n                        const item_set_t &amp; item_set,\n                        const agent_set_t &amp; agent_set) override\n    {\n      // An agent should use their current state as well as the provided\n      // grid, type_options, item_set, and agent set to decide next action.\n    }\n</code></pre> <p>The arguments passed in to <code>SelectAction</code> will be the full set of possibilities by default (i.e., the full grid, all type options, all items, and all agents), but some worlds may choose to maintain more limited versions of these variables containing only what an organism currently knows about.  In such cases it would be these more limited version that would be passed in to the function.</p> <p>As part of their current state, agents have two relevant member variables inherited from their base class.  (1) A map of strings to action IDs called <code>action_map</code>, that indicates which value to return to take an action by a given name, and (2) an <code>int</code> called <code>action_result</code> that indicates the results of their last action.  Usually <code>action_result</code> will be 1 or 0 to indicate success or failure of that action.</p>"},{"location":"HowToBuildAnAgent/#agent-properties","title":"Agent Properties","text":"<p>While properties are typically added to agents from a World, they are technically allowed to add properties to themselves, typically in their own constructor.  These properties might be ones that affect the behavior of the agents, but should also be accessible from outside of the Agent class itself.</p> <p>For example, you might want to put <code>double facing = 1.0;</code> inside the private section if facing should only ever be used by this class.  Alternatively you can put <code>SetProperty(\"facing\", 1.0);</code> in the constructor if you want it accessible to the world.  Any other class would be able to run <code>agent.HasProperty(\"facing\")</code> to determine if the property exists in <code>agent</code>, or <code>agent.GetProperty(\"facing\")</code> to retrieve its value.</p>"},{"location":"HowToBuildAnInterface/","title":"How to Build an Interface","text":"<p>When building your own interface, the first steps are boilerplate:</p> <ol> <li> <p>Include the InterfaceBase file If you're in the Interfaces/ directory, do this with: <code>#include \"../core/InterfaceBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your Interface class, making sure to derive it from <code>InterfaceBase</code>.  Something like <code>class MYInterface : public InterfaceBase {</code>, but of course use your Interface name instead of \"MYInterface\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member functions or variables that your interface might use.  I recommend a series of helper functions, such as a <code>DrawGrid</code> function to display the current state of the world.</p> <p>In the public section, you should create:</p> <ol> <li> <p>A constructor and destructor, as needed for your implementation.  Interfaces will likely need to do substantial setup in the constructor and teardown in the destructor.</p> </li> <li> <p>Add an Initialize function. This gets run after the interface has been configured by the world, thus you will have access to all of the available actions in order to map them to buttons or other inputs.  This function has the format <code>bool Initialize() override {...}</code> and should return <code>true</code> as long as everything initialized correctly (false otherwise).</p> </li> <li> <p>A <code>SelectAction</code> function that presents to the user the current state of the world and then reports back the next action for the user's agent should take. The format for <code>SelectionAction</code> is:</p> </li> </ol> <pre><code>    size_t SelectAction(const WorldGrid &amp; grid,\n                        const type_options_t &amp; type_options,\n                        const item_set_t &amp; item_set,\n                        const agent_set_t &amp; agent_set) override\n    {\n      // An interface should keep track of the user's actions and report them\n      // back.  If the system is not supposed to wait for the user (i.e., real\n      // time) then return a zero any time the user has not selected an action.\n    }\n</code></pre> <p>The arguments passed in to <code>SelectAction</code> will be the full set of possibilities by default (i.e., the full grid, all type options, all items, and all agents), but some worlds may choose to maintain more limited versions of these variables containing only what an organism currently knows about.  In such cases it would be these more limited version that would be passed in to the function.</p> <p>As part of their current state, agents have two relevant member variables inherited from their base class.  (1) A map of strings to action IDs called <code>action_map</code>, that indicates which value to return to take an action by a given name, and (2) an <code>int</code> called <code>action_result</code> that indicates the results of their last action.  Usually <code>action_result</code> will be 1 or 0 to indicate success or failure of that action.</p>"},{"location":"HowToCompile/","title":"How to Compile","text":"<p>First you'll need to clone the repo with submodules. </p> <p>If you haven't yet cloned the repo, run: </p> <pre><code>git clone https://github.com/MSU-CSE491/cse_491_fall_2023.git --recursive\n</code></pre> <p>If you have already cloned the repo, but you need to download the submodules, run the following inside the repo's directory:</p> <pre><code>git submodule init\ngit submodule update\n</code></pre> <p>Now jump to the section for your operating system.</p>"},{"location":"HowToCompile/#compiling-under-linux","title":"Compiling under Linux","text":"<p>If you're on a Linux machine, you first need to download some dependencies for SFML.  Specifically, you need:  - freetype - x11 - xrandr - udev - opengl - flac - ogg - vorbis - vorbisenc - vorbisfile - openal - pthread</p> <p>If you're on Ubuntu or other similar Debian distro, you can run the following: </p> <pre><code>sudo apt install libX-dev\n</code></pre> <p>For library X. </p> <p>Once you have all dependencies downloaded, navigate to the root of the repo and run the following to build: </p> <pre><code>mkdir cmake-build-release\ncd cmake-build-release\ncmake -DCMAKE_BUILD_TYPE=Release ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory.  Note that <code>Debug</code> can be swapped with <code>Release</code> or <code>Test</code> here.</p>"},{"location":"HowToCompile/#compiling-under-macos","title":"Compiling under MacOS","text":"<p>Mac shouldn't require any additional dependencies, so simply run the following, starting at the root of the repo:</p> <pre><code>mkdir cmake-build-release\ncd cmake-build-release\ncmake -DCMAKE_BUILD_TYPE=Release ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory. </p>"},{"location":"HowToCompile/#compiling-under-windows-with-mingw","title":"Compiling under Windows with MinGW","text":"<p>After you have the repo and submodules downloaded, we need to ensure you have MinGW and CMake. In a command line window, try running <code>g++</code> and <code>cmake</code>, if either give a \"command not found\" message, then we need to install them. </p> <p>MinGW gives us g++, and can be downloaded here: https://winlibs.com/</p> <p>CMake can be downloaded from here: https://cmake.org/download/</p> <p>Note: You'll likely need to add both MinGW's and CMake's <code>bin</code> folder to your path (I think CMake has a <code>bin</code> directory, otherwise add whatever directory contains the executable).  To add a directory to your path, follow these instructions: https://www.architectryan.com/2018/03/17/add-to-the-path-on-windows-10/ Note that you may run into issues if the directories you're adding have spaces in their paths (e.g., \"C:\\Program Files...\" was giving me issues). If you run into this, I'd recommend creating a new directory on your <code>C:\\</code> drive, like <code>C:\\bin\\</code> and then add CMake and MinGW as subdirectories there. </p> <p>Once you have CMake and MinGW working in your terminal (note you'll have to restart cmd/VSCode/whatever to get the path changes to take effect), run the following from the root of your repo:</p> <pre><code>mkdir build-build-release\ncd build-build-release\ncmake -DCMAKE_BUILD_TYPE=Release -G \"MinGW Makefiles\" ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory. </p> <p>Note that if you tried to build using CMake before, it likely tried to use MSVC as a compiler. If so, just wipe the build folder and start fresh. </p>"},{"location":"HowToCompile/#how-to-compile-in-debug-mode","title":"How to compile in debug mode","text":"<p>First, it is recommended you build debug and release modes in separate directories.  To follow CLion's lead, you can create both <code>cmake-build-debug</code> and <code>cmake-build-release</code>. This will prevent you from needing to recompile Catch and SFML when you switch between debug and release!</p> <p>To compile in debug mode, change the build type to debug via <code>-DCMAKE_BUILD_TYPE=Debug</code> in the first cmake command. </p> <p>This would normally look like: </p> <pre><code>cmake -DCMAKE_BUILD_TYPE=Debug ..\n</code></pre> <p>Unless you're on Windows, which would be:</p> <pre><code>cmake -DCMAKE_BUILD_TYPE=Debug -G \"MinGW Makefiles\" ..\n</code></pre> <p>You can then build like normal. </p> <p>Note that you can also replace <code>Debug</code> with <code>Test</code> to run only the unit tests.</p>"},{"location":"HowToOverview/","title":"How-To Guides","text":"<p>Below are a set of guides for how to develop your own modules and joining them together into an executable (potentially with additional analysis and data collection.)</p> <ul> <li> <p>How to compile - Walks through how to compile via CMake.</p> </li> <li> <p>How to Build an Agent - A guide to designing your own type of autonomous agent.</p> </li> <li> <p>How to Build a World - A guide to designing you own world with custom interaction modes among agents and other environmental properties.</p> </li> <li> <p>How to Build an Interface - How to build an interface that allows a human user to control an agent.</p> </li> <li> <p>How to Assemble a <code>main()</code> function - A guide to selecting worlds, agents, and interfaces and turning them into a custom executable (including how to collect data about the resulting system.)</p> </li> <li> <p>How to build, run, and create unit tests - Walks through how to build and run existing unit tests, as well as create new unit test files. </p> </li> </ul>"},{"location":"HowToTest/","title":"How to Test","text":"<p>This guide will demonstrate how to create, build, and run tests.</p> <p>Note: that these instructions should work on Mac and Linux systems. Windows instructions should be similar, but please add any information about working with tests on Windows via a pull request! </p> <p>Note: this guide assumes you have Catch2 downloaded.  If you haven't yet downloaded the repo, simply add a <code>--recursive</code> to the end of your <code>git clone</code>.  If you have downloaded the rest of the repo, simply initialize and update the submodules: </p> <pre><code>git submodule init\ngit submodule update\n</code></pre>"},{"location":"HowToTest/#how-to-compile-tests","title":"How to compile tests","text":"<p>First, create a build directory for tests if you don't already have one, and then enter that directory:</p> <pre><code>mkdir cmake-build-test\ncd cmake-build-test\n</code></pre> <p>Now we need to use CMake to compile. This is a two step process. First we tell CMake where to find the files, relative to our current directory. </p> <pre><code>cmake -DCMAKE_BUILD_TYPE=Test ..\n</code></pre> <p>If that completes without errors, we can now build the files in our current directory. </p> <pre><code>cmake --build .\n</code></pre> <p>That should compile the unit tests.  Note that this process will take a while the first time as it needs to compile Catch2. It should be much faster in subsequent builds. </p>"},{"location":"HowToTest/#compiling-with-extra-source-files","title":"Compiling with extra source files.","text":"<p>Note that if you want to compile code that depends on additional source files (i.e., additional <code>.cpp</code> files), you need to perform one additional step before compiling. Specifically, you need to create an additional <code>.cmake</code> file. </p> <p>The <code>.cmake</code> file should have the same base name as your test's main <code>.cpp</code>, for example, <code>WorldGrid.cpp</code> would have an accompanying <code>WorldGrid.cmake</code>. </p> <p>You have free reign within this CMake file, but to add sources you will need to add lines like this (one per source file you want to add): </p> <pre><code>add_source_to_target(${EXE_NAME} \"source/Agents/PathAgent.cpp\")\n</code></pre> <p>The <code>${EXE_NAME}</code> DOES NOT CHANGE, it is a variable set in the other CMake files. You wimply need to change the string to match the path of your source file (relative to the repo's root). </p> <p>Once this file is created, compilation can proceed as normal. The CMake build system will automatically detect and execute the file you just created. </p>"},{"location":"HowToTest/#running-tests","title":"Running tests","text":"<p>Inside of your test build directory (<code>/cmake-build-test/</code> above), run the following: </p> <pre><code>ctest --output-on-failure\n</code></pre> <p>This should run all the unit tests, providing something like the following: </p> <pre><code>\nTest project /Users/thammina/projectsLocal/CSE491_GP_Group7/build\n    Start 1: tests-unit-core-Data\n1/3 Test #1: tests-unit-core-Data .............   Passed    0.01 sec\n    Start 2: tests-unit-core-WorldGrid\n2/3 Test #2: tests-unit-core-WorldGrid ........   Passed    0.01 sec\n    Start 3: tests-unit-gp_agents-agent\n3/3 Test #3: tests-unit-gp_agents-agent .......   Passed    0.01 sec\n\n100% tests passed, 0 tests failed out of 3\n</code></pre> <p>By specifying the <code>--output-on-failure</code> flag, we should see also see the specifics of which cases failed, if any. </p> <p>If you wish to run a particular test, simply navigate to the <code>executable</code> directory inside the build folder, and then run that particular test (e.g., <code>tests-unit-core-Data</code>). Note that it may end in <code>.exe</code> on  Windows.</p>"},{"location":"HowToTest/#adding-new-tests","title":"Adding new tests","text":"<p>To add tests for a new file, navigate to the corresponding folder in the <code>tests/unit</code> directory (not in <code>cmake-build-test</code> directory).  For example, if we want to add a test for a new file in <code>core</code>, from the root of the repo we would navigate like so: </p> <pre><code>cd tests/unit/core\n</code></pre> <p>Once in the correct directory we need to add the actual source code of the test.  This should be done as a new <code>.cpp</code> file, which will typically have the same name as the header file in source (e.g., <code>WorldGrid.hpp</code> will have a new test file called <code>WorldGrid.cpp</code>). </p> <p>Once you've created that file, you can start with this skeleton code: </p> <pre><code>/**\n * This file is part of the Fall 2023, CSE 491 course project.\n * @brief &lt;TODO&gt;\n **/\n\n// Catch2 \n#define CATCH_CONFIG_MAIN\n#include &lt;catch2/catch_all.hpp&gt;\n\n// Class project\n// Place your includes here\n// e.g., #include \"core/Data.hpp\"\n\nTEST_CASE(\"NAME\", \"[tags]\"){\n}\n\n</code></pre> <p>This should be it! CMake should automatically detect the file and compile (and let Austin know if that doesn't work!)</p>"},{"location":"Core%20Project/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace clogged Tools for debug-logging that can be easily controlled. <ul> <li>class Logger Logger class with colors and team names. </li> </ul> </li> <li>namespace cse491 A base class interface for all agent types. <ul> <li>class AgentBase </li> <li>struct CellType Simple data structure to hold info about a TYPE of cell in the world. </li> <li>class CoreObject </li> <li>class Entity </li> <li>class GridPosition Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. </li> <li>class InterfaceBase </li> <li>class ItemBase </li> <li>struct Property </li> <li>struct PropertyBase </li> <li>class WorldBase </li> <li>class WorldGrid A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. </li> <li>struct is_any_map Type trait to determine if we are working with any type of map. </li> <li>struct is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; </li> <li>struct is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; </li> <li>struct is_vector Type trait to determine if we are working with a vector. </li> <li>struct is_vector&lt; std::vector&lt; T &gt; &gt; </li> </ul> </li> <li>namespace std </li> <li>namespace worldlang A base class for all World modules. </li> </ul>"},{"location":"Core%20Project/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir core <ul> <li>file AgentBase.hpp </li> <li>file CoreObject.hpp </li> <li>file Data.hpp </li> <li>file EasyLogging.hpp </li> <li>file Entity.cpp </li> <li>file Entity.hpp </li> <li>file GridPosition.hpp </li> <li>file InterfaceBase.hpp </li> <li>file ItemBase.hpp </li> <li>file Property.hpp </li> <li>file Serialize.hpp </li> <li>file WorldBase.hpp </li> <li>file WorldGrid.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"Core%20Project/namespaceclogged/","title":"Namespace clogged","text":"<p>Namespace List &gt; clogged</p> <p>Tools for debug-logging that can be easily controlled. More...</p>"},{"location":"Core%20Project/namespaceclogged/#classes","title":"Classes","text":"Type Name class Logger Logger class with colors and team names."},{"location":"Core%20Project/namespaceclogged/#public-types","title":"Public Types","text":"Type Name enum Color Colors for logging. enum LogLevel Log levels for logging. enum Team Teams Names for logging."},{"location":"Core%20Project/namespaceclogged/#public-attributes","title":"Public Attributes","text":"Type Name const LogLevel LOGLEVEL   = = LogLevel::DEBUGLevel of logging @TODO: Change this to be a flag in the CMakeLists.txt."},{"location":"Core%20Project/namespaceclogged/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: ALPHA </p>"},{"location":"Core%20Project/namespaceclogged/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Core%20Project/namespaceclogged/#enum-color","title":"enum Color","text":"<pre><code>enum clogged::Color {\n    RESET = 0,\n    BLUE = 34,\n    GREEN = 32,\n    RED = 31\n};\n</code></pre>"},{"location":"Core%20Project/namespaceclogged/#enum-loglevel","title":"enum LogLevel","text":"<pre><code>enum clogged::LogLevel {\n    DEBUG,\n    INFO,\n    WARNING,\n    ERR,\n    NA\n};\n</code></pre>"},{"location":"Core%20Project/namespaceclogged/#enum-team","title":"enum Team","text":"<pre><code>enum clogged::Team {\n    TEAM_1,\n    TEAM_2,\n    TEAM_3,\n    TEAM_4,\n    TEAM_5,\n    TEAM_6,\n    TEAM_7,\n    TEAM_8,\n    TEAM_9,\n    GENERAL,\n    NA\n};\n</code></pre>"},{"location":"Core%20Project/namespaceclogged/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Core%20Project/namespaceclogged/#variable-loglevel","title":"variable LOGLEVEL","text":"<pre><code>const LogLevel LOGLEVEL;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/EasyLogging.hpp</code></p>"},{"location":"Core%20Project/classclogged_1_1_logger/","title":"Class clogged::Logger","text":"<p>ClassList &gt; clogged &gt; Logger</p> <p>Logger class with colors and team names.More...</p> <ul> <li><code>#include &lt;EasyLogging.hpp&gt;</code></li> </ul>"},{"location":"Core%20Project/classclogged_1_1_logger/#public-functions","title":"Public Functions","text":"Type Name Logger &amp; operator&lt;&lt; (Team team) Sets the Team name for the current log. Logger &amp; operator&lt;&lt; (LogLevel logLevel) sets the log level for the current log Logger &amp; operator&lt;&lt; (Color color) colors of the log Logger &amp; operator&lt;&lt; (std::ostream &amp;(*)(std::ostream &amp;) manipulator) Manipulator for endl so that we can reset the values when a team is done logging. Logger &amp; operator&lt;&lt; (const T &amp; value) Aye I used a template."},{"location":"Core%20Project/classclogged_1_1_logger/#public-static-functions","title":"Public Static Functions","text":"Type Name Logger &amp; Log ()  Logger &amp; Log (T &amp;&amp; arg1, EXTRA_Ts &amp;&amp;... extra_args)  std::ostream &amp; endl (std::ostream &amp; os) Custom endl to reset the values."},{"location":"Core%20Project/classclogged_1_1_logger/#detailed-description","title":"Detailed Description","text":"<p>Not a fan of this practice But would prefer not to use parenthesis </p> <p>Author:</p> <p>@amantham20 @chatGPT</p> <p>I was about to name this clogged.</p> <p>This is a custom logger class that can be used to log messages to the console. </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator","title":"function operator&lt;&lt;","text":"<p>Sets the Team name for the current log. </p> <pre><code>inline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    Team team\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>team</code> name of the team </li> </ul> <p>Returns:</p> <p>Logger&amp; </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator_1","title":"function operator&lt;&lt;","text":"<p>sets the log level for the current log </p> <pre><code>inline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    LogLevel logLevel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>logLevel</code> Level/Type of the log </li> </ul> <p>Returns:</p> <p>Logger&amp; </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator_2","title":"function operator&lt;&lt;","text":"<p>colors of the log </p> <pre><code>inline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    Color color\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>color</code> </li> </ul> <p>Returns:</p> <p>Logger&amp; </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator_3","title":"function operator&lt;&lt;","text":"<p>Manipulator for endl so that we can reset the values when a team is done logging. </p> <pre><code>inline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    std::ostream &amp;(*)(std::ostream &amp;) manipulator\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>manipulator</code> </li> </ul> <p>Returns:</p> <p>Logger&amp; </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator_4","title":"function operator&lt;&lt;","text":"<p>Aye I used a template. </p> <pre><code>template&lt;typename T typename T&gt;\ninline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    const T &amp; value\n) \n</code></pre> <p>Function to log the value</p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>value</code> </li> </ul> <p>Returns:</p> <p>Logger&amp;</p> <p>@TODO: Might have to change this so that we only break a team log when a new team is set. aka ensure that logger &lt;&lt; Team::TEAM_1 &lt;&lt; \"Hello\" &lt;&lt; \"World\" &lt;&lt; endl; works in one line with one team print </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Core%20Project/classclogged_1_1_logger/#function-log-12","title":"function Log [1/2]","text":"<pre><code>static inline Logger &amp; clogged::Logger::Log () \n</code></pre> <p>Only instance of the logger once Changes requested from Dr.@ofria</p> <p>Authors:</p> <p>@mercere99 </p> <p>Returns:</p> <p>a unique Logger instance </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-log-22","title":"function Log [2/2]","text":"<pre><code>template&lt;typename T typename T, typename... EXTRA_Ts&gt;\nstatic inline Logger &amp; clogged::Logger::Log (\n    T &amp;&amp; arg1,\n    EXTRA_Ts &amp;&amp;... extra_args\n) \n</code></pre> <p>Only instance of the logger once Changes requested from Dr.@ofria</p> <p>Authors:</p> <p>@mercere99 </p> <p>Parameters:</p> <ul> <li><code>arg1</code> Set of values that you want to have logged. </li> </ul> <p>Returns:</p> <p>Unique Logger instance </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-endl","title":"function endl","text":"<p>Custom endl to reset the values. </p> <pre><code>static inline std::ostream &amp; clogged::Logger::endl (\n    std::ostream &amp; os\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> </li> </ul> <p>Returns:</p> <p>std::ostream&amp; </p> <p>The documentation for this class was generated from the following file <code>source/core/EasyLogging.hpp</code></p>"},{"location":"Core%20Project/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>A base class interface for all agent types. More...</p>"},{"location":"Core%20Project/namespacecse491/#classes","title":"Classes","text":"Type Name class AgentBase struct CellType Simple data structure to hold info about a TYPE of cell in the world. class CoreObject class Entity class GridPosition Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. class InterfaceBase class ItemBase struct Property &lt;typename T&gt; struct PropertyBase class WorldBase class WorldGrid A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. struct is_any_map &lt;typename T&gt;Type trait to determine if we are working with any type of map. struct is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; &lt;typename KEY_T, typename VALUE_T&gt; struct is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; &lt;typename KEY_T, typename VALUE_T&gt; struct is_vector &lt;typename T&gt;Type trait to determine if we are working with a vector. struct is_vector&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt;"},{"location":"Core%20Project/namespacecse491/#public-types","title":"Public Types","text":"Type Name enum PropertyType Common types of properties in network serialization. enum State States that an agent can be in. enum WorldType Enum for World types in network serialization. typedef std::map&lt; size_t, std::unique_ptr&lt; AgentBase &gt; &gt; agent_map_t Maps of agent IDs to agent pointers. typedef std::map&lt; size_t, std::unique_ptr&lt; ItemBase &gt; &gt; item_map_t Maps of item IDs to item pointers. typedef std::vector&lt; CellType &gt; type_options_t Available CellTypes will be passed around as a vector of options."},{"location":"Core%20Project/namespacecse491/#public-static-functions","title":"Public Static Functions","text":"Type Name T DeserializeAs (std::istream &amp; is) Helper function to deserialize and return a specified type. void DeserializeFunction (std::istream &amp; is, std::function&lt; void(T)&gt; set_fun) Helper function to deserialize a member variables from a function. void DeserializeValue (std::istream &amp; is, T &amp; var) Helper function to deserialize a single member variable. void DeserializeValue_Map (std::istream &amp;, T &amp;)  void DeserializeValue_Map (std::istream &amp; is, MAP_T &amp; var) Helper specialty function to deserialize a unordered_map member variable. void DeserializeValue_Vector (std::istream &amp; is, std::vector&lt; T &gt; &amp; var) Helper specialty function to deserialize a vector-based member variable. void SerializeValue (std::ostream &amp; os, const T &amp; var) Helper function to serialize a single member variable. void SerializeValue_Map (std::ostream &amp; os, const T &amp; var) Helper specialty function to serialize a unordered_map member variable. void SerializeValue_Vector (std::ostream &amp; os, const std::vector&lt; T &gt; &amp; var) Helper specialty function to serialize a vector-based member variable."},{"location":"Core%20Project/namespacecse491/#detailed-description","title":"Detailed Description","text":"<p>A simple 2D Grid container.</p> <p>Tools to simplify serializing classes.</p> <p>A class to maintain arbitrary data and facilitate its use.</p> <p>A base class interface for all non-agent item types.</p> <p>A base class for all player-interface types.</p> <p>A mechanism of identifying a grid cell, as well as a position within the cell.</p> <p>A base class for all items or agents that can exist on the grid.</p> <p>Set of types used throughout the codebase.</p> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: ALPHA </p>"},{"location":"Core%20Project/namespacecse491/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Core%20Project/namespacecse491/#enum-propertytype","title":"enum PropertyType","text":"<pre><code>enum cse491::PropertyType {\n    t_double,\n    t_int,\n    t_char,\n    t_string,\n    t_position,\n    t_bool,\n    t_other\n};\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#enum-state","title":"enum State","text":"<pre><code>enum cse491::State {\n    Healthy,\n    Taking_Damage,\n    Dying,\n    Deceased\n};\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#enum-worldtype","title":"enum WorldType","text":"<pre><code>enum cse491::WorldType {\n    w_maze,\n    w_second,\n    w_generative,\n    w_manual\n};\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#typedef-agent_map_t","title":"typedef agent_map_t","text":"<pre><code>using agent_map_t =  std::map&lt;size_t, std::unique_ptr&lt;AgentBase&gt; &gt;;\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#typedef-item_map_t","title":"typedef item_map_t","text":"<pre><code>using item_map_t =  std::map&lt;size_t, std::unique_ptr&lt;ItemBase&gt; &gt;;\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#typedef-type_options_t","title":"typedef type_options_t","text":"<pre><code>using type_options_t =  std::vector&lt;CellType&gt;;\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Core%20Project/namespacecse491/#function-deserializeas","title":"function DeserializeAs","text":"<p>Helper function to deserialize and return a specified type. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic T cse491::DeserializeAs (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Input stream to write from. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-deserializefunction","title":"function DeserializeFunction","text":"<p>Helper function to deserialize a member variables from a function. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::DeserializeFunction (\n    std::istream &amp; is,\n    std::function&lt; void(T)&gt; set_fun\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Input stream to write from. </li> <li><code>var</code> Variable to serialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-deserializevalue","title":"function DeserializeValue","text":"<p>Helper function to deserialize a single member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::DeserializeValue (\n    std::istream &amp; is,\n    T &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Input stream to write from. </li> <li><code>var</code> Variable to deserialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-deserializevalue_map","title":"function DeserializeValue_Map","text":"<pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::DeserializeValue_Map (\n    std::istream &amp;,\n    T &amp;\n) \n</code></pre>"},{"location":"Core%20Project/namespacecse491/#function-deserializevalue_map_1","title":"function DeserializeValue_Map","text":"<p>Helper specialty function to deserialize a unordered_map member variable. </p> <pre><code>template&lt;typename MAP_T typename MAP_T&gt;\nstatic void cse491::DeserializeValue_Map (\n    std::istream &amp; is,\n    MAP_T &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> Input stream to read from. </li> <li><code>var</code> Variable to deserialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-deserializevalue_vector","title":"function DeserializeValue_Vector","text":"<p>Helper specialty function to deserialize a vector-based member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::DeserializeValue_Vector (\n    std::istream &amp; is,\n    std::vector&lt; T &gt; &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Input stream to read from. </li> <li><code>var</code> Variable to deserialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-serializevalue","title":"function SerializeValue","text":"<p>Helper function to serialize a single member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::SerializeValue (\n    std::ostream &amp; os,\n    const T &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to write to. </li> <li><code>var</code> Variable to serialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-serializevalue_map","title":"function SerializeValue_Map","text":"<p>Helper specialty function to serialize a unordered_map member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::SerializeValue_Map (\n    std::ostream &amp; os,\n    const T &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to write to. </li> <li><code>var</code> Variable to serialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-serializevalue_vector","title":"function SerializeValue_Vector","text":"<p>Helper specialty function to serialize a vector-based member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::SerializeValue_Vector (\n    std::ostream &amp; os,\n    const std::vector&lt; T &gt; &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to write to. </li> <li><code>var</code> Variable to serialize. </li> </ul> <p>The documentation for this class was generated from the following file <code>source/core/AgentBase.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/","title":"Class cse491::AgentBase","text":"<p>ClassList &gt; cse491 &gt; AgentBase</p> <p>Inherits the following classes: cse491::Entity</p> <p>Inherited by the following classes: cse491::InterfaceBase</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#public-functions","title":"Public Functions","text":"Type Name virtual AgentBase &amp; AddAction (const std::string &amp; action_name, size_t action_id) Provide a new action that this agent can take. AgentBase (size_t id, const std::string &amp; name) Default value upon initialization. virtual void Deserialize_impl (std::istream &amp; is) overrideDeserialize item-specific values and call Entity 's Deserialize_impl. size_t GetActionID (const std::string &amp; action_name) constReturn an action ID if that action exists, otherwise return zero. int GetActionResult () constRetrieve the result of the most recent action. State GetAgentState () Get the current state of the Agent. virtual GridPosition GetNextPosition () Allow derived agents to provide an arbitrary next position for the world to move the agent to. virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. bool HasAction (const std::string &amp; action_name) constTest if agent already has a specified action. virtual bool Initialize () Run AFTER the world configures the agent, for additional tests or setup. virtual bool IsAgent () override constIs Entity an autonomous agent? virtual void Notify (const std::string &amp;, const std::string &amp;=\"none\") Send a notification to this agent, typically from the world. virtual size_t SelectAction (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) Decide the next action for this agent to perform; should be overridden! virtual void Serialize_impl (std::ostream &amp; os) override constSerialize item-specific values and call Entity 's Serialize_impl. void SetActionResult (int result) Update the result from the most recent action. void TakeDamage (cse491::AgentBase &amp; agent) If the agent is in State::Taking_Damage, decrease the health by the damage factor once per timestep. void UpdateAgentState (cse491::AgentBase &amp; agent) Updates an Agent's state depending on health. void storeActionMap (std::string name)  ~AgentBase () = default"},{"location":"Core%20Project/classcse491_1_1_agent_base/#public-functions-inherited-from-cse491entity","title":"Public Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Entity &amp; AddItem (size_t id)  Entity &amp; AddItem (Entity &amp; item)  virtual void Deserialize_impl (std::istream &amp; is) overrideSerialize entity-specific values. Entity (size_t id, const std::string &amp; name)  Entity (const Entity &amp;) = delete Entity (Entity &amp;&amp;) = default size_t GetGridID () const size_t GetID () const std::vector&lt; size_t &gt; GetInventory () const const std::string &amp; GetName () const size_t GetNumProperties () constHow many properties does this entity have? GridPosition GetPosition () const const T &amp; GetProperty (const std::string &amp; name) constReturn the current value of the specified property. property_map_t &amp; GetPropertyMap () return the property map for the entity PropertyType GetPropertyType (const std::string &amp; name) const WorldBase &amp; GetWorld () const bool HasItem (size_t id) constInventory Management. bool HasProperty (const std::string &amp; name) constDoes this agent have a property with the specified name? bool HasWorld () const virtual bool IsAgent () constIs Entity an autonomous agent? virtual bool IsInterface () constIs Entity an interface for a human? virtual bool IsItem () constIs Entity an item? bool IsOnGrid (size_t in_grid_id) const Entity &amp; RemoveItem (size_t id)  Entity &amp; RemoveItem (Entity &amp; item)  Entity &amp; RemoveProperty (const std::string &amp; name) Completely remove a property from an Entity . virtual void Serialize_impl (std::ostream &amp; os) override constSerialize entity-specific values. Entity &amp; SetName (const std::string in_name)  Entity &amp; SetPosition (GridPosition in_pos, size_t grid_id=0)  Entity &amp; SetPosition (double x, double y)  Entity &amp; SetProperties () Allow for setting multiple properties at once. Entity &amp; SetProperties (const std::string &amp; name, VALUE_T &amp;&amp; value, EXTRA_Ts &amp;&amp;... extras)  Entity &amp; SetProperty (const std::string &amp; name, const T &amp; value) Change the value of the specified property (will create if needed) virtual Entity &amp; SetWorld (WorldBase &amp; in_world)  Entity &amp; operator= (const Entity &amp;) = delete Entity &amp; operator= (Entity &amp;&amp;) = delete virtual ~Entity () = default"},{"location":"Core%20Project/classcse491_1_1_agent_base/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-types-inherited-from-cse491entity","title":"Protected Types inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name typedef std::unordered_map&lt; std::string, std::unique_ptr&lt; PropertyBase &gt; &gt; property_map_t Every entity can have a simple set of properties (with values) associated with it."},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-attributes","title":"Protected Attributes","text":"Type Name int action Action that agent is currently performing. std::unordered_map&lt; std::string, size_t &gt; action_map Map of names to action ids. int action_result   = = 0Usually a one (success) or zero (failure). State agent_state   = = Healthy"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-attributes-inherited-from-cse491entity","title":"Protected Attributes inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name size_t grid_id   = = 0Which grid is this entity on? size_t id   = = 0Unique ID for this entity (0 is used for \"no ID\") std::vector&lt; size_t &gt; inventory What entity ids are held by this entity? std::string name   = = \"\"Name for this entity (E.g., \"Player 1\" or \"+2 Sword\") GridPosition position Where on the grid is this entity? property_map_t property_map"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-functions-inherited-from-cse491entity","title":"Protected Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Property&lt; T &gt; &amp; AsProperty (const std::string &amp; name) const"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_agent_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-addaction","title":"function AddAction","text":"<pre><code>inline virtual AgentBase &amp; cse491::AgentBase::AddAction (\n    const std::string &amp; action_name,\n    size_t action_id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-agentbase","title":"function AgentBase","text":"<pre><code>inline cse491::AgentBase::AgentBase (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Deserialize item-specific values and call Entity 's Deserialize_impl.</p> <pre><code>inline virtual void cse491::AgentBase::Deserialize_impl (\n    std::istream &amp; is\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> istream to read contents from. </li> </ul> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-getactionid","title":"function GetActionID","text":"<pre><code>inline size_t cse491::AgentBase::GetActionID (\n    const std::string &amp; action_name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-getactionresult","title":"function GetActionResult","text":"<pre><code>inline int cse491::AgentBase::GetActionResult () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-getagentstate","title":"function GetAgentState","text":"<p>Get the current state of the Agent. </p> <pre><code>inline State cse491::AgentBase::GetAgentState () \n</code></pre> <p>Returns:</p> <p>State enum of agent_state </p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-getnextposition","title":"function GetNextPosition","text":"<pre><code>inline virtual GridPosition cse491::AgentBase::GetNextPosition () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::AgentBase::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-hasaction","title":"function HasAction","text":"<pre><code>inline bool cse491::AgentBase::HasAction (\n    const std::string &amp; action_name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-initialize","title":"function Initialize","text":"<p>Run AFTER the world configures the agent, for additional tests or setup. </p> <pre><code>inline virtual bool cse491::AgentBase::Initialize () \n</code></pre> <p>Returns:</p> <p>Was the initialization successful? </p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-isagent","title":"function IsAgent","text":"<pre><code>inline virtual bool cse491::AgentBase::IsAgent () override const\n</code></pre> <p>Implements cse491::Entity::IsAgent</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-notify","title":"function Notify","text":"<p>Send a notification to this agent, typically from the world. </p> <pre><code>inline virtual void cse491::AgentBase::Notify (\n    const std::string &amp;,\n    const std::string &amp;=\"none\"\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>message</code> Contents of the notification </li> <li><code>msg_type</code> Category of message, such as \"item_alert\", \"damage\", or \"enemy\" This function is useful to notify users of events in the world, such as them taking damage, finding an item, etc. The message type can potentially also provide information to an autonomous agent assuming we come up with a standard list of types. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-selectaction","title":"function SelectAction","text":"<p>Decide the next action for this agent to perform; should be overridden! </p> <pre><code>inline virtual size_t cse491::AgentBase::SelectAction (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The agent is provided with the current WorldGrid </li> </ul> <p>Returns:</p> <p>ID associated with the action to perform; (zero is always \"no action\") </p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Serialize item-specific values and call Entity 's Serialize_impl.</p> <pre><code>inline virtual void cse491::AgentBase::Serialize_impl (\n    std::ostream &amp; os\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream to write contents to. </li> </ul> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-setactionresult","title":"function SetActionResult","text":"<pre><code>inline void cse491::AgentBase::SetActionResult (\n    int result\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-takedamage","title":"function TakeDamage","text":"<pre><code>inline void cse491::AgentBase::TakeDamage (\n    cse491::AgentBase &amp; agent\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-updateagentstate","title":"function UpdateAgentState","text":"<p>Updates an Agent's state depending on health. </p> <pre><code>inline void cse491::AgentBase::UpdateAgentState (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent whose state to update If the agent's health is between Max_health and 3 -&gt; Healthy If the agent's health is between 0 and 3 -&gt; Dying If the agent is Taking_Damage -&gt; Taking_Damage If the agent is at 0 or below -&gt; Dead </li> </ul> <p>See also: TakeDamage </p> <p>Returns:</p> <p>None </p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-storeactionmap","title":"function storeActionMap","text":"<pre><code>inline void cse491::AgentBase::storeActionMap (\n    std::string name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-agentbase_1","title":"function ~AgentBase","text":"<pre><code>cse491::AgentBase::~AgentBase () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_agent_base/#variable-action","title":"variable action","text":"<pre><code>int action;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#variable-action_map","title":"variable action_map","text":"<pre><code>std::unordered_map&lt;std::string, size_t&gt; action_map;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#variable-action_result","title":"variable action_result","text":"<pre><code>int action_result;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#variable-agent_state","title":"variable agent_state","text":"<pre><code>State agent_state;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/AgentBase.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1_cell_type/","title":"Struct cse491::CellType","text":"<p>ClassList &gt; cse491 &gt; CellType</p> <p>Simple data structure to hold info about a TYPE of cell in the world. </p> <ul> <li><code>#include &lt;Data.hpp&gt;</code></li> </ul>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-attributes","title":"Public Attributes","text":"Type Name std::string desc Full description of what this type of cell is. std::string name Unique name for this type of cell (e.g., \"wall\", \"tree\", \"moon\") std::set&lt; std::string &gt; properties   = {}Set of properties for this cell type. char symbol Symbol for text representations (files or interface)"},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr char CELL_WALL   = = \"wall\" constexpr char CELL_WATER   = = \"water\""},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-functions","title":"Public Functions","text":"Type Name bool HasProperty (const std::string &amp; property) constChecks if the given property is set on this CellType . CellType &amp; RemoveProperty (const std::string &amp; property) Removes the specifed property from this CellType . CellType &amp; SetProperty (const std::string &amp; property) Adds the specifed property to this CellType ."},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-desc","title":"variable desc","text":"<pre><code>std::string desc;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-name","title":"variable name","text":"<pre><code>std::string name;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-properties","title":"variable properties","text":"<pre><code>std::set&lt;std::string&gt; properties;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-symbol","title":"variable symbol","text":"<pre><code>char symbol;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-cell_wall","title":"variable CELL_WALL","text":"<pre><code>constexpr char CELL_WALL[];\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-cell_water","title":"variable CELL_WATER","text":"<pre><code>constexpr char CELL_WATER[];\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_cell_type/#function-hasproperty","title":"function HasProperty","text":"<pre><code>inline bool cse491::CellType::HasProperty (\n    const std::string &amp; property\n) const\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#function-removeproperty","title":"function RemoveProperty","text":"<pre><code>inline CellType &amp; cse491::CellType::RemoveProperty (\n    const std::string &amp; property\n) \n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#function-setproperty","title":"function SetProperty","text":"<pre><code>inline CellType &amp; cse491::CellType::SetProperty (\n    const std::string &amp; property\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/Data.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_core_object/","title":"Class cse491::CoreObject","text":"<p>ClassList &gt; cse491 &gt; CoreObject</p> <p>Inherited by the following classes: cse491::Entity,  cse491::GridPosition,  cse491::PropertyBase,  cse491::WorldGrid</p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#public-functions","title":"Public Functions","text":"Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_core_object/#protected-functions","title":"Protected Functions","text":"Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_core_object/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_core_object/#function-deserialize-12","title":"function Deserialize [1/2]","text":"<p>Restore the state of this object, extracting it from the provided stream. </p> <pre><code>inline void cse491::CoreObject::Deserialize (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>input_stream</code> The istream with full details about this object. This function takes in an istream that was previously written using the paired Serialize() function and restores the associated class. It should stop loading when all data is finished; this may be signalled by the \":::END\" directive. The stream should end ready for the next extraction. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-deserialize-22","title":"function Deserialize [2/2]","text":"<p>A version of Deserialize that accepts a filename to read this object from. </p> <pre><code>inline bool cse491::CoreObject::Deserialize (\n    std::string filename\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> The name of the file to open to load this object from. </li> </ul> <p>Returns:</p> <p>Success (true/false) </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-gettypename","title":"function GetTypeName","text":"<p>Access the derived name for this type. </p> <pre><code>inline std::string cse491::CoreObject::GetTypeName () const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-serialize-12","title":"function Serialize [1/2]","text":"<p>Store the current state of this object for later extraction. </p> <pre><code>inline void cse491::CoreObject::Serialize (\n    std::ostream &amp; os\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_stream</code> An ostream that the required information should be stored in. A derived class is required to store all information about itself in Serialize() and clearly note the end of storage to simplify de-serializing the data. This function will automatic add a start line that reads \":::START\" followed by the typename, and an end line with \":::END\" followed by the typename again. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-serialize-22","title":"function Serialize [2/2]","text":"<p>A version of Serialize that accepts a filename for saving just this object. </p> <pre><code>inline bool cse491::CoreObject::Serialize (\n    std::string filename\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> The name of the file to create for storing this object. </li> </ul> <p>Returns:</p> <p>Success (true/false) </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-operator","title":"function operator&lt;=&gt;","text":"<pre><code>auto cse491::CoreObject::operator&lt;=&gt; (\n    const CoreObject &amp;\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-coreobject","title":"function ~CoreObject","text":"<pre><code>inline virtual cse491::CoreObject::~CoreObject () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_core_object/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_core_object/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Override to restore the state of this object from the provided stream. </p> <pre><code>virtual void cse491::CoreObject::Deserialize_impl (\n    std::istream &amp;\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>input_stream</code> The istream with full details about this object. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-enddeserialize","title":"function EndDeserialize","text":"<p>Set up end of the deserialization for this class (does type checking) </p> <pre><code>inline bool cse491::CoreObject::EndDeserialize (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> Input stream to deserialize from. </li> </ul> <p>Returns:</p> <p>success (true/false) </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-endserialize","title":"function EndSerialize","text":"<p>Set up end of the serialization for this class (allows checking later) </p> <pre><code>inline void cse491::CoreObject::EndSerialize (\n    std::ostream &amp; os\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to Serialize into. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>virtual std::string cse491::CoreObject::GetTypeName_impl () const = 0\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Override to store the current state of this object for later extraction. </p> <pre><code>virtual void cse491::CoreObject::Serialize_impl (\n    std::ostream &amp;\n) const = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_stream</code> An ostream that the required information should be stored in. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-startdeserialize","title":"function StartDeserialize","text":"<p>Set up beginning of the deserialization for this class (does type checking) </p> <pre><code>inline bool cse491::CoreObject::StartDeserialize (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> Input stream to deserialize from. </li> </ul> <p>Returns:</p> <p>success (true/false) </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-startserialize","title":"function StartSerialize","text":"<p>Set up beginning of the serialization for this class (allows checking later) </p> <pre><code>inline void cse491::CoreObject::StartSerialize (\n    std::ostream &amp; os\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to Serialize into. </li> </ul> <p>The documentation for this class was generated from the following file <code>source/core/CoreObject.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_entity/","title":"Class cse491::Entity","text":"<p>ClassList &gt; cse491 &gt; Entity</p> <p>Inherits the following classes: cse491::CoreObject</p> <p>Inherited by the following classes: cse491::AgentBase,  cse491::ItemBase</p>"},{"location":"Core%20Project/classcse491_1_1_entity/#public-functions","title":"Public Functions","text":"Type Name Entity &amp; AddItem (size_t id)  Entity &amp; AddItem (Entity &amp; item)  virtual void Deserialize_impl (std::istream &amp; is) overrideSerialize entity-specific values. Entity (size_t id, const std::string &amp; name)  Entity (const Entity &amp;) = delete Entity (Entity &amp;&amp;) = default size_t GetGridID () const size_t GetID () const std::vector&lt; size_t &gt; GetInventory () const const std::string &amp; GetName () const size_t GetNumProperties () constHow many properties does this entity have? GridPosition GetPosition () const const T &amp; GetProperty (const std::string &amp; name) constReturn the current value of the specified property. property_map_t &amp; GetPropertyMap () return the property map for the entity PropertyType GetPropertyType (const std::string &amp; name) const WorldBase &amp; GetWorld () const bool HasItem (size_t id) constInventory Management. bool HasProperty (const std::string &amp; name) constDoes this agent have a property with the specified name? bool HasWorld () const virtual bool IsAgent () constIs Entity an autonomous agent? virtual bool IsInterface () constIs Entity an interface for a human? virtual bool IsItem () constIs Entity an item? bool IsOnGrid (size_t in_grid_id) const Entity &amp; RemoveItem (size_t id)  Entity &amp; RemoveItem (Entity &amp; item)  Entity &amp; RemoveProperty (const std::string &amp; name) Completely remove a property from an Entity . virtual void Serialize_impl (std::ostream &amp; os) override constSerialize entity-specific values. Entity &amp; SetName (const std::string in_name)  Entity &amp; SetPosition (GridPosition in_pos, size_t grid_id=0)  Entity &amp; SetPosition (double x, double y)  Entity &amp; SetProperties () Allow for setting multiple properties at once. Entity &amp; SetProperties (const std::string &amp; name, VALUE_T &amp;&amp; value, EXTRA_Ts &amp;&amp;... extras)  Entity &amp; SetProperty (const std::string &amp; name, const T &amp; value) Change the value of the specified property (will create if needed) virtual Entity &amp; SetWorld (WorldBase &amp; in_world)  Entity &amp; operator= (const Entity &amp;) = delete Entity &amp; operator= (Entity &amp;&amp;) = delete virtual ~Entity () = default"},{"location":"Core%20Project/classcse491_1_1_entity/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-types","title":"Protected Types","text":"Type Name typedef std::unordered_map&lt; std::string, std::unique_ptr&lt; PropertyBase &gt; &gt; property_map_t Every entity can have a simple set of properties (with values) associated with it."},{"location":"Core%20Project/classcse491_1_1_entity/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t grid_id   = = 0Which grid is this entity on? size_t id   = = 0Unique ID for this entity (0 is used for \"no ID\") std::vector&lt; size_t &gt; inventory What entity ids are held by this entity? std::string name   = = \"\"Name for this entity (E.g., \"Player 1\" or \"+2 Sword\") GridPosition position Where on the grid is this entity? property_map_t property_map"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-functions","title":"Protected Functions","text":"Type Name Property&lt; T &gt; &amp; AsProperty (const std::string &amp; name) const"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_entity/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_entity/#function-additem-12","title":"function AddItem [1/2]","text":"<pre><code>Entity &amp; cse491::Entity::AddItem (\n    size_t id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-additem-22","title":"function AddItem [2/2]","text":"<pre><code>inline Entity &amp; cse491::Entity::AddItem (\n    Entity &amp; item\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Serialize entity-specific values. </p> <pre><code>inline virtual void cse491::Entity::Deserialize_impl (\n    std::istream &amp; is\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream to write contents to. </li> </ul> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-entity-13","title":"function Entity [1/3]","text":"<pre><code>inline cse491::Entity::Entity (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-entity-23","title":"function Entity [2/3]","text":"<pre><code>cse491::Entity::Entity (\n    const Entity &amp;\n) = delete\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-entity-33","title":"function Entity [3/3]","text":"<pre><code>cse491::Entity::Entity (\n    Entity &amp;&amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getgridid","title":"function GetGridID","text":"<pre><code>inline size_t cse491::Entity::GetGridID () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getid","title":"function GetID","text":"<pre><code>inline size_t cse491::Entity::GetID () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getinventory","title":"function GetInventory","text":"<pre><code>inline std::vector&lt; size_t &gt; cse491::Entity::GetInventory () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getname","title":"function GetName","text":"<pre><code>inline const std::string &amp; cse491::Entity::GetName () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getnumproperties","title":"function GetNumProperties","text":"<pre><code>inline size_t cse491::Entity::GetNumProperties () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getposition","title":"function GetPosition","text":"<pre><code>inline GridPosition cse491::Entity::GetPosition () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getproperty","title":"function GetProperty","text":"<pre><code>template&lt;typename T typename T&gt;\ninline const T &amp; cse491::Entity::GetProperty (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getpropertymap","title":"function GetPropertyMap","text":"<pre><code>inline property_map_t &amp; cse491::Entity::GetPropertyMap () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getpropertytype","title":"function GetPropertyType","text":"<pre><code>inline PropertyType cse491::Entity::GetPropertyType (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getworld","title":"function GetWorld","text":"<pre><code>inline WorldBase &amp; cse491::Entity::GetWorld () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-hasitem","title":"function HasItem","text":"<pre><code>inline bool cse491::Entity::HasItem (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-hasproperty","title":"function HasProperty","text":"<pre><code>inline bool cse491::Entity::HasProperty (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-hasworld","title":"function HasWorld","text":"<pre><code>inline bool cse491::Entity::HasWorld () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-isagent","title":"function IsAgent","text":"<pre><code>inline virtual bool cse491::Entity::IsAgent () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-isinterface","title":"function IsInterface","text":"<pre><code>inline virtual bool cse491::Entity::IsInterface () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-isitem","title":"function IsItem","text":"<pre><code>inline virtual bool cse491::Entity::IsItem () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-isongrid","title":"function IsOnGrid","text":"<pre><code>inline bool cse491::Entity::IsOnGrid (\n    size_t in_grid_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-removeitem-12","title":"function RemoveItem [1/2]","text":"<pre><code>Entity &amp; cse491::Entity::RemoveItem (\n    size_t id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-removeitem-22","title":"function RemoveItem [2/2]","text":"<pre><code>inline Entity &amp; cse491::Entity::RemoveItem (\n    Entity &amp; item\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-removeproperty","title":"function RemoveProperty","text":"<pre><code>inline Entity &amp; cse491::Entity::RemoveProperty (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Serialize entity-specific values. </p> <pre><code>inline virtual void cse491::Entity::Serialize_impl (\n    std::ostream &amp; os\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream to write contents to. </li> </ul> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setname","title":"function SetName","text":"<pre><code>inline Entity &amp; cse491::Entity::SetName (\n    const std::string in_name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setposition-12","title":"function SetPosition [1/2]","text":"<pre><code>Entity &amp; cse491::Entity::SetPosition (\n    GridPosition in_pos,\n    size_t grid_id=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setposition-22","title":"function SetPosition [2/2]","text":"<pre><code>inline Entity &amp; cse491::Entity::SetPosition (\n    double x,\n    double y\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setproperties-12","title":"function SetProperties [1/2]","text":"<pre><code>inline Entity &amp; cse491::Entity::SetProperties () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setproperties-22","title":"function SetProperties [2/2]","text":"<pre><code>template&lt;typename VALUE_T typename VALUE_T, typename... EXTRA_Ts&gt;\ninline Entity &amp; cse491::Entity::SetProperties (\n    const std::string &amp; name,\n    VALUE_T &amp;&amp; value,\n    EXTRA_Ts &amp;&amp;... extras\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setproperty","title":"function SetProperty","text":"<pre><code>template&lt;typename T typename T&gt;\ninline Entity &amp; cse491::Entity::SetProperty (\n    const std::string &amp; name,\n    const T &amp; value\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setworld","title":"function SetWorld","text":"<pre><code>inline virtual Entity &amp; cse491::Entity::SetWorld (\n    WorldBase &amp; in_world\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-operator","title":"function operator=","text":"<pre><code>Entity &amp; cse491::Entity::operator= (\n    const Entity &amp;\n) = delete\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-operator_1","title":"function operator=","text":"<pre><code>Entity &amp; cse491::Entity::operator= (\n    Entity &amp;&amp;\n) = delete\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-entity","title":"function ~Entity","text":"<pre><code>virtual cse491::Entity::~Entity () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_entity/#typedef-property_map_t","title":"typedef property_map_t","text":"<pre><code>using property_map_t =  std::unordered_map&lt;std::string, std::unique_ptr&lt;PropertyBase&gt; &gt;;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_entity/#variable-grid_id","title":"variable grid_id","text":"<pre><code>size_t grid_id;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-id","title":"variable id","text":"<pre><code>size_t id;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-inventory","title":"variable inventory","text":"<pre><code>std::vector&lt;size_t&gt; inventory;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-name","title":"variable name","text":"<pre><code>std::string name;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-position","title":"variable position","text":"<pre><code>GridPosition position;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-property_map","title":"variable property_map","text":"<pre><code>property_map_t property_map;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_entity/#function-asproperty","title":"function AsProperty","text":"<pre><code>template&lt;typename T typename T&gt;\ninline Property &lt; T &gt; &amp; cse491::Entity::AsProperty (\n    const std::string &amp; name\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/Entity.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/","title":"Class cse491::GridPosition","text":"<p>ClassList &gt; cse491 &gt; GridPosition</p> <p>Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. </p> <ul> <li><code>#include &lt;GridPosition.hpp&gt;</code></li> </ul> <p>Inherits the following classes: cse491::CoreObject</p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-functions","title":"Public Functions","text":"Type Name GridPosition Above (double dist=1.0) constReturn a grid position above this one (by default, directly above) GridPosition Below (double dist=1.0) constReturn a grid position below this one (by default, directly below) size_t CellX () const size_t CellY () const virtual void Deserialize_impl (std::istream &amp;) overrideOverride to restore the state of this object from the provided stream. double Distance (GridPosition pos2) const GridPosition &amp; FromStream (std::istream &amp; ss)  GridPosition &amp; FromString (std::string in_str)  GridPosition GetOffset (double offset_x, double offset_y) constReturn a the GridPosition at the requested offset. virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. double GetX () const double GetY () const GridPosition () = default GridPosition (double x, double y)  GridPosition (const std::string &amp; str)  GridPosition (const GridPosition &amp;) = default bool IsInvalid () const bool IsNear (GridPosition pos2, double max_dist=1.0) const bool IsValid () const double MDistance (GridPosition pos2) constManhattan distance between grid positions. GridPosition &amp; MakeInvalid () Make this grid position invalid, by setting both coords to \"not-a-number\". virtual void Serialize_impl (std::ostream &amp;) override constOverride to store the current state of this object for later extraction. GridPosition &amp; Set (double in_x, double in_y)  GridPosition &amp; SetX (double in)  GridPosition &amp; SetY (double in)  GridPosition &amp; Shift (double shift_x, double shift_y)  GridPosition ToLeft (double dist=1.0) constReturn a grid position to the left of this one (by default, directly left) GridPosition ToRight (double dist=1.0) constReturn a grid position to the right of this one (by default, directly right) std::string ToString () const GridPosition operator+ (GridPosition in) constAdd together two grid positions and return the result. GridPosition &amp; operator+= (const GridPosition &amp; in)  GridPosition &amp; operator-= (const GridPosition &amp; in)  auto operator&lt;=&gt; (const GridPosition &amp;) constEnable all comparison operators (==, !=, &lt;, &lt;=, &gt;, &gt;=) GridPosition &amp; operator= (const GridPosition &amp;) = default ~GridPosition () = default"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-static-functions","title":"Public Static Functions","text":"Type Name const GridPosition &amp; Invalid ()"},{"location":"Core%20Project/classcse491_1_1_grid_position/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-above","title":"function Above","text":"<pre><code>inline GridPosition cse491::GridPosition::Above (\n    double dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-below","title":"function Below","text":"<pre><code>inline GridPosition cse491::GridPosition::Below (\n    double dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-cellx","title":"function CellX","text":"<pre><code>inline size_t cse491::GridPosition::CellX () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-celly","title":"function CellY","text":"<pre><code>inline size_t cse491::GridPosition::CellY () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Override to restore the state of this object from the provided stream. </p> <pre><code>inline virtual void cse491::GridPosition::Deserialize_impl (\n    std::istream &amp;\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>input_stream</code> The istream with full details about this object. </li> </ul> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-distance","title":"function Distance","text":"<pre><code>inline double cse491::GridPosition::Distance (\n    GridPosition pos2\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-fromstream","title":"function FromStream","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::FromStream (\n    std::istream &amp; ss\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-fromstring","title":"function FromString","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::FromString (\n    std::string in_str\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-getoffset","title":"function GetOffset","text":"<pre><code>inline GridPosition cse491::GridPosition::GetOffset (\n    double offset_x,\n    double offset_y\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::GridPosition::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-getx","title":"function GetX","text":"<pre><code>inline double cse491::GridPosition::GetX () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gety","title":"function GetY","text":"<pre><code>inline double cse491::GridPosition::GetY () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition-14","title":"function GridPosition [1/4]","text":"<pre><code>cse491::GridPosition::GridPosition () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition-24","title":"function GridPosition [2/4]","text":"<pre><code>inline cse491::GridPosition::GridPosition (\n    double x,\n    double y\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition-34","title":"function GridPosition [3/4]","text":"<pre><code>inline cse491::GridPosition::GridPosition (\n    const std::string &amp; str\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition-44","title":"function GridPosition [4/4]","text":"<pre><code>cse491::GridPosition::GridPosition (\n    const GridPosition &amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-isinvalid","title":"function IsInvalid","text":"<pre><code>inline bool cse491::GridPosition::IsInvalid () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-isnear","title":"function IsNear","text":"<pre><code>inline bool cse491::GridPosition::IsNear (\n    GridPosition pos2,\n    double max_dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-isvalid","title":"function IsValid","text":"<pre><code>inline bool cse491::GridPosition::IsValid () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-mdistance","title":"function MDistance","text":"<p>Manhattan distance between grid positions. </p> <pre><code>inline double cse491::GridPosition::MDistance (\n    GridPosition pos2\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos2</code> Position to compare to </li> </ul> <p>Returns:</p> <p>Manhattan distance </p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-makeinvalid","title":"function MakeInvalid","text":"<p>Make this grid position invalid, by setting both coords to \"not-a-number\". </p> <pre><code>inline GridPosition &amp; cse491::GridPosition::MakeInvalid () \n</code></pre> <p>Returns:</p> <p>This object. </p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Override to store the current state of this object for later extraction. </p> <pre><code>inline virtual void cse491::GridPosition::Serialize_impl (\n    std::ostream &amp;\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_stream</code> An ostream that the required information should be stored in. </li> </ul> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-set","title":"function Set","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::Set (\n    double in_x,\n    double in_y\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-setx","title":"function SetX","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::SetX (\n    double in\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-sety","title":"function SetY","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::SetY (\n    double in\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-shift","title":"function Shift","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::Shift (\n    double shift_x,\n    double shift_y\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-toleft","title":"function ToLeft","text":"<pre><code>inline GridPosition cse491::GridPosition::ToLeft (\n    double dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-toright","title":"function ToRight","text":"<pre><code>inline GridPosition cse491::GridPosition::ToRight (\n    double dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-tostring","title":"function ToString","text":"<pre><code>inline std::string cse491::GridPosition::ToString () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator","title":"function operator+","text":"<pre><code>inline GridPosition cse491::GridPosition::operator+ (\n    GridPosition in\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator_1","title":"function operator+=","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::operator+= (\n    const GridPosition &amp; in\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator-","title":"function operator-=","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::operator-= (\n    const GridPosition &amp; in\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator_2","title":"function operator&lt;=&gt;","text":"<pre><code>auto cse491::GridPosition::operator&lt;=&gt; (\n    const GridPosition &amp;\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator_3","title":"function operator=","text":"<pre><code>GridPosition &amp; cse491::GridPosition::operator= (\n    const GridPosition &amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition","title":"function ~GridPosition","text":"<pre><code>cse491::GridPosition::~GridPosition () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-invalid","title":"function Invalid","text":"<pre><code>static inline const GridPosition &amp; cse491::GridPosition::Invalid () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/GridPosition.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_interface_base/","title":"Class cse491::InterfaceBase","text":"<p>ClassList &gt; cse491 &gt; InterfaceBase</p> <p>Inherits the following classes: cse491::AgentBase</p>"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions","title":"Public Functions","text":"Type Name InterfaceBase (size_t id, const std::string &amp; name)  virtual bool IsInterface () override constIs Entity an interface for a human? ~InterfaceBase () = default"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions-inherited-from-cse491agentbase","title":"Public Functions inherited from cse491::AgentBase","text":"<p>See cse491::AgentBase</p> Type Name virtual AgentBase &amp; AddAction (const std::string &amp; action_name, size_t action_id) Provide a new action that this agent can take. AgentBase (size_t id, const std::string &amp; name) Default value upon initialization. virtual void Deserialize_impl (std::istream &amp; is) overrideDeserialize item-specific values and call Entity 's Deserialize_impl. size_t GetActionID (const std::string &amp; action_name) constReturn an action ID if that action exists, otherwise return zero. int GetActionResult () constRetrieve the result of the most recent action. State GetAgentState () Get the current state of the Agent. virtual GridPosition GetNextPosition () Allow derived agents to provide an arbitrary next position for the world to move the agent to. virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. bool HasAction (const std::string &amp; action_name) constTest if agent already has a specified action. virtual bool Initialize () Run AFTER the world configures the agent, for additional tests or setup. virtual bool IsAgent () override constIs Entity an autonomous agent? virtual void Notify (const std::string &amp;, const std::string &amp;=\"none\") Send a notification to this agent, typically from the world. virtual size_t SelectAction (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) Decide the next action for this agent to perform; should be overridden! virtual void Serialize_impl (std::ostream &amp; os) override constSerialize item-specific values and call Entity 's Serialize_impl. void SetActionResult (int result) Update the result from the most recent action. void TakeDamage (cse491::AgentBase &amp; agent) If the agent is in State::Taking_Damage, decrease the health by the damage factor once per timestep. void UpdateAgentState (cse491::AgentBase &amp; agent) Updates an Agent's state depending on health. void storeActionMap (std::string name)  ~AgentBase () = default"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions-inherited-from-cse491entity","title":"Public Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Entity &amp; AddItem (size_t id)  Entity &amp; AddItem (Entity &amp; item)  virtual void Deserialize_impl (std::istream &amp; is) overrideSerialize entity-specific values. Entity (size_t id, const std::string &amp; name)  Entity (const Entity &amp;) = delete Entity (Entity &amp;&amp;) = default size_t GetGridID () const size_t GetID () const std::vector&lt; size_t &gt; GetInventory () const const std::string &amp; GetName () const size_t GetNumProperties () constHow many properties does this entity have? GridPosition GetPosition () const const T &amp; GetProperty (const std::string &amp; name) constReturn the current value of the specified property. property_map_t &amp; GetPropertyMap () return the property map for the entity PropertyType GetPropertyType (const std::string &amp; name) const WorldBase &amp; GetWorld () const bool HasItem (size_t id) constInventory Management. bool HasProperty (const std::string &amp; name) constDoes this agent have a property with the specified name? bool HasWorld () const virtual bool IsAgent () constIs Entity an autonomous agent? virtual bool IsInterface () constIs Entity an interface for a human? virtual bool IsItem () constIs Entity an item? bool IsOnGrid (size_t in_grid_id) const Entity &amp; RemoveItem (size_t id)  Entity &amp; RemoveItem (Entity &amp; item)  Entity &amp; RemoveProperty (const std::string &amp; name) Completely remove a property from an Entity . virtual void Serialize_impl (std::ostream &amp; os) override constSerialize entity-specific values. Entity &amp; SetName (const std::string in_name)  Entity &amp; SetPosition (GridPosition in_pos, size_t grid_id=0)  Entity &amp; SetPosition (double x, double y)  Entity &amp; SetProperties () Allow for setting multiple properties at once. Entity &amp; SetProperties (const std::string &amp; name, VALUE_T &amp;&amp; value, EXTRA_Ts &amp;&amp;... extras)  Entity &amp; SetProperty (const std::string &amp; name, const T &amp; value) Change the value of the specified property (will create if needed) virtual Entity &amp; SetWorld (WorldBase &amp; in_world)  Entity &amp; operator= (const Entity &amp;) = delete Entity &amp; operator= (Entity &amp;&amp;) = delete virtual ~Entity () = default"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-types-inherited-from-cse491entity","title":"Protected Types inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name typedef std::unordered_map&lt; std::string, std::unique_ptr&lt; PropertyBase &gt; &gt; property_map_t Every entity can have a simple set of properties (with values) associated with it."},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-attributes-inherited-from-cse491agentbase","title":"Protected Attributes inherited from cse491::AgentBase","text":"<p>See cse491::AgentBase</p> Type Name int action Action that agent is currently performing. std::unordered_map&lt; std::string, size_t &gt; action_map Map of names to action ids. int action_result   = = 0Usually a one (success) or zero (failure). State agent_state   = = Healthy"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-attributes-inherited-from-cse491entity","title":"Protected Attributes inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name size_t grid_id   = = 0Which grid is this entity on? size_t id   = = 0Unique ID for this entity (0 is used for \"no ID\") std::vector&lt; size_t &gt; inventory What entity ids are held by this entity? std::string name   = = \"\"Name for this entity (E.g., \"Player 1\" or \"+2 Sword\") GridPosition position Where on the grid is this entity? property_map_t property_map"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-functions-inherited-from-cse491entity","title":"Protected Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Property&lt; T &gt; &amp; AsProperty (const std::string &amp; name) const"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-static-functions","title":"Protected Static Functions","text":"Type Name void exitCleanup ()"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_interface_base/#function-interfacebase","title":"function InterfaceBase","text":"<pre><code>inline cse491::InterfaceBase::InterfaceBase (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_interface_base/#function-isinterface","title":"function IsInterface","text":"<pre><code>inline virtual bool cse491::InterfaceBase::IsInterface () override const\n</code></pre> <p>Implements cse491::Entity::IsInterface</p>"},{"location":"Core%20Project/classcse491_1_1_interface_base/#function-interfacebase_1","title":"function ~InterfaceBase","text":"<pre><code>cse491::InterfaceBase::~InterfaceBase () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_interface_base/#function-exitcleanup","title":"function exitCleanup","text":"<pre><code>static inline void cse491::InterfaceBase::exitCleanup () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/InterfaceBase.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_item_base/","title":"Class cse491::ItemBase","text":"<p>ClassList &gt; cse491 &gt; ItemBase</p> <p>Inherits the following classes: cse491::Entity</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#public-functions","title":"Public Functions","text":"Type Name virtual void Deserialize_impl (std::istream &amp; is) overrideDeserialize item-specific values and call Entity 's Deserialize_impl. size_t GetOwnerID () const virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. virtual bool IsItem () override constIs Entity an item? bool IsOnGrid () const bool IsOnGrid (size_t grid_id) const bool IsOwned () const bool IsOwnedBy (size_t entity_id) const bool IsOwnedByAgent () const bool IsOwnedByAgent (size_t agent_id) const bool IsOwnedByItem () const bool IsOwnedByItem (size_t item_id) const ItemBase (size_t id, const std::string &amp; name)  virtual void Serialize_impl (std::ostream &amp; os) override constSerialize item-specific values and call Entity 's Serialize_impl. ItemBase &amp; SetGrid (size_t grid_id=0)  ItemBase &amp; SetOwner (const Entity &amp; owner) Identify the entity (item or agent) that now owns this item. ItemBase &amp; SetUnowned ()  ~ItemBase () = default"},{"location":"Core%20Project/classcse491_1_1_item_base/#public-functions-inherited-from-cse491entity","title":"Public Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Entity &amp; AddItem (size_t id)  Entity &amp; AddItem (Entity &amp; item)  virtual void Deserialize_impl (std::istream &amp; is) overrideSerialize entity-specific values. Entity (size_t id, const std::string &amp; name)  Entity (const Entity &amp;) = delete Entity (Entity &amp;&amp;) = default size_t GetGridID () const size_t GetID () const std::vector&lt; size_t &gt; GetInventory () const const std::string &amp; GetName () const size_t GetNumProperties () constHow many properties does this entity have? GridPosition GetPosition () const const T &amp; GetProperty (const std::string &amp; name) constReturn the current value of the specified property. property_map_t &amp; GetPropertyMap () return the property map for the entity PropertyType GetPropertyType (const std::string &amp; name) const WorldBase &amp; GetWorld () const bool HasItem (size_t id) constInventory Management. bool HasProperty (const std::string &amp; name) constDoes this agent have a property with the specified name? bool HasWorld () const virtual bool IsAgent () constIs Entity an autonomous agent? virtual bool IsInterface () constIs Entity an interface for a human? virtual bool IsItem () constIs Entity an item? bool IsOnGrid (size_t in_grid_id) const Entity &amp; RemoveItem (size_t id)  Entity &amp; RemoveItem (Entity &amp; item)  Entity &amp; RemoveProperty (const std::string &amp; name) Completely remove a property from an Entity . virtual void Serialize_impl (std::ostream &amp; os) override constSerialize entity-specific values. Entity &amp; SetName (const std::string in_name)  Entity &amp; SetPosition (GridPosition in_pos, size_t grid_id=0)  Entity &amp; SetPosition (double x, double y)  Entity &amp; SetProperties () Allow for setting multiple properties at once. Entity &amp; SetProperties (const std::string &amp; name, VALUE_T &amp;&amp; value, EXTRA_Ts &amp;&amp;... extras)  Entity &amp; SetProperty (const std::string &amp; name, const T &amp; value) Change the value of the specified property (will create if needed) virtual Entity &amp; SetWorld (WorldBase &amp; in_world)  Entity &amp; operator= (const Entity &amp;) = delete Entity &amp; operator= (Entity &amp;&amp;) = delete virtual ~Entity () = default"},{"location":"Core%20Project/classcse491_1_1_item_base/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-types","title":"Protected Types","text":"Type Name enum OwnerType"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-types-inherited-from-cse491entity","title":"Protected Types inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name typedef std::unordered_map&lt; std::string, std::unique_ptr&lt; PropertyBase &gt; &gt; property_map_t Every entity can have a simple set of properties (with values) associated with it."},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t owner_id   = = 0 OwnerType owner_type   = = OwnerType::NONE"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-attributes-inherited-from-cse491entity","title":"Protected Attributes inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name size_t grid_id   = = 0Which grid is this entity on? size_t id   = = 0Unique ID for this entity (0 is used for \"no ID\") std::vector&lt; size_t &gt; inventory What entity ids are held by this entity? std::string name   = = \"\"Name for this entity (E.g., \"Player 1\" or \"+2 Sword\") GridPosition position Where on the grid is this entity? property_map_t property_map"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-functions-inherited-from-cse491entity","title":"Protected Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Property&lt; T &gt; &amp; AsProperty (const std::string &amp; name) const"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_item_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_item_base/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Deserialize item-specific values and call Entity 's Deserialize_impl.</p> <pre><code>inline virtual void cse491::ItemBase::Deserialize_impl (\n    std::istream &amp; is\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> istream to read contents from. </li> </ul> <p>Implements cse491::Entity::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-getownerid","title":"function GetOwnerID","text":"<pre><code>inline size_t cse491::ItemBase::GetOwnerID () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::ItemBase::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isitem","title":"function IsItem","text":"<pre><code>inline virtual bool cse491::ItemBase::IsItem () override const\n</code></pre> <p>Implements cse491::Entity::IsItem</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isongrid-12","title":"function IsOnGrid [1/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOnGrid () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isongrid-22","title":"function IsOnGrid [2/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOnGrid (\n    size_t grid_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isowned","title":"function IsOwned","text":"<pre><code>inline bool cse491::ItemBase::IsOwned () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedby","title":"function IsOwnedBy","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedBy (\n    size_t entity_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedbyagent-12","title":"function IsOwnedByAgent [1/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedByAgent () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedbyagent-22","title":"function IsOwnedByAgent [2/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedByAgent (\n    size_t agent_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedbyitem-12","title":"function IsOwnedByItem [1/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedByItem () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedbyitem-22","title":"function IsOwnedByItem [2/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedByItem (\n    size_t item_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-itembase","title":"function ItemBase","text":"<pre><code>inline cse491::ItemBase::ItemBase (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Serialize item-specific values and call Entity 's Serialize_impl.</p> <pre><code>inline virtual void cse491::ItemBase::Serialize_impl (\n    std::ostream &amp; os\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream to write contents to. </li> </ul> <p>Implements cse491::Entity::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-setgrid","title":"function SetGrid","text":"<pre><code>inline ItemBase &amp; cse491::ItemBase::SetGrid (\n    size_t grid_id=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-setowner","title":"function SetOwner","text":"<p>Identify the entity (item or agent) that now owns this item. </p> <pre><code>inline ItemBase &amp; cse491::ItemBase::SetOwner (\n    const Entity &amp; owner\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>owner</code> The new owning entity. </li> </ul> <p>Returns:</p> <p>A reference to this item. </p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-setunowned","title":"function SetUnowned","text":"<pre><code>inline ItemBase &amp; cse491::ItemBase::SetUnowned () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-itembase_1","title":"function ~ItemBase","text":"<pre><code>cse491::ItemBase::~ItemBase () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_item_base/#enum-ownertype","title":"enum OwnerType","text":"<pre><code>enum cse491::ItemBase::OwnerType {\n    NONE = 0,\n    GRID,\n    ITEM,\n    AGENT\n};\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_item_base/#variable-owner_id","title":"variable owner_id","text":"<pre><code>size_t owner_id;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#variable-owner_type","title":"variable owner_type","text":"<pre><code>OwnerType owner_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/ItemBase.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1_property/","title":"Struct cse491::Property","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; cse491 &gt; Property</p> <p>Inherits the following classes: cse491::PropertyBase</p>"},{"location":"Core%20Project/structcse491_1_1_property/#public-attributes","title":"Public Attributes","text":"Type Name T value"},{"location":"Core%20Project/structcse491_1_1_property/#public-functions","title":"Public Functions","text":"Type Name virtual void Deserialize_impl (std::istream &amp;) overrideOverride to restore the state of this object from the provided stream. virtual PropertyType GetType () override const virtual std::string GetTypeName () override const virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. Property (const T &amp; in)  Property (T &amp;&amp; in)  virtual void Serialize_impl (std::ostream &amp;) override constOverride to store the current state of this object for later extraction. virtual char ToChar () override const virtual double ToDouble () override const virtual GridPosition ToGridPosition () override const virtual int ToInt () override const virtual std::string ToString () override const"},{"location":"Core%20Project/structcse491_1_1_property/#public-functions-inherited-from-cse491propertybase","title":"Public Functions inherited from cse491::PropertyBase","text":"<p>See cse491::PropertyBase</p> Type Name virtual PropertyType GetType () const = 0 virtual std::string GetTypeName () const = 0 virtual char ToChar () const = 0 virtual double ToDouble () const = 0 virtual GridPosition ToGridPosition () const = 0 virtual int ToInt () const = 0 virtual std::string ToString () const = 0 virtual ~PropertyBase ()"},{"location":"Core%20Project/structcse491_1_1_property/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/structcse491_1_1_property/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/structcse491_1_1_property/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_property/#variable-value","title":"variable value","text":"<pre><code>T value;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_property/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Override to restore the state of this object from the provided stream. </p> <pre><code>inline virtual void cse491::Property::Deserialize_impl (\n    std::istream &amp;\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>input_stream</code> The istream with full details about this object. </li> </ul> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-gettype","title":"function GetType","text":"<pre><code>inline virtual PropertyType cse491::Property::GetType () override const\n</code></pre> <p>Implements cse491::PropertyBase::GetType</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-gettypename","title":"function GetTypeName","text":"<pre><code>inline virtual std::string cse491::Property::GetTypeName () override const\n</code></pre> <p>Implements cse491::PropertyBase::GetTypeName</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::Property::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-property-12","title":"function Property [1/2]","text":"<pre><code>inline cse491::Property::Property (\n    const T &amp; in\n) \n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property/#function-property-22","title":"function Property [2/2]","text":"<pre><code>inline cse491::Property::Property (\n    T &amp;&amp; in\n) \n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Override to store the current state of this object for later extraction. </p> <pre><code>inline virtual void cse491::Property::Serialize_impl (\n    std::ostream &amp;\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_stream</code> An ostream that the required information should be stored in. </li> </ul> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-tochar","title":"function ToChar","text":"<pre><code>inline virtual char cse491::Property::ToChar () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToChar</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-todouble","title":"function ToDouble","text":"<pre><code>inline virtual double cse491::Property::ToDouble () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToDouble</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-togridposition","title":"function ToGridPosition","text":"<pre><code>inline virtual GridPosition cse491::Property::ToGridPosition () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToGridPosition</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-toint","title":"function ToInt","text":"<pre><code>inline virtual int cse491::Property::ToInt () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToInt</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-tostring","title":"function ToString","text":"<pre><code>inline virtual std::string cse491::Property::ToString () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToString</p> <p>The documentation for this class was generated from the following file <code>source/core/Property.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1_property_base/","title":"Struct cse491::PropertyBase","text":"<p>ClassList &gt; cse491 &gt; PropertyBase</p> <p>Inherits the following classes: cse491::CoreObject</p> <p>Inherited by the following classes: cse491::Property</p>"},{"location":"Core%20Project/structcse491_1_1_property_base/#public-functions","title":"Public Functions","text":"Type Name virtual PropertyType GetType () const = 0 virtual std::string GetTypeName () const = 0 virtual char ToChar () const = 0 virtual double ToDouble () const = 0 virtual GridPosition ToGridPosition () const = 0 virtual int ToInt () const = 0 virtual std::string ToString () const = 0 virtual ~PropertyBase ()"},{"location":"Core%20Project/structcse491_1_1_property_base/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/structcse491_1_1_property_base/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/structcse491_1_1_property_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_property_base/#function-gettype","title":"function GetType","text":"<pre><code>virtual PropertyType cse491::PropertyBase::GetType () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-gettypename","title":"function GetTypeName","text":"<pre><code>virtual std::string cse491::PropertyBase::GetTypeName () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-tochar","title":"function ToChar","text":"<pre><code>virtual char cse491::PropertyBase::ToChar () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-todouble","title":"function ToDouble","text":"<pre><code>virtual double cse491::PropertyBase::ToDouble () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-togridposition","title":"function ToGridPosition","text":"<pre><code>virtual GridPosition cse491::PropertyBase::ToGridPosition () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-toint","title":"function ToInt","text":"<pre><code>virtual int cse491::PropertyBase::ToInt () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-tostring","title":"function ToString","text":"<pre><code>virtual std::string cse491::PropertyBase::ToString () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-propertybase","title":"function ~PropertyBase","text":"<pre><code>inline virtual cse491::PropertyBase::~PropertyBase () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/Property.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_world_base/","title":"Class cse491::WorldBase","text":"<p>ClassList &gt; cse491 &gt; WorldBase</p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-attributes","title":"Public Attributes","text":"Type Name netWorth::ClientManager * client_manager   = = nullptrServer manager for world if used. netWorth::ServerManager * server_manager   = = nullptr"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t npos   = = static_cast&lt;size_t&gt;(-1)"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-functions","title":"Public Functions","text":"Type Name AgentBase &amp; AddAgent (std::string agent_name=\"None\", PROPERTY_Ts... properties) Build a new agent of the specified type. AgentBase &amp; AddConfiguredAgent (std::unique_ptr&lt; AgentBase &gt; agent_ptr) Add an already-created agent. ItemBase &amp; AddItem (std::unique_ptr&lt; ItemBase &gt; item_ptr) Add a new, already-built item. ItemBase &amp; AddItem (std::string item_name=\"None\", PROPERTY_Ts... properties) Build a new item and add it. WorldBase &amp; AddItemToGrid (size_t item_id, GridPosition pos, size_t grid_id=0)  void CollectData ()  virtual void ConfigAgent (AgentBase &amp;) constClient manager for world if used. void Deserialize (std::istream &amp; is, netWorth::ClientManager * manager) Deserialize world, agents, and items from istream. void DeserializeAgentSet (std::istream &amp; is, netWorth::ClientManager * manager) Add deserialized agents to world with a manager. void DeserializeItemSet (std::istream &amp; is) Add deserialized items to world. virtual int DoAction (AgentBase &amp; agent, size_t action_id) = 0Central function for an agent to take any action. virtual std::vector&lt; size_t &gt; FindAgentsAt (GridPosition pos, size_t grid_id=0) constLookup IDs for all agents at a given grid position. virtual std::vector&lt; size_t &gt; FindAgentsNear (GridPosition pos, double dist=1.0, size_t grid_id=0) constLookup IDs for all agents near a given grid position. virtual std::vector&lt; size_t &gt; FindItemsAt (GridPosition pos, size_t grid_id=0) constLookup IDs for all items at a given grid position. virtual std::vector&lt; size_t &gt; FindItemsNear (GridPosition pos, double dist=1.0, size_t grid_id=0) constLookup IDs for all items near a given grid position. AgentBase &amp; GetAgent (size_t id) Return a reference to an agent with a given ID. size_t GetAgentID (const std::string &amp; name) Return the ID of an agent with a given name. size_t GetCellTypeID (const std::string &amp; name) constReturn the ID associated with the cell type name. const std::string &amp; GetCellTypeName (size_t id) const char GetCellTypeSymbol (size_t id) const const type_options_t &amp; GetCellTypes () const virtual WorldGrid &amp; GetGrid () Return an editable version of the current grid for this world (main_grid by default) virtual WorldGrid &amp; GetGrid (size_t grid_id)  virtual const WorldGrid &amp; GetGrid () constReturn a const grid for this world (main_grid by default) virtual const WorldGrid &amp; GetGrid (size_t grid_id) const ItemBase &amp; GetItem (size_t id) Return a reference to an agent with a given ID. size_t GetItemID (const std::string &amp; name) Return the ID of an item with a given name. size_t GetNumAgents () constGet the total number of AGENT entities. size_t GetNumItems () constGet the total number of NON-agent entities. double GetRandom () Return a uniform random value between 0.0 and 1.0. double GetRandom (double max) Return a uniform random value between 0.0 and max. double GetRandom (double min, double max) Return a uniform random value between min and max. double GetRandomNormal () Return a gaussian random value with mean 0.0 and sd 1.0. double GetRandomNormal (double mean, double sd=1.0) Return a gaussian random value with provided mean and sd. virtual bool GetRunOver () constDetermine if the run has ended. unsigned int GetSeed () constGet the seed used to initialize this RNG. bool HasAgent (size_t id) constDoes an agent with the provided ID exist? bool HasItem (size_t id) constDoes an item with the provided ID exist? virtual bool IsTraversable (const AgentBase &amp;, cse491::GridPosition) constDetermine if this tile can be walked on, defaults to every tile is walkable. WorldBase &amp; RemoveAgent (size_t agent_id) Remove an agent from the agent map. WorldBase &amp; RemoveAgent (std::string agent_name=\"None\") Remove an agent from the agent map by name. WorldBase &amp; RemoveItem (size_t item_id) Remove an item from the item map. WorldBase &amp; RemoveItem (std::string item_name) Remove an item from the item map by name. virtual void Reset ()  virtual void Run () Run all agents repeatedly until an end condition is met. virtual void RunAgents () Step through each agent giving them a chance to take an action. virtual void RunClient (netWorth::ClientManager * manager) Run, but for client-side. virtual void RunClientAgents () RunAgents, but with extra features for client-side. virtual void RunServer (netWorth::ServerManager * manager) Run, but for server-side. virtual void RunServerAgents () RunAgents, but with extra features for server-side. void Serialize (std::ostream &amp; os) Serialize world, agents, and items into ostream. void SerializeAgentSet (std::ostream &amp; os) Serialize agent data into an ostream. void SerializeItemSet (std::ostream &amp; os) Serialize item data into an ostream. virtual void SetWorldRunning (bool running) Set if world is running or not for concurrency purposes. virtual void UpdateWorld () UpdateWorld() is run after every agent has a turn. Override this function to manage background events for a world. WorldBase (unsigned int seed=0)  virtual ~WorldBase () = default"},{"location":"Core%20Project/classcse491_1_1_world_base/#protected-attributes","title":"Protected Attributes","text":"Type Name std::string action The action that the agent is currently performing. agent_map_t agent_map Map of IDs to pointers to agent entities. std::shared_ptr&lt; DataCollection::AgentReceiver &gt; agent_receiver std::unordered_map&lt; size_t, WorldGrid &gt; grids Derived worlds may choose to have more than one grid. item_map_t item_map Map of IDs to pointers to non-agent entities. size_t last_entity_id   = = 0The last Entity ID used; increment at each creation. WorldGrid &amp; main_grid Main grid for this world; shortcut to <code>grids[\"main\"]</code> __ std::normal_distribution norm_dist Normal distribution; mean 0, std 1. std::mt19937 random_gen Random number generator. bool run_over   = = falseShould the run end? unsigned int seed Seed used for generator. type_options_t type_options Vector of types of cells in grids for this world. std::uniform_real_distribution uni_dist Uniform distribution of doubles, 0 to 1. bool world_running   = = trueIs the world currently running?"},{"location":"Core%20Project/classcse491_1_1_world_base/#protected-functions","title":"Protected Functions","text":"Type Name size_t AddCellType (const std::string &amp; name, const std::string &amp; desc=\"\", char symbol='\\0') Add a new type of cell to this world. virtual void ConfigAgent (AgentBase &amp;)  size_t NextEntityID () Helper function to set the next entity id."},{"location":"Core%20Project/classcse491_1_1_world_base/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-client_manager","title":"variable client_manager","text":"<pre><code>netWorth::ClientManager* client_manager;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-server_manager","title":"variable server_manager","text":"<pre><code>netWorth::ServerManager* server_manager;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-npos","title":"variable npos","text":"<pre><code>constexpr size_t npos;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#function-addagent","title":"function AddAgent","text":"<p>Build a new agent of the specified type. </p> <pre><code>template&lt;typename AGENT_T typename AGENT_T, typename... PROPERTY_Ts&gt;\ninline AgentBase &amp; cse491::WorldBase::AddAgent (\n    std::string agent_name=\"None\",\n    PROPERTY_Ts... properties\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>AGENT_T</code> The type of agent to build </li> <li><code>PROPERTY_Ts</code> Types for any properties to set at creation (automatic) </li> </ul> <p>Parameters:</p> <ul> <li><code>agent_name</code> The name of this agent </li> <li><code>properties</code> Name/value pairs for any properties set at creation </li> </ul> <p>Returns:</p> <p>A reference to the newly created agent </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-addconfiguredagent","title":"function AddConfiguredAgent","text":"<pre><code>inline AgentBase &amp; cse491::WorldBase::AddConfiguredAgent (\n    std::unique_ptr&lt; AgentBase &gt; agent_ptr\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-additem-12","title":"function AddItem [1/2]","text":"<p>Add a new, already-built item. </p> <pre><code>inline ItemBase &amp; cse491::WorldBase::AddItem (\n    std::unique_ptr&lt; ItemBase &gt; item_ptr\n) \n</code></pre> <p>Returns:</p> <p>A reference to the newly created item </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-additem-22","title":"function AddItem [2/2]","text":"<p>Build a new item and add it. </p> <pre><code>template&lt;typename ITEM_T typename ITEM_T, typename... PROPERTY_Ts&gt;\ninline ItemBase &amp; cse491::WorldBase::AddItem (\n    std::string item_name=\"None\",\n    PROPERTY_Ts... properties\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>PROPERTY_Ts</code> Types for any properties to set at creation (automatic) </li> </ul> <p>Parameters:</p> <ul> <li><code>item_name</code> The name of this item </li> <li><code>properties</code> Name/value pairs for any properties set at creation </li> </ul> <p>Returns:</p> <p>A reference to the newly created item </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-additemtogrid","title":"function AddItemToGrid","text":"<pre><code>inline WorldBase &amp; cse491::WorldBase::AddItemToGrid (\n    size_t item_id,\n    GridPosition pos,\n    size_t grid_id=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-collectdata","title":"function CollectData","text":"<pre><code>inline void cse491::WorldBase::CollectData () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-configagent-12","title":"function ConfigAgent [1/2]","text":"<p>Client manager for world if used. </p> <pre><code>inline virtual void cse491::WorldBase::ConfigAgent (\n    AgentBase &amp;\n) const\n</code></pre> <p>Helper function that is run whenever a new agent is created. </p> <p>Note:</p> <p>Override this function to provide agents with actions or other setup. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-deserialize","title":"function Deserialize","text":"<p>Deserialize world, agents, and items from istream. </p> <pre><code>inline void cse491::WorldBase::Deserialize (\n    std::istream &amp; is,\n    netWorth::ClientManager * manager\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>manager</code> ClientManager for ControlledAgents </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-deserializeagentset","title":"function DeserializeAgentSet","text":"<p>Add deserialized agents to world with a manager. </p> <pre><code>inline void cse491::WorldBase::DeserializeAgentSet (\n    std::istream &amp; is,\n    netWorth::ClientManager * manager\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> istream </li> <li><code>manager</code> ClientManager which manages ControlledAgents </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-deserializeitemset","title":"function DeserializeItemSet","text":"<p>Add deserialized items to world. </p> <pre><code>inline void cse491::WorldBase::DeserializeItemSet (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>istream</code> </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-doaction","title":"function DoAction","text":"<p>Central function for an agent to take any action. </p> <pre><code>virtual int cse491::WorldBase::DoAction (\n    AgentBase &amp; agent,\n    size_t action_id\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The specific agent taking the action </li> <li><code>action</code> The id of the action to take </li> </ul> <p>Returns:</p> <p>The result of this action (usually 0/1 to indicate success) </p> <p>Note:</p> <p>Thus function must be overridden in any derived world. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-findagentsat","title":"function FindAgentsAt","text":"<p>Lookup IDs for all agents at a given grid position. </p> <pre><code>inline virtual std::vector&lt; size_t &gt; cse491::WorldBase::FindAgentsAt (\n    GridPosition pos,\n    size_t grid_id=0\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> Grid position to look up. </li> </ul> <p>Returns:</p> <p>A vector of agent IDs at the target position. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-findagentsnear","title":"function FindAgentsNear","text":"<p>Lookup IDs for all agents near a given grid position. </p> <pre><code>inline virtual std::vector&lt; size_t &gt; cse491::WorldBase::FindAgentsNear (\n    GridPosition pos,\n    double dist=1.0,\n    size_t grid_id=0\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> Grid position to look up. </li> <li><code>dist</code> Maximum distance away from pos for an agent to be included. </li> </ul> <p>Returns:</p> <p>A vector of agent IDs within dist of the target position. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-finditemsat","title":"function FindItemsAt","text":"<p>Lookup IDs for all items at a given grid position. </p> <pre><code>inline virtual std::vector&lt; size_t &gt; cse491::WorldBase::FindItemsAt (\n    GridPosition pos,\n    size_t grid_id=0\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> Grid position to look up. </li> <li><code>grid_id</code> ID of grid we are examining (default: main grid) </li> </ul> <p>Returns:</p> <p>A vector of item IDs at the target position. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-finditemsnear","title":"function FindItemsNear","text":"<p>Lookup IDs for all items near a given grid position. </p> <pre><code>inline virtual std::vector&lt; size_t &gt; cse491::WorldBase::FindItemsNear (\n    GridPosition pos,\n    double dist=1.0,\n    size_t grid_id=0\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> Grid position to look up. </li> <li><code>dist</code> Maximum distance away from pos for an item to be included. </li> </ul> <p>Returns:</p> <p>A vector of item IDs within dist of the target position. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getagent","title":"function GetAgent","text":"<pre><code>inline AgentBase &amp; cse491::WorldBase::GetAgent (\n    size_t id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getagentid","title":"function GetAgentID","text":"<pre><code>inline size_t cse491::WorldBase::GetAgentID (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getcelltypeid","title":"function GetCellTypeID","text":"<p>Return the ID associated with the cell type name. </p> <pre><code>inline size_t cse491::WorldBase::GetCellTypeID (\n    const std::string &amp; name\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> The unique name of the cell type </li> </ul> <p>Returns:</p> <p>The unique ID of the cell type (or 0 if it doesn't exist.) </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getcelltypename","title":"function GetCellTypeName","text":"<pre><code>inline const std::string &amp; cse491::WorldBase::GetCellTypeName (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getcelltypesymbol","title":"function GetCellTypeSymbol","text":"<pre><code>inline char cse491::WorldBase::GetCellTypeSymbol (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getcelltypes","title":"function GetCellTypes","text":"<pre><code>inline const type_options_t &amp; cse491::WorldBase::GetCellTypes () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getgrid-14","title":"function GetGrid [1/4]","text":"<pre><code>inline virtual WorldGrid &amp; cse491::WorldBase::GetGrid () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getgrid-24","title":"function GetGrid [2/4]","text":"<pre><code>inline virtual WorldGrid &amp; cse491::WorldBase::GetGrid (\n    size_t grid_id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getgrid-34","title":"function GetGrid [3/4]","text":"<pre><code>inline virtual const WorldGrid &amp; cse491::WorldBase::GetGrid () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getgrid-44","title":"function GetGrid [4/4]","text":"<pre><code>inline virtual const WorldGrid &amp; cse491::WorldBase::GetGrid (\n    size_t grid_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getitem","title":"function GetItem","text":"<pre><code>inline ItemBase &amp; cse491::WorldBase::GetItem (\n    size_t id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getitemid","title":"function GetItemID","text":"<pre><code>inline size_t cse491::WorldBase::GetItemID (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getnumagents","title":"function GetNumAgents","text":"<pre><code>inline size_t cse491::WorldBase::GetNumAgents () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getnumitems","title":"function GetNumItems","text":"<pre><code>inline size_t cse491::WorldBase::GetNumItems () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandom-13","title":"function GetRandom [1/3]","text":"<pre><code>inline double cse491::WorldBase::GetRandom () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandom-23","title":"function GetRandom [2/3]","text":"<pre><code>inline double cse491::WorldBase::GetRandom (\n    double max\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandom-33","title":"function GetRandom [3/3]","text":"<pre><code>inline double cse491::WorldBase::GetRandom (\n    double min,\n    double max\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandomnormal-12","title":"function GetRandomNormal [1/2]","text":"<pre><code>inline double cse491::WorldBase::GetRandomNormal () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandomnormal-22","title":"function GetRandomNormal [2/2]","text":"<pre><code>inline double cse491::WorldBase::GetRandomNormal (\n    double mean,\n    double sd=1.0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrunover","title":"function GetRunOver","text":"<pre><code>inline virtual bool cse491::WorldBase::GetRunOver () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getseed","title":"function GetSeed","text":"<pre><code>inline unsigned int cse491::WorldBase::GetSeed () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-hasagent","title":"function HasAgent","text":"<pre><code>inline bool cse491::WorldBase::HasAgent (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-hasitem","title":"function HasItem","text":"<pre><code>inline bool cse491::WorldBase::HasItem (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-istraversable","title":"function IsTraversable","text":"<p>Determine if this tile can be walked on, defaults to every tile is walkable. </p> <pre><code>inline virtual bool cse491::WorldBase::IsTraversable (\n    const AgentBase &amp;,\n    cse491::GridPosition\n) const\n</code></pre> <p>Author:</p> <p>@mdkdoc15 </p> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position we are checking </li> </ul> <p>Returns:</p> <p>If an agent should be allowed on this square </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-removeagent-12","title":"function RemoveAgent [1/2]","text":"<p>Remove an agent from the agent map. </p> <pre><code>inline WorldBase &amp; cse491::WorldBase::RemoveAgent (\n    size_t agent_id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent_id</code> The unique ID this agent </li> </ul> <p>Returns:</p> <p>A reference to this world. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-removeagent-22","title":"function RemoveAgent [2/2]","text":"<p>Remove an agent from the agent map by name. </p> <pre><code>inline WorldBase &amp; cse491::WorldBase::RemoveAgent (\n    std::string agent_name=\"None\"\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent_name</code> The name of this agent </li> </ul> <p>Returns:</p> <p>This world </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-removeitem-12","title":"function RemoveItem [1/2]","text":"<p>Remove an item from the item map. </p> <pre><code>inline WorldBase &amp; cse491::WorldBase::RemoveItem (\n    size_t item_id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>item_id</code> The unique ID this item </li> </ul> <p>Returns:</p> <p>A reference to this world. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-removeitem-22","title":"function RemoveItem [2/2]","text":"<p>Remove an item from the item map by name. </p> <pre><code>inline WorldBase &amp; cse491::WorldBase::RemoveItem (\n    std::string item_name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>item_id</code> The ID of this item </li> </ul> <p>Returns:</p> <p>This world </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-reset","title":"function Reset","text":"<pre><code>inline virtual void cse491::WorldBase::Reset () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-run","title":"function Run","text":"<pre><code>inline virtual void cse491::WorldBase::Run () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runagents","title":"function RunAgents","text":"<p>Step through each agent giving them a chance to take an action. </p> <pre><code>inline virtual void cse491::WorldBase::RunAgents () \n</code></pre> <p>Note:</p> <p>Override this function if you want to control which grid the agents receive. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runclient","title":"function RunClient","text":"<pre><code>inline virtual void cse491::WorldBase::RunClient (\n    netWorth::ClientManager * manager\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runclientagents","title":"function RunClientAgents","text":"<p>RunAgents, but with extra features for client-side. </p> <pre><code>inline virtual void cse491::WorldBase::RunClientAgents () \n</code></pre> <p>Note:</p> <p>Override this function if you want to control which grid the agents receive. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runserver","title":"function RunServer","text":"<pre><code>inline virtual void cse491::WorldBase::RunServer (\n    netWorth::ServerManager * manager\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runserveragents","title":"function RunServerAgents","text":"<p>RunAgents, but with extra features for server-side. </p> <pre><code>inline virtual void cse491::WorldBase::RunServerAgents () \n</code></pre> <p>Note:</p> <p>Override this function if you want to control which grid the agents receive. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-serialize","title":"function Serialize","text":"<p>Serialize world, agents, and items into ostream. </p> <pre><code>inline void cse491::WorldBase::Serialize (\n    std::ostream &amp; os\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-serializeagentset","title":"function SerializeAgentSet","text":"<p>Serialize agent data into an ostream. </p> <pre><code>inline void cse491::WorldBase::SerializeAgentSet (\n    std::ostream &amp; os\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-serializeitemset","title":"function SerializeItemSet","text":"<p>Serialize item data into an ostream. </p> <pre><code>inline void cse491::WorldBase::SerializeItemSet (\n    std::ostream &amp; os\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-setworldrunning","title":"function SetWorldRunning","text":"<pre><code>inline virtual void cse491::WorldBase::SetWorldRunning (\n    bool running\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-updateworld","title":"function UpdateWorld","text":"<pre><code>inline virtual void cse491::WorldBase::UpdateWorld () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-worldbase","title":"function WorldBase","text":"<pre><code>inline cse491::WorldBase::WorldBase (\n    unsigned int seed=0\n) \n</code></pre> <p>Initializes world with cell types and random generator </p> <p>Parameters:</p> <ul> <li><code>seed</code> Seed used for RNG. Use 0 for a non-deterministic result. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-worldbase_1","title":"function ~WorldBase","text":"<pre><code>virtual cse491::WorldBase::~WorldBase () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-action","title":"variable action","text":"<pre><code>std::string action;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-agent_map","title":"variable agent_map","text":"<pre><code>agent_map_t agent_map;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-agent_receiver","title":"variable agent_receiver","text":"<pre><code>std::shared_ptr&lt;DataCollection::AgentReceiver&gt; agent_receiver;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-grids","title":"variable grids","text":"<pre><code>std::unordered_map&lt;size_t, WorldGrid&gt; grids;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-item_map","title":"variable item_map","text":"<pre><code>item_map_t item_map;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-last_entity_id","title":"variable last_entity_id","text":"<pre><code>size_t last_entity_id;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-main_grid","title":"variable main_grid","text":"<pre><code>WorldGrid&amp; main_grid;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-norm_dist","title":"variable norm_dist","text":"<pre><code>std::normal_distribution norm_dist;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-random_gen","title":"variable random_gen","text":"<pre><code>std::mt19937 random_gen;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-run_over","title":"variable run_over","text":"<pre><code>bool run_over;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-seed","title":"variable seed","text":"<pre><code>unsigned int seed;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-type_options","title":"variable type_options","text":"<pre><code>type_options_t type_options;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-uni_dist","title":"variable uni_dist","text":"<pre><code>std::uniform_real_distribution uni_dist;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-world_running","title":"variable world_running","text":"<pre><code>bool world_running;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#function-addcelltype","title":"function AddCellType","text":"<p>Add a new type of cell to this world. </p> <pre><code>inline size_t cse491::WorldBase::AddCellType (\n    const std::string &amp; name,\n    const std::string &amp; desc=\"\",\n    char symbol='\\0'\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> A unique name for this cell type </li> <li><code>desc</code> A longer description of the cell type </li> <li><code>symbol</code> An (optional) unique symbol for text IO (files, command line) </li> </ul> <p>Returns:</p> <p>A unique ID associated with this cell type (position in type_options vector) </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-configagent-22","title":"function ConfigAgent [2/2]","text":"<pre><code>inline virtual void cse491::WorldBase::ConfigAgent (\n    AgentBase &amp;\n) \n</code></pre> <p>Helper function that is run whenever a new agent is created. </p> <p>Note:</p> <p>Override this function to provide agents with actions or other setup. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-nextentityid","title":"function NextEntityID","text":"<pre><code>inline size_t cse491::WorldBase::NextEntityID () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/WorldBase.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/","title":"Class cse491::WorldGrid","text":"<p>ClassList &gt; cse491 &gt; WorldGrid</p> <p>A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. More...</p> <ul> <li><code>#include &lt;CoreObject.hpp&gt;</code></li> </ul> <p>Inherits the following classes: cse491::CoreObject</p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#public-functions","title":"Public Functions","text":"Type Name size_t At (size_t x, size_t y) const size_t &amp; At (size_t x, size_t y)  size_t At (GridPosition p) const size_t &amp; At (GridPosition p)  size_t GetHeight () const size_t GetNumCells () const size_t GetWidth () const bool IsValid (double x, double y) constTest if specific coordinates are in range for this GridWorld. bool IsValid (GridPosition pos) constTest if a GridPosition is in range for this GridWorld. void Read (std::istream &amp; is, const type_options_t &amp; types)  bool Read (std::string filename, const type_options_t &amp; types) Helper function to specify a file name to read the grid state from. void Resize (size_t new_width, size_t new_height, size_t default_type=0)  WorldGrid () = default WorldGrid (size_t width, size_t height, size_t default_type=0)  WorldGrid (const WorldGrid &amp;) = default WorldGrid (WorldGrid &amp;&amp;) = default void Write (std::ostream &amp; os, const type_options_t &amp; types) constWrite out a human-readable version of the current WorldGrid . bool Write (std::string filename, const type_options_t &amp; types) constHelper function to specify a file name to write the grid state to. WorldGrid &amp; operator= (const WorldGrid &amp;) = default WorldGrid &amp; operator= (WorldGrid &amp;&amp;) = default size_t operator[] (GridPosition p) const size_t &amp; operator[] (GridPosition p)"},{"location":"Core%20Project/classcse491_1_1_world_grid/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; size_t &gt; cells All cells, grouped by full rows, top to bottom. size_t height   = = 0Number of rows of cells in the grid. size_t width   = = 0Number of cells in each row of the grid."},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-functions","title":"Protected Functions","text":"Type Name virtual void Deserialize_impl (std::istream &amp; is) overrideRead the state of the grid out of the provided stream. virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp; os) override constWrite the current state of this grid into the provided stream. size_t ToIndex (size_t x, size_t y) constConvert an X and a Y value to the index in the vector."},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_world_grid/#detailed-description","title":"Detailed Description","text":"<p>Represents a 2D grid of cells. This class provides utilities to manage, access, and modify cells within a grid. </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-at-14","title":"function At [1/4]","text":"<pre><code>inline size_t cse491::WorldGrid::At (\n    size_t x,\n    size_t y\n) const\n</code></pre> <p>Returns:</p> <p>The grid state at the provided x and y coordinates </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-at-24","title":"function At [2/4]","text":"<pre><code>inline size_t &amp; cse491::WorldGrid::At (\n    size_t x,\n    size_t y\n) \n</code></pre> <p>Returns:</p> <p>A reference to the grid state at the provided x and y coordinates </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-at-34","title":"function At [3/4]","text":"<pre><code>inline size_t cse491::WorldGrid::At (\n    GridPosition p\n) const\n</code></pre> <p>Returns:</p> <p>The state at a given GridPosition. </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-at-44","title":"function At [4/4]","text":"<pre><code>inline size_t &amp; cse491::WorldGrid::At (\n    GridPosition p\n) \n</code></pre> <p>Returns:</p> <p>A reference to the state at a given GridPosition. </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-getheight","title":"function GetHeight","text":"<pre><code>inline size_t cse491::WorldGrid::GetHeight () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-getnumcells","title":"function GetNumCells","text":"<pre><code>inline size_t cse491::WorldGrid::GetNumCells () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-getwidth","title":"function GetWidth","text":"<pre><code>inline size_t cse491::WorldGrid::GetWidth () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-isvalid-12","title":"function IsValid [1/2]","text":"<pre><code>inline bool cse491::WorldGrid::IsValid (\n    double x,\n    double y\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-isvalid-22","title":"function IsValid [2/2]","text":"<pre><code>inline bool cse491::WorldGrid::IsValid (\n    GridPosition pos\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-read-12","title":"function Read [1/2]","text":"<pre><code>inline void cse491::WorldGrid::Read (\n    std::istream &amp; is,\n    const type_options_t &amp; types\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-read-22","title":"function Read [2/2]","text":"<pre><code>inline bool cse491::WorldGrid::Read (\n    std::string filename,\n    const type_options_t &amp; types\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-resize","title":"function Resize","text":"<pre><code>inline void cse491::WorldGrid::Resize (\n    size_t new_width,\n    size_t new_height,\n    size_t default_type=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-worldgrid-14","title":"function WorldGrid [1/4]","text":"<pre><code>cse491::WorldGrid::WorldGrid () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-worldgrid-24","title":"function WorldGrid [2/4]","text":"<pre><code>inline cse491::WorldGrid::WorldGrid (\n    size_t width,\n    size_t height,\n    size_t default_type=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-worldgrid-34","title":"function WorldGrid [3/4]","text":"<pre><code>cse491::WorldGrid::WorldGrid (\n    const WorldGrid &amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-worldgrid-44","title":"function WorldGrid [4/4]","text":"<pre><code>cse491::WorldGrid::WorldGrid (\n    WorldGrid &amp;&amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-write-12","title":"function Write [1/2]","text":"<p>Write out a human-readable version of the current WorldGrid .</p> <pre><code>inline void cse491::WorldGrid::Write (\n    std::ostream &amp; os,\n    const type_options_t &amp; types\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Stream to write to </li> <li><code>types</code> A vector of CellTypes for symbol identification </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-write-22","title":"function Write [2/2]","text":"<pre><code>inline bool cse491::WorldGrid::Write (\n    std::string filename,\n    const type_options_t &amp; types\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-operator","title":"function operator=","text":"<pre><code>WorldGrid &amp; cse491::WorldGrid::operator= (\n    const WorldGrid &amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-operator_1","title":"function operator=","text":"<pre><code>WorldGrid &amp; cse491::WorldGrid::operator= (\n    WorldGrid &amp;&amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-operator_2","title":"function operator[]","text":"<pre><code>inline size_t cse491::WorldGrid::operator[] (\n    GridPosition p\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-operator_3","title":"function operator[]","text":"<pre><code>inline size_t &amp; cse491::WorldGrid::operator[] (\n    GridPosition p\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_grid/#variable-cells","title":"variable cells","text":"<pre><code>std::vector&lt;size_t&gt; cells;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#variable-height","title":"variable height","text":"<pre><code>size_t height;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#variable-width","title":"variable width","text":"<pre><code>size_t width;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-deserialize_impl","title":"function Deserialize_impl","text":"<pre><code>inline virtual void cse491::WorldGrid::Deserialize_impl (\n    std::istream &amp; is\n) override\n</code></pre> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::WorldGrid::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-serialize_impl","title":"function Serialize_impl","text":"<pre><code>inline virtual void cse491::WorldGrid::Serialize_impl (\n    std::ostream &amp; os\n) override const\n</code></pre> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-toindex","title":"function ToIndex","text":"<pre><code>inline size_t cse491::WorldGrid::ToIndex (\n    size_t x,\n    size_t y\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/WorldGrid.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__any__map/","title":"Struct cse491::is_any_map","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; cse491 &gt; is_any_map</p> <p>Type trait to determine if we are working with any type of map. </p> <ul> <li><code>#include &lt;Serialize.hpp&gt;</code></li> </ul> <p>Inherits the following classes: false_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__any__map_3_01std_1_1map_3_01_k_e_y___t_00_01_v_a_l_u_e___t_01_4_01_4/","title":"Struct cse491::is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt;","text":"<p>template &lt;typename KEY_T typename KEY_T, typename VALUE_T typename VALUE_T&gt;</p> <p>ClassList &gt; cse491 &gt; is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt;</p> <p>Inherits the following classes: true_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__any__map_3_01std_1_1unordered__map_3_01_k_e_y___t_00_01_v_a_l_u_e___t_01_4_01_4/","title":"Struct cse491::is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt;","text":"<p>template &lt;typename KEY_T typename KEY_T, typename VALUE_T typename VALUE_T&gt;</p> <p>ClassList &gt; cse491 &gt; is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt;</p> <p>Inherits the following classes: true_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__vector/","title":"Struct cse491::is_vector","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; cse491 &gt; is_vector</p> <p>Type trait to determine if we are working with a vector. </p> <ul> <li><code>#include &lt;Serialize.hpp&gt;</code></li> </ul> <p>Inherits the following classes: false_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__vector_3_01std_1_1vector_3_01_t_01_4_01_4/","title":"Struct cse491::is_vector&lt; std::vector&lt; T &gt; &gt;","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; cse491 &gt; is_vector&lt; std::vector&lt; T &gt; &gt;</p> <p>Inherits the following classes: true_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Core%20Project/namespaceworldlang/","title":"Namespace worldlang","text":"<p>Namespace List &gt; worldlang</p> <p>A base class for all World modules. More...</p>"},{"location":"Core%20Project/namespaceworldlang/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: ALPHA </p> <p>The documentation for this class was generated from the following file <code>source/core/WorldBase.hpp</code></p>"},{"location":"Core%20Project/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Core%20Project/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir core <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Core%20Project/dir_0d27ce74e9bd514c31e1d63efab6b388/","title":"Dir source/core","text":"<p>FileList &gt; core</p>"},{"location":"Core%20Project/dir_0d27ce74e9bd514c31e1d63efab6b388/#files","title":"Files","text":"Type Name file AgentBase.hpp file CoreObject.hpp file Data.hpp file EasyLogging.hpp file Entity.cpp file Entity.hpp file GridPosition.hpp file InterfaceBase.hpp file ItemBase.hpp file Property.hpp file Serialize.hpp file WorldBase.hpp file WorldGrid.hpp <p>The documentation for this class was generated from the following file <code>source/core/</code></p>"},{"location":"Core%20Project/_agent_base_8hpp/","title":"File AgentBase.hpp","text":"<p>FileList &gt; core &gt; AgentBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"../DataCollection/AgentData.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"Entity.hpp\"</code></li> <li><code>#include \"GridPosition.hpp\"</code></li> <li><code>#include \"WorldGrid.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_agent_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_agent_base_8hpp/#classes","title":"Classes","text":"Type Name class AgentBase <p>The documentation for this class was generated from the following file <code>source/core/AgentBase.hpp</code></p>"},{"location":"Core%20Project/_agent_base_8hpp_source/","title":"File AgentBase.hpp","text":"<p>File List &gt; core &gt; AgentBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;utility&gt;\n\n#include \"../DataCollection/AgentData.hpp\"\n#include \"Data.hpp\"\n#include \"Entity.hpp\"\n#include \"GridPosition.hpp\"\n#include \"WorldGrid.hpp\"\n\nnamespace cse491 {\n\nenum State  \n{\n  Healthy,\n  Taking_Damage,\n  Dying,\n  Deceased\n};\n\nclass AgentBase : public Entity {\nprotected:\n  std::unordered_map&lt;std::string, size_t&gt; action_map;  \n  int action;             \n  int action_result = 0;  \n\n  State agent_state = Healthy;  \n\npublic:\n  AgentBase(size_t id, const std::string &amp;name) : Entity(id, name) {}\n  ~AgentBase() = default;  // Already virtual from Entity\n\n  // -- World Interactions --\n\n  virtual bool Initialize() { return true; }\n\n  // -- Entity Overrides --\n\n  bool IsAgent() const override { return true; }\n\n  // -- Agent Interaction --\n\n  State GetAgentState() { return agent_state; }\n\n  void UpdateAgentState(cse491::AgentBase &amp;agent) {\n    if (agent.HasProperty(\"Health\")) {\n      if (agent.GetProperty&lt;int&gt;(\"Health\") &lt;= agent.GetProperty&lt;int&gt;(\"Max_Health\") &amp;&amp;\n          agent.GetProperty&lt;int&gt;(\"Health\") &gt; 3) {\n        agent.agent_state = Healthy;\n      } else if (agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 3 &amp;&amp; agent.GetProperty&lt;int&gt;(\"Health\") &gt; 0) {\n        agent.agent_state = Dying;\n      } else if (agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 0) {\n        agent.agent_state = Deceased;\n      }\n    }\n    if (agent.HasProperty(\"Taking_Damage\")) {\n      if (agent.GetProperty&lt;bool&gt;(\"Taking_Damage\") == true) {\n        agent.agent_state = Taking_Damage;\n      }\n    }\n  }\n\n  void TakeDamage(cse491::AgentBase &amp;agent) {\n    agent.SetProperty&lt;int&gt;(\n        \"Health\", agent.GetProperty&lt;int&gt;(\"Health\") - agent.GetProperty&lt;int&gt;(\"Taking_Damage\"));\n    UpdateAgentState(agent);\n  }\n\n  // -- Action management --\n\n  [[nodiscard]] bool HasAction(const std::string &amp;action_name) const {\n    return action_map.count(action_name);\n  }\n\n  [[nodiscard]] size_t GetActionID(const std::string &amp;action_name) const {\n    auto it = action_map.find(action_name);\n    if (it == action_map.end()) return 0;\n    return it-&gt;second;\n  }\n\n  void storeActionMap(std::string name) {\n    DataCollection::AgentData data(name);\n    data.StoreAction(action_map);\n  }\n\n  [[nodiscard]] virtual GridPosition GetNextPosition() { return Entity::GetPosition(); }\n\n  virtual AgentBase &amp;AddAction(const std::string &amp;action_name, size_t action_id) {\n    assert(!HasAction(action_name));  // Cannot add existing action name.\n    action_map[action_name] = action_id;\n    return *this;\n  }\n\n  [[nodiscard]] virtual size_t SelectAction([[maybe_unused]] const WorldGrid &amp;grid,\n                                            [[maybe_unused]] const type_options_t &amp;type_options,\n                                            [[maybe_unused]] const item_map_t &amp;item_map,\n                                            [[maybe_unused]] const agent_map_t &amp;agent_map) {\n    return 0;\n  }\n\n  [[nodiscard]] int GetActionResult() const { return action_result; }\n\n  void SetActionResult(int result) { action_result = result; }\n\n  virtual void Notify(const std::string &amp; /*message*/, const std::string &amp; /*msg_type*/ = \"none\") {}\n\n  std::string GetTypeName_impl() const override { return \"cse491::AgentBase\"; }\n\n  void Serialize_impl(std::ostream &amp;os) const override {\n    Entity::Serialize_impl(os);\n    SerializeValue(os, action_map);\n    SerializeValue(os, action);\n    SerializeValue(os, action_result);\n    SerializeValue(os, agent_state);\n  }\n\n  void Deserialize_impl(std::istream &amp;is) override {\n    Entity::Deserialize_impl(is);\n    DeserializeValue(is, action_map);\n    DeserializeValue(is, action);\n    DeserializeValue(is, action_result);\n    DeserializeValue(is, agent_state);\n  }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_core_object_8hpp/","title":"File CoreObject.hpp","text":"<p>FileList &gt; core &gt; CoreObject.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"Serialize.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_core_object_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_core_object_8hpp/#classes","title":"Classes","text":"Type Name class CoreObject"},{"location":"Core%20Project/_core_object_8hpp/#macros","title":"Macros","text":"Type Name define EXPERIMENTAL_CLASS  __attribute__((annotate(\"experimental_class\"))) define EXPERIMENTAL_FUNCTION  __attribute__((annotate(\"experimental_function\")))A common interface class for core objects that sets up required functionality."},{"location":"Core%20Project/_core_object_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Core%20Project/_core_object_8hpp/#define-experimental_class","title":"define EXPERIMENTAL_CLASS","text":"<pre><code>#define EXPERIMENTAL_CLASS __attribute__((annotate(\"experimental_class\")))\n</code></pre>"},{"location":"Core%20Project/_core_object_8hpp/#define-experimental_function","title":"define EXPERIMENTAL_FUNCTION","text":"<p>A common interface class for core objects that sets up required functionality. </p> <pre><code>#define EXPERIMENTAL_FUNCTION __attribute__((annotate(\"experimental_function\")))\n</code></pre> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: ALPHA</p> <p>This CoreObject class builds an interface for all of the core object, ensuring that they can be properly serialized.</p> <p>Derived classes must implement: GetTypeName_impl() - Return the qualified type name. Serialize_impl(std::ostream &amp;) - Store the object in a stream. Deserialize_impl(std::istream &amp;) - Restore the object from a stream. </p> <p>Author:</p> <p>@amantham20 uses as attribute to mark experimental classes and functions </p> <p>The documentation for this class was generated from the following file <code>source/core/CoreObject.hpp</code></p>"},{"location":"Core%20Project/_core_object_8hpp_source/","title":"File CoreObject.hpp","text":"<p>File List &gt; core &gt; CoreObject.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\n#include \"Serialize.hpp\"\n\n#ifndef NDEBUG\n#define EXPERIMENTAL_FUNCTION __attribute__((annotate(\"experimental_function\")))\n#define EXPERIMENTAL_CLASS __attribute__((annotate(\"experimental_class\")))\n\n#else // NDEBUG *not* set, so debug mode.\n#define EXPERIMENTAL_CLASS                       \\\n  __attribute__((annotate(\"experimental_class\"), \\\n                 warning(\"This is an experimental class and should be used with caution.\")))\n#define EXPERIMENTAL_FUNCTION                                              \\\n  __attribute__((annotate(\"experimental_function\"),                        \\\n                 warning(\"This is an experimental function and should be \" \\\n                         \"used with caution.\")))\n#endif\n\nnamespace cse491 {\n\nclass CoreObject {\nprotected:\n  // -- Required functionality in all core classes --\n  // These functions are core functionality that must be implemented in all derived\n  // classes.  They will enable the public interface to behave correctly.\n\n  virtual std::string GetTypeName_impl() const = 0;\n\n  virtual void Serialize_impl(std::ostream &amp;) const = 0;\n\n  virtual void Deserialize_impl(std::istream &amp;) = 0;\n\n  // -- Helper functions --\n  // The functions below can be used in derived classes to implement above functionality.\n\n  void StartSerialize(std::ostream &amp;os) const { os &lt;&lt; \":::START \" &lt;&lt; GetTypeName() &lt;&lt; \"\\n\"; }\n\n  void EndSerialize(std::ostream &amp;os) const { os &lt;&lt; \":::END \" &lt;&lt; GetTypeName() &lt;&lt; \"\\n\"; }\n\n  bool StartDeserialize(std::istream &amp;is) {\n    std::string line;\n    std::getline(is, line);\n    std::string expected = \":::START \" + GetTypeName();\n    if (line != expected) {\n      std::cerr &lt;&lt; \"Deserialization error.  Expected: \" &lt;&lt; expected &lt;&lt; \"...Found: \" &lt;&lt; line;\n      return false;\n    }\n    return true;\n  }\n\n  bool EndDeserialize(std::istream &amp;is) {\n    std::string line;\n    std::getline(is, line);\n    std::string expected = \":::END \" + GetTypeName();\n    if (line != expected) {\n      std::cerr &lt;&lt; \"Deserialization error.  Expected: \" &lt;&lt; expected &lt;&lt; \"...Found: \" &lt;&lt; line;\n      return false;\n    }\n    return true;\n  }\n\n\npublic:\n  virtual ~CoreObject() {}\n\n  auto operator&lt;=&gt;(const CoreObject &amp;) const = default;\n\n  std::string GetTypeName() const { return GetTypeName_impl(); }\n\n  void Serialize(std::ostream &amp;os) const {\n    StartSerialize(os);\n    Serialize_impl(os);\n    EndSerialize(os);\n  }\n\n  void Deserialize(std::istream &amp;is) {\n    StartDeserialize(is);\n    Deserialize_impl(is);\n    EndDeserialize(is);\n  }\n\n  bool Serialize(std::string filename) const {\n    std::ofstream os(filename);\n    if (!os.is_open()) {\n      std::cerr &lt;&lt; \"Could not open file '\" &lt;&lt; filename &lt;&lt; \"' for Serialize().\" &lt;&lt; std::endl;\n      return false;\n    }\n    Serialize(os);\n    return true;\n  }\n\n  bool Deserialize(std::string filename) {\n    std::ifstream is(filename);\n    if (!is.is_open()) {\n      std::cerr &lt;&lt; \"Could not open file '\" &lt;&lt; filename &lt;&lt; \"' for Serialize().\" &lt;&lt; std::endl;\n      return false;\n    }\n    Deserialize(is);\n    return true;\n  }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_data_8hpp/","title":"File Data.hpp","text":"<p>FileList &gt; core &gt; Data.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Core%20Project/_data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_data_8hpp/#classes","title":"Classes","text":"Type Name struct CellType Simple data structure to hold info about a TYPE of cell in the world. <p>The documentation for this class was generated from the following file <code>source/core/Data.hpp</code></p>"},{"location":"Core%20Project/_data_8hpp_source/","title":"File Data.hpp","text":"<p>File List &gt; core &gt; Data.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace cse491 {\n\nstruct CellType {\n  std::string name;  \n  std::string desc;  \n  char symbol;       \n  std::set&lt;std::string&gt; properties{};  \n\n  CellType&amp; SetProperty(const std::string&amp; property) {\n    properties.insert(property);\n    return *this;\n  }\n\n  CellType&amp; RemoveProperty(const std::string&amp; property) {\n    properties.erase(property);\n    return *this;\n  }\n\n  bool HasProperty(const std::string&amp; property) const { return properties.count(property); }\n\n  constexpr static char CELL_WALL[] = \"wall\";\n  constexpr static char CELL_WATER[] = \"water\";\n};\n\nusing type_options_t = std::vector&lt;CellType&gt;;\n\nclass ItemBase;\nusing item_map_t = std::map&lt;size_t, std::unique_ptr&lt;ItemBase&gt;&gt;;\n\nclass AgentBase;\nusing agent_map_t = std::map&lt;size_t, std::unique_ptr&lt;AgentBase&gt;&gt;;\n\nenum class PropertyType { t_double, t_int, t_char, t_string, t_position, t_bool, t_other };\n\nenum class WorldType { w_maze, w_second, w_generative, w_manual };\n\n}  // namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_easy_logging_8hpp/","title":"File EasyLogging.hpp","text":"<p>FileList &gt; core &gt; EasyLogging.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"Core%20Project/_easy_logging_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace clogged Tools for debug-logging that can be easily controlled."},{"location":"Core%20Project/_easy_logging_8hpp/#classes","title":"Classes","text":"Type Name class Logger Logger class with colors and team names."},{"location":"Core%20Project/_easy_logging_8hpp/#macros","title":"Macros","text":"Type Name define LOGLINE  \"File: \" &lt;&lt; __FILE__ &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"Ensure that we only log when NDEBUG flg is not set. define LOG_FNC  \"Function: \" &lt;&lt; __func__ &lt;&lt; \" \" define LOG_RELLINE  \"File: \" &lt;&lt; RELATIVE_PATH(__FILE__) &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\" define RELATIVE_PATH (file)"},{"location":"Core%20Project/_easy_logging_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Core%20Project/_easy_logging_8hpp/#define-logline","title":"define LOGLINE","text":"<pre><code>#define LOGLINE \"File: \" &lt;&lt; __FILE__ &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"\n</code></pre>"},{"location":"Core%20Project/_easy_logging_8hpp/#define-log_fnc","title":"define LOG_FNC","text":"<pre><code>#define LOG_FNC \"Function: \" &lt;&lt; __func__ &lt;&lt; \" \"\n</code></pre>"},{"location":"Core%20Project/_easy_logging_8hpp/#define-log_relline","title":"define LOG_RELLINE","text":"<pre><code>#define LOG_RELLINE \"File: \" &lt;&lt; RELATIVE_PATH(__FILE__) &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"\n</code></pre>"},{"location":"Core%20Project/_easy_logging_8hpp/#define-relative_path","title":"define RELATIVE_PATH","text":"<pre><code>#define RELATIVE_PATH (\n    file\n) (std::string(file).find_last_of(\"/\\\\\") != std::string::npos                \\\n       ? std::string(file).substr(std::string(file).find_last_of(\"/\\\\\") + 1) \\\n       : std::string(file))\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/EasyLogging.hpp</code></p>"},{"location":"Core%20Project/_easy_logging_8hpp_source/","title":"File EasyLogging.hpp","text":"<p>File List &gt; core &gt; EasyLogging.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n\nnamespace clogged {\n\nenum class LogLevel { DEBUG, INFO, WARNING, ERR, NA };\n\nenum class Team {\n  TEAM_1,\n  TEAM_2,\n  TEAM_3,\n  TEAM_4,\n  TEAM_5,\n  TEAM_6,\n  TEAM_7,\n  TEAM_8,\n  TEAM_9,\n  GENERAL,\n  NA\n};\n\nenum class Color { RESET = 0, BLUE = 34, GREEN = 32, RED = 31 };\n\nconst LogLevel LOGLEVEL = LogLevel::DEBUG;\n\n#ifndef NDEBUG\n\n#define LOGLINE \"File: \" &lt;&lt; __FILE__ &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"\n\n#define RELATIVE_PATH(file)                                                  \\\n  (std::string(file).find_last_of(\"/\\\\\") != std::string::npos                \\\n       ? std::string(file).substr(std::string(file).find_last_of(\"/\\\\\") + 1) \\\n       : std::string(file))\n\n#define LOG_RELLINE \"File: \" &lt;&lt; RELATIVE_PATH(__FILE__) &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"\n\n#define LOG_FNC \"Function: \" &lt;&lt; __func__ &lt;&lt; \" \"\n\n\nclass Logger {\npublic:\n  Logger &amp;operator&lt;&lt;(Team team) {\n    currentTeam = team;\n    metaPrinted = false;\n    //         std::cout &lt;&lt; endl; //TODO: Might have to enable this so that we\n    //         can have same line logging when endl is not used\n    return *this;\n  }\n\n  Logger &amp;operator&lt;&lt;(LogLevel logLevel) {\n    currentLogLevel = logLevel;\n    metaPrinted = false;\n    return *this;\n  }\n\n  Logger &amp;operator&lt;&lt;(Color color) {\n    currentColor = color;\n    return *this;\n  }\n\n  Logger &amp;operator&lt;&lt;(std::ostream &amp;(*manipulator)(std::ostream &amp;)) {\n    typedef std::ostream &amp;(*EndlManipulator)(std::ostream &amp;);\n\n    // Compare the function pointers\n    if (manipulator == static_cast&lt;EndlManipulator&gt;(std::endl) || manipulator == endl) {\n      // Handle std::endl here\n      currentTeam = Team::NA;\n      currentLogLevel = LogLevel::DEBUG;\n      currentColor = Color::RESET;\n\n      std::cout &lt;&lt; std::endl;\n\n      metaPrinted = false;\n    }\n\n    return *this;\n  }\n\n  template &lt;typename T&gt;\n  Logger &amp;operator&lt;&lt;(const T &amp;value) {\n    // TODO: Define when to log by loglevel comparison. Goal is to send it in as\n    // a flag in the CMakeLists.txt\n    if (currentLogLevel &gt;= LOGLEVEL) {\n      // added additional flag in case one wants to compile without colors (or)\n      // if the terminal does not support colors\n#ifndef D_ANSI_COLOR_CODES\n      std::string colorStart = \"\\033[\" + std::to_string(static_cast&lt;int&gt;(currentColor)) + \"m\";\n      std::string colorEnd = \"\\033[0m\";\n#else\n      std::string colorStart = \"\";\n      std::string colorEnd = \"\";\n#endif\n      std::ostringstream logMessage;\n      logMessage &lt;&lt; colorStart;\n      if (!metaPrinted) {\n        logMessage &lt;&lt; teamToString(currentTeam) &lt;&lt; logToString(currentLogLevel);\n        metaPrinted = true;\n      }\n\n      logMessage &lt;&lt; value &lt;&lt; colorEnd;\n      std::cout &lt;&lt; logMessage.str();  // &lt;&lt; std::endl;  //TODO: Might have to\n                                      // make enable this so that we can have\n                                      // same line logging when endl is not used\n    }\n\n    return *this;\n  }\n\n  static Logger &amp;Log() {\n    static Logger instance;  // Guaranteed to be initialized only once.\n    return instance;\n  }\n\n  template &lt;typename T, typename... EXTRA_Ts&gt;\n  static Logger &amp;Log(T &amp;&amp;arg1, EXTRA_Ts &amp;&amp;...extra_args) {\n    Log() &lt;&lt; std::forward&lt;T&gt;(arg1);            // Log the first argument.\n    if constexpr (sizeof...(EXTRA_Ts) == 0) {  // No arguments left.\n      return Log() &lt;&lt; Logger::endl;            // Trigger a flush.\n    } else {\n      return Log(std::forward&lt;EXTRA_Ts&gt;(extra_args)...);  // Log remaining arguments.\n    }\n  }\n\n  static std::ostream &amp;endl(std::ostream &amp;os) {\n    Log() &lt;&lt; std::endl;  // Call the custom Logger::endl to reset values\n    return os;\n  }\n\nprivate:\n  Team currentTeam = Team::NA;\n\n  LogLevel currentLogLevel = LogLevel::DEBUG;\n\n  Color currentColor = Color::RESET;\n\n  bool metaPrinted = false;\n\n  std::map&lt;Team, std::string&gt; teamToStringMap = {\n      {Team::TEAM_1, \"Team 1\"},  {Team::TEAM_2, \"Team 2\"}, {Team::TEAM_3, \"Team 3\"},\n      {Team::TEAM_4, \"Team 4\"},  {Team::TEAM_5, \"Team 5\"}, {Team::TEAM_6, \"Team 6\"},\n      {Team::TEAM_7, \"Team 7\"},  {Team::TEAM_8, \"Team 8\"}, {Team::TEAM_9, \"Team 9\"},\n      {Team::GENERAL, \"General\"}};\n\n  std::string teamToString(Team team) {\n    auto it = teamToStringMap.find(team);\n    if (it != teamToStringMap.end()) {\n      return \"[\" + it-&gt;second + \"]\";\n    }\n\n    return \"\";\n  }\n\n  std::string logToString(LogLevel logLevel) {\n    if (logLevel == LogLevel::DEBUG) {\n      return \"(DEBUG) \";\n    } else if (logLevel == LogLevel::INFO) {\n      return \"(INFO) \";\n    } else if (logLevel == LogLevel::WARNING) {\n      return \"(WARNING) \";\n    } else if (logLevel == LogLevel::ERR) {\n      return \"(ERROR) \";\n    } else {\n      return \"\";\n    }\n  }\n};\n\n#else\n\n#define LOGLINE \"\"\n#define LOG_RELLINE \"\"\n#define LOG_FNC \"\"\n\n// #define log Log()\n\nclass Logger {\npublic:\n  template &lt;typename T&gt;\n  Logger &amp;operator&lt;&lt;(const T &amp; /*value*/) {\n    return *this;\n  }\n\n  Logger &amp;operator&lt;&lt;(std::ostream &amp;(* /*manipulator*/)(std::ostream &amp;)) { return *this; }\n\n  static std::ostream &amp;endl(std::ostream &amp;os) { return os; }\n\n  static Logger &amp;Log() {\n    static Logger instance;  // Guaranteed to be initialized only once.\n    return instance;\n  }\n};\n\n// Logger Logger::log;\n#endif\n\n}  // namespace clogged\n\n</code></pre>"},{"location":"Core%20Project/_entity_8cpp/","title":"File Entity.cpp","text":"<p>FileList &gt; core &gt; Entity.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Entity.hpp\"</code></li> <li><code>#include \"WorldBase.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_entity_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types. <p>The documentation for this class was generated from the following file <code>source/core/Entity.cpp</code></p>"},{"location":"Core%20Project/_entity_8cpp_source/","title":"File Entity.cpp","text":"<p>File List &gt; core &gt; Entity.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#include \"Entity.hpp\"\n#include \"WorldBase.hpp\"\n\nnamespace cse491 {\n\n  Entity &amp; Entity::SetPosition(GridPosition in_pos, size_t grid_id) {\n    position = in_pos;\n    if (IsItem()) {\n      auto &amp; item = static_cast&lt;ItemBase&amp;&gt;(*this);\n      item.SetGrid(grid_id);\n    }\n    return *this;\n  }\n\n  Entity &amp; Entity::AddItem(size_t id) {\n    assert(!HasItem(id));\n    inventory.push_back(id);\n    world_ptr-&gt;GetItem(id).SetOwner(*this);\n    return *this;\n  }\n\n  Entity &amp; Entity::RemoveItem(size_t id) {\n    assert(HasItem(id));\n    inventory.erase(std::find(inventory.begin(), inventory.end(), id));\n    world_ptr-&gt;GetItem(id).SetUnowned();\n    return *this;\n  }\n\n}\n\n</code></pre>"},{"location":"Core%20Project/_entity_8hpp/","title":"File Entity.hpp","text":"<p>FileList &gt; core &gt; Entity.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;istream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"CoreObject.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"GridPosition.hpp\"</code></li> <li><code>#include \"Property.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_entity_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_entity_8hpp/#classes","title":"Classes","text":"Type Name class Entity <p>The documentation for this class was generated from the following file <code>source/core/Entity.hpp</code></p>"},{"location":"Core%20Project/_entity_8hpp_source/","title":"File Entity.hpp","text":"<p>File List &gt; core &gt; Entity.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;istream&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"CoreObject.hpp\"\n#include \"Data.hpp\"\n#include \"GridPosition.hpp\"\n#include \"Property.hpp\"\n\nnamespace cse491 {\n\nclass WorldBase;\n\nclass Entity : public CoreObject {\nprivate:\n  WorldBase *world_ptr = nullptr;  \n\nprotected:\n  size_t id = 0;          \n  std::string name = \"\";  \n\n  size_t grid_id = 0;     \n  GridPosition position;  \n\n  std::vector&lt;size_t&gt; inventory; \n\n  using property_map_t = std::unordered_map&lt;std::string, std::unique_ptr&lt;PropertyBase&gt;&gt;;\n  property_map_t property_map;\n\n  // -- Helper Functions --\n\n  template &lt;typename T&gt;\n  Property&lt;T&gt; &amp;AsProperty(const std::string &amp;name) const {\n    assert(HasProperty(name));\n    PropertyBase *raw_ptr = property_map.at(name).get();\n    assert(dynamic_cast&lt;Property&lt;T&gt; *&gt;(raw_ptr));\n    auto property_ptr = static_cast&lt;Property&lt;T&gt; *&gt;(raw_ptr);\n    return *property_ptr;\n  }\n\npublic:\n  Entity(size_t id, const std::string &amp;name) : id(id), name(name) {}\n  Entity(const Entity &amp;) = delete;  // Entities must be unique and shouldn't be copied.\n  Entity(Entity &amp;&amp;) = default;\n  virtual ~Entity() = default;\n\n  Entity &amp;operator=(const Entity &amp;) = delete;  // Entities must be unique and shouldn't be copied.\n  Entity &amp;operator=(Entity &amp;&amp;) = delete;       // Entities should never have IDs change.\n\n  // -- Accessors --\n  [[nodiscard]] size_t GetID() const { return id; }\n  [[nodiscard]] const std::string &amp;GetName() const { return name; }\n  [[nodiscard]] GridPosition GetPosition() const { return position; }\n  [[nodiscard]] WorldBase &amp;GetWorld() const {\n    assert(world_ptr);\n    return *world_ptr;\n  }\n  [[nodiscard]] size_t GetGridID() const { return grid_id; }\n  [[nodiscard]] bool IsOnGrid(size_t in_grid_id) const { return grid_id == in_grid_id; }\n\n  [[nodiscard]] bool HasWorld() const { return world_ptr != nullptr; }\n  Entity &amp;SetName(const std::string in_name) {\n    name = in_name;\n    return *this;\n  }\n  Entity &amp;SetPosition(GridPosition in_pos, size_t grid_id = 0);\n  Entity &amp;SetPosition(double x, double y) {\n    position = GridPosition{x, y};\n    return *this;\n  }\n  virtual Entity &amp;SetWorld(WorldBase &amp;in_world) {\n    world_ptr = &amp;in_world;\n    return *this;\n  }\n\n  virtual bool IsAgent() const { return false; }      \n  virtual bool IsItem() const { return false; }       \n  virtual bool IsInterface() const { return false; }  \n\n  // -- Property Management --\n\n  [[nodiscard]] bool HasProperty(const std::string &amp;name) const { return property_map.count(name); }\n\n  [[nodiscard]] size_t GetNumProperties() const { return property_map.size(); }\n\n  template &lt;typename T = double&gt;\n  [[nodiscard]] const T &amp;GetProperty(const std::string &amp;name) const {\n    assert(HasProperty(name));  // Break if property does not already exist.\n    return AsProperty&lt;T&gt;(name).value;\n  }\n\n  [[nodiscard]] PropertyType GetPropertyType(const std::string &amp;name) const {\n    auto it = property_map.find(name);\n    if (it == property_map.end()) return PropertyType::t_other;\n    return it-&gt;second-&gt;GetType();\n  }\n\n  template &lt;typename T&gt;\n  Entity &amp;SetProperty(const std::string &amp;name, const T &amp;value) {\n    if (HasProperty(name)) {\n      AsProperty&lt;T&gt;(name).value = value;\n    } else {\n      property_map[name] = std::make_unique&lt;Property&lt;T&gt;&gt;(value);\n    }\n    return *this;\n  }\n\n  Entity &amp;SetProperties() { return *this; }\n\n  template &lt;typename VALUE_T, typename... EXTRA_Ts&gt;\n  Entity &amp;SetProperties(const std::string &amp;name, VALUE_T &amp;&amp;value, EXTRA_Ts &amp;&amp;...extras) {\n    SetProperty(name, std::forward&lt;VALUE_T&gt;(value));          // Set the first property...\n    return SetProperties(std::forward&lt;EXTRA_Ts&gt;(extras)...);  // And any additional properties...\n  }\n\n  Entity &amp;RemoveProperty(const std::string &amp;name) {\n    property_map.erase(name);\n    return *this;\n  }\n\n  property_map_t &amp;GetPropertyMap() {\n    return property_map;\n  }\n\n  bool HasItem(size_t id) const {\n    return std::find(inventory.begin(), inventory.end(), id) != inventory.end();\n  }\n\n  Entity &amp;AddItem(size_t id);\n  Entity &amp;AddItem(Entity &amp;item) { return AddItem(item.GetID()); }\n\n  Entity &amp;RemoveItem(size_t id);\n  Entity &amp;RemoveItem(Entity &amp;item) { return RemoveItem(item.GetID()); }\n\n  void Serialize_impl(std::ostream &amp;os) const override {\n    SerializeValue(os, id);\n    SerializeValue(os, name);\n    SerializeValue(os, grid_id);\n    SerializeValue(os, position);\n    SerializeValue(os, inventory);\n\n    SerializeValue(os, property_map.size());\n    for (const auto &amp; [name, ptr] : property_map) {\n      SerializeValue(os, name);\n      SerializeValue(os, ptr-&gt;GetType());\n      SerializeValue(os, ptr-&gt;ToString());\n    }\n  }\n\n  void Deserialize_impl(std::istream &amp;is) override {\n    DeserializeValue(is, id);\n    DeserializeValue(is, name);\n    DeserializeValue(is, grid_id);\n    DeserializeValue(is, position);\n    DeserializeValue(is, inventory);\n\n    size_t num_properties = 0;\n    property_map.clear();\n    std::string name;\n    PropertyType type;\n    DeserializeValue(is, num_properties);\n    for (size_t i = 0; i &lt; num_properties; ++i) {\n      DeserializeValue(is, name);\n      DeserializeValue(is, type);\n      switch (type) {\n        using enum PropertyType;\n      case t_char:     SetProperty(name, DeserializeAs&lt;char&gt;(is));         break;\n      case t_double:   SetProperty(name, DeserializeAs&lt;double&gt;(is));       break;\n      case t_int:      SetProperty(name, DeserializeAs&lt;int&gt;(is));          break;\n      case t_bool:     SetProperty(name, DeserializeAs&lt;bool&gt;(is));          break;\n      case t_string:   SetProperty(name, DeserializeAs&lt;std::string&gt;(is));  break;\n      case t_position: SetProperty(name, DeserializeAs&lt;GridPosition&gt;(is)); break;\n      case t_other:\n        std::cerr &lt;&lt; \"Warning: Cannot deserialize property'\" &lt;&lt; name &lt;&lt; \"'.\" &lt;&lt; std::endl;\n        std::string tmp_str;\n        std::getline(is, tmp_str, '\\n');\n        std::cerr &lt;&lt; \"  Data for that property: \\\"\" &lt;&lt; tmp_str &lt;&lt; \"\\\".\" &lt;&lt; std::endl;\n      }\n    }\n  }\n\n  [[nodiscard]] std::vector&lt;size_t&gt; GetInventory() const { return inventory; }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_grid_position_8hpp/","title":"File GridPosition.hpp","text":"<p>FileList &gt; core &gt; GridPosition.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;compare&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"CoreObject.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_grid_position_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_grid_position_8hpp/#classes","title":"Classes","text":"Type Name class GridPosition Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. <p>The documentation for this class was generated from the following file <code>source/core/GridPosition.hpp</code></p>"},{"location":"Core%20Project/_grid_position_8hpp_source/","title":"File GridPosition.hpp","text":"<p>File List &gt; core &gt; GridPosition.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;    // For sqrt and std::nan()\n#include &lt;compare&gt;  // For operator&lt;=&gt;\n#include &lt;cstddef&gt;  // For size_t\n#include &lt;sstream&gt;  // For std::stringstream\n#include &lt;string&gt;\n\n#include \"CoreObject.hpp\"\n\nnamespace cse491 {\n\nclass GridPosition : public CoreObject {\nprivate:\n  double x = 0.0;\n  double y = 0.0;\n\npublic:\n  GridPosition() = default;\n  GridPosition(double x, double y) : x(x), y(y) {}\n  GridPosition(const std::string &amp; str) { FromString(str); }\n  GridPosition(const GridPosition &amp;) = default;\n\n  ~GridPosition() = default;\n\n  GridPosition &amp;operator=(const GridPosition &amp;) = default;\n\n  // -- Accessors --\n\n  [[nodiscard]] double GetX() const { return x; }\n  [[nodiscard]] double GetY() const { return y; }\n  [[nodiscard]] size_t CellX() const { return static_cast&lt;size_t&gt;(x); }\n  [[nodiscard]] size_t CellY() const { return static_cast&lt;size_t&gt;(y); }\n\n  auto operator&lt;=&gt;(const GridPosition &amp;) const = default;\n\n  [[nodiscard]] bool IsInvalid() const { return std::isnan(x) || std::isnan(y); }\n  [[nodiscard]] bool IsValid() const { return !IsInvalid(); }\n\n  // -- Modifiers --\n\n  GridPosition &amp;Set(double in_x, double in_y) {\n    x = in_x;\n    y = in_y;\n    return *this;\n  }\n  GridPosition &amp;SetX(double in) { x = in; return *this; }\n  GridPosition &amp;SetY(double in) { y = in; return *this; }\n\n  GridPosition &amp;Shift(double shift_x, double shift_y) {\n    x += shift_x;\n    y += shift_y;\n    return *this;\n  }\n\n  GridPosition &amp;operator+=(const GridPosition &amp;in) { return Shift(in.x, in.y); }\n  GridPosition &amp;operator-=(const GridPosition &amp;in) { return Shift(-in.x, -in.y); }\n\n  GridPosition &amp;MakeInvalid() {\n    x = y = std::nan(\"NAN(0)\");\n    return *this;\n  }\n\n  // A static function to request an invalid grid position.\n  static const GridPosition &amp; Invalid() {\n    static GridPosition invalid_pos(std::nan(\"NAN(0)\"), std::nan(\"NAN(0)\"));\n    return invalid_pos;\n  }\n\n  // -- Const Operations --\n\n  [[nodiscard]] GridPosition GetOffset(double offset_x, double offset_y) const {\n    return GridPosition{x + offset_x, y + offset_y};\n  }\n\n  [[nodiscard]] GridPosition Above(double dist = 1.0) const { return GetOffset(0.0, -dist); }\n\n  [[nodiscard]] GridPosition Below(double dist = 1.0) const { return GetOffset(0.0, dist); }\n\n  [[nodiscard]] GridPosition ToLeft(double dist = 1.0) const { return GetOffset(-dist, 0.0); }\n\n  [[nodiscard]] GridPosition ToRight(double dist = 1.0) const { return GetOffset(dist, 0.0); }\n\n  [[nodiscard]] GridPosition operator+(GridPosition in) const { return GetOffset(in.x, in.y); }\n\n  [[nodiscard]] double Distance(GridPosition pos2) const {\n    const double dist1 = x - pos2.x;\n    const double dist2 = y - pos2.y;\n    return sqrt(dist1 * dist1 + dist2 * dist2);\n  }\n\n  [[nodiscard]] double MDistance(GridPosition pos2) const {\n    const double dist1 = x - pos2.x;\n    const double dist2 = y - pos2.y;\n    return abs(dist1) + abs(dist2);\n  }\n\n  [[nodiscard]] bool IsNear(GridPosition pos2, double max_dist = 1.0) const {\n    const double dist1 = x - pos2.x;\n    const double dist2 = y - pos2.y;\n    return (dist1 * dist1 + dist2 * dist2) &lt;= (max_dist * max_dist);\n  }\n\n  [[nodiscard]] std::string ToString() const {\n    std::stringstream ss;\n    ss &lt;&lt; '(' &lt;&lt; x &lt;&lt; ',' &lt;&lt; y &lt;&lt; ')';\n    return ss.str();\n  }\n\n  GridPosition &amp; FromStream(std::istream &amp; ss) {\n    // Format should be \"(x,y)\" with values filled in.\n    // Any deviation from this format produces an undefined position.\n    char c = '\\0';    \n    ss &gt;&gt; c;\n    if (c != '(') return MakeInvalid();\n    ss &gt;&gt; x;\n    ss &gt;&gt; c;\n    if (c != ',') return MakeInvalid();\n    ss &gt;&gt; y;\n    ss &gt;&gt; c;\n    if (c != ')') return MakeInvalid();\n\n    return *this;\n  }\n\n  GridPosition &amp; FromString(std::string in_str) {\n    // Format should be \"(x,y)\" with values filled in.\n    // Any deviation from this format produces an undefined position.\n    std::stringstream ss(in_str);\n    return FromStream(ss); \n  }\n\n\n  // --- CoreObject Functionality ---\n  std::string GetTypeName_impl() const override { return \"cse491::GridPosition\"; }\n\n  void Serialize_impl(std::ostream &amp; os) const override {\n    SerializeValue(os, x);\n    SerializeValue(os, y);\n  };\n\n  void Deserialize_impl(std::istream &amp; is) override {\n    DeserializeValue(is, x);\n    DeserializeValue(is, y);\n  };\n\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_interface_base_8hpp/","title":"File InterfaceBase.hpp","text":"<p>FileList &gt; core &gt; InterfaceBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"../DataCollection/DataManager.hpp\"</code></li> <li><code>#include \"AgentBase.hpp\"</code></li> <li><code>#include \"ItemBase.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_interface_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_interface_base_8hpp/#classes","title":"Classes","text":"Type Name class InterfaceBase <p>The documentation for this class was generated from the following file <code>source/core/InterfaceBase.hpp</code></p>"},{"location":"Core%20Project/_interface_base_8hpp_source/","title":"File InterfaceBase.hpp","text":"<p>File List &gt; core &gt; InterfaceBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;string&gt;\n\n#include \"../DataCollection/DataManager.hpp\"\n#include \"AgentBase.hpp\"\n#include \"ItemBase.hpp\"\n\nnamespace cse491 {\n\nclass InterfaceBase : public AgentBase {\nprotected:\n  static void exitCleanup() {\n    DataCollection::DataManager::GetInstance().WriteToJson();\n    exit(0);\n  }\n\npublic:\n  InterfaceBase(size_t id, const std::string&amp; name) : AgentBase(id, name) {}\n  ~InterfaceBase() = default;  // Already virtual from Entity\n\n  // -- Entity Overrides --\n\n  bool IsInterface() const override { return true; }\n\n  // -- AgentBase overrides --\n  //\n  // Multiple functions defined as virtual in AgentBase can also be overridden from\n  // custom Interfaces.  Specific available function to override include:\n\n  // bool Initialize() { return true; }\n  //\n  // Initialize is run AFTER the world configures the interface with actions, etc, allowing\n  // for additional setup, such as targeted buttons.\n\n  // size_t SelectAction([[maybe_unused]] const WorldGrid &amp; grid) { return 0; }\n  //\n  // SelectAction is run when the world is given the player an opportunity to choose\n  // and action to perform. The interface will be provided with the current WorldGrid\n  // Return the ID associated with the action to perform; (zero is always \"no action\")\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_item_base_8hpp/","title":"File ItemBase.hpp","text":"<p>FileList &gt; core &gt; ItemBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"Entity.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_item_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_item_base_8hpp/#classes","title":"Classes","text":"Type Name class ItemBase <p>The documentation for this class was generated from the following file <code>source/core/ItemBase.hpp</code></p>"},{"location":"Core%20Project/_item_base_8hpp_source/","title":"File ItemBase.hpp","text":"<p>File List &gt; core &gt; ItemBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\n#include \"Data.hpp\"\n#include \"Entity.hpp\"\n\nnamespace cse491 {\n\nclass ItemBase : public Entity {\nprotected:\n  enum OwnerType { NONE = 0, GRID, ITEM, AGENT };\n  OwnerType owner_type = OwnerType::NONE;\n  size_t owner_id = 0;\n\npublic:\n  ItemBase(size_t id, const std::string &amp;name) : Entity(id, name) {}\n  ~ItemBase() = default;  // Already virtual from Entity\n\n  // -- Entity Overrides --\n\n  bool IsItem() const override { return true; }\n\n  // -- Ownership Info --\n  [[nodiscard]] bool IsOnGrid() const { return owner_type == OwnerType::GRID; }\n  [[nodiscard]] bool IsOwnedByItem() const { return owner_type == OwnerType::ITEM; }\n  [[nodiscard]] bool IsOwnedByAgent() const { return owner_type == OwnerType::AGENT; }\n  [[nodiscard]] bool IsOwned() const { return IsOwnedByItem() || IsOwnedByAgent(); }\n  [[nodiscard]] bool IsOnGrid(size_t grid_id) const { return IsOnGrid() &amp;&amp; owner_id == grid_id; }\n  [[nodiscard]] bool IsOwnedByItem(size_t item_id) const {\n    return IsOwnedByItem() &amp;&amp; owner_id == item_id;\n  }\n  [[nodiscard]] bool IsOwnedByAgent(size_t agent_id) const {\n    return IsOwnedByAgent() &amp;&amp; owner_id == agent_id;\n  }\n  [[nodiscard]] bool IsOwnedBy(size_t entity_id) const {\n    return IsOwned() &amp;&amp; owner_id == entity_id;\n  }\n  [[nodiscard]] size_t GetOwnerID() const { return owner_id; }\n\n  ItemBase &amp;SetOwner(const Entity &amp;owner) {\n    if (owner.IsItem())\n      owner_type = OwnerType::ITEM;\n    else if (owner.IsAgent())\n      owner_type = OwnerType::AGENT;\n    else\n      owner_type = OwnerType::NONE;  // Error?\n    owner_id = owner.GetID();\n    position.MakeInvalid();\n    return *this;\n  }\n\n  ItemBase &amp;SetGrid(size_t grid_id = 0) {\n    owner_type = OwnerType::GRID;\n    owner_id = grid_id;\n    return *this;\n  }\n  ItemBase &amp;SetUnowned() {\n    owner_type = OwnerType::NONE;\n    return *this;\n  }\n\n  std::string GetTypeName_impl() const override { return \"cse491::ItemBase\"; }\n\n  void Serialize_impl(std::ostream &amp;os) const override {\n    Entity::Serialize_impl(os);\n    SerializeValue(os, owner_type);\n    SerializeValue(os, owner_id);\n  }\n\n  void Deserialize_impl(std::istream &amp;is) override {\n    Entity::Deserialize_impl(is);\n    DeserializeValue(is, owner_type);\n    DeserializeValue(is, owner_id);\n  }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_property_8hpp/","title":"File Property.hpp","text":"<p>FileList &gt; core &gt; Property.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"CoreObject.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"GridPosition.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_property_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_property_8hpp/#classes","title":"Classes","text":"Type Name struct Property &lt;typename T&gt; struct PropertyBase <p>The documentation for this class was generated from the following file <code>source/core/Property.hpp</code></p>"},{"location":"Core%20Project/_property_8hpp_source/","title":"File Property.hpp","text":"<p>File List &gt; core &gt; Property.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n\n#include \"CoreObject.hpp\"\n#include \"Data.hpp\"\n#include \"GridPosition.hpp\"\n\nnamespace cse491 {\n\nstruct PropertyBase : public CoreObject {\n  virtual ~PropertyBase() {}\n  virtual PropertyType GetType() const = 0;\n  virtual std::string GetTypeName() const = 0;\n  virtual std::string ToString() const = 0;\n  virtual char ToChar() const = 0;\n  virtual double ToDouble() const = 0;\n  virtual int ToInt() const = 0;\n  virtual GridPosition ToGridPosition() const = 0;\n};\n\n// For the moment, properties can be char, int, double, string, or GridPosition\ntemplate &lt;typename T&gt;\nstruct Property : public PropertyBase {\n  T value;\n  Property(const T &amp;in) : value(in) {}\n  Property(T &amp;&amp;in) : value(in) {}\n\n  PropertyType GetType() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return PropertyType::t_char;\n    if constexpr (std::is_same&lt;T, int&gt;())          return PropertyType::t_int;\n    if constexpr (std::is_same&lt;T, bool&gt;())         return PropertyType::t_bool;\n    if constexpr (std::is_same&lt;T, double&gt;())       return PropertyType::t_double;\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return PropertyType::t_string;\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return PropertyType::t_position;\n    return PropertyType::t_other;\n  }\n\n  std::string GetTypeName() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return \"char\";\n    if constexpr (std::is_same&lt;T, int&gt;())          return \"int\";\n    if constexpr (std::is_same&lt;T, bool&gt;())         return \"bool\";\n    if constexpr (std::is_same&lt;T, double&gt;())       return \"double\";\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return \"string\";\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return \"GridPosition\";\n    return \"unknown\";\n  }\n\n  std::string ToString() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return std::string(1, value);\n    if constexpr (std::is_same&lt;T, int&gt;())          return std::to_string(value);\n    if constexpr (std::is_same&lt;T, double&gt;())       return std::to_string(value);\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return value;\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return value.ToString();\n    return \"unknown\";\n  }\n\n  char ToChar() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return value;\n    if constexpr (std::is_same&lt;T, int&gt;())          return static_cast&lt;char&gt;(value);\n    if constexpr (std::is_same&lt;T, double&gt;())       return static_cast&lt;char&gt;(value);\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return value.size() ? value[0] : '\\0';\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return '\\0'; // No conversion.\n    return '\\0';\n  }\n\n  double ToDouble() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return static_cast&lt;double&gt;(value);\n    if constexpr (std::is_same&lt;T, int&gt;())          return static_cast&lt;double&gt;(value);\n    if constexpr (std::is_same&lt;T, double&gt;())       return value;\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return std::stod(value);\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return std::nan(\"nan\"); // No conversion.\n    return std::nan(\"nan\");\n  }\n\n  int ToInt() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return static_cast&lt;int&gt;(value);\n    if constexpr (std::is_same&lt;T, int&gt;())          return value;\n    if constexpr (std::is_same&lt;T, double&gt;())       return static_cast&lt;int&gt;(value);\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return std::stoi(value);\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return 0; // No conversion.\n    return 0;\n  }\n\n  GridPosition ToGridPosition() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return GridPosition::Invalid();\n    if constexpr (std::is_same&lt;T, int&gt;())          return GridPosition::Invalid();\n    if constexpr (std::is_same&lt;T, double&gt;())       return GridPosition::Invalid();\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return GridPosition(value);\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return value;\n    return GridPosition::Invalid();\n  }\n\n  // --- CoreObject Functionality ---\n  std::string GetTypeName_impl() const override {\n    return std::string(\"cse491::Property&lt;\") + GetTypeName() + \"&gt;\";\n  }\n\n  void Serialize_impl(std::ostream &amp; os) const override {\n    SerializeValue(os, value);\n  };\n\n  void Deserialize_impl(std::istream &amp; is) override {\n    DeserializeValue(is, value);\n  };\n};\n\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_serialize_8hpp/","title":"File Serialize.hpp","text":"<p>FileList &gt; core &gt; Serialize.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Core%20Project/_serialize_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_serialize_8hpp/#classes","title":"Classes","text":"Type Name struct is_any_map &lt;typename T&gt;Type trait to determine if we are working with any type of map. struct is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; &lt;typename KEY_T, typename VALUE_T&gt; struct is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; &lt;typename KEY_T, typename VALUE_T&gt; struct is_vector &lt;typename T&gt;Type trait to determine if we are working with a vector. struct is_vector&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/_serialize_8hpp_source/","title":"File Serialize.hpp","text":"<p>File List &gt; core &gt; Serialize.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nnamespace cse491 {\n\n// --- Pre-declarations of Functions ---\ntemplate &lt;typename T&gt; static void SerializeValue_Vector(std::ostream &amp;, const std::vector&lt;T&gt; &amp;);\ntemplate &lt;typename T&gt; static void SerializeValue_Map(std::ostream &amp;, const T &amp;);\ntemplate &lt;typename T&gt; static void DeserializeValue_Vector(std::istream &amp;, std::vector&lt;T&gt; &amp;);\ntemplate &lt;typename T&gt; static void DeserializeValue_Map(std::istream &amp;, T &amp;);\n\n\n// --- Type Traits ---\n\ntemplate &lt;typename T&gt; struct is_vector : std::false_type {};\ntemplate &lt;typename T&gt; struct is_vector&lt;std::vector&lt;T&gt;&gt; : std::true_type {};\n\ntemplate &lt;typename T&gt;\nstruct is_any_map : std::false_type {};\ntemplate &lt;typename KEY_T, typename VALUE_T&gt;\nstruct is_any_map&lt;std::map&lt;KEY_T, VALUE_T&gt;&gt; : std::true_type {};\ntemplate &lt;typename KEY_T, typename VALUE_T&gt;\nstruct is_any_map&lt;std::unordered_map&lt;KEY_T, VALUE_T&gt;&gt; : std::true_type {};\n\ntemplate &lt;typename STREAM_T, typename OBJ_T&gt;\nconcept CanStreamTo = requires(STREAM_T &amp; stream, OBJ_T value) {\n  { stream &lt;&lt; value } -&gt; std::convertible_to&lt;std::ostream&amp;&gt;;\n};\n\ntemplate &lt;typename STREAM_T, typename OBJ_T&gt;\nconcept CanStreamFrom = requires(STREAM_T &amp; stream, OBJ_T value) {\n  { stream &gt;&gt; value } -&gt; std::convertible_to&lt;std::istream&amp;&gt;;\n};\n\ntemplate &lt;typename OBJ_T&gt;\nconcept HasSerialize = requires(OBJ_T value) {\n  { value.Serialize(std::cout) } -&gt; std::same_as&lt;void&gt;;\n};\n\ntemplate &lt;typename OBJ_T&gt;\nconcept HasDeserialize = requires(OBJ_T value) {\n  { value.Deserialize(std::cin) } -&gt; std::same_as&lt;void&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstatic void SerializeValue(std::ostream &amp; os, const T &amp; var) {\n  if constexpr (std::is_enum&lt;T&gt;()) {\n    os &lt;&lt; static_cast&lt;int&gt;(var) &lt;&lt; std::endl;\n  } else if constexpr (is_vector&lt;T&gt;()) {\n    SerializeValue_Vector(os, var);\n  } else if constexpr (is_any_map&lt;T&gt;()) {\n    SerializeValue_Map(os, var);\n  } else if constexpr (HasSerialize&lt;T&gt;) {\n    var.Serialize(os);\n  } else if constexpr (CanStreamTo&lt;std::stringstream, T&gt;) {\n    os &lt;&lt; var &lt;&lt; '\\n';\n  } else {\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic void SerializeValue_Vector(std::ostream &amp; os, const std::vector&lt;T&gt; &amp; var) {\n  SerializeValue(os, var.size());\n  for (const auto &amp; x : var) {\n    SerializeValue(os, x);\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic void SerializeValue_Map(std::ostream &amp; os, const T &amp; var) {\n  SerializeValue(os, var.size());\n  for (const auto &amp; [key, value] : var) {\n    SerializeValue(os, key);\n    SerializeValue(os, value);\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic void DeserializeValue(std::istream &amp; is, T &amp; var) {\n  static_assert(!std::is_const&lt;T&gt;(), \"Cannot deserialize const variables.\");\n\n  // If we are loading a string, load it directly.\n  if constexpr (std::is_same&lt;std::decay_t&lt;T&gt;, std::string&gt;()) {\n    std::getline(is, var, '\\n');\n  } else if constexpr (is_vector&lt;T&gt;()) {\n    DeserializeValue_Vector(is, var);\n  } else if constexpr (is_any_map&lt;T&gt;()) {\n    DeserializeValue_Map(is, var);\n  } else if constexpr (HasDeserialize&lt;T&gt;) {\n    var.Deserialize(is);\n  } else {\n    // @CAO: This can be streamlined to use only the original is, and based on type.\n    //       For example, \"is &lt;&lt; var\" followed by \"is.peek()\" to make sure we have a\n    //       newline, and then \"is.ignore()\" to skip the newline.\n    std::string str;\n    std::getline(is, str, '\\n');\n    std::stringstream ss(str);\n    if constexpr (std::is_enum&lt;T&gt;()) { // enums must be converted properly.\n      int enum_val;\n      ss &gt;&gt; enum_val;\n      var = static_cast&lt;T&gt;(enum_val);\n    } else if constexpr (CanStreamFrom&lt;std::stringstream, T&gt;) {\n      ss &gt;&gt; var;\n    } else if constexpr (std::is_pointer&lt;T&gt;()) {\n      std::cerr &lt;&lt; \"Warning: Attempting to deserialize pointer.\" &lt;&lt; std::endl;\n    } else { \n      // Finally, ignore this value?  Most likely a pointer.\n      std::cerr &lt;&lt; \"Warning: Attempting to deserialize unknown type.\" &lt;&lt; std::endl;\n    }\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic void DeserializeFunction(std::istream &amp; is, std::function&lt;void(T)&gt; set_fun) {\n  std::string str;\n  std::getline(is, str, '\\n');\n  if constexpr (std::is_same&lt;std::decay_t&lt;T&gt;, std::string&gt;()) {\n    set_fun(str);\n  } else if constexpr (std::is_same&lt;std::decay_t&lt;T&gt;, int&gt;()) {\n    set_fun(stoi(str));\n  } else if constexpr (std::is_same&lt;std::decay_t&lt;T&gt;, double&gt;()) {\n    set_fun(stod(str));\n  } else {\n    T var;\n    std::stringstream ss(str);\n    ss &gt;&gt; var;\n    set_fun(var);\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic T DeserializeAs(std::istream &amp; is) {\n  T value;\n  DeserializeValue(is, value);\n  return value;\n}\n\ntemplate &lt;typename T&gt;\nstatic void DeserializeValue_Vector(std::istream &amp; is, std::vector&lt;T&gt; &amp; var) {\n  DeserializeFunction&lt;size_t&gt;(is, [&amp;var](size_t in_size){ var.resize(in_size); } );\n  for (auto &amp; x : var) {\n    DeserializeValue(is, x);\n  }\n}\n\ntemplate &lt;typename MAP_T&gt;\nstatic void DeserializeValue_Map(std::istream &amp; is, MAP_T &amp; var) {\n  size_t map_size = 0;\n  typename MAP_T::key_type key;\n  typename MAP_T::mapped_type value;\n  DeserializeValue(is, map_size);\n  for (size_t i = 0; i &lt; map_size; ++i) {\n    DeserializeValue(is, key);\n    DeserializeValue(is, value);\n    var[key] = value;\n  }\n}\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_world_base_8hpp/","title":"File WorldBase.hpp","text":"<p>FileList &gt; core &gt; WorldBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../DataCollection/AgentReciever.hpp\"</code></li> <li><code>#include \"AgentBase.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"DataCollection/DataManager.hpp\"</code></li> <li><code>#include \"Interfaces/NetWorth/client/ClientInterface.hpp\"</code></li> <li><code>#include \"Interfaces/NetWorth/client/ClientManager.hpp\"</code></li> <li><code>#include \"Interfaces/NetWorth/client/ControlledAgent.hpp\"</code></li> <li><code>#include \"Interfaces/NetWorth/server/ServerManager.hpp\"</code></li> <li><code>#include \"ItemBase.hpp\"</code></li> <li><code>#include \"WorldGrid.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_world_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types. namespace worldlang A base class for all World modules."},{"location":"Core%20Project/_world_base_8hpp/#classes","title":"Classes","text":"Type Name class WorldBase <p>The documentation for this class was generated from the following file <code>source/core/WorldBase.hpp</code></p>"},{"location":"Core%20Project/_world_base_8hpp_source/","title":"File WorldBase.hpp","text":"<p>File List &gt; core &gt; WorldBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;memory&gt;\n#include &lt;queue&gt;\n#include &lt;random&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"../DataCollection/AgentReciever.hpp\"\n#include \"AgentBase.hpp\"\n#include \"Data.hpp\"\n#include \"DataCollection/DataManager.hpp\"\n#include \"Interfaces/NetWorth/client/ClientInterface.hpp\"\n#include \"Interfaces/NetWorth/client/ClientManager.hpp\"\n#include \"Interfaces/NetWorth/client/ControlledAgent.hpp\"\n#include \"Interfaces/NetWorth/server/ServerManager.hpp\"\n#include \"ItemBase.hpp\"\n#include \"WorldGrid.hpp\"\n\n// Forward declaration\nnamespace worldlang {\nclass ProgramExecutor;\n}\n\nnamespace cse491 {\nclass DataReceiver;\n\nclass WorldBase {\npublic:\n  static constexpr size_t npos = static_cast&lt;size_t&gt;(-1);\n  netWorth::ServerManager *server_manager = nullptr;  \n  netWorth::ClientManager *client_manager = nullptr;  \n\n  virtual void ConfigAgent(AgentBase &amp; /* agent */) const {}\n\nprotected:\n  std::unordered_map&lt;size_t, WorldGrid&gt; grids;\n\n  WorldGrid &amp;main_grid;         \n  type_options_t type_options;  \n\n  item_map_t item_map;        \n  agent_map_t agent_map;      \n  size_t last_entity_id = 0;  \n\n  bool run_over = false;      \n  bool world_running = true;  \n\n  std::string action;  \n  std::shared_ptr&lt;DataCollection::AgentReceiver&gt; agent_receiver;\n\n  unsigned int seed;                          \n  std::mt19937 random_gen;                    \n  std::uniform_real_distribution&lt;&gt; uni_dist;  \n  std::normal_distribution&lt;&gt; norm_dist;       \n\n  size_t NextEntityID() { return ++last_entity_id; }\n\n  virtual void ConfigAgent(AgentBase &amp; /* agent */) {}\n\n  size_t AddCellType(const std::string &amp;name, const std::string &amp;desc = \"\", char symbol = '\\0') {\n    type_options.push_back(CellType{name, desc, symbol});\n    return type_options.size() - 1;\n  }\n\npublic:\n  WorldBase(unsigned int seed = 0) : grids(), main_grid(grids[0]), seed(seed) {\n    // The first cell type (ID 0) should be reserved for errors or empty spots in a grid.\n    AddCellType(\"Unknown\", \"This is an invalid cell type and should not be reachable.\");\n\n    // Initialize the random number generator.\n    if (seed == 0) {\n      std::random_device rd;  // An expensive \"true\" random number generator.\n      seed = rd();            // Change the seed to a random value.\n    }\n    random_gen.seed(seed);\n  }\n\n  virtual ~WorldBase() = default;\n\n  virtual void Reset() {\n    item_map.clear();\n    agent_map.clear();\n    last_entity_id = 0;\n    run_over = false;\n  }\n\n  // -- Accessors --\n\n  [[nodiscard]] size_t GetNumItems() const { return item_map.size(); }\n\n  [[nodiscard]] size_t GetNumAgents() const { return agent_map.size(); }\n\n  [[nodiscard]] bool HasItem(size_t id) const { return item_map.count(id); }\n\n  [[nodiscard]] bool HasAgent(size_t id) const { return agent_map.count(id); }\n\n  [[nodiscard]] ItemBase &amp;GetItem(size_t id) {\n    assert(HasItem(id));\n    return *item_map[id];\n  }\n\n  [[nodiscard]] AgentBase &amp;GetAgent(size_t id) {\n    assert(HasAgent(id));\n    return *agent_map[id];\n  }\n\n  [[nodiscard]] size_t GetItemID(const std::string &amp;name) {\n    for (auto &amp;[id, ptr] : item_map) {\n      if (ptr-&gt;GetName() == name) return id;\n    }\n    return npos;\n  }\n\n  [[nodiscard]] size_t GetAgentID(const std::string &amp;name) {\n    for (auto &amp;[id, ptr] : agent_map) {\n      if (ptr-&gt;GetName() == name) return id;\n    }\n    return npos;\n  }\n\n  virtual WorldGrid &amp;GetGrid() { return main_grid; }\n  virtual WorldGrid &amp;GetGrid(size_t grid_id) { return grids[grid_id]; }\n\n  virtual const WorldGrid &amp;GetGrid() const { return main_grid; }\n  virtual const WorldGrid &amp;GetGrid(size_t grid_id) const { return grids.at(grid_id); }\n\n  virtual bool GetRunOver() const { return run_over; }\n\n  // -- Random Number Generation --\n\n  unsigned int GetSeed() const { return seed; }\n\n  double GetRandom() { return uni_dist(random_gen); }\n\n  double GetRandom(double max) { return GetRandom() * max; }\n\n  double GetRandom(double min, double max) {\n    assert(max &gt; min);\n    return min + GetRandom(max - min);\n  }\n\n  double GetRandomNormal() { return norm_dist(random_gen); }\n\n  double GetRandomNormal(double mean, double sd = 1.0) {\n    assert(sd &gt; 0);\n    return mean + norm_dist(random_gen) * sd;\n  }\n\n  // -- Agent Management --\n\n  AgentBase &amp;AddConfiguredAgent(std::unique_ptr&lt;AgentBase&gt; agent_ptr) {\n    std::mutex agent_map_lock;\n    agent_map_lock.lock();\n    agent_ptr-&gt;SetWorld(*this);\n    if (agent_ptr-&gt;Initialize() == false) {\n      std::cerr &lt;&lt; \"Failed to initialize agent '\" &lt;&lt; agent_ptr-&gt;GetName() &lt;&lt; \"'.\" &lt;&lt; std::endl;\n    }\n    AgentBase &amp; agentReturn = *agent_map[agent_ptr-&gt;GetID()];\n    agent_map[agent_ptr-&gt;GetID()] = std::move(agent_ptr);\n    agent_map_lock.unlock();\n    return agentReturn;\n  }\n\n\n  template &lt;typename AGENT_T, typename... PROPERTY_Ts&gt;\n  AgentBase &amp;AddAgent(std::string agent_name = \"None\", PROPERTY_Ts... properties) {\n    std::mutex agent_map_lock;\n    agent_map_lock.lock();\n    const size_t agent_id = NextEntityID();\n    auto agent_ptr = std::make_unique&lt;AGENT_T&gt;(agent_id, agent_name);\n    agent_ptr-&gt;SetWorld(*this);\n    agent_ptr-&gt;SetProperties(std::forward&lt;PROPERTY_Ts&gt;(properties)...);\n    ConfigAgent(*agent_ptr);\n    if (agent_ptr-&gt;Initialize() == false) {\n      std::cerr &lt;&lt; \"Failed to initialize agent '\" &lt;&lt; agent_name &lt;&lt; \"'.\" &lt;&lt; std::endl;\n    }\n    agent_map[agent_id] = std::move(agent_ptr);\n    AgentBase &amp;agentReturn = *agent_map[agent_id];\n    agent_map_lock.unlock();\n    return agentReturn;\n  }\n\n  ItemBase &amp;AddItem(std::unique_ptr&lt;ItemBase&gt; item_ptr) {\n    assert(item_ptr);                // item_ptr must not be null.\n    assert(item_ptr-&gt;GetID() != 0);  // item_ptr must have had a non-zero ID assigned.\n    item_ptr-&gt;SetWorld(*this);\n    size_t item_id = item_ptr-&gt;GetID();\n    item_map[item_id] = std::move(item_ptr);\n    return *item_map[item_id];\n  }\n\n  template &lt;typename ITEM_T = ItemBase, typename... PROPERTY_Ts&gt;\n  ItemBase &amp;AddItem(std::string item_name = \"None\", PROPERTY_Ts... properties) {\n    auto item_ptr = std::make_unique&lt;ITEM_T&gt;(NextEntityID(), item_name);\n    item_ptr-&gt;SetProperties(std::forward&lt;PROPERTY_Ts&gt;(properties)...);\n    return AddItem(std::move(item_ptr));\n  }\n\n  WorldBase &amp;RemoveAgent(size_t agent_id) {\n    agent_map.erase(agent_id);\n    return *this;\n  }\n\n  WorldBase &amp;RemoveItem(size_t item_id) {\n    item_map.erase(item_id);\n    return *this;\n  }\n\n  WorldBase &amp;RemoveAgent(std::string agent_name = \"None\") {\n    assert(agent_name != \"Interface\");  // We are not allowed to remove interfaces.\n    return RemoveAgent(GetAgentID(agent_name));\n  }\n\n  WorldBase &amp;RemoveItem(std::string item_name) { return RemoveItem(GetItemID(item_name)); }\n\n  WorldBase &amp;AddItemToGrid(size_t item_id, GridPosition pos, size_t grid_id = 0) {\n    item_map[item_id]-&gt;SetPosition(pos, grid_id);\n    return *this;\n  }\n\n  // -- Action Management --\n\n  virtual int DoAction(AgentBase &amp;agent, size_t action_id) = 0;\n\n  virtual void RunAgents() {\n    for (auto &amp;[id, agent_ptr] : agent_map) {\n      size_t action_id = agent_ptr-&gt;SelectAction(main_grid, type_options, item_map, agent_map);\n      agent_ptr-&gt;storeActionMap(agent_ptr-&gt;GetName());\n      int result = DoAction(*agent_ptr, action_id);\n      agent_ptr-&gt;SetActionResult(result);\n    }\n  }\n\n  virtual void RunClientAgents() {\n    for (auto &amp;[id, agent_ptr] : agent_map) {\n      size_t action_id = agent_ptr-&gt;SelectAction(main_grid, type_options, item_map, agent_map);\n      agent_ptr-&gt;storeActionMap(agent_ptr-&gt;GetName());\n      int result = DoAction(*agent_ptr, action_id);\n      agent_ptr-&gt;SetActionResult(result);\n    }\n\n    // Deserialize agents\n    std::string data = client_manager-&gt;getSerializedAgents();\n    if (data.substr(0, 18) == \":::START agent_set\") {\n      std::istringstream is(data);\n      DeserializeAgentSet(is, client_manager);\n    }\n  }\n\n  virtual void RunServerAgents() {\n    std::set&lt;size_t&gt; to_delete;\n\n    for (auto &amp;[id, agent_ptr] : agent_map) {\n      // wait until clients have connected to run\n      while (!server_manager-&gt;hasAgentsPresent() || !world_running) {\n      }\n\n      // select action and send to client\n      size_t action_id = agent_ptr-&gt;SelectAction(main_grid, type_options, item_map, agent_map);\n      server_manager-&gt;writeToActionMap(id, action_id);\n      agent_ptr-&gt;storeActionMap(agent_ptr-&gt;GetName());\n      int result = DoAction(*agent_ptr, action_id);\n      agent_ptr-&gt;SetActionResult(result);\n\n      // mark agent for deletion if client disconnects\n      if (action_id == 9999) to_delete.insert(id);\n    }\n\n    // delete agents\n    for (size_t id : to_delete) {\n      RemoveAgent(id);\n    }\n\n    // send updates to client for deleted agents\n    if (!to_delete.empty()) {\n      std::ostringstream os;\n      SerializeAgentSet(os);\n      std::string data = os.str();\n      server_manager-&gt;setSerializedAgents(data);\n      server_manager-&gt;setNewAgent(true);\n      server_manager-&gt;sendGameUpdates();\n    }\n  }\n\n  void CollectData() {\n    for (const auto &amp;[id, agent_ptr] : agent_map) {\n      DataCollection::DataManager::GetInstance().GetAgentReceiver().StoreData(\n          agent_ptr-&gt;GetName(), agent_ptr-&gt;GetPosition(), agent_ptr-&gt;GetActionResult());\n    }\n  }\n\n  virtual void UpdateWorld() {}\n\n  virtual void Run() {\n    run_over = false;\n    while (!run_over) {\n      RunAgents();\n      CollectData();\n      UpdateWorld();\n    }\n  }\n\n  virtual void RunClient(netWorth::ClientManager *manager) {\n    run_over = false;\n    client_manager = manager;\n    while (!run_over) {\n      if (world_running) {\n        RunClientAgents();\n        CollectData();\n        UpdateWorld();\n      }\n    }\n  }\n\n  virtual void RunServer(netWorth::ServerManager *manager) {\n    run_over = false;\n    server_manager = manager;\n    while (!run_over) {\n      if (world_running) {\n        RunServerAgents();\n        CollectData();\n        UpdateWorld();\n      }\n    }\n  }\n\n  virtual void SetWorldRunning(bool running) { world_running = running; }\n\n  // CellType management.\n\n  // Return a const vector of all of the possible cell types.\n  [[nodiscard]] const type_options_t &amp;GetCellTypes() const { return type_options; }\n\n  [[nodiscard]] size_t GetCellTypeID(const std::string &amp;name) const {\n    for (size_t i = 1; i &lt; type_options.size(); ++i) {\n      if (type_options[i].name == name) return i;\n    }\n    return 0;\n  }\n\n  [[nodiscard]] const std::string &amp;GetCellTypeName(size_t id) const {\n    if (id &gt;= type_options.size()) return type_options[0].name;\n    return type_options[id].name;\n  }\n\n  [[nodiscard]] char GetCellTypeSymbol(size_t id) const {\n    if (id &gt;= type_options.size()) return type_options[0].symbol;\n    return type_options[id].symbol;\n  }\n\n  // -- Grid Analysis Helpers --\n\n  [[nodiscard]] virtual std::vector&lt;size_t&gt; FindItemsAt(GridPosition pos,\n                                                        size_t grid_id = 0) const {\n    std::vector&lt;size_t&gt; item_ids;\n    for (const auto &amp;[id, item_ptr] : item_map) {\n      if (item_ptr-&gt;IsOnGrid(grid_id) &amp;&amp; item_ptr-&gt;GetPosition() == pos) item_ids.push_back(id);\n    }\n    return item_ids;\n  }\n\n  [[nodiscard]] virtual std::vector&lt;size_t&gt; FindAgentsAt(GridPosition pos,\n                                                         size_t grid_id = 0) const {\n    std::vector&lt;size_t&gt; agent_ids;\n    for (const auto &amp;[id, agent_ptr] : agent_map) {\n      if (agent_ptr-&gt;IsOnGrid(grid_id) &amp;&amp; agent_ptr-&gt;GetPosition() == pos) agent_ids.push_back(id);\n    }\n    return agent_ids;\n  }\n\n  [[nodiscard]] virtual std::vector&lt;size_t&gt; FindItemsNear(GridPosition pos, double dist = 1.0,\n                                                          size_t grid_id = 0) const {\n    std::vector&lt;size_t&gt; item_ids;\n    for (const auto &amp;[id, item_ptr] : item_map) {\n      if (item_ptr-&gt;IsOnGrid(grid_id) &amp;&amp; item_ptr-&gt;GetPosition().IsNear(pos, dist)) {\n        item_ids.push_back(id);\n      }\n    }\n    return item_ids;\n  }\n\n  [[nodiscard]] virtual std::vector&lt;size_t&gt; FindAgentsNear(GridPosition pos, double dist = 1.0,\n                                                           size_t grid_id = 0) const {\n    std::vector&lt;size_t&gt; agent_ids;\n    for (const auto &amp;[id, agent_ptr] : agent_map) {\n      if (agent_ptr-&gt;IsOnGrid(grid_id) &amp;&amp; agent_ptr-&gt;GetPosition().IsNear(pos, dist)) {\n        agent_ids.push_back(id);\n      }\n    }\n    return agent_ids;\n  }\n\n  [[nodiscard]] virtual bool IsTraversable(const AgentBase &amp; /*agent*/,\n                                           cse491::GridPosition /*pos*/) const {\n    return true;\n  }\n\n  // -- Network Serialization and Deserialization --\n\n  void SerializeAgentSet(std::ostream &amp;os) {\n    os &lt;&lt; \":::START agent_set\\n\";\n    SerializeValue(os, agent_map.size());\n\n    for (const auto &amp;[agent_id, agent_ptr] : agent_map) {\n      SerializeValue(os, *agent_ptr);\n    }\n    os &lt;&lt; \":::END agent_set\\n\";\n  }\n\n  void DeserializeAgentSet(std::istream &amp;is, netWorth::ClientManager *manager) {\n    // find beginning of agent_set serialization\n    std::string read;\n    std::getline(is, read, '\\n');\n    if (read != \":::START agent_set\") {\n      std::cerr &lt;&lt; \"Could not find start of agent_set serialization\" &lt;&lt; std::endl;\n      return;\n    }\n\n    size_t client_id = manager-&gt;getClientID();\n\n    // Remove all agents other than the interface\n    std::vector&lt;size_t&gt; to_delete;\n    for (auto &amp; [agent_id, agent_ptr] : agent_map) {\n      if (agent_id != client_id) to_delete.push_back(agent_id);\n    }\n\n    for (size_t agent_id : to_delete) {\n      RemoveAgent(agent_id);\n    }\n\n    // reset last_entity_id; start from the beginning\n    last_entity_id = 0;\n\n    // Load the number of agents saved.\n    size_t server_last_entity_id = DeserializeAs&lt;size_t&gt;(is);\n\n    // client id NOT in agent map yet if ID = 0\n    // append to end of set\n    if (client_id == 0) client_id = server_last_entity_id;\n\n    // Load back in all agents.\n    for (size_t i = 0; i &lt; server_last_entity_id; i++) {\n      // First, check to see if we've hit the end of the agent_set\n      // Because we are looking at last entity id (and not total size), we may have\n      //  gaps in our agent_set\n      auto tmp_pos = is.tellg();\n      std::getline(is, read, '\\n');\n      if(read == \":::END agent_set\"){\n        if(last_entity_id &lt; client_id) last_entity_id = client_id;\n        return;\n      }\n      else is.seekg(tmp_pos);\n      auto agent_ptr = std::make_unique&lt;netWorth::ControlledAgent&gt;(0, \"temp\");\n      DeserializeValue(is, *agent_ptr);\n      agent_ptr-&gt;SetProperty(\"manager\", manager);\n\n      if (agent_ptr-&gt;GetID() &gt;= last_entity_id) last_entity_id = agent_ptr-&gt;GetID();\n\n      // If this agent is the client interface, skip it (we already have it).\n      if (agent_ptr-&gt;GetID() == client_id) { continue; }\n\n      AddConfiguredAgent(std::move(agent_ptr));\n    }\n\n    // find end of agent_set deserialization\n    std::getline(is, read, '\\n');\n    if (read != \":::END agent_set\") {\n      std::cerr &lt;&lt; \"Could not find end of agent_set serialization\" &lt;&lt; std::endl;\n      return;\n    }\n  }\n\n  void SerializeItemSet(std::ostream &amp;os) {\n    os &lt;&lt; \":::START item_set\\n\";\n    SerializeValue(os, item_map.size());\n\n    for (const auto &amp;item : item_map) {\n      item.second-&gt;Serialize(os);\n    }\n    os &lt;&lt; \":::END item_set\\n\";\n  }\n\n  void DeserializeItemSet(std::istream &amp;is) {\n    // find beginning of item_set serialization\n    std::string read;\n    std::getline(is, read, '\\n');\n    if (read != \":::START item_set\") {\n      std::cerr &lt;&lt; \"Could not find start of item_set serialization\" &lt;&lt; std::endl;\n      return;\n    }\n\n    // how many items?\n    size_t size;\n    DeserializeValue(is, size);\n\n    // read each item\n    for (size_t i = 0; i &lt; size; i++) {\n      auto item = std::make_unique&lt;ItemBase&gt;(agent_map.size() + i, \"\");\n      DeserializeValue(is, *item);\n      AddItem(std::move(item));\n    }\n\n    // find end of item_set serialization\n    std::getline(is, read, '\\n');\n    if (read != \":::END item_set\") {\n      std::cerr &lt;&lt; \"Could not find end of item_set serialization\" &lt;&lt; std::endl;\n      return;\n    }\n  }\n\n  void Serialize(std::ostream &amp;os) {\n    main_grid.Serialize(os);\n    SerializeAgentSet(os);\n    SerializeItemSet(os);\n  }\n\n  void Deserialize(std::istream &amp;is, netWorth::ClientManager *manager) {\n    main_grid.Deserialize(is);\n    DeserializeAgentSet(is, manager);\n    DeserializeItemSet(is);\n  }\n\n  // Needs access to most things here so this is easiest way to do so\n  friend worldlang::ProgramExecutor;\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_world_grid_8hpp/","title":"File WorldGrid.hpp","text":"<p>FileList &gt; core &gt; WorldGrid.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"CoreObject.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"GridPosition.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_world_grid_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_world_grid_8hpp/#classes","title":"Classes","text":"Type Name class WorldGrid A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. <p>The documentation for this class was generated from the following file <code>source/core/WorldGrid.hpp</code></p>"},{"location":"Core%20Project/_world_grid_8hpp_source/","title":"File WorldGrid.hpp","text":"<p>File List &gt; core &gt; WorldGrid.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"CoreObject.hpp\"\n#include \"Data.hpp\"\n#include \"GridPosition.hpp\"\n\nnamespace cse491 {\n\nclass WorldGrid : public CoreObject {\nprotected:\n  size_t width = 0;           \n  size_t height = 0;          \n  std::vector&lt;size_t&gt; cells;  \n\n  // -- Helper functions --\n\n  [[nodiscard]] inline size_t ToIndex(size_t x, size_t y) const { return x + y * width; }\n\n  // -- Serialize and Deserialize functions --\n  // Mechanisms to efficiently save and load the exact state of the grid.\n  // File format is width and height followed by all\n  // values in the grid on each line thereafter.\n\n  std::string GetTypeName_impl() const override { return \"cse491::WorldGrid\"; }\n\n  void Serialize_impl(std::ostream &amp;os) const override {\n    SerializeValue(os, width);\n    SerializeValue(os, height);\n    for (size_t state : cells) SerializeValue(os, state);\n  }\n\n  void Deserialize_impl(std::istream &amp;is) override {\n    DeserializeValue(is, width);\n    DeserializeValue(is, height);\n    cells.resize(width * height);\n    for (size_t &amp;state : cells) DeserializeValue(is, state);\n  }\n\npublic:\n  WorldGrid() = default;\n  WorldGrid(size_t width, size_t height, size_t default_type = 0)\n      : width(width), height(height), cells(width * height, default_type) {}\n  WorldGrid(const WorldGrid &amp;) = default;\n  WorldGrid(WorldGrid &amp;&amp;) = default;\n\n  WorldGrid &amp;operator=(const WorldGrid &amp;) = default;\n  WorldGrid &amp;operator=(WorldGrid &amp;&amp;) = default;\n\n  // -- Accessors --\n  [[nodiscard]] size_t GetWidth() const { return width; }\n  [[nodiscard]] size_t GetHeight() const { return height; }\n  [[nodiscard]] size_t GetNumCells() const { return cells.size(); }\n\n  [[nodiscard]] bool IsValid(double x, double y) const {\n    return x &gt;= 0.0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0.0 &amp;&amp; y &lt; height;\n  }\n\n  [[nodiscard]] bool IsValid(GridPosition pos) const { return IsValid(pos.GetX(), pos.GetY()); }\n\n  [[nodiscard]] size_t At(size_t x, size_t y) const {\n    assert(IsValid(x, y));\n    return cells[ToIndex(x, y)];\n  }\n\n  [[nodiscard]] size_t &amp;At(size_t x, size_t y) {\n    assert(IsValid(x, y));\n    return cells[ToIndex(x, y)];\n  }\n\n  [[nodiscard]] size_t At(GridPosition p) const { return At(p.CellX(), p.CellY()); }\n\n  [[nodiscard]] size_t &amp;At(GridPosition p) { return At(p.CellX(), p.CellY()); }\n\n  [[nodiscard]] size_t operator[](GridPosition p) const { return At(p); }\n  [[nodiscard]] size_t &amp;operator[](GridPosition p) { return At(p); }\n\n  // Size adjustments.\n  void Resize(size_t new_width, size_t new_height, size_t default_type = 0) {\n    // Create a new vector of the correct size.\n    std::vector&lt;size_t&gt; new_cells(new_width * new_height, default_type);\n\n    // Copy the overlapping portions of the two grids.\n    size_t min_width = std::min(width, new_width);\n    size_t min_height = std::min(height, new_height);\n    for (size_t x = 0; x &lt; min_width; ++x) {\n      for (size_t y = 0; y &lt; min_height; ++y) {\n        new_cells[x + y * new_width] = cells[ToIndex(x, y)];\n      }\n    }\n\n    // Swap the new grid in; let the old grid be deallocated in its place.\n    std::swap(cells, new_cells);\n    width = new_width;\n    height = new_height;\n  }\n\n  // -- Read and Write functions --\n  // These are the same idea as Save and Load, but they are human readable, but they\n  // also require that each state has been assigned a unique character symbol.\n\n  void Write(std::ostream &amp;os, const type_options_t &amp;types) const {\n    size_t cell_id = 0;\n    for (size_t y = 0; y &lt; height; ++y) {\n      for (size_t x = 0; x &lt; width; ++x) {\n        os &lt;&lt; types[cells[cell_id++]].symbol;\n      }\n      os &lt;&lt; '\\n';\n    }\n    os.flush();\n  }\n\n  bool Write(std::string filename, const type_options_t &amp;types) const {\n    std::ofstream os(filename);\n    if (!os.is_open()) {\n      std::cerr &lt;&lt; \"Could not open file '\" &lt;&lt; filename &lt;&lt; \"' to write grid.\" &lt;&lt; std::endl;\n      return false;\n    }\n    Write(os, types);\n    return true;\n  }\n\n  void Read(std::istream &amp;is, const type_options_t &amp;types) {\n    // Build a symbol chart for conversions back.\n    std::unordered_map&lt;char, size_t&gt; symbol_map;\n    for (size_t i = 0; i &lt; types.size(); ++i) {\n      symbol_map[types[i].symbol] = i;\n    }\n\n    // Load the file into memory.\n    std::vector&lt;std::string&gt; char_grid;\n    std::string line;\n    width = 0;\n    while (std::getline(is, line)) {\n      char_grid.push_back(line);\n      if (line.size() &gt; width) width = line.size();\n    }\n    height = char_grid.size();\n\n    // Convert each symbol to the appropriate value.\n    cells.resize(width * height);\n    size_t cell_id = 0;\n    for (size_t y = 0; y &lt; height; ++y) {\n      for (size_t x = 0; x &lt; width; ++x) {\n        // Use the cell values provided, or zero if a cell position is missing.\n        cells[cell_id++] = (x &lt; char_grid[y].size()) ? symbol_map[char_grid[y][x]] : 0;\n      }\n    }\n  }\n\n  bool Read(std::string filename, const type_options_t &amp;types) {\n    std::ifstream is(filename);\n    if (!is.is_open()) {\n      std::cerr &lt;&lt; \"Could not open file '\" &lt;&lt; filename &lt;&lt; \"' to write grid.\" &lt;&lt; std::endl;\n      return false;\n    }\n    Read(is, types);\n    return true;\n  }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace clogged Tools for debug-logging that can be easily controlled. </li> <li>namespace cse491 A base class interface for all agent types. </li> <li>namespace std </li> <li>namespace worldlang A base class for all World modules. </li> </ul>"},{"location":"Core%20Project/classes/","title":"Class Index","text":""},{"location":"Core%20Project/classes/#a","title":"a","text":"<ul> <li>AgentBase (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#c","title":"c","text":"<ul> <li>CellType (cse491)</li> <li>CoreObject (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#e","title":"e","text":"<ul> <li>Entity (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#g","title":"g","text":"<ul> <li>GridPosition (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#i","title":"i","text":"<ul> <li>InterfaceBase (cse491)</li> <li>is_any_map (cse491)</li> <li>is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; (cse491)</li> <li>is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; (cse491)</li> <li>is_vector (cse491)</li> <li>is_vector&lt; std::vector&lt; T &gt; &gt; (cse491)</li> <li>ItemBase (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#l","title":"l","text":"<ul> <li>Logger (clogged)</li> </ul>"},{"location":"Core%20Project/classes/#p","title":"p","text":"<ul> <li>Property (cse491)</li> <li>PropertyBase (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#w","title":"w","text":"<ul> <li>WorldBase (cse491)</li> <li>WorldGrid (cse491)</li> </ul>"},{"location":"Core%20Project/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class clogged::Logger Logger class with colors and team names.</li> <li>class cse491::CoreObject <ul> <li>class cse491::Entity <ul> <li>class cse491::AgentBase <ul> <li>class cse491::InterfaceBase </li> </ul> </li> <li>class cse491::ItemBase </li> </ul> </li> <li>class cse491::GridPosition Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. </li> <li>struct cse491::PropertyBase <ul> <li>struct cse491::Property </li> </ul> </li> <li>class cse491::WorldGrid A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. </li> </ul> </li> <li>class cse491::WorldBase </li> <li>struct cse491::CellType Simple data structure to hold info about a TYPE of cell in the world. </li> <li>class false_type <ul> <li>struct cse491::is_any_map Type trait to determine if we are working with any type of map. </li> <li>struct cse491::is_vector Type trait to determine if we are working with a vector. </li> </ul> </li> <li>class true_type <ul> <li>struct cse491::is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; </li> <li>struct cse491::is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; </li> <li>struct cse491::is_vector&lt; std::vector&lt; T &gt; &gt; </li> </ul> </li> </ul>"},{"location":"Core%20Project/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Core%20Project/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Core%20Project/class_members/","title":"Class Members","text":""},{"location":"Core%20Project/class_members/#a","title":"a","text":"<ul> <li>AddAction (cse491::AgentBase)</li> <li>AgentBase (cse491::AgentBase)</li> <li>action (cse491::AgentBase, cse491::WorldBase)</li> <li>action_map (cse491::AgentBase)</li> <li>action_result (cse491::AgentBase)</li> <li>agent_state (cse491::AgentBase)</li> <li>AddItem (cse491::Entity, cse491::WorldBase)</li> <li>AsProperty (cse491::Entity)</li> <li>Above (cse491::GridPosition)</li> <li>AddAgent (cse491::WorldBase)</li> <li>AddCellType (cse491::WorldBase)</li> <li>AddConfiguredAgent (cse491::WorldBase)</li> <li>AddItemToGrid (cse491::WorldBase)</li> <li>agent_map (cse491::WorldBase)</li> <li>agent_receiver (cse491::WorldBase)</li> <li>At (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#b","title":"b","text":"<ul> <li>Below (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_members/#c","title":"c","text":"<ul> <li>currentColor (clogged::Logger)</li> <li>currentLogLevel (clogged::Logger)</li> <li>currentTeam (clogged::Logger)</li> <li>CELL_WALL (cse491::CellType)</li> <li>CELL_WATER (cse491::CellType)</li> <li>CellX (cse491::GridPosition)</li> <li>CellY (cse491::GridPosition)</li> <li>CollectData (cse491::WorldBase)</li> <li>ConfigAgent (cse491::WorldBase)</li> <li>client_manager (cse491::WorldBase)</li> <li>cells (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#d","title":"d","text":"<ul> <li>Deserialize_impl (cse491::AgentBase, cse491::CoreObject, cse491::Entity, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>desc (cse491::CellType)</li> <li>Deserialize (cse491::CoreObject, cse491::WorldBase)</li> <li>Distance (cse491::GridPosition)</li> <li>DeserializeAgentSet (cse491::WorldBase)</li> <li>DeserializeItemSet (cse491::WorldBase)</li> <li>DoAction (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#e","title":"e","text":"<ul> <li>endl (clogged::Logger)</li> <li>EndDeserialize (cse491::CoreObject)</li> <li>EndSerialize (cse491::CoreObject)</li> <li>Entity (cse491::Entity)</li> <li>exitCleanup (cse491::InterfaceBase)</li> </ul>"},{"location":"Core%20Project/class_members/#f","title":"f","text":"<ul> <li>FromStream (cse491::GridPosition)</li> <li>FromString (cse491::GridPosition)</li> <li>FindAgentsAt (cse491::WorldBase)</li> <li>FindAgentsNear (cse491::WorldBase)</li> <li>FindItemsAt (cse491::WorldBase)</li> <li>FindItemsNear (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#g","title":"g","text":"<ul> <li>GetActionID (cse491::AgentBase)</li> <li>GetActionResult (cse491::AgentBase)</li> <li>GetAgentState (cse491::AgentBase)</li> <li>GetNextPosition (cse491::AgentBase)</li> <li>GetTypeName_impl (cse491::AgentBase, cse491::CoreObject, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>GetTypeName (cse491::CoreObject, cse491::Property, cse491::PropertyBase)</li> <li>GetGridID (cse491::Entity)</li> <li>GetID (cse491::Entity)</li> <li>GetInventory (cse491::Entity)</li> <li>GetName (cse491::Entity)</li> <li>GetNumProperties (cse491::Entity)</li> <li>GetPosition (cse491::Entity)</li> <li>GetProperty (cse491::Entity)</li> <li>GetPropertyMap (cse491::Entity)</li> <li>GetPropertyType (cse491::Entity)</li> <li>GetWorld (cse491::Entity)</li> <li>grid_id (cse491::Entity)</li> <li>GetOffset (cse491::GridPosition)</li> <li>GetX (cse491::GridPosition)</li> <li>GetY (cse491::GridPosition)</li> <li>GridPosition (cse491::GridPosition)</li> <li>GetOwnerID (cse491::ItemBase)</li> <li>GetType (cse491::Property, cse491::PropertyBase)</li> <li>GetAgent (cse491::WorldBase)</li> <li>GetAgentID (cse491::WorldBase)</li> <li>GetCellTypeID (cse491::WorldBase)</li> <li>GetCellTypeName (cse491::WorldBase)</li> <li>GetCellTypeSymbol (cse491::WorldBase)</li> <li>GetCellTypes (cse491::WorldBase)</li> <li>GetGrid (cse491::WorldBase)</li> <li>GetItem (cse491::WorldBase)</li> <li>GetItemID (cse491::WorldBase)</li> <li>GetNumAgents (cse491::WorldBase)</li> <li>GetNumItems (cse491::WorldBase)</li> <li>GetRandom (cse491::WorldBase)</li> <li>GetRandomNormal (cse491::WorldBase)</li> <li>GetRunOver (cse491::WorldBase)</li> <li>GetSeed (cse491::WorldBase)</li> <li>grids (cse491::WorldBase)</li> <li>GetHeight (cse491::WorldGrid)</li> <li>GetNumCells (cse491::WorldGrid)</li> <li>GetWidth (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#h","title":"h","text":"<ul> <li>HasAction (cse491::AgentBase)</li> <li>HasProperty (cse491::CellType, cse491::Entity)</li> <li>HasItem (cse491::Entity, cse491::WorldBase)</li> <li>HasWorld (cse491::Entity)</li> <li>HasAgent (cse491::WorldBase)</li> <li>height (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#i","title":"i","text":"<ul> <li>Initialize (cse491::AgentBase)</li> <li>IsAgent (cse491::AgentBase, cse491::Entity)</li> <li>IsInterface (cse491::Entity, cse491::InterfaceBase)</li> <li>IsItem (cse491::Entity, cse491::ItemBase)</li> <li>IsOnGrid (cse491::Entity, cse491::ItemBase)</li> <li>id (cse491::Entity)</li> <li>inventory (cse491::Entity)</li> <li>Invalid (cse491::GridPosition)</li> <li>IsInvalid (cse491::GridPosition)</li> <li>IsNear (cse491::GridPosition)</li> <li>IsValid (cse491::GridPosition, cse491::WorldGrid)</li> <li>InterfaceBase (cse491::InterfaceBase)</li> <li>IsOwned (cse491::ItemBase)</li> <li>IsOwnedBy (cse491::ItemBase)</li> <li>IsOwnedByAgent (cse491::ItemBase)</li> <li>IsOwnedByItem (cse491::ItemBase)</li> <li>ItemBase (cse491::ItemBase)</li> <li>IsTraversable (cse491::WorldBase)</li> <li>item_map (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#l","title":"l","text":"<ul> <li>Log (clogged::Logger)</li> <li>logToString (clogged::Logger)</li> <li>last_entity_id (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#m","title":"m","text":"<ul> <li>metaPrinted (clogged::Logger)</li> <li>MDistance (cse491::GridPosition)</li> <li>MakeInvalid (cse491::GridPosition)</li> <li>main_grid (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#n","title":"n","text":"<ul> <li>Notify (cse491::AgentBase)</li> <li>name (cse491::CellType, cse491::Entity)</li> <li>NextEntityID (cse491::WorldBase)</li> <li>norm_dist (cse491::WorldBase)</li> <li>npos (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (clogged::Logger)</li> <li>operator&lt;=&gt; (cse491::CoreObject, cse491::GridPosition)</li> <li>operator= (cse491::Entity, cse491::GridPosition, cse491::WorldGrid)</li> <li>operator+ (cse491::GridPosition)</li> <li>operator+= (cse491::GridPosition)</li> <li>operator-= (cse491::GridPosition)</li> <li>OwnerType (cse491::ItemBase)</li> <li>owner_id (cse491::ItemBase)</li> <li>owner_type (cse491::ItemBase)</li> <li>operator[] (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#p","title":"p","text":"<ul> <li>properties (cse491::CellType)</li> <li>position (cse491::Entity)</li> <li>property_map (cse491::Entity)</li> <li>property_map_t (cse491::Entity)</li> <li>Property (cse491::Property)</li> </ul>"},{"location":"Core%20Project/class_members/#r","title":"r","text":"<ul> <li>RemoveProperty (cse491::CellType, cse491::Entity)</li> <li>RemoveItem (cse491::Entity, cse491::WorldBase)</li> <li>RemoveAgent (cse491::WorldBase)</li> <li>Reset (cse491::WorldBase)</li> <li>Run (cse491::WorldBase)</li> <li>RunAgents (cse491::WorldBase)</li> <li>RunClient (cse491::WorldBase)</li> <li>RunClientAgents (cse491::WorldBase)</li> <li>RunServer (cse491::WorldBase)</li> <li>RunServerAgents (cse491::WorldBase)</li> <li>random_gen (cse491::WorldBase)</li> <li>run_over (cse491::WorldBase)</li> <li>Read (cse491::WorldGrid)</li> <li>Resize (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#s","title":"s","text":"<ul> <li>SelectAction (cse491::AgentBase)</li> <li>Serialize_impl (cse491::AgentBase, cse491::CoreObject, cse491::Entity, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>SetActionResult (cse491::AgentBase)</li> <li>storeActionMap (cse491::AgentBase)</li> <li>SetProperty (cse491::CellType, cse491::Entity)</li> <li>symbol (cse491::CellType)</li> <li>Serialize (cse491::CoreObject, cse491::WorldBase)</li> <li>StartDeserialize (cse491::CoreObject)</li> <li>StartSerialize (cse491::CoreObject)</li> <li>SetName (cse491::Entity)</li> <li>SetPosition (cse491::Entity)</li> <li>SetProperties (cse491::Entity)</li> <li>SetWorld (cse491::Entity)</li> <li>Set (cse491::GridPosition)</li> <li>SetX (cse491::GridPosition)</li> <li>SetY (cse491::GridPosition)</li> <li>Shift (cse491::GridPosition)</li> <li>SetGrid (cse491::ItemBase)</li> <li>SetOwner (cse491::ItemBase)</li> <li>SetUnowned (cse491::ItemBase)</li> <li>SerializeAgentSet (cse491::WorldBase)</li> <li>SerializeItemSet (cse491::WorldBase)</li> <li>SetWorldRunning (cse491::WorldBase)</li> <li>seed (cse491::WorldBase)</li> <li>server_manager (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#t","title":"t","text":"<ul> <li>teamToString (clogged::Logger)</li> <li>teamToStringMap (clogged::Logger)</li> <li>TakeDamage (cse491::AgentBase)</li> <li>ToLeft (cse491::GridPosition)</li> <li>ToRight (cse491::GridPosition)</li> <li>ToString (cse491::GridPosition, cse491::Property, cse491::PropertyBase)</li> <li>ToChar (cse491::Property, cse491::PropertyBase)</li> <li>ToDouble (cse491::Property, cse491::PropertyBase)</li> <li>ToGridPosition (cse491::Property, cse491::PropertyBase)</li> <li>ToInt (cse491::Property, cse491::PropertyBase)</li> <li>type_options (cse491::WorldBase)</li> <li>ToIndex (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#u","title":"u","text":"<ul> <li>UpdateAgentState (cse491::AgentBase)</li> <li>UpdateWorld (cse491::WorldBase)</li> <li>uni_dist (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#v","title":"v","text":"<ul> <li>value (cse491::Property)</li> </ul>"},{"location":"Core%20Project/class_members/#w","title":"w","text":"<ul> <li>world_ptr (cse491::Entity)</li> <li>WorldBase (cse491::WorldBase)</li> <li>world_running (cse491::WorldBase)</li> <li>WorldGrid (cse491::WorldGrid)</li> <li>Write (cse491::WorldGrid)</li> <li>width (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#x","title":"x","text":"<ul> <li>x (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_members/#y","title":"y","text":"<ul> <li>y (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_members/#_1","title":"~","text":"<ul> <li>~AgentBase (cse491::AgentBase)</li> <li>~CoreObject (cse491::CoreObject)</li> <li>~Entity (cse491::Entity)</li> <li>~GridPosition (cse491::GridPosition)</li> <li>~InterfaceBase (cse491::InterfaceBase)</li> <li>~ItemBase (cse491::ItemBase)</li> <li>~PropertyBase (cse491::PropertyBase)</li> <li>~WorldBase (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Core%20Project/class_member_functions/#a","title":"a","text":"<ul> <li>AddAction (cse491::AgentBase)</li> <li>AgentBase (cse491::AgentBase)</li> <li>AddItem (cse491::Entity, cse491::WorldBase)</li> <li>AsProperty (cse491::Entity)</li> <li>Above (cse491::GridPosition)</li> <li>AddAgent (cse491::WorldBase)</li> <li>AddCellType (cse491::WorldBase)</li> <li>AddConfiguredAgent (cse491::WorldBase)</li> <li>AddItemToGrid (cse491::WorldBase)</li> <li>At (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#b","title":"b","text":"<ul> <li>Below (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#c","title":"c","text":"<ul> <li>CellX (cse491::GridPosition)</li> <li>CellY (cse491::GridPosition)</li> <li>CollectData (cse491::WorldBase)</li> <li>ConfigAgent (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#d","title":"d","text":"<ul> <li>Deserialize_impl (cse491::AgentBase, cse491::CoreObject, cse491::Entity, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>Deserialize (cse491::CoreObject, cse491::WorldBase)</li> <li>Distance (cse491::GridPosition)</li> <li>DeserializeAgentSet (cse491::WorldBase)</li> <li>DeserializeItemSet (cse491::WorldBase)</li> <li>DoAction (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#e","title":"e","text":"<ul> <li>endl (clogged::Logger)</li> <li>EndDeserialize (cse491::CoreObject)</li> <li>EndSerialize (cse491::CoreObject)</li> <li>Entity (cse491::Entity)</li> <li>exitCleanup (cse491::InterfaceBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#f","title":"f","text":"<ul> <li>FromStream (cse491::GridPosition)</li> <li>FromString (cse491::GridPosition)</li> <li>FindAgentsAt (cse491::WorldBase)</li> <li>FindAgentsNear (cse491::WorldBase)</li> <li>FindItemsAt (cse491::WorldBase)</li> <li>FindItemsNear (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#g","title":"g","text":"<ul> <li>GetActionID (cse491::AgentBase)</li> <li>GetActionResult (cse491::AgentBase)</li> <li>GetAgentState (cse491::AgentBase)</li> <li>GetNextPosition (cse491::AgentBase)</li> <li>GetTypeName_impl (cse491::AgentBase, cse491::CoreObject, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>GetTypeName (cse491::CoreObject, cse491::Property, cse491::PropertyBase)</li> <li>GetGridID (cse491::Entity)</li> <li>GetID (cse491::Entity)</li> <li>GetInventory (cse491::Entity)</li> <li>GetName (cse491::Entity)</li> <li>GetNumProperties (cse491::Entity)</li> <li>GetPosition (cse491::Entity)</li> <li>GetProperty (cse491::Entity)</li> <li>GetPropertyMap (cse491::Entity)</li> <li>GetPropertyType (cse491::Entity)</li> <li>GetWorld (cse491::Entity)</li> <li>GetOffset (cse491::GridPosition)</li> <li>GetX (cse491::GridPosition)</li> <li>GetY (cse491::GridPosition)</li> <li>GridPosition (cse491::GridPosition)</li> <li>GetOwnerID (cse491::ItemBase)</li> <li>GetType (cse491::Property, cse491::PropertyBase)</li> <li>GetAgent (cse491::WorldBase)</li> <li>GetAgentID (cse491::WorldBase)</li> <li>GetCellTypeID (cse491::WorldBase)</li> <li>GetCellTypeName (cse491::WorldBase)</li> <li>GetCellTypeSymbol (cse491::WorldBase)</li> <li>GetCellTypes (cse491::WorldBase)</li> <li>GetGrid (cse491::WorldBase)</li> <li>GetItem (cse491::WorldBase)</li> <li>GetItemID (cse491::WorldBase)</li> <li>GetNumAgents (cse491::WorldBase)</li> <li>GetNumItems (cse491::WorldBase)</li> <li>GetRandom (cse491::WorldBase)</li> <li>GetRandomNormal (cse491::WorldBase)</li> <li>GetRunOver (cse491::WorldBase)</li> <li>GetSeed (cse491::WorldBase)</li> <li>GetHeight (cse491::WorldGrid)</li> <li>GetNumCells (cse491::WorldGrid)</li> <li>GetWidth (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#h","title":"h","text":"<ul> <li>HasAction (cse491::AgentBase)</li> <li>HasProperty (cse491::CellType, cse491::Entity)</li> <li>HasItem (cse491::Entity, cse491::WorldBase)</li> <li>HasWorld (cse491::Entity)</li> <li>HasAgent (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (cse491::AgentBase)</li> <li>IsAgent (cse491::AgentBase, cse491::Entity)</li> <li>IsInterface (cse491::Entity, cse491::InterfaceBase)</li> <li>IsItem (cse491::Entity, cse491::ItemBase)</li> <li>IsOnGrid (cse491::Entity, cse491::ItemBase)</li> <li>Invalid (cse491::GridPosition)</li> <li>IsInvalid (cse491::GridPosition)</li> <li>IsNear (cse491::GridPosition)</li> <li>IsValid (cse491::GridPosition, cse491::WorldGrid)</li> <li>InterfaceBase (cse491::InterfaceBase)</li> <li>IsOwned (cse491::ItemBase)</li> <li>IsOwnedBy (cse491::ItemBase)</li> <li>IsOwnedByAgent (cse491::ItemBase)</li> <li>IsOwnedByItem (cse491::ItemBase)</li> <li>ItemBase (cse491::ItemBase)</li> <li>IsTraversable (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#l","title":"l","text":"<ul> <li>Log (clogged::Logger)</li> <li>logToString (clogged::Logger)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#m","title":"m","text":"<ul> <li>MDistance (cse491::GridPosition)</li> <li>MakeInvalid (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#n","title":"n","text":"<ul> <li>Notify (cse491::AgentBase)</li> <li>NextEntityID (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (clogged::Logger)</li> <li>operator&lt;=&gt; (cse491::CoreObject, cse491::GridPosition)</li> <li>operator= (cse491::Entity, cse491::GridPosition, cse491::WorldGrid)</li> <li>operator+ (cse491::GridPosition)</li> <li>operator+= (cse491::GridPosition)</li> <li>operator-= (cse491::GridPosition)</li> <li>operator[] (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#p","title":"p","text":"<ul> <li>Property (cse491::Property)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#r","title":"r","text":"<ul> <li>RemoveProperty (cse491::CellType, cse491::Entity)</li> <li>RemoveItem (cse491::Entity, cse491::WorldBase)</li> <li>RemoveAgent (cse491::WorldBase)</li> <li>Reset (cse491::WorldBase)</li> <li>Run (cse491::WorldBase)</li> <li>RunAgents (cse491::WorldBase)</li> <li>RunClient (cse491::WorldBase)</li> <li>RunClientAgents (cse491::WorldBase)</li> <li>RunServer (cse491::WorldBase)</li> <li>RunServerAgents (cse491::WorldBase)</li> <li>Read (cse491::WorldGrid)</li> <li>Resize (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (cse491::AgentBase)</li> <li>Serialize_impl (cse491::AgentBase, cse491::CoreObject, cse491::Entity, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>SetActionResult (cse491::AgentBase)</li> <li>storeActionMap (cse491::AgentBase)</li> <li>SetProperty (cse491::CellType, cse491::Entity)</li> <li>Serialize (cse491::CoreObject, cse491::WorldBase)</li> <li>StartDeserialize (cse491::CoreObject)</li> <li>StartSerialize (cse491::CoreObject)</li> <li>SetName (cse491::Entity)</li> <li>SetPosition (cse491::Entity)</li> <li>SetProperties (cse491::Entity)</li> <li>SetWorld (cse491::Entity)</li> <li>Set (cse491::GridPosition)</li> <li>SetX (cse491::GridPosition)</li> <li>SetY (cse491::GridPosition)</li> <li>Shift (cse491::GridPosition)</li> <li>SetGrid (cse491::ItemBase)</li> <li>SetOwner (cse491::ItemBase)</li> <li>SetUnowned (cse491::ItemBase)</li> <li>SerializeAgentSet (cse491::WorldBase)</li> <li>SerializeItemSet (cse491::WorldBase)</li> <li>SetWorldRunning (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#t","title":"t","text":"<ul> <li>teamToString (clogged::Logger)</li> <li>TakeDamage (cse491::AgentBase)</li> <li>ToLeft (cse491::GridPosition)</li> <li>ToRight (cse491::GridPosition)</li> <li>ToString (cse491::GridPosition, cse491::Property, cse491::PropertyBase)</li> <li>ToChar (cse491::Property, cse491::PropertyBase)</li> <li>ToDouble (cse491::Property, cse491::PropertyBase)</li> <li>ToGridPosition (cse491::Property, cse491::PropertyBase)</li> <li>ToInt (cse491::Property, cse491::PropertyBase)</li> <li>ToIndex (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#u","title":"u","text":"<ul> <li>UpdateAgentState (cse491::AgentBase)</li> <li>UpdateWorld (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#w","title":"w","text":"<ul> <li>WorldBase (cse491::WorldBase)</li> <li>WorldGrid (cse491::WorldGrid)</li> <li>Write (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#_1","title":"~","text":"<ul> <li>~AgentBase (cse491::AgentBase)</li> <li>~CoreObject (cse491::CoreObject)</li> <li>~Entity (cse491::Entity)</li> <li>~GridPosition (cse491::GridPosition)</li> <li>~InterfaceBase (cse491::InterfaceBase)</li> <li>~ItemBase (cse491::ItemBase)</li> <li>~PropertyBase (cse491::PropertyBase)</li> <li>~WorldBase (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Core%20Project/class_member_variables/#a","title":"a","text":"<ul> <li>action (cse491::AgentBase, cse491::WorldBase)</li> <li>action_map (cse491::AgentBase)</li> <li>action_result (cse491::AgentBase)</li> <li>agent_state (cse491::AgentBase)</li> <li>agent_map (cse491::WorldBase)</li> <li>agent_receiver (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#c","title":"c","text":"<ul> <li>currentColor (clogged::Logger)</li> <li>currentLogLevel (clogged::Logger)</li> <li>currentTeam (clogged::Logger)</li> <li>CELL_WALL (cse491::CellType)</li> <li>CELL_WATER (cse491::CellType)</li> <li>client_manager (cse491::WorldBase)</li> <li>cells (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#d","title":"d","text":"<ul> <li>desc (cse491::CellType)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#g","title":"g","text":"<ul> <li>grid_id (cse491::Entity)</li> <li>grids (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#h","title":"h","text":"<ul> <li>height (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#i","title":"i","text":"<ul> <li>id (cse491::Entity)</li> <li>inventory (cse491::Entity)</li> <li>item_map (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#l","title":"l","text":"<ul> <li>last_entity_id (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#m","title":"m","text":"<ul> <li>metaPrinted (clogged::Logger)</li> <li>main_grid (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#n","title":"n","text":"<ul> <li>name (cse491::CellType, cse491::Entity)</li> <li>norm_dist (cse491::WorldBase)</li> <li>npos (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#o","title":"o","text":"<ul> <li>owner_id (cse491::ItemBase)</li> <li>owner_type (cse491::ItemBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#p","title":"p","text":"<ul> <li>properties (cse491::CellType)</li> <li>position (cse491::Entity)</li> <li>property_map (cse491::Entity)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#r","title":"r","text":"<ul> <li>random_gen (cse491::WorldBase)</li> <li>run_over (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#s","title":"s","text":"<ul> <li>symbol (cse491::CellType)</li> <li>seed (cse491::WorldBase)</li> <li>server_manager (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#t","title":"t","text":"<ul> <li>teamToStringMap (clogged::Logger)</li> <li>type_options (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#u","title":"u","text":"<ul> <li>uni_dist (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#v","title":"v","text":"<ul> <li>value (cse491::Property)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#w","title":"w","text":"<ul> <li>world_ptr (cse491::Entity)</li> <li>world_running (cse491::WorldBase)</li> <li>width (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#x","title":"x","text":"<ul> <li>x (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#y","title":"y","text":"<ul> <li>y (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"Core%20Project/class_member_typedefs/#p","title":"p","text":"<ul> <li>property_map_t (cse491::Entity)</li> </ul>"},{"location":"Core%20Project/class_member_enums/","title":"Class Member Enums","text":""},{"location":"Core%20Project/class_member_enums/#o","title":"o","text":"<ul> <li>OwnerType (cse491::ItemBase)</li> </ul>"},{"location":"Core%20Project/namespace_members/","title":"Namespace Members","text":""},{"location":"Core%20Project/namespace_members/#a","title":"a","text":"<ul> <li>agent_map_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#c","title":"c","text":"<ul> <li>Color (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_members/#d","title":"d","text":"<ul> <li>DeserializeAs (cse491)</li> <li>DeserializeFunction (cse491)</li> <li>DeserializeValue (cse491)</li> <li>DeserializeValue_Map (cse491)</li> <li>DeserializeValue_Vector (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#i","title":"i","text":"<ul> <li>item_map_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#l","title":"l","text":"<ul> <li>LOGLEVEL (clogged)</li> <li>LogLevel (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_members/#p","title":"p","text":"<ul> <li>PropertyType (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#s","title":"s","text":"<ul> <li>SerializeValue (cse491)</li> <li>SerializeValue_Map (cse491)</li> <li>SerializeValue_Vector (cse491)</li> <li>State (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#t","title":"t","text":"<ul> <li>Team (clogged)</li> <li>type_options_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#w","title":"w","text":"<ul> <li>WorldType (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"Core%20Project/namespace_member_functions/#d","title":"d","text":"<ul> <li>DeserializeAs (cse491)</li> <li>DeserializeFunction (cse491)</li> <li>DeserializeValue (cse491)</li> <li>DeserializeValue_Map (cse491)</li> <li>DeserializeValue_Vector (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_functions/#s","title":"s","text":"<ul> <li>SerializeValue (cse491)</li> <li>SerializeValue_Map (cse491)</li> <li>SerializeValue_Vector (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"Core%20Project/namespace_member_variables/#l","title":"l","text":"<ul> <li>LOGLEVEL (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"Core%20Project/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>agent_map_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>item_map_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>type_options_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"Core%20Project/namespace_member_enums/#c","title":"c","text":"<ul> <li>Color (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#l","title":"l","text":"<ul> <li>LogLevel (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#p","title":"p","text":"<ul> <li>PropertyType (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#s","title":"s","text":"<ul> <li>State (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#t","title":"t","text":"<ul> <li>Team (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#w","title":"w","text":"<ul> <li>WorldType (cse491)</li> </ul>"},{"location":"Core%20Project/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Core%20Project/macros/","title":"Macros","text":""},{"location":"Core%20Project/macros/#e","title":"e","text":"<ul> <li>EXPERIMENTAL_CLASS (CoreObject.hpp)</li> <li>EXPERIMENTAL_FUNCTION (CoreObject.hpp)</li> </ul>"},{"location":"Core%20Project/macros/#l","title":"l","text":"<ul> <li>LOGLINE (EasyLogging.hpp)</li> <li>LOG_FNC (EasyLogging.hpp)</li> <li>LOG_RELLINE (EasyLogging.hpp)</li> </ul>"},{"location":"Core%20Project/macros/#r","title":"r","text":"<ul> <li>RELATIVE_PATH (EasyLogging.hpp)</li> </ul>"},{"location":"Core%20Project/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Core%20Project/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cse491 An Agent that will walk back and forth along a row or column. <ul> <li>class PacingAgent </li> </ul> </li> <li>namespace walle <ul> <li>class AStarAgent </li> <li>struct AStarAgentData </li> <li>class AgentFactory </li> <li>class Alerter </li> <li>struct BaseAgentData </li> <li>struct CompareNodes Custom comparison function for priority queue. </li> <li>struct Node Node class to hold information about positions for A* search. </li> <li>struct PacingAgentData </li> <li>class PathAgent </li> <li>struct PathAgentData </li> <li>class RandomAgent </li> <li>class TrackingAgent </li> <li>struct TrackingAgentData </li> </ul> </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Agents <ul> <li>file AStarAgent.hpp AStar Agent Class. </li> <li>file AgentFactory.hpp A factory class that abstracts away the initialization of adding an agent to a world. </li> <li>file AgentLibary.hpp </li> <li>file PacingAgent.hpp </li> <li>file PathAgent.cpp Path Agent Class. </li> <li>file PathAgent.hpp </li> <li>file RandomAgent.hpp An Agent that will move around using random actions. </li> <li>file TrackingAgent.hpp Agent that switches between user-defined custom movement pattern and tracking a given agent. </li> </ul> </li> </ul> </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>An Agent that will walk back and forth along a row or column. More...</p>"},{"location":"Agent%20Library%28Group%201%29/namespacecse491/#classes","title":"Classes","text":"Type Name class PacingAgent"},{"location":"Agent%20Library%28Group%201%29/namespacecse491/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>The documentation for this class was generated from the following file <code>source/Agents/PacingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/","title":"Class cse491::PacingAgent","text":"<p>ClassList &gt; cse491 &gt; PacingAgent</p> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#public-functions","title":"Public Functions","text":"Type Name bool GetVertical () constReturns the vertical member variable. bool Initialize () overrideThis agent needs a specific set of actions to function. PacingAgent (size_t id, const std::string &amp; name)  size_t SelectAction (const WorldGrid &amp;, const type_options_t &amp;, const item_map_t &amp;, const agent_map_t &amp;) overrideChoose the action to take a step in the appropriate direction. PacingAgent &amp; SetVertical (bool vert)  ~PacingAgent () = default"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name bool reverse   = = falseIs this agent on their way back? (up/left?) bool vertical   = = trueIs this agent moving down&amp;up? False = right&amp;left."},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-getvertical","title":"function GetVertical","text":"<pre><code>inline bool cse491::PacingAgent::GetVertical () const\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool cse491::PacingAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-pacingagent","title":"function PacingAgent","text":"<pre><code>inline cse491::PacingAgent::PacingAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cse491::PacingAgent::SelectAction (\n    const WorldGrid &amp;,\n    const type_options_t &amp;,\n    const item_map_t &amp;,\n    const agent_map_t &amp;\n) override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-setvertical","title":"function SetVertical","text":"<pre><code>inline PacingAgent &amp; cse491::PacingAgent::SetVertical (\n    bool vert\n) \n</code></pre> <p>Setter for vertical param </p> <p>Parameters:</p> <ul> <li><code>vert</code> what vertical should be </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-pacingagent_1","title":"function ~PacingAgent","text":"<pre><code>cse491::PacingAgent::~PacingAgent () = default\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#variable-reverse","title":"variable reverse","text":"<pre><code>bool reverse;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#variable-vertical","title":"variable vertical","text":"<pre><code>bool vertical;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/PacingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/","title":"Namespace walle","text":"<p>Namespace List &gt; walle</p>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#classes","title":"Classes","text":"Type Name class AStarAgent struct AStarAgentData class AgentFactory class Alerter struct BaseAgentData struct CompareNodes Custom comparison function for priority queue. struct Node Node class to hold information about positions for A* search. struct PacingAgentData class PathAgent struct PathAgentData class RandomAgent class TrackingAgent struct TrackingAgentData"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#public-types","title":"Public Types","text":"Type Name enum TrackingState"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#public-functions","title":"Public Functions","text":"Type Name T &amp; DownCastAgent (cse491::Entity &amp; entity) Helper function for simplifying downcasting entities that have been added to the world. std::vector&lt; cse491::GridPosition &gt; GetShortestPath (const cse491::GridPosition &amp; start, const cse491::GridPosition &amp; end, const cse491::WorldBase &amp; world, const cse491::AgentBase &amp; agent) Uses A* to return a list of grid positions. std::vector&lt; cse491::GridPosition &gt; StrToOffsets (std::string_view commands)"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#enum-trackingstate","title":"enum TrackingState","text":"<pre><code>enum walle::TrackingState {\n    RETURNING_TO_START,\n    TRACKING,\n    PATROLLING\n};\n</code></pre> <p>Used to keep track of what action we are currently taking </p>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#function-downcastagent","title":"function DownCastAgent","text":"<pre><code>template&lt;typename T typename T&gt;\nT &amp; walle::DownCastAgent (\n    cse491::Entity &amp; entity\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#function-getshortestpath","title":"function GetShortestPath","text":"<p>Uses A* to return a list of grid positions. </p> <pre><code>inline std::vector&lt; cse491::GridPosition &gt; walle::GetShortestPath (\n    const cse491::GridPosition &amp; start,\n    const cse491::GridPosition &amp; end,\n    const cse491::WorldBase &amp; world,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Author:</p> <p>@mdkdoc15 </p> <p>Parameters:</p> <ul> <li><code>start</code> Starting position for search </li> <li><code>end</code> Ending position for the search </li> </ul> <p>Returns:</p> <p>vector of A* path from start to end, empty vector if no path exists </p>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#function-strtooffsets","title":"function StrToOffsets","text":"<pre><code>inline std::vector&lt; cse491::GridPosition &gt; walle::StrToOffsets (\n    std::string_view commands\n) \n</code></pre> <p>Converts a string to a sequence of offsets</p> <p>This convenience method takes a string with a special formatting that allows one to specify a sequence of whitespace-separated inputs in linear directions. The format is [steps[*]]&lt;direction&gt; where <code>steps</code> is a positive integer and optional (assumed to be 1 by default) star <code>*</code> represents scaling the movement by <code>steps</code>. Optional, but cannot be used if <code>steps</code> is not provided if the star is not present, then <code>steps</code> individual offsets are created in the direction <code>direction</code> <code>direction</code> is a cardinal direction with the following logical mapping: n: north s: south e: east w: west x: stay put Example: \"n w 3e 10*s 5*w x\" should create the sequence of offsets {0, -1}, {-1, 0}, {1, 0}, {1, 0}, {1, 0}, {0, 10}, {-5, 0}, {0, 0} </p> <p>Parameters:</p> <ul> <li><code>commands</code> string in a format of sequential directions </li> </ul> <p>Note:</p> <p>throws an <code>std::invalid_argument</code> when input string is poorly formatted </p> <p>Note:</p> <p>this includes when a negative integer is passed as <code>steps</code>. If a zero is used, treated as the default (one) </p> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/","title":"Class walle::AStarAgent","text":"<p>ClassList &gt; walle &gt; AStarAgent</p> <p>More...</p> <ul> <li><code>#include &lt;AStarAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#public-functions","title":"Public Functions","text":"Type Name AStarAgent (size_t id, const std::string &amp; name) Constructor for creating a new AStarAgent object. cse491::GridPosition GetGoalPosition () constgets the goal position and returns it cse491::GridPosition GetNextPosition () overrideGet the next position to move to. int GetPathLength () const int GetRecalculateValue () const bool Initialize () overrideThis agent needs a specific set of actions to function. void RecalculatePath () Update the path to go to goal position. size_t SelectAction (const cse491::WorldGrid &amp;, const cse491::type_options_t &amp;, const cse491::item_map_t &amp;, const cse491::agent_map_t &amp;) overrideChoose the action to take a step in the appropriate direction. void SetGoalPosition (const double x, const double y) Set where the agent should head towards. void SetGoalPosition (const cse491::GridPosition gp) Set where the agent should head towards. void SetRecalculate (const int recalculate) Set how many moves should occur before recalculating path A lower number will react faster to updates in the world but will call A* search more often. ~AStarAgent () = default"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#detailed-description","title":"Detailed Description","text":"<p>Class that describes a AStarAgent class </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-astaragent","title":"function AStarAgent","text":"<p>Constructor for creating a new AStarAgent object.</p> <pre><code>inline walle::AStarAgent::AStarAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> id of the agent </li> <li><code>name</code> name of the agent </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-getgoalposition","title":"function GetGoalPosition","text":"<p>gets the goal position and returns it </p> <pre><code>inline cse491::GridPosition walle::AStarAgent::GetGoalPosition () const\n</code></pre> <p>Returns:</p> <p>goal_position member variable </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-getnextposition","title":"function GetNextPosition","text":"<p>Get the next position to move to. </p> <pre><code>inline cse491::GridPosition walle::AStarAgent::GetNextPosition () override\n</code></pre> <p>Returns:</p> <p>GridPosition to move to </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-getpathlength","title":"function GetPathLength","text":"<pre><code>inline int walle::AStarAgent::GetPathLength () const\n</code></pre> <p>Gets the size of the current path </p> <p>Returns:</p> <p>length of path </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-getrecalculatevalue","title":"function GetRecalculateValue","text":"<pre><code>inline int walle::AStarAgent::GetRecalculateValue () const\n</code></pre> <p>Returns the recalculate value </p> <p>Returns:</p> <p>recalculated value </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool walle::AStarAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-recalculatepath","title":"function RecalculatePath","text":"<pre><code>inline void walle::AStarAgent::RecalculatePath () \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t walle::AStarAgent::SelectAction (\n    const cse491::WorldGrid &amp;,\n    const cse491::type_options_t &amp;,\n    const cse491::item_map_t &amp;,\n    const cse491::agent_map_t &amp;\n) override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-setgoalposition-12","title":"function SetGoalPosition [1/2]","text":"<p>Set where the agent should head towards. </p> <pre><code>inline void walle::AStarAgent::SetGoalPosition (\n    const double x,\n    const double y\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>x</code> x-coordinate of the goal position </li> <li><code>y</code> y-coordinate of the goal position </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-setgoalposition-22","title":"function SetGoalPosition [2/2]","text":"<p>Set where the agent should head towards. </p> <pre><code>inline void walle::AStarAgent::SetGoalPosition (\n    const cse491::GridPosition gp\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>gp</code> position agent should go towards </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-setrecalculate","title":"function SetRecalculate","text":"<p>Set how many moves should occur before recalculating path A lower number will react faster to updates in the world but will call A* search more often. </p> <pre><code>inline void walle::AStarAgent::SetRecalculate (\n    const int recalculate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>recalculate</code> How often path should be recalculated </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-astaragent_1","title":"function ~AStarAgent","text":"<pre><code>walle::AStarAgent::~AStarAgent () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AStarAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/","title":"Struct walle::AStarAgentData","text":"<p>ClassList &gt; walle &gt; AStarAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherits the following classes: walle::BaseAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name cse491::GridPosition goal_pos The final position in the world that the AStarAgent is travelling to. int recalculate_after_x_turns   = = 5Number of steps after which the shortest path is recalculated."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#public-attributes-inherited-from-wallebaseagentdata","title":"Public Attributes inherited from walle::BaseAgentData","text":"<p>See walle::BaseAgentData</p> Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for an AStarAgent </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#variable-goal_pos","title":"variable goal_pos","text":"<pre><code>cse491::GridPosition goal_pos;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#variable-recalculate_after_x_turns","title":"variable recalculate_after_x_turns","text":"<pre><code>int recalculate_after_x_turns;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/","title":"Class walle::AgentFactory","text":"<p>ClassList &gt; walle &gt; AgentFactory</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#public-functions","title":"Public Functions","text":"Type Name AStarAgent &amp; AddAStarAgent (const AStarAgentData &amp; agent_data)  cse491::PacingAgent &amp; AddPacingAgent (const PacingAgentData &amp; agent_data)  PathAgent &amp; AddPathAgent (const PathAgentData &amp; agent_data)  TrackingAgent &amp; AddTrackingAgent (const TrackingAgentData &amp; agent_data)  AgentFactory () = deleteThe world to create Agents in. AgentFactory (cse491::WorldBase &amp; world)"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-addastaragent","title":"function AddAStarAgent","text":"<pre><code>AStarAgent &amp; walle::AgentFactory::AddAStarAgent (\n    const AStarAgentData &amp; agent_data\n) \n</code></pre> <p>Add an AStarAgent to the world </p> <p>Parameters:</p> <ul> <li><code>agent_data</code> data for agent we want to create </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-addpacingagent","title":"function AddPacingAgent","text":"<pre><code>cse491::PacingAgent &amp; walle::AgentFactory::AddPacingAgent (\n    const PacingAgentData &amp; agent_data\n) \n</code></pre> <p>Add a PacingAgent to the world </p> <p>Parameters:</p> <ul> <li><code>agent_data</code> data for agent we want to create </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-addpathagent","title":"function AddPathAgent","text":"<pre><code>PathAgent &amp; walle::AgentFactory::AddPathAgent (\n    const PathAgentData &amp; agent_data\n) \n</code></pre> <p>Add a PathAgent to the world </p> <p>Parameters:</p> <ul> <li><code>agent_data</code> data for agent we want to create </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-addtrackingagent","title":"function AddTrackingAgent","text":"<pre><code>TrackingAgent &amp; walle::AgentFactory::AddTrackingAgent (\n    const TrackingAgentData &amp; agent_data\n) \n</code></pre> <p>Add a TrackingAgent to the world </p> <p>Parameters:</p> <ul> <li><code>agent_data</code> data for agent we want to create </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-agentfactory-12","title":"function AgentFactory [1/2]","text":"<pre><code>walle::AgentFactory::AgentFactory () = delete\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-agentfactory-22","title":"function AgentFactory [2/2]","text":"<pre><code>inline explicit walle::AgentFactory::AgentFactory (\n    cse491::WorldBase &amp; world\n) \n</code></pre> <p>Constructor for AgentFactory </p> <p>Parameters:</p> <ul> <li><code>world</code> we are adding agents too </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/","title":"Class walle::Alerter","text":"<p>ClassList &gt; walle &gt; Alerter</p> <p>More...</p> <ul> <li><code>#include &lt;TrackingAgent.hpp&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#public-functions","title":"Public Functions","text":"Type Name void AddAgent (size_t id)  void AlertAllTrackingAgents (size_t caller_id)  Alerter () = delete Alerter (cse491::WorldBase * world_ptr)  Alerter (cse491::WorldBase * world_ptr, size_t id)  std::unordered_set&lt; size_t &gt; const &amp; GetNetworkSet () constReturns an immutable reference to the Alerter 's set of agents it knows about. void RemoveAgent (size_t id)"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#detailed-description","title":"Detailed Description","text":"<p>A single Alerter is responsible for forcefully changing the state of all trackers in its network to TrackingState::TRACKING when a single TrackingAgent in the set of trackers comes into range of its goal_pos </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-addagent","title":"function AddAgent","text":"<pre><code>void walle::Alerter::AddAgent (\n    size_t id\n) \n</code></pre> <p>Adds a TrackingAgent to the network </p> <p>Parameters:</p> <ul> <li><code>id</code> id of agent to be added </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-alertalltrackingagents","title":"function AlertAllTrackingAgents","text":"<pre><code>void walle::Alerter::AlertAllTrackingAgents (\n    size_t caller_id\n) \n</code></pre> <p>Uses UpdateState to focus all trackers onto their goal_pos regardless of the distance away </p> <p>Parameters:</p> <ul> <li><code>caller_id</code> the original id of the agent that came into range of its goal_pos; does not need to be updated </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-alerter-13","title":"function Alerter [1/3]","text":"<pre><code>walle::Alerter::Alerter () = delete\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-alerter-23","title":"function Alerter [2/3]","text":"<pre><code>explicit walle::Alerter::Alerter (\n    cse491::WorldBase * world_ptr\n) \n</code></pre> <p>Alerter constructor (only knows its world and has no agents in its network) </p> <p>Parameters:</p> <ul> <li><code>world_ptr</code> the world this alerter is associated with </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-alerter-33","title":"function Alerter [3/3]","text":"<pre><code>walle::Alerter::Alerter (\n    cse491::WorldBase * world_ptr,\n    size_t id\n) \n</code></pre> <p>Alerter constructor (adds the TrackingAgent with that id to the alerter network) </p> <p>Parameters:</p> <ul> <li><code>id</code> id of agent to be added </li> <li><code>world_ptr</code> the world this alerter is associated with </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-getnetworkset","title":"function GetNetworkSet","text":"<pre><code>inline std::unordered_set&lt; size_t &gt; const &amp; walle::Alerter::GetNetworkSet () const\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-removeagent","title":"function RemoveAgent","text":"<pre><code>void walle::Alerter::RemoveAgent (\n    size_t id\n) \n</code></pre> <p>Removes a TrackingAgent to the network </p> <p>Parameters:</p> <ul> <li><code>id</code> id of agent to be removed </li> </ul> <p>Note:</p> <p>no assertions here since we may want to allow the TrackingAgent to join another network later if it's not being destructed </p> <p>The documentation for this class was generated from the following file <code>source/Agents/TrackingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/","title":"Struct walle::BaseAgentData","text":"<p>ClassList &gt; walle &gt; BaseAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: walle::AStarAgentData,  walle::PacingAgentData,  walle::PathAgentData,  walle::TrackingAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for AgentBase </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#variable-name","title":"variable name","text":"<pre><code>std::string name;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#variable-position","title":"variable position","text":"<pre><code>cse491::GridPosition position;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#variable-symbol","title":"variable symbol","text":"<pre><code>char symbol;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/","title":"Struct walle::CompareNodes","text":"<p>ClassList &gt; walle &gt; CompareNodes</p> <p>Custom comparison function for priority queue. More...</p> <ul> <li><code>#include &lt;AgentLibary.hpp&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/#public-functions","title":"Public Functions","text":"Type Name bool operator() (const std::shared_ptr&lt; walle::Node &gt; &amp; a, const std::shared_ptr&lt; walle::Node &gt; &amp; b) const"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/#detailed-description","title":"Detailed Description","text":"<p>Returns:</p> <p>if a has a greater total cost than b </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/#function-operator","title":"function operator()","text":"<pre><code>inline bool walle::CompareNodes::operator() (\n    const std::shared_ptr&lt; walle::Node &gt; &amp; a,\n    const std::shared_ptr&lt; walle::Node &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentLibary.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/","title":"Struct walle::Node","text":"<p>ClassList &gt; walle &gt; Node</p> <p>Node class to hold information about positions for A* search.</p> <ul> <li><code>#include &lt;AgentLibary.hpp&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#public-attributes","title":"Public Attributes","text":"Type Name double g Cost from start to current node. double h Heuristic (estimated cost from current node to goal) std::shared_ptr&lt; Node &gt; parent How we got to this node (Used to construct final path) cse491::GridPosition position Where node is located."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#public-functions","title":"Public Functions","text":"Type Name Node (const cse491::GridPosition &amp; position, double g, double h, std::shared_ptr&lt; Node &gt; parent)  double f () constCalculate the total cost (f) of the node."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#variable-g","title":"variable g","text":"<pre><code>double g;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#variable-h","title":"variable h","text":"<pre><code>double h;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#variable-parent","title":"variable parent","text":"<pre><code>std::shared_ptr&lt;Node&gt; parent;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#variable-position","title":"variable position","text":"<pre><code>cse491::GridPosition position;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#function-node","title":"function Node","text":"<pre><code>inline walle::Node::Node (\n    const cse491::GridPosition &amp; position,\n    double g,\n    double h,\n    std::shared_ptr&lt; Node &gt; parent\n) \n</code></pre> <p>Constructor for a node </p> <p>Parameters:</p> <ul> <li><code>position</code> location on grid of this node </li> <li><code>g</code> actual distance to get from start to this node </li> <li><code>h</code> heuristic guess for distance from this node to end location </li> <li><code>parent</code> Used to construct path back at end </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#function-f","title":"function f","text":"<p>Calculate the total cost (f) of the node. </p> <pre><code>inline double walle::Node::f () const\n</code></pre> <p>Returns:</p> <p>sum of actual distance and heuristic distance </p> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentLibary.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/","title":"Struct walle::PacingAgentData","text":"<p>ClassList &gt; walle &gt; PacingAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherits the following classes: walle::BaseAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name bool vertical   = = falseWhether the PacingAgent is moving up and down (vertical) or left and right(!vertical)"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#public-attributes-inherited-from-wallebaseagentdata","title":"Public Attributes inherited from walle::BaseAgentData","text":"<p>See walle::BaseAgentData</p> Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for a PacingAgent </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#variable-vertical","title":"variable vertical","text":"<pre><code>bool vertical;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/","title":"Class walle::PathAgent","text":"<p>ClassList &gt; walle &gt; PathAgent</p> <p>More...</p> <ul> <li><code>#include &lt;PathAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#public-functions","title":"Public Functions","text":"Type Name cse491::GridPosition CalcNextPos () const void DecrementIndex ()  int GetIndex () constGet the index. cse491::GridPosition GetNextPosition () override std::vector&lt; cse491::GridPosition &gt; const &amp; GetPath () constGet the Path. void IncrementIndex ()  bool Initialize () override PathAgent () = delete PathAgent (size_t id, std::string const &amp; name)  PathAgent (size_t id, std::string const &amp; name, std::vector&lt; cse491::GridPosition &gt; offsets)  PathAgent (size_t id, std::string const &amp; name, std::string_view commands)  PathAgent &amp; ResetIndex () Reset the index to 0. size_t SelectAction (cse491::WorldGrid const &amp;, cse491::type_options_t const &amp;, cse491::item_map_t const &amp;, cse491::agent_map_t const &amp;) override PathAgent &amp; SetPath (std::vector&lt; cse491::GridPosition &gt; offsets, size_t start_index=0)  PathAgent &amp; SetPath (std::string_view commands, size_t start_index=0)  virtual cse491::GridPosition UpdateAndGetNextPos (bool increment)  ~PathAgent () override"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name int index_   = = 0Current index into offsets_. std::vector&lt; cse491::GridPosition &gt; offsets_"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#detailed-description","title":"Detailed Description","text":"<p>Agent that has a user-defined custom movement pattern Passed a sequence of to be sequentially applied as the agent is updated </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-calcnextpos","title":"function CalcNextPos","text":"<pre><code>cse491::GridPosition walle::PathAgent::CalcNextPos () const\n</code></pre> <p>Retrieves the position of the agent after applying the current offset </p> <p>Returns:</p> <p>next position of the agent </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-decrementindex","title":"function DecrementIndex","text":"<pre><code>void walle::PathAgent::DecrementIndex () \n</code></pre> <p>Decrements the index into the offsets sequence </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-getindex","title":"function GetIndex","text":"<p>Get the index. </p> <pre><code>int walle::PathAgent::GetIndex () const\n</code></pre> <p>Returns:</p> <p>int index</p> <p>Retrieves which step the agent is on </p> <p>Returns:</p> <p>the current index into the offsets </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-getnextposition","title":"function GetNextPosition","text":"<pre><code>cse491::GridPosition walle::PathAgent::GetNextPosition () override\n</code></pre> <p>Overrides AgentBase GetNextPosition to retrieve the calculated next position </p> <p>Returns:</p> <p>next position to move the path agent in </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-getpath","title":"function GetPath","text":"<p>Get the Path. </p> <pre><code>std::vector&lt; cse491::GridPosition &gt; const &amp; walle::PathAgent::GetPath () const\n</code></pre> <p>Returns:</p> <p>vector of GridPositions</p> <p>Returns an immutable reference to this agent's current path </p> <p>Returns:</p> <p>sequence of offsets </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-incrementindex","title":"function IncrementIndex","text":"<pre><code>void walle::PathAgent::IncrementIndex () \n</code></pre> <p>Increments the index into the offsets sequence </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-initialize","title":"function Initialize","text":"<pre><code>bool walle::PathAgent::Initialize () override\n</code></pre> <p>Checks that the agent is able to move arbitrarily Verifies that it can currently index into a valid offset </p> <p>Returns:</p> <p>true if so; false otherwise </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent-14","title":"function PathAgent [1/4]","text":"<pre><code>walle::PathAgent::PathAgent () = delete\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent-24","title":"function PathAgent [2/4]","text":"<pre><code>walle::PathAgent::PathAgent (\n    size_t id,\n    std::string const &amp; name\n) \n</code></pre> <p>Constructor (agent default) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> </ul> <p>Note:</p> <p>When this constructor is called, the agent must still be assigned a path before a call to Initialize </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent-34","title":"function PathAgent [3/4]","text":"<pre><code>walle::PathAgent::PathAgent (\n    size_t id,\n    std::string const &amp; name,\n    std::vector&lt; cse491::GridPosition &gt; offsets\n) \n</code></pre> <p>Constructor (vector) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> <li><code>offsets</code> collection of offsets to move the agent </li> </ul> <p>Attention:</p> <p>The sequence of offsets must not be empty </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent-44","title":"function PathAgent [4/4]","text":"<pre><code>walle::PathAgent::PathAgent (\n    size_t id,\n    std::string const &amp; name,\n    std::string_view commands\n) \n</code></pre> <p>Constructor (string) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> <li><code>commands</code> sequence of commands to be interpreted as offsets </li> </ul> <p>Attention:</p> <p>The sequence of offsets must not be empty </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-resetindex","title":"function ResetIndex","text":"<p>Reset the index to 0. </p> <pre><code>inline PathAgent &amp; walle::PathAgent::ResetIndex () \n</code></pre> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>size_t walle::PathAgent::SelectAction (\n    cse491::WorldGrid const &amp;,\n    cse491::type_options_t const &amp;,\n    cse491::item_map_t const &amp;,\n    cse491::agent_map_t const &amp;\n) override\n</code></pre> <p>Tells world to </p> <p>Returns:</p> <p>whether the update succeeded </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-setpath-12","title":"function SetPath [1/2]","text":"<pre><code>PathAgent &amp; walle::PathAgent::SetPath (\n    std::vector&lt; cse491::GridPosition &gt; offsets,\n    size_t start_index=0\n) \n</code></pre> <p>Assigns the offsets_member to a new series of offsets </p> <p>Parameters:</p> <ul> <li><code>offsets</code> collection of grid positions used as the new offsets </li> <li><code>start_index</code> which offset to start indexing into (beginning by default) </li> </ul> <p>Returns:</p> <p>self </p> <p>Attention:</p> <p>throws an <code>std::invalid_argument</code> when an invalid start index is provided </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-setpath-22","title":"function SetPath [2/2]","text":"<pre><code>PathAgent &amp; walle::PathAgent::SetPath (\n    std::string_view commands,\n    size_t start_index=0\n) \n</code></pre> <p>Assigns the offsets_ member to a new series of offsets, taking a command string </p> <p>Parameters:</p> <ul> <li><code>commands</code> formatted string of commands used as offsets </li> <li><code>start_index</code> which command to begin indexing into (first command by default) </li> </ul> <p>Returns:</p> <p>self </p> <p>Attention:</p> <p>throws an <code>std::invalid_argument</code> when mis-formatted commands an invalid index is provided </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-updateandgetnextpos","title":"function UpdateAndGetNextPos","text":"<pre><code>virtual cse491::GridPosition walle::PathAgent::UpdateAndGetNextPos (\n    bool increment\n) \n</code></pre> <p>Convenience method Applies the current offset to calculate the next position and then adjusts the index </p> <p>Parameters:</p> <ul> <li><code>increment</code> decides whether to move in the forward or backward direction to allow for complex pathing </li> </ul> <p>Returns:</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent","title":"function ~PathAgent","text":"<pre><code>walle::PathAgent::~PathAgent () override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#variable-index_","title":"variable index_","text":"<pre><code>int index_;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#variable-offsets_","title":"variable offsets_","text":"<pre><code>std::vector&lt;cse491::GridPosition&gt; offsets_;\n</code></pre> <p>Collection of ways to offset the Agent's position </p> <p>Attention:</p> <p>This is a not a sequence of direct coordinates on the WorldGrid, but a series of offsets </p> <p>The documentation for this class was generated from the following file <code>source/Agents/PathAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/","title":"Struct walle::PathAgentData","text":"<p>ClassList &gt; walle &gt; PathAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherits the following classes: walle::BaseAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name int index Starting index into the vector of GridPositions. std::string string_path String representation of the path traveled (e.g. \"n s e w\" for north south east west) std::vector&lt; cse491::GridPosition &gt; vector_path Set of grid positions that are applied to the agent's position during one step (constructed from string_path)"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#public-attributes-inherited-from-wallebaseagentdata","title":"Public Attributes inherited from walle::BaseAgentData","text":"<p>See walle::BaseAgentData</p> Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for a PathAgent </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#variable-index","title":"variable index","text":"<pre><code>int index;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#variable-string_path","title":"variable string_path","text":"<pre><code>std::string string_path;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#variable-vector_path","title":"variable vector_path","text":"<pre><code>std::vector&lt;cse491::GridPosition&gt; vector_path;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/","title":"Class walle::RandomAgent","text":"<p>ClassList &gt; walle &gt; RandomAgent</p> <p>More...</p> <ul> <li><code>#include &lt;RandomAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#public-functions","title":"Public Functions","text":"Type Name void CalculateRandom (double multiplier) Function to calculate the random direction. bool GetMoving () constGet the Moving object. double GetRandom () constGet the Random object. bool Initialize () overrideThis agent needs a specific set of actions to function. RandomAgent (size_t id, const std::string &amp; name) Is the agent moving? size_t SelectAction (const cse491::WorldGrid &amp;, const cse491::type_options_t &amp;, const cse491::item_map_t &amp;, const cse491::agent_map_t &amp;) overrideChoose the action to take a step in the random direction. void SetDirection (double direction) Set the Direction object. void SetMoving (bool move) Set the Moving object. ~RandomAgent () = default"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#detailed-description","title":"Detailed Description","text":"<p>Class for the Random Agent </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-calculaterandom","title":"function CalculateRandom","text":"<p>Function to calculate the random direction. </p> <pre><code>inline void walle::RandomAgent::CalculateRandom (\n    double multiplier\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>multiplier</code> double: random multiplier </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-getmoving","title":"function GetMoving","text":"<p>Get the Moving object. </p> <pre><code>inline bool walle::RandomAgent::GetMoving () const\n</code></pre> <p>Returns:</p> <p>true </p> <p>Returns:</p> <p>false </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-getrandom","title":"function GetRandom","text":"<p>Get the Random object. </p> <pre><code>inline double walle::RandomAgent::GetRandom () const\n</code></pre> <p>Returns:</p> <p>double random member variable </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool walle::RandomAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-randomagent","title":"function RandomAgent","text":"<p>Is the agent moving? </p> <pre><code>inline walle::RandomAgent::RandomAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Construct a new Random Agent object </p> <p>Parameters:</p> <ul> <li><code>id</code> id of the agent </li> <li><code>name</code> name of the agent </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t walle::RandomAgent::SelectAction (\n    const cse491::WorldGrid &amp;,\n    const cse491::type_options_t &amp;,\n    const cse491::item_map_t &amp;,\n    const cse491::agent_map_t &amp;\n) override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-setdirection","title":"function SetDirection","text":"<p>Set the Direction object. </p> <pre><code>inline void walle::RandomAgent::SetDirection (\n    double direction\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>direction</code> direction to set </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-setmoving","title":"function SetMoving","text":"<p>Set the Moving object. </p> <pre><code>inline void walle::RandomAgent::SetMoving (\n    bool move\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>move</code> move to set </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-randomagent_1","title":"function ~RandomAgent","text":"<pre><code>walle::RandomAgent::~RandomAgent () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/RandomAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/","title":"Class walle::TrackingAgent","text":"<p>ClassList &gt; walle &gt; TrackingAgent</p> <p>More...</p> <ul> <li><code>#include &lt;TrackingAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#public-functions","title":"Public Functions","text":"Type Name void AddToAlerter (std::shared_ptr&lt; Alerter &gt; alerter)  void CallAlerter (size_t agent_id) Tells the alerter to notify all other tracking agents in network. std::shared_ptr&lt; Alerter &gt; GetAlerter () const cse491::GridPosition GetNextPosition () override std::vector&lt; cse491::GridPosition &gt; const &amp; GetPath () const TrackingState GetState ()  cse491::Entity const * GetTarget () const double GetTrackingDistance () const bool Initialize () override void MakeAlerter () Creates an alerter network and adds this tracking agent to it. void RemoveFromAlerter ()  size_t SelectAction (cse491::WorldGrid const &amp; grid, cse491::type_options_t const &amp; type, cse491::item_map_t const &amp; item_set, cse491::agent_map_t const &amp; agent_set) overrideUpdates the internal state of the TrackingAgent and calls the internal agent's select action method. size_t SelectInnerAction (PathAgent &amp; agent, cse491::WorldGrid const &amp; grid, cse491::type_options_t const &amp; type, cse491::item_map_t const &amp; item_set, cse491::agent_map_t const &amp; agent_set) Select action for PathAgent inner type. size_t SelectInnerAction (AStarAgent &amp; agent, cse491::WorldGrid const &amp; grid, cse491::type_options_t const &amp; type, cse491::item_map_t const &amp; item_set, cse491::agent_map_t const &amp; agent_set) Select action for AStarAgent inner type. TrackingAgent &amp; SetPath (std::vector&lt; cse491::GridPosition &gt; offsets)  TrackingAgent &amp; SetPath (std::string_view offsets)  TrackingAgent &amp; SetStartPosition (cse491::GridPosition pos)  TrackingAgent &amp; SetStartPosition (double x, double y)  TrackingAgent &amp; SetTarget (Entity * agent)  TrackingAgent &amp; SetTrackingDistance (double dist)  TrackingAgent &amp; SetWorld (cse491::WorldBase &amp; in_world) override TrackingAgent () = delete TrackingAgent (size_t id, std::string const &amp; name)  TrackingAgent (size_t id, std::string const &amp; name, std::vector&lt; cse491::GridPosition &gt; &amp;&amp; offsets, std::shared_ptr&lt; Alerter &gt; &amp;&amp; alerter=nullptr)  TrackingAgent (size_t id, std::string const &amp; name, std::string_view commands, std::shared_ptr&lt; Alerter &gt; &amp;&amp; alerter=nullptr)  void UpdateState (bool alerting=true)  ~TrackingAgent () override"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#detailed-description","title":"Detailed Description","text":"<p>Agent that switches between user-defined custom movement pattern and tracking a given agent </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-addtoalerter","title":"function AddToAlerter","text":"<pre><code>inline void walle::TrackingAgent::AddToAlerter (\n    std::shared_ptr&lt; Alerter &gt; alerter\n) \n</code></pre> <p>Adds this tracking agent to an already-existing alerter network </p> <p>Parameters:</p> <ul> <li><code>alerter</code> alerter that this agent should be associated with </li> </ul> <p>Note:</p> <p>alerter must not be null </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-callalerter","title":"function CallAlerter","text":"<pre><code>inline void walle::TrackingAgent::CallAlerter (\n    size_t agent_id\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-getalerter","title":"function GetAlerter","text":"<pre><code>inline std::shared_ptr&lt; Alerter &gt; walle::TrackingAgent::GetAlerter () const\n</code></pre> <p>Used to expand the alerter network by adding other tracking agents to it </p> <p>Returns:</p> <p>a copy of this tracking agent's alerter </p> <p>Note:</p> <p>it's expected that this function is used when calling AddToAlerter on a different tracking agent </p> <p>Note:</p> <p>may be null </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-getnextposition","title":"function GetNextPosition","text":"<pre><code>inline cse491::GridPosition walle::TrackingAgent::GetNextPosition () override\n</code></pre> <p>Overrides the AgentBase getter to retrieve the next calculated position </p> <p>Returns:</p> <p>inner PathAgent's next position </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-getpath","title":"function GetPath","text":"<pre><code>inline std::vector&lt; cse491::GridPosition &gt; const &amp; walle::TrackingAgent::GetPath () const\n</code></pre> <p>Returns an immutable reference to this agent's current path </p> <p>Returns:</p> <p>sequence of offsets </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-getstate","title":"function GetState","text":"<pre><code>inline TrackingState walle::TrackingAgent::GetState () \n</code></pre> <p>Retrieves the current internal state of the Tracking Agent </p> <p>Returns:</p> <p>current state </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-gettarget","title":"function GetTarget","text":"<pre><code>inline cse491::Entity const * walle::TrackingAgent::GetTarget () const\n</code></pre> <p>Returns an immutable pointer to this agent's target </p> <p>Returns:</p> <p>ptr to entity </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-gettrackingdistance","title":"function GetTrackingDistance","text":"<pre><code>inline double walle::TrackingAgent::GetTrackingDistance () const\n</code></pre> <p>Get the distance around this tracker that it surveys </p> <p>Returns:</p> <p>tracking distance </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-initialize","title":"function Initialize","text":"<pre><code>inline bool walle::TrackingAgent::Initialize () override\n</code></pre> <p>Ensure that the TrackingAgent's internal PathAgent is correctly initialized Verifies that it can currently index into a valid offset </p> <p>Returns:</p> <p>true if so; false otherwise </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-makealerter","title":"function MakeAlerter","text":"<pre><code>inline void walle::TrackingAgent::MakeAlerter () \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-removefromalerter","title":"function RemoveFromAlerter","text":"<pre><code>inline void walle::TrackingAgent::RemoveFromAlerter () \n</code></pre> <p>Removes this tracking agent from it's own tracking network </p> <p>Note:</p> <p>called from the TrackingAgent destructor </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t walle::TrackingAgent::SelectAction (\n    cse491::WorldGrid const &amp; grid,\n    cse491::type_options_t const &amp; type,\n    cse491::item_map_t const &amp; item_set,\n    cse491::agent_map_t const &amp; agent_set\n) override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-selectinneraction-12","title":"function SelectInnerAction [1/2]","text":"<pre><code>inline size_t walle::TrackingAgent::SelectInnerAction (\n    PathAgent &amp; agent,\n    cse491::WorldGrid const &amp; grid,\n    cse491::type_options_t const &amp; type,\n    cse491::item_map_t const &amp; item_set,\n    cse491::agent_map_t const &amp; agent_set\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-selectinneraction-22","title":"function SelectInnerAction [2/2]","text":"<pre><code>inline size_t walle::TrackingAgent::SelectInnerAction (\n    AStarAgent &amp; agent,\n    cse491::WorldGrid const &amp; grid,\n    cse491::type_options_t const &amp; type,\n    cse491::item_map_t const &amp; item_set,\n    cse491::agent_map_t const &amp; agent_set\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setpath-12","title":"function SetPath [1/2]","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetPath (\n    std::vector&lt; cse491::GridPosition &gt; offsets\n) \n</code></pre> <p>Sets the patrolling path of the TrackingAgent </p> <p>Parameters:</p> <ul> <li><code>offsets</code> grid position offsets creating the path </li> </ul> <p>Returns:</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setpath-22","title":"function SetPath [2/2]","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetPath (\n    std::string_view offsets\n) \n</code></pre> <p>Sets the patrolling path of the TrackingAgent </p> <p>Parameters:</p> <ul> <li><code>offsets</code> grid position offsets creating the path </li> </ul> <p>Returns:</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setstartposition-12","title":"function SetStartPosition [1/2]","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetStartPosition (\n    cse491::GridPosition pos\n) \n</code></pre> <p>Set where this agent \"patrol area\" starts </p> <p>Parameters:</p> <ul> <li><code>gp</code> grid position of position </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setstartposition-22","title":"function SetStartPosition [2/2]","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetStartPosition (\n    double x,\n    double y\n) \n</code></pre> <p>Set where this agent \"patrol area\" starts </p> <p>Parameters:</p> <ul> <li><code>x</code> x-coordinate of start pos </li> <li><code>y</code> y-coordinate of start pos </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-settarget","title":"function SetTarget","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetTarget (\n    Entity * agent\n) \n</code></pre> <p>Set which agent we are following </p> <p>Parameters:</p> <ul> <li><code>agent</code> we want to track </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-settrackingdistance","title":"function SetTrackingDistance","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetTrackingDistance (\n    double dist\n) \n</code></pre> <p>Set how close goal_pos has to be to start tracking </p> <p>Parameters:</p> <ul> <li><code>dist</code> to start tracking at </li> </ul> <p>Returns:</p> <p>calling object </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setworld","title":"function SetWorld","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetWorld (\n    cse491::WorldBase &amp; in_world\n) override\n</code></pre> <p>Set both the world for the current agent and the agents it is a part of </p> <p>Parameters:</p> <ul> <li><code>in_world</code> new world to associate the agent with </li> </ul> <p>Returns:</p> <p>calling agent </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent-14","title":"function TrackingAgent [1/4]","text":"<pre><code>walle::TrackingAgent::TrackingAgent () = delete\n</code></pre> <p>Delete default constructor </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent-24","title":"function TrackingAgent [2/4]","text":"<pre><code>inline walle::TrackingAgent::TrackingAgent (\n    size_t id,\n    std::string const &amp; name\n) \n</code></pre> <p>Constructor (default) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent-34","title":"function TrackingAgent [3/4]","text":"<pre><code>inline walle::TrackingAgent::TrackingAgent (\n    size_t id,\n    std::string const &amp; name,\n    std::vector&lt; cse491::GridPosition &gt; &amp;&amp; offsets,\n    std::shared_ptr&lt; Alerter &gt; &amp;&amp; alerter=nullptr\n) \n</code></pre> <p>Constructor (vector) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> <li><code>offsets</code> collection of offsets to move the agent </li> <li><code>alerter</code> alerter network to add agent to </li> </ul> <p>Attention:</p> <p>The sequence of offsets must not be empty </p> <p>Attention:</p> <p>alerter should be a nullptr if this tracker is not part of any group of tracking agents </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent-44","title":"function TrackingAgent [4/4]","text":"<pre><code>inline walle::TrackingAgent::TrackingAgent (\n    size_t id,\n    std::string const &amp; name,\n    std::string_view commands,\n    std::shared_ptr&lt; Alerter &gt; &amp;&amp; alerter=nullptr\n) \n</code></pre> <p>Constructor (string view) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> <li><code>commands</code> sequence of commands to be interpreted as offsets </li> <li><code>alerter</code> alerter network to add agent to </li> </ul> <p>Attention:</p> <p>The sequence of offsets must not be empty </p> <p>Attention:</p> <p>alerter should be a nullptr if this tracker is not part of any group of tracking agents </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-updatestate","title":"function UpdateState","text":"<pre><code>inline void walle::TrackingAgent::UpdateState (\n    bool alerting=true\n) \n</code></pre> <p>Handles focusing the agent onto a goal_pos, returning it to its original location, and patrolling </p> <p>Parameters:</p> <ul> <li><code>alerting</code> determines whether this agent should alert all other TrackingAgents in its network when its goal_pos comes into range </li> </ul> <p>Note:</p> <p>the inner variant type will be AStarAgent when tracking OR returning to a location, but PathAgent when patrolling </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent","title":"function ~TrackingAgent","text":"<pre><code>inline walle::TrackingAgent::~TrackingAgent () override\n</code></pre> <p>Destructor </p> <p>The documentation for this class was generated from the following file <code>source/Agents/TrackingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/","title":"Struct walle::TrackingAgentData","text":"<p>ClassList &gt; walle &gt; TrackingAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherits the following classes: walle::BaseAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name std::shared_ptr&lt; Alerter &gt; alerter   = = nullptr cse491::GridPosition start_pos Where the TrackingAgent begins from patrolling from and returns two after the target moves out of range. std::string string_path String representation of the path traveled (e.g. \"n s e w\" for north south east west) like in PathAgent . cse491::Entity * target Goal Entity being tracked (must not be null or else the agent simply behaves like a PathAgent ) int tracking_distance   = = 5Distance that the TrackingAgent can \"see\" such that when the target enters that range, it begins tracking. std::vector&lt; cse491::GridPosition &gt; vector_path Set of grid positions that are applied to the agent's position during one step (constructed from string_path) like in PathAgent ."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-attributes-inherited-from-wallebaseagentdata","title":"Public Attributes inherited from walle::BaseAgentData","text":"<p>See walle::BaseAgentData</p> Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-functions","title":"Public Functions","text":"Type Name TrackingAgentData () = defaultUse initial values. TrackingAgentData (std::string name, cse491::GridPosition curr_pos, char symbol, std::string path, cse491::Entity * target, int tracking_dist, cse491::GridPosition start_pos, std::shared_ptr&lt; Alerter &gt; alerter) Set all values."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for a TrackingAgent </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-alerter","title":"variable alerter","text":"<pre><code>std::shared_ptr&lt;Alerter&gt; alerter;\n</code></pre> <p>Shared reference to an Alerter, which is non-null if the agent should be able to tell other agents to immediately focus on their targets </p> <p>Remark:</p> <p>You should be using the same shared pointer across multiple instances of TrackingAgentData in order to make the TrackingAgents part of the same network. This means you need to copy around this shared pointer when using the factory </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-start_pos","title":"variable start_pos","text":"<pre><code>cse491::GridPosition start_pos;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-string_path","title":"variable string_path","text":"<pre><code>std::string string_path;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-target","title":"variable target","text":"<pre><code>cse491::Entity* target;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-tracking_distance","title":"variable tracking_distance","text":"<pre><code>int tracking_distance;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-vector_path","title":"variable vector_path","text":"<pre><code>std::vector&lt;cse491::GridPosition&gt; vector_path;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#function-trackingagentdata-12","title":"function TrackingAgentData [1/2]","text":"<pre><code>walle::TrackingAgentData::TrackingAgentData () = default\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#function-trackingagentdata-22","title":"function TrackingAgentData [2/2]","text":"<pre><code>inline walle::TrackingAgentData::TrackingAgentData (\n    std::string name,\n    cse491::GridPosition curr_pos,\n    char symbol,\n    std::string path,\n    cse491::Entity * target,\n    int tracking_dist,\n    cse491::GridPosition start_pos,\n    std::shared_ptr&lt; Alerter &gt; alerter\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Agent%20Library%28Group%201%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Agents <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Agent%20Library%28Group%201%29/dir_425e53e3c77c59c8573ea1fd0ff9622a/","title":"Dir source/Agents","text":"<p>FileList &gt; Agents</p>"},{"location":"Agent%20Library%28Group%201%29/dir_425e53e3c77c59c8573ea1fd0ff9622a/#files","title":"Files","text":"Type Name file AStarAgent.hpp AStar Agent Class. file AgentFactory.hpp A factory class that abstracts away the initialization of adding an agent to a world. file AgentLibary.hpp file PacingAgent.hpp file PathAgent.cpp Path Agent Class. file PathAgent.hpp file RandomAgent.hpp An Agent that will move around using random actions. file TrackingAgent.hpp Agent that switches between user-defined custom movement pattern and tracking a given agent. <p>The documentation for this class was generated from the following file <code>source/Agents/</code></p>"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp/","title":"File AStarAgent.hpp","text":"<p>FileList &gt; Agents &gt; AStarAgent.hpp</p> <p>Go to the source code of this file</p> <p>AStar Agent Class. More...</p> <ul> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"AgentLibary.hpp\"</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp/#classes","title":"Classes","text":"Type Name class AStarAgent"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>Matt Kight </p> <p>The documentation for this class was generated from the following file <code>source/Agents/AStarAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp_source/","title":"File AStarAgent.hpp","text":"<p>File List &gt; Agents &gt; AStarAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../core/AgentBase.hpp\"\n#include \"AgentLibary.hpp\"\n#include &lt;vector&gt;\n\nnamespace walle {\n\n    class AStarAgent : public cse491::AgentBase {\n    private:\n        std::vector&lt;cse491::GridPosition&gt; path; \n        cse491::GridPosition goal_position;     \n        int recalculate_after_x_turns = 100; \n        int current_move_num = 0;            \n\n    public:\n        AStarAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {}\n\n        ~AStarAgent() = default;\n\n        bool Initialize() override {\n            return HasAction(\"up\") &amp;&amp; HasAction(\"down\") &amp;&amp; HasAction(\"left\") &amp;&amp;\n                HasAction(\"right\");\n        }\n\n        void SetGoalPosition(const double x, const double y) {\n            goal_position = cse491::GridPosition(x, y);\n        }\n\n        void SetGoalPosition(const cse491::GridPosition gp) {\n            goal_position = gp;\n        }\n\n        cse491::GridPosition GetGoalPosition() const {return goal_position; }\n\n        int GetRecalculateValue() const {return recalculate_after_x_turns; }\n\n        int GetPathLength() const {return path.size(); }\n\n\n        void SetRecalculate(const int recalculate) {\n            recalculate_after_x_turns = recalculate;\n        }\n\n        void RecalculatePath() {\n            path = GetShortestPath(GetPosition(), goal_position, GetWorld(), *this);\n            if (!path.empty()){path.pop_back();} // Remove the val that we are currently at\n            current_move_num = 0;\n        }\n\n        [[nodiscard]] cse491::GridPosition GetNextPosition() override {\n            return !path.empty() ? path.back() : GetPosition();\n        }\n\n        size_t SelectAction(const cse491::WorldGrid &amp; /*grid*/,\n                            const cse491::type_options_t &amp; /* type_options*/,\n                            const cse491::item_map_t &amp; /* item_map*/,\n                            const cse491::agent_map_t &amp; /* agent_map*/) override {\n            // We are taking an action so another turn has passed\n            ++current_move_num;\n            // If the last step failed, or we need a new path the then regenerate the\n            // path\n            if (action_result == 0 || path.empty() ||\n                current_move_num &gt; recalculate_after_x_turns) {\n            RecalculatePath();\n            }\n            // Return whatever action gets us closer to our goal\n            if (!path.empty()) {\n            auto pos = path.back();\n            path.pop_back();\n            if (pos == position.Above())\n                return action_map[\"up\"];\n            if (pos == position.Below())\n                return action_map[\"down\"];\n            if (pos == position.ToLeft())\n                return action_map[\"left\"];\n            if (pos == position.ToRight())\n                return action_map[\"right\"];\n            }\n            return 0; // If no path then do not do anything\n        }\n    };\n}; // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp/","title":"File AgentFactory.hpp","text":"<p>FileList &gt; Agents &gt; AgentFactory.hpp</p> <p>Go to the source code of this file</p> <p>A factory class that abstracts away the initialization of adding an agent to a world. More...</p> <ul> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"AStarAgent.hpp\"</code></li> <li><code>#include \"PacingAgent.hpp\"</code></li> <li><code>#include \"PathAgent.hpp\"</code></li> <li><code>#include \"TrackingAgent.hpp\"</code></li> <li><code>#include \"AgentLibary.hpp\"</code></li> <li><code>#include \"../core/Entity.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp/#classes","title":"Classes","text":"Type Name struct AStarAgentData class AgentFactory struct BaseAgentData struct PacingAgentData struct PathAgentData struct TrackingAgentData"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>Matt Kight </p> <p>Author:</p> <p>David Rackerby </p> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp_source/","title":"File AgentFactory.hpp","text":"<p>File List &gt; Agents &gt; AgentFactory.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../core/AgentBase.hpp\"\n#include \"AStarAgent.hpp\"\n#include \"PacingAgent.hpp\"\n#include \"PathAgent.hpp\"\n#include \"TrackingAgent.hpp\"\n#include \"AgentLibary.hpp\"\n\n#include \"../core/Entity.hpp\"\n#include \"../core/WorldBase.hpp\"\n\nnamespace walle {\n\n// Forward-declare since it's easier to understand how AddXAgent works \n// when the structs are defined nearby\nstruct PacingAgentData;\nstruct PathAgentData;\nstruct AStarAgentData;\nstruct TrackingAgentData;\n\nclass AgentFactory {\nprivate:\n    cse491::WorldBase &amp;world;   \n\npublic:\n    AgentFactory() = delete;\n\n    explicit AgentFactory(cse491::WorldBase &amp;world) : world(world) {}\n\n    AStarAgent &amp;AddAStarAgent(const AStarAgentData &amp;agent_data);\n    cse491::PacingAgent &amp;AddPacingAgent(const PacingAgentData &amp;agent_data);\n    TrackingAgent &amp;AddTrackingAgent(const TrackingAgentData &amp;agent_data);\n    PathAgent &amp;AddPathAgent(const PathAgentData &amp;agent_data);\n\n}; // class AgentFactory\n\nstruct BaseAgentData {\n    std::string name;\n\n    cse491::GridPosition position;\n\n    char symbol = '*';\n};\n\nstruct PacingAgentData : public BaseAgentData {\n    bool vertical = false;\n};\n\ncse491::PacingAgent &amp;AgentFactory::AddPacingAgent(const PacingAgentData &amp;agent_data) {\n    auto &amp;entity = world.AddAgent&lt;cse491::PacingAgent&gt;(agent_data.name).SetPosition(agent_data.position).SetProperty(\n        \"symbol\",\n        agent_data.symbol);\n    auto &amp;agent = DownCastAgent&lt;cse491::PacingAgent&gt;(entity);\n    agent.SetVertical(agent_data.vertical);\n    return agent;\n}\n\nstruct PathAgentData : public BaseAgentData {\n    int index;\n\n    std::string string_path;\n\n    std::vector&lt;cse491::GridPosition&gt; vector_path;\n};\n\nPathAgent &amp;AgentFactory::AddPathAgent(const PathAgentData &amp;agent_data) {\n    auto &amp;entity = world.AddAgent&lt;walle::PathAgent&gt;(agent_data.name).SetPosition(agent_data.position).SetProperty(\n        \"symbol\",\n        agent_data.symbol);\n    auto &amp;agent = DownCastAgent&lt;walle::PathAgent&gt;(entity);\n    if (!agent_data.string_path.empty()) {\n        agent.SetProperty&lt;std::basic_string_view&lt;char&gt;&gt;(\"path\",\n                                                    agent_data.string_path); // TODO add another option to provide grid point\n    } else {\n        agent.SetPath(agent_data.vector_path);\n    }\n    agent.Initialize();\n    return agent;\n}\n\nstruct AStarAgentData : public BaseAgentData {\n    int recalculate_after_x_turns = 5;\n\n    cse491::GridPosition goal_pos;\n};\n\nAStarAgent &amp;AgentFactory::AddAStarAgent(const AStarAgentData &amp;agent_data) {\n    auto &amp;entity = world.AddAgent&lt;walle::AStarAgent&gt;(agent_data.name).SetPosition(agent_data.position).SetProperty(\n        \"symbol\",\n        agent_data.symbol);\n    auto &amp;agent = DownCastAgent&lt;walle::AStarAgent&gt;(entity);\n    agent.SetGoalPosition(agent_data.goal_pos);\n    agent.SetRecalculate(agent_data.recalculate_after_x_turns);\n    return agent;\n}\n\nstruct TrackingAgentData : public BaseAgentData {\n    std::vector&lt;cse491::GridPosition&gt; vector_path;\n\n    std::string string_path;\n\n    cse491::Entity *target;\n\n    int tracking_distance = 5;\n\n    cse491::GridPosition start_pos;\n\n    std::shared_ptr&lt;Alerter&gt; alerter = nullptr;\n\n    TrackingAgentData() = default;\n\n    TrackingAgentData(std::string name,\n                    cse491::GridPosition curr_pos,\n                    char symbol,\n                    std::string path,\n                    cse491::Entity * target,\n                    int tracking_dist,\n                    cse491::GridPosition start_pos,\n                    std::shared_ptr&lt;Alerter&gt; alerter)\n        : BaseAgentData({std::move(name), curr_pos, symbol}),\n        vector_path(StrToOffsets(path)),\n        string_path(std::move(path)),\n        target(target),\n        tracking_distance(tracking_dist),\n        start_pos(start_pos),\n        alerter(alerter) {}\n};\n\nTrackingAgent &amp;AgentFactory::AddTrackingAgent(const TrackingAgentData &amp;agent_data) {\n    auto &amp;entity = world.AddAgent&lt;walle::TrackingAgent&gt;(agent_data.name).SetPosition(agent_data.position).SetProperty(\n        \"symbol\",\n        agent_data.symbol);\n    auto &amp;agent = DownCastAgent&lt;TrackingAgent&gt;(entity);\n    if (!agent_data.string_path.empty()) {\n        agent.SetProperty&lt;std::basic_string_view&lt;char&gt;&gt;(\"path\", agent_data.string_path);\n    } else {\n        agent.SetPath(agent_data.vector_path);\n    }\n    agent.SetTarget(agent_data.target);\n    agent.SetTrackingDistance(agent_data.tracking_distance);\n    agent.SetStartPosition(agent_data.start_pos);\n    if (agent_data.alerter != nullptr) {\n        agent.SetProperty(\"alerter\", agent_data.alerter);\n    }\n    agent.Initialize();\n    return agent;\n}\n\n} // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_agent_libary_8hpp/","title":"File AgentLibary.hpp","text":"<p>FileList &gt; Agents &gt; AgentLibary.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_agent_libary_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_agent_libary_8hpp/#classes","title":"Classes","text":"Type Name struct CompareNodes Custom comparison function for priority queue. struct Node Node class to hold information about positions for A* search. <p>The documentation for this class was generated from the following file <code>source/Agents/AgentLibary.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_agent_libary_8hpp_source/","title":"File AgentLibary.hpp","text":"<p>File List &gt; Agents &gt; AgentLibary.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;regex&gt;\n#include &lt;sstream&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\n#include \"../core/AgentBase.hpp\"\n#include \"../core/WorldBase.hpp\"\n\nnamespace walle {\n\n    struct Node {\n        cse491::GridPosition position; \n        double g;                      \n        double h; \n        std::shared_ptr&lt;Node&gt;\n            parent; \n\n        Node(const cse491::GridPosition &amp;position, double g, double h,\n            std::shared_ptr&lt;Node&gt; parent)\n            : position(position), g(g), h(h), parent(std::move(parent)) {}\n\n        [[nodiscard]] double f() const { return g + h; }\n    };\n\n    struct CompareNodes {\n        bool operator()(const std::shared_ptr&lt;walle::Node&gt; &amp;a,\n                        const std::shared_ptr&lt;walle::Node&gt; &amp;b) const {\n            return a-&gt;f() &gt; b-&gt;f();\n        }\n    };\n\n    inline std::vector&lt;cse491::GridPosition&gt;\n    GetShortestPath(const cse491::GridPosition &amp;start,\n                    const cse491::GridPosition &amp;end, const cse491::WorldBase &amp;world,\n                    const cse491::AgentBase &amp;agent) {\n    // Generated with the help of chat.openai.com\n    const size_t rows = world.GetGrid().GetWidth();\n    const size_t cols = world.GetGrid().GetHeight();\n    std::vector&lt;cse491::GridPosition&gt; path;\n    // If the start or end is not valid then return empty list\n    if (!(world.GetGrid().IsValid(start) &amp;&amp; world.GetGrid().IsValid(end)))\n        return path;\n\n    // Define possible movements (up, down, left, right)\n    const int dx[] = {-1, 1, 0, 0};\n    const int dy[] = {0, 0, -1, 1};\n\n    // Create a 2D vector to store the cost to reach each cell\n    std::vector&lt;std::vector&lt;double&gt;&gt; cost(rows,\n                                            std::vector&lt;double&gt;(cols, INT_MAX));\n\n    // Create an open list as a priority queue\n    std::priority_queue&lt;std::shared_ptr&lt;walle::Node&gt;,\n                        std::vector&lt;std::shared_ptr&lt;walle::Node&gt;&gt;,\n                        walle::CompareNodes&gt;\n        openList;\n\n    // Create the start and end nodes\n    auto startNode = std::make_shared&lt;walle::Node&gt;(start, 0, 0, nullptr);\n    auto endNode = std::make_shared&lt;walle::Node&gt;(end, 0, 0, nullptr);\n\n    openList.push(startNode);\n    cost[start.CellX()][start.CellY()] = 0;\n\n    while (!openList.empty()) {\n        auto current = openList.top();\n        openList.pop();\n\n        if (current-&gt;position == endNode-&gt;position) {\n\n        // Reached the goal, reconstruct the path\n        while (current != nullptr) {\n            path.push_back(current-&gt;position);\n            current = current-&gt;parent;\n        }\n        break;\n        }\n\n        // Explore the neighbors\n        for (int i = 0; i &lt; 4; ++i) {\n            cse491::GridPosition newPos(current-&gt;position.GetX() + dx[i],\n                                        current-&gt;position.GetY() + dy[i]);\n            // Check if the neighbor is within bounds and is a valid move\n            if (world.GetGrid().IsValid(newPos) &amp;&amp;\n                world.IsTraversable(agent, newPos)) {\n                double newG =\n                    current-&gt;g + 1; // Assuming a cost of 1 to move to a neighbor\n                double newH = std::abs(newPos.GetX() - endNode-&gt;position.GetX()) +\n                    std::abs(newPos.GetY() -\n                        endNode-&gt;position.GetY()); // Manhattan distance\n\n                if (newG + newH &lt; cost[newPos.CellX()][newPos.CellY()]) {\n                    auto neighbor =\n                        std::make_shared&lt;walle::Node&gt;(newPos, newG, newH, current);\n                    openList.push(neighbor);\n                    cost[newPos.CellX()][newPos.CellY()] = newG + newH;\n                }\n            }\n        }\n    }\n    return path;\n    }\n\n    inline std::vector&lt;cse491::GridPosition&gt;\n    StrToOffsets(std::string_view commands) {\n        std::vector&lt;cse491::GridPosition&gt; positions;\n\n        // Regex capturing groups logically mean the following:\n        // Group 0: whole regex\n        // Group 1: `steps` and `*` pair (optional)(unused)\n        // Group 2: `steps` (optional)\n        // Group 3: `*` (optional, only matches when Group 2 matches)\n        // Group 4: direction\n        std::regex pattern(\"(([1-9]\\\\d*)(\\\\*?))?([nswex])\");\n        std::istringstream iss{std::string(commands)};\n        iss &gt;&gt; std::skipws;\n\n        std::string single_command;\n        while (iss &gt;&gt; single_command) {\n            std::smatch pattern_match;\n            if (std::regex_match(single_command, pattern_match, pattern)) {\n                int steps = 1;\n\n                if (pattern_match[2].length() &gt; 0) {\n                    std::istringstream step_val(pattern_match[1].str());\n                    step_val &gt;&gt; steps;\n                }\n\n                bool multiply = pattern_match[3].length() &gt; 0;\n\n                char direction = pattern_match[4].str()[0];\n\n                cse491::GridPosition base_pos;\n                switch (direction) {\n                    // Move up\n                    case 'n': {\n                        if (multiply) {\n                            positions.push_back(base_pos.Above(steps));\n                        } else {\n                            for (int i = 0; i &lt; steps; ++i) {\n                                positions.push_back(base_pos.Above());\n                            }\n                        }\n                        break;\n                    }\n\n                    // Move down\n                    case 's': {\n                        if (multiply) {\n                            positions.push_back(base_pos.Below(steps));\n                        } else {\n                            for (int i = 0; i &lt; steps; ++i) {\n                                positions.push_back(base_pos.Below());\n                            }\n                        }\n                        break;\n                    }\n\n                    // Move left\n                    case 'w': {\n                        if (multiply) {\n                            positions.push_back(base_pos.ToLeft(steps));\n                        } else {\n                            for (int i = 0; i &lt; steps; ++i) {\n                                positions.push_back(base_pos.ToLeft());\n                            }\n                        }\n                        break;\n                    }\n\n                    // Move right\n                    case 'e': {\n                        if (multiply) {\n                            positions.push_back(base_pos.ToRight(steps));\n                        } else {\n                            for (int i = 0; i &lt; steps; ++i) {\n                                positions.push_back(base_pos.ToRight());\n                            }\n                        }\n                        break;\n                    }\n\n                    // Stay\n                    case 'x': {\n                        // Using the `*` does nothing to scale the offset since it's scaling {0,\n                        // 0}\n                        steps = multiply ? 1 : steps;\n\n                        for (int i = 0; i &lt; steps; ++i) {\n                            positions.push_back(base_pos);\n                        }\n                    }\n                }\n            } else {\n                std::ostringstream what;\n                what &lt;&lt; \"Incorrectly formatted argument: \" &lt;&lt; single_command;\n                throw std::invalid_argument(what.str());\n            }\n\n            iss &gt;&gt; std::skipws;\n        }\n        return positions;\n    }\n\n    template&lt;typename T&gt;\n    concept Agent_Type = std::is_base_of_v&lt;cse491::AgentBase, T&gt;;\n\n    template&lt;typename T&gt;\n    T &amp;DownCastAgent(cse491::Entity &amp;entity) requires(Agent_Type&lt;T&gt;) {\n        assert(dynamic_cast&lt;T *&gt;(&amp;entity)!=nullptr);\n        return static_cast&lt;T &amp;&gt;(entity);\n    }\n\n} // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_pacing_agent_8hpp/","title":"File PacingAgent.hpp","text":"<p>FileList &gt; Agents &gt; PacingAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_pacing_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 An Agent that will walk back and forth along a row or column."},{"location":"Agent%20Library%28Group%201%29/_pacing_agent_8hpp/#classes","title":"Classes","text":"Type Name class PacingAgent <p>The documentation for this class was generated from the following file <code>source/Agents/PacingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_pacing_agent_8hpp_source/","title":"File PacingAgent.hpp","text":"<p>File List &gt; Agents &gt; PacingAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"../core/AgentBase.hpp\"\n\nnamespace cse491 {\n\nclass PacingAgent : public AgentBase {\n protected:\n    bool vertical = true; \n    bool reverse = false;  \n\n public:\n    PacingAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {}\n    ~PacingAgent() = default;\n\n    bool Initialize() override {\n        return HasAction(\"up\") &amp;&amp; HasAction(\"down\") &amp;&amp; HasAction(\"left\") &amp;&amp; HasAction(\"right\");\n    }\n\n    size_t SelectAction(const WorldGrid &amp; /* grid*/,\n                        const type_options_t &amp; /* type_options*/,\n                        const item_map_t &amp; /* item_map*/,\n                        const agent_map_t &amp; /* agent_map*/) override {\n        // If the last step failed, try going in the other direction.\n        if (action_result == 0) {\n            reverse = !reverse;\n        }\n        // Take as tep in the direction we are trying to go in.\n        if (vertical) {\n            if (reverse) return action_map[\"up\"];\n            else return action_map[\"down\"];\n        } else {\n            if (reverse) return action_map[\"left\"];\n            else return action_map[\"right\"];\n        }\n        return 0;  // Should never actually get here...\n    }\n\n    PacingAgent &amp;SetVertical(bool vert) {\n        vertical = vert;\n        return *this;\n    }\n\n    bool GetVertical() const { return vertical; }\n\n};\n\n} // End of namespace cse491\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8cpp/","title":"File PathAgent.cpp","text":"<p>FileList &gt; Agents &gt; PathAgent.cpp</p> <p>Go to the source code of this file</p> <p>Path Agent Class. More...</p> <ul> <li><code>#include \"PathAgent.hpp\"</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Path Agent Class: Agent to move in a predefined path.</p> <p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>David Rackerby </p> <p>The documentation for this class was generated from the following file <code>source/Agents/PathAgent.cpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8cpp_source/","title":"File PathAgent.cpp","text":"<p>File List &gt; Agents &gt; PathAgent.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"PathAgent.hpp\"\n\n#include &lt;sstream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;vector&gt;\n\nnamespace walle {\n\n    PathAgent::PathAgent(size_t id, std::string const &amp;name)\n        : cse491::AgentBase(id, name) {}\n\n    PathAgent::PathAgent(size_t id, std::string const &amp;name, std::vector&lt;cse491::GridPosition&gt; offsets)\n        : cse491::AgentBase(id, name), offsets_(std::move(offsets)) {\n        if (offsets_.empty()) {\n            throw std::invalid_argument(\"Sequence of input offsets must not be empty\");\n        }\n    }\n\n    PathAgent::PathAgent(size_t id, std::string const &amp;name, std::string_view commands)\n        : cse491::AgentBase(id, name), offsets_(StrToOffsets(commands)) {\n        if (offsets_.empty()) {\n            throw std::invalid_argument(\"Sequence of input offsets must not be empty\");\n        }\n    }\n\n    bool PathAgent::Initialize() {\n        if (property_map.contains(\"path\")) {\n            offsets_ = StrToOffsets(GetProperty&lt;std::basic_string_view&lt;char&gt;&gt;(\"path\"));\n        } else {\n            return false;\n        }\n        return HasAction(\"move_arbitrary\") &amp;&amp; index_ &gt;= 0 &amp;&amp;\n            static_cast&lt;size_t&gt;(index_) &lt; offsets_.size();\n    }\n\n    void PathAgent::IncrementIndex() {\n        ++index_;\n\n        // Wrap-around to front of offsets\n        if (index_ &gt;= static_cast&lt;int&gt;(offsets_.size())) {\n            index_ = 0;\n        }\n    }\n\n    void PathAgent::DecrementIndex() {\n        --index_;\n\n        // Wrap-around to back of offsets\n        if (index_ &lt; 0) {\n            index_ = static_cast&lt;int&gt;(offsets_.size()) - 1;\n        }\n    }\n\n    cse491::GridPosition PathAgent::CalcNextPos() const {\n        return offsets_[index_] + GetPosition();\n    }\n\n    cse491::GridPosition PathAgent::UpdateAndGetNextPos(bool increment) {\n        auto next_pos = CalcNextPos();\n        if (increment) {\n            IncrementIndex();\n        } else {\n            DecrementIndex();\n        }\n        return next_pos;\n    }\n\n    cse491::GridPosition PathAgent::GetNextPosition() {\n        return UpdateAndGetNextPos(true);\n    }\n\n    size_t PathAgent::SelectAction(cse491::WorldGrid const &amp; /* grid*/,\n                                cse491::type_options_t const &amp; /* type_options*/,\n                                cse491::item_map_t const &amp; /* item_map*/,\n                                cse491::agent_map_t const &amp; /* agent_map*/) {\n        assert(HasAction(\"move_arbitrary\"));\n        return action_map[\"move_arbitrary\"];\n    }\n\n    PathAgent &amp;PathAgent::SetPath(std::vector&lt;cse491::GridPosition&gt; offsets, size_t start_index) {\n        offsets_ = offsets;\n        index_ = static_cast&lt;int&gt;(start_index);\n        if (static_cast&lt;size_t&gt;(index_) &gt;= offsets_.size()) {\n            std::ostringstream what;\n            what &lt;&lt; \"Out of bounds offset index to begin from: \" &lt;&lt; index_\n                &lt;&lt; \", number of offsets: \" &lt;&lt; offsets_.size();\n            throw std::invalid_argument(what.str());\n        }\n        return *this;\n    }\n\n    PathAgent &amp;PathAgent::SetPath(std::string_view commands, size_t start_index) {\n        offsets_.clear();\n        return SetPath(StrToOffsets(commands), start_index);\n    }\n\n    int PathAgent::GetIndex() const { return index_; }\n\n    std::vector&lt;cse491::GridPosition&gt; const &amp;PathAgent::GetPath() const { return offsets_; }\n\n} // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8hpp/","title":"File PathAgent.hpp","text":"<p>FileList &gt; Agents &gt; PathAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include \"AgentLibary.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8hpp/#classes","title":"Classes","text":"Type Name class PathAgent <p>The documentation for this class was generated from the following file <code>source/Agents/PathAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8hpp_source/","title":"File PathAgent.hpp","text":"<p>File List &gt; Agents &gt; PathAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#ifndef GROUP_1_PROJECT_SOURCE_AGENTS_PATHAGENT_H_\n#define GROUP_1_PROJECT_SOURCE_AGENTS_PATHAGENT_H_\n\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;vector&gt;\n\n#include \"../core/AgentBase.hpp\"\n#include \"../core/GridPosition.hpp\"\n#include \"AgentLibary.hpp\"\n\nnamespace walle {\n\n    class PathAgent : public cse491::AgentBase {\n    protected:\n        std::vector&lt;cse491::GridPosition&gt; offsets_;\n\n        int index_ = 0;\n\n    public:\n        PathAgent() = delete;\n        PathAgent(size_t id, std::string const &amp;name);\n        PathAgent(size_t id, std::string const &amp;name,\n                std::vector&lt;cse491::GridPosition&gt; offsets);\n        PathAgent(size_t id, std::string const &amp;name, std::string_view commands);\n        ~PathAgent() override = default;\n\n        bool Initialize() override;\n\n        void IncrementIndex();\n        void DecrementIndex();\n\n        [[nodiscard]] cse491::GridPosition CalcNextPos() const;\n\n        virtual cse491::GridPosition UpdateAndGetNextPos(bool increment);\n\n        size_t SelectAction(cse491::WorldGrid const &amp;, cse491::type_options_t const &amp;,\n                            cse491::item_map_t const &amp;, cse491::agent_map_t const &amp;) override;\n\n        [[nodiscard]] cse491::GridPosition GetNextPosition() override;\n\n        PathAgent &amp;SetPath(std::vector&lt;cse491::GridPosition&gt; offsets,\n                        size_t start_index = 0);\n        PathAgent &amp;SetPath(std::string_view commands, size_t start_index = 0);\n\n        [[nodiscard]] int GetIndex() const;\n\n        [[nodiscard]] std::vector&lt;cse491::GridPosition&gt; const &amp;GetPath() const;\n\n        PathAgent &amp;ResetIndex() {\n            index_ = 0;\n            return *this;\n        }\n    };\n\n} // namespace walle\n\n#endif // GROUP_1_PROJECT_SOURCE_AGENTS_PATHAGENT_H_\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp/","title":"File RandomAgent.hpp","text":"<p>FileList &gt; Agents &gt; RandomAgent.hpp</p> <p>Go to the source code of this file</p> <p>An Agent that will move around using random actions. More...</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp/#classes","title":"Classes","text":"Type Name class RandomAgent"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 Course Project</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>Yousif Murrani </p> <p>The documentation for this class was generated from the following file <code>source/Agents/RandomAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp_source/","title":"File RandomAgent.hpp","text":"<p>File List &gt; Agents &gt; RandomAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include \"../core/AgentBase.hpp\"\n#include \"../core/GridPosition.hpp\"\n#include \"../core/WorldBase.hpp\"\n\nnamespace walle {\n\n    class RandomAgent : public cse491::AgentBase {\n\n        private:\n\n            double random_val = 4.0; \n\n            bool moving = true; \n\n        public:\n            RandomAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {\n            }\n\n            ~RandomAgent() = default;\n\n            bool Initialize() override {\n                return HasAction(\"up\") &amp;&amp; HasAction(\"down\") &amp;&amp; HasAction(\"left\") &amp;&amp; HasAction(\"right\");\n            }\n\n            size_t SelectAction(const cse491::WorldGrid &amp; /*grid*/,\n                                const cse491::type_options_t &amp; /* type_options*/,\n                                const cse491::item_map_t &amp; /* item_map*/,\n                                const cse491::agent_map_t &amp; /* agent_map*/) override {\n                // We are taking an action so another turn has passed\n\n                CalculateRandom(random_val);\n\n                if(moving){\n                    if(random_val &lt; 1.0){\n                        return action_map[\"up\"];\n                    }\n                    else if(random_val &lt; 2.0){\n                        return action_map[\"down\"];\n                    }\n                    else if(random_val &lt; 3.0){\n                        return action_map[\"left\"];\n                    }\n                    else{\n                        return action_map[\"right\"];\n                    }\n                }\n\n                return 0; // should not reach this point\n            }\n\n            void CalculateRandom(double multiplier){\n                random_val = GetWorld().GetRandom(multiplier);\n            }\n\n            void SetDirection(double direction) { random_val = direction; }\n\n            void SetMoving(bool move) { moving = move; }\n\n            double GetRandom() const { return random_val; }\n\n            bool GetMoving() const { return moving; }\n    };\n}\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp/","title":"File TrackingAgent.hpp","text":"<p>FileList &gt; Agents &gt; TrackingAgent.hpp</p> <p>Go to the source code of this file</p> <p>Agent that switches between user-defined custom movement pattern and tracking a given agent. More...</p> <ul> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include \"AStarAgent.hpp\"</code></li> <li><code>#include \"PathAgent.hpp\"</code></li> <li><code>#include \"AgentLibary.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp/#classes","title":"Classes","text":"Type Name class Alerter class TrackingAgent"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 Course Project</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>David Rackerby </p> <p>Author:</p> <p>Matt Kight </p> <p>The documentation for this class was generated from the following file <code>source/Agents/TrackingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp_source/","title":"File TrackingAgent.hpp","text":"<p>File List &gt; Agents &gt; TrackingAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../core/AgentBase.hpp\"\n#include \"../core/GridPosition.hpp\"\n#include \"AStarAgent.hpp\"\n#include \"PathAgent.hpp\"\n#include \"AgentLibary.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;limits&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;type_traits&gt;\n#include &lt;unordered_set&gt;\n#include &lt;variant&gt;\n#include &lt;vector&gt;\n\nnamespace walle {\n\nclass Alerter {\n private:\n    cse491::WorldBase *world_ptr_;\n\n    std::unordered_set&lt;size_t&gt; agent_network_set_;\n\n public:\n    // Must be constructed with an associated world\n    Alerter() = delete;\n    explicit Alerter(cse491::WorldBase *world_ptr);\n    Alerter(cse491::WorldBase *world_ptr, size_t id);\n    void AddAgent(size_t id);\n    void RemoveAgent(size_t id);\n    void AlertAllTrackingAgents(size_t caller_id);\n\n    std::unordered_set&lt;size_t&gt; const &amp;GetNetworkSet() const { return agent_network_set_; }\n}; // Alerter\n\nenum class TrackingState { RETURNING_TO_START, TRACKING, PATROLLING };\n\ntemplate&lt;typename T&gt;\nconcept TrackingAgentInner_Type = std::is_same_v&lt;PathAgent, T&gt; || std::is_same_v&lt;AStarAgent, T&gt;;\n\nclass TrackingAgent : public cse491::AgentBase {\n private:\n    std::variant&lt;PathAgent, AStarAgent&gt; inner_;\n\n    TrackingState state_ = TrackingState::PATROLLING;\n\n    std::vector&lt;cse491::GridPosition&gt; offsets_;\n\n    cse491::GridPosition start_pos_;\n\n    Entity *target_ = nullptr;\n\n    double tracking_distance_ = 50;\n\n    std::shared_ptr&lt;Alerter&gt; alerter_ = nullptr;\n\n public:\n    TrackingAgent() = delete;\n\n    TrackingAgent(size_t id, std::string const &amp;name)\n        : cse491::AgentBase(id, name),\n          inner_(std::in_place_type&lt;PathAgent&gt;, id, name) {}\n\n    TrackingAgent(size_t id,\n                  std::string const &amp;name,\n                  std::vector&lt;cse491::GridPosition&gt; &amp;&amp;offsets,\n                  std::shared_ptr&lt;Alerter&gt; &amp;&amp;alerter = nullptr)\n        : cse491::AgentBase(id, name),\n          inner_(std::in_place_type&lt;PathAgent&gt;, id, name, offsets),\n          offsets_(offsets),\n          alerter_(alerter) {}\n\n    TrackingAgent(size_t id,\n                  std::string const &amp;name,\n                  std::string_view commands,\n                  std::shared_ptr&lt;Alerter&gt; &amp;&amp;alerter = nullptr)\n        : cse491::AgentBase(id, name),\n          inner_(std::in_place_type&lt;PathAgent&gt;, id, name, commands),\n          offsets_(StrToOffsets(commands)),\n          alerter_(alerter) {}\n\n    ~TrackingAgent() override {\n        RemoveFromAlerter();\n    }\n\n    bool Initialize() override {\n        SetStartPosition(GetPosition());\n        if (property_map.contains(\"path\")) {\n            auto view = GetProperty&lt;std::basic_string_view&lt;char&gt;&gt;(\"path\");\n            offsets_ = StrToOffsets(view);\n            std::get&lt;PathAgent&gt;(inner_).SetProperty(\"path\", view);\n            std::get&lt;PathAgent&gt;(inner_).SetWorld(GetWorld());\n            std::get&lt;PathAgent&gt;(inner_).SetPosition(GetPosition());\n\n            if (property_map.contains(\"alerter\")) {\n                auto alerter_property = GetProperty&lt;std::shared_ptr&lt;Alerter&gt;&gt;(\"alerter\");\n                AddToAlerter(alerter_property);\n            }\n            return std::get&lt;PathAgent&gt;(inner_).Initialize();\n        }\n        return false;\n    }\n\n    void MakeAlerter() {\n        alerter_ = std::make_shared&lt;Alerter&gt;(&amp;GetWorld(), id);\n    }\n\n    void AddToAlerter(std::shared_ptr&lt;Alerter&gt; alerter) {\n        assert(alerter != nullptr);\n        alerter-&gt;AddAgent(id);\n        alerter_ = alerter;\n    }\n\n    void RemoveFromAlerter() {\n        if (alerter_ != nullptr) {\n            alerter_-&gt;RemoveAgent(id);\n            alerter_ = nullptr;\n        }\n    }\n\n    [[nodiscard]] std::shared_ptr&lt;Alerter&gt; GetAlerter() const {\n        return alerter_;\n    }\n\n    void CallAlerter(size_t agent_id) {\n        if (alerter_ != nullptr) {\n            alerter_-&gt;AlertAllTrackingAgents(agent_id);\n        }\n    }\n\n    void UpdateState(bool alerting = true) {\n        SetPosition(std::visit([](TrackingAgentInner_Type auto const &amp;agent) { return agent.GetPosition(); }, inner_));\n        switch (state_) {\n            // Tracking can transition only to Returning\n            case TrackingState::TRACKING: {\n                // Reached goal position\n                if (GetPosition() == std::get&lt;AStarAgent&gt;(inner_).GetGoalPosition()) {\n                    if (target_ != nullptr &amp;&amp; GetPosition().Distance(target_-&gt;GetPosition()) &lt; tracking_distance_) {\n                        // Target is still in range of goal position so\n                        std::get&lt;AStarAgent&gt;(inner_).SetGoalPosition(target_-&gt;GetPosition());\n\n                        // Alert all trackers\n                        if (alerting) {\n                            CallAlerter(id);\n                        }\n                    } else {\n                        state_ = TrackingState::RETURNING_TO_START;\n                        std::get&lt;AStarAgent&gt;(inner_).SetGoalPosition(start_pos_);\n                    }\n                    std::get&lt;AStarAgent&gt;(inner_).RecalculatePath();\n                    std::get&lt;AStarAgent&gt;(inner_).SetActionResult(1);\n                }\n                break;\n            }\n\n                // Returning can transition to either Patrolling or Tracking\n            case TrackingState::RETURNING_TO_START: {\n                // Within tracking range, start tracking again\n                if (target_ != nullptr &amp;&amp; GetPosition().Distance(target_-&gt;GetPosition()) &lt; tracking_distance_) {\n                    state_ = TrackingState::TRACKING;\n                    std::get&lt;AStarAgent&gt;(inner_).SetGoalPosition(target_-&gt;GetPosition());\n                    std::get&lt;AStarAgent&gt;(inner_).RecalculatePath();\n                    std::get&lt;AStarAgent&gt;(inner_).SetActionResult(1);\n\n                    // Alert other trackers\n                    if (alerting) {\n                        CallAlerter(id);\n                    }\n                }\n\n                    // Returned to the beginning, start patrolling again\n                else if (GetPosition() == start_pos_) {\n                    state_ = TrackingState::PATROLLING;\n                    inner_.emplace&lt;PathAgent&gt;(id, name);\n                    std::get&lt;PathAgent&gt;(inner_).SetPosition(GetPosition());\n                    std::get&lt;PathAgent&gt;(inner_).SetPath(std::vector(offsets_));\n\n                    // Inner world_ptr needs to be reset\n                    SetWorld(GetWorld());\n                }\n                break;\n            }\n\n                // Patrolling can transition only to Tracking\n            case TrackingState::PATROLLING: {\n                // Within tracking range, needs internal object replacement\n                if (target_ != nullptr &amp;&amp; GetPosition().Distance(target_-&gt;GetPosition()) &lt; tracking_distance_) {\n                    state_ = TrackingState::TRACKING;\n                    inner_.emplace&lt;AStarAgent&gt;(id, name);\n                    // Set internal AStarAgent's position to the outer position\n                    std::get&lt;AStarAgent&gt;(inner_).SetPosition(GetPosition());\n                    std::get&lt;AStarAgent&gt;(inner_).SetGoalPosition(target_-&gt;GetPosition());\n\n                    // Inner world_ptr needs to be set\n                    SetWorld(GetWorld());\n\n                    std::get&lt;AStarAgent&gt;(inner_).RecalculatePath();\n                    std::get&lt;AStarAgent&gt;(inner_).SetActionResult(1);\n\n                    // Alert all other trackers\n                    if (alerting) {\n                        CallAlerter(id);\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    [[nodiscard]] cse491::GridPosition GetNextPosition() override {\n        auto pos = std::get&lt;PathAgent&gt;(inner_).GetNextPosition();\n        std::get&lt;PathAgent&gt;(inner_).SetPosition(pos);\n        return pos;\n    }\n\n    size_t SelectInnerAction(PathAgent &amp;agent,\n                             cse491::WorldGrid const &amp;grid,\n                             cse491::type_options_t const &amp;type,\n                             cse491::item_map_t const &amp;item_set,\n                             cse491::agent_map_t const &amp;agent_set) {\n        return agent.SelectAction(grid, type, item_set, agent_set);\n    }\n\n    size_t SelectInnerAction(AStarAgent &amp;agent,\n                             cse491::WorldGrid const &amp;grid,\n                             cse491::type_options_t const &amp;type,\n                             cse491::item_map_t const &amp;item_set,\n                             cse491::agent_map_t const &amp;agent_set) {\n        auto next_pos = agent.GetNextPosition();\n        auto res = agent.SelectAction(grid, type, item_set, agent_set);\n        agent.SetPosition(next_pos);\n        return res;\n    }\n\n    size_t SelectAction(cse491::WorldGrid const &amp;grid,\n                        cse491::type_options_t const &amp;type,\n                        cse491::item_map_t const &amp;item_set,\n                        cse491::agent_map_t const &amp;agent_set) override {\n        UpdateState();\n        return std::visit([&amp;](TrackingAgentInner_Type auto &amp;agent) {\n                              return SelectInnerAction(agent, grid, type, item_set, agent_set);\n                          },\n                          inner_);\n    }\n\n    TrackingAgent &amp;SetStartPosition(cse491::GridPosition pos) {\n        start_pos_ = pos;\n        return *this;\n    }\n\n    TrackingAgent &amp;SetStartPosition(double x, double y) {\n        start_pos_ = cse491::GridPosition(x, y);\n        return *this;\n    }\n\n    TrackingAgent &amp;SetTarget(Entity *agent) {\n        target_ = agent;\n        return *this;\n    }\n\n    [[nodiscard]] double GetTrackingDistance() const { return tracking_distance_; }\n\n    TrackingAgent &amp;SetTrackingDistance(double dist) {\n        tracking_distance_ = dist;\n        return *this;\n    }\n\n    TrackingAgent &amp;SetWorld(cse491::WorldBase &amp;in_world) override {\n        Entity::SetWorld(in_world);\n        std::visit([&amp;in_world](TrackingAgentInner_Type auto &amp;agent) {\n            agent.SetWorld(in_world);\n            std::as_const(in_world).ConfigAgent(agent);\n        }, inner_);\n        return *this;\n    }\n\n    TrackingState GetState() {\n        return state_;\n    }\n\n    TrackingAgent &amp;SetPath(std::vector&lt;cse491::GridPosition&gt; offsets) {\n        offsets_ = std::move(offsets);\n        if (offsets_.empty()) {\n            std::ostringstream what;\n            what &lt;&lt; \"TrackingAgent cannot have empty path. If you meant to make the agent stay still, use \\\"x\\\"\";\n            throw std::invalid_argument(what.str());\n        }\n        return *this;\n    }\n\n    TrackingAgent &amp;SetPath(std::string_view offsets) {\n        return SetPath(StrToOffsets(offsets));\n    }\n\n    std::vector&lt;cse491::GridPosition&gt; const &amp;GetPath() const { return offsets_; }\n\n    cse491::Entity const *GetTarget() const { return target_; }\n\n}; // TrackingAgent\n\nAlerter::Alerter(cse491::WorldBase *world_ptr) : world_ptr_(world_ptr) { assert(world_ptr != nullptr); }\n\nAlerter::Alerter(cse491::WorldBase *world_ptr, size_t id) : world_ptr_(world_ptr) {\n    assert(world_ptr != nullptr);\n    AddAgent(id);\n}\n\nvoid Alerter::AddAgent(size_t id) {\n    // Note: GetAgent already handles checking that the agent exists, but we must type-check\n    assert(dynamic_cast&lt;TrackingAgent *&gt;(&amp;(world_ptr_-&gt;GetAgent(id))) != nullptr);\n    agent_network_set_.insert(id);\n}\n\nvoid Alerter::RemoveAgent(size_t id) {\n    agent_network_set_.erase(id);\n}\n\nvoid Alerter::AlertAllTrackingAgents(size_t caller_id) {\n    for (auto id : agent_network_set_) {\n        // Do not update the caller who gave the alert\n        if (caller_id == id) {\n            continue;\n        }\n        auto &amp;tracking_agent = DownCastAgent&lt;TrackingAgent&gt;(world_ptr_-&gt;GetAgent(id));\n        // UpdateState sets an agent's TrackingState to TRACKING if it is within some distance of the goal_pos\n        // if this distance is positive infinity, then the state will always be reset (given that there IS a goal_pos)\n        // Important: UpdateState must be called with alerting == false in order to\n        // avoid infinite recursion from recursively calling AlertAllTrackingAgents\n        double old_tracking_dist = tracking_agent.GetTrackingDistance();\n        tracking_agent.SetTrackingDistance(std::numeric_limits&lt;double&gt;::infinity());\n        tracking_agent.UpdateState(false);\n        tracking_agent.SetTrackingDistance(old_tracking_dist);\n    }\n}\n\n} // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cse491 An Agent that will walk back and forth along a row or column. </li> <li>namespace walle </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/","title":"Class Index","text":""},{"location":"Agent%20Library%28Group%201%29/classes/#a","title":"a","text":"<ul> <li>AgentFactory (walle)</li> <li>Alerter (walle)</li> <li>AStarAgent (walle)</li> <li>AStarAgentData (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#b","title":"b","text":"<ul> <li>BaseAgentData (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#c","title":"c","text":"<ul> <li>CompareNodes (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#n","title":"n","text":"<ul> <li>Node (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#p","title":"p","text":"<ul> <li>PacingAgent (cse491)</li> <li>PacingAgentData (walle)</li> <li>PathAgent (walle)</li> <li>PathAgentData (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#r","title":"r","text":"<ul> <li>RandomAgent (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#t","title":"t","text":"<ul> <li>TrackingAgent (walle)</li> <li>TrackingAgentData (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class walle::AgentFactory </li> <li>class walle::Alerter </li> <li>struct walle::BaseAgentData <ul> <li>struct walle::AStarAgentData </li> <li>struct walle::PacingAgentData </li> <li>struct walle::PathAgentData </li> <li>struct walle::TrackingAgentData </li> </ul> </li> <li>struct walle::CompareNodes Custom comparison function for priority queue. </li> <li>struct walle::Node Node class to hold information about positions for A* search.</li> <li>class AgentBase <ul> <li>class cse491::PacingAgent </li> <li>class walle::AStarAgent </li> <li>class walle::PathAgent </li> <li>class walle::RandomAgent </li> <li>class walle::TrackingAgent </li> </ul> </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Agent%20Library%28Group%201%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Agent%20Library%28Group%201%29/class_members/","title":"Class Members","text":""},{"location":"Agent%20Library%28Group%201%29/class_members/#a","title":"a","text":"<ul> <li>AStarAgent (walle::AStarAgent)</li> <li>AddAStarAgent (walle::AgentFactory)</li> <li>AddPacingAgent (walle::AgentFactory)</li> <li>AddPathAgent (walle::AgentFactory)</li> <li>AddTrackingAgent (walle::AgentFactory)</li> <li>AgentFactory (walle::AgentFactory)</li> <li>AddAgent (walle::Alerter)</li> <li>AlertAllTrackingAgents (walle::Alerter)</li> <li>Alerter (walle::Alerter)</li> <li>agent_network_set_ (walle::Alerter)</li> <li>AddToAlerter (walle::TrackingAgent)</li> <li>alerter_ (walle::TrackingAgent)</li> <li>alerter (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#c","title":"c","text":"<ul> <li>current_move_num (walle::AStarAgent)</li> <li>CalcNextPos (walle::PathAgent)</li> <li>CalculateRandom (walle::RandomAgent)</li> <li>CallAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#d","title":"d","text":"<ul> <li>DecrementIndex (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#f","title":"f","text":"<ul> <li>f (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#g","title":"g","text":"<ul> <li>GetVertical (cse491::PacingAgent)</li> <li>GetGoalPosition (walle::AStarAgent)</li> <li>GetNextPosition (walle::AStarAgent, walle::PathAgent, walle::TrackingAgent)</li> <li>GetPathLength (walle::AStarAgent)</li> <li>GetRecalculateValue (walle::AStarAgent)</li> <li>goal_position (walle::AStarAgent)</li> <li>goal_pos (walle::AStarAgentData)</li> <li>GetNetworkSet (walle::Alerter)</li> <li>g (walle::Node)</li> <li>GetIndex (walle::PathAgent)</li> <li>GetPath (walle::PathAgent, walle::TrackingAgent)</li> <li>GetMoving (walle::RandomAgent)</li> <li>GetRandom (walle::RandomAgent)</li> <li>GetAlerter (walle::TrackingAgent)</li> <li>GetState (walle::TrackingAgent)</li> <li>GetTarget (walle::TrackingAgent)</li> <li>GetTrackingDistance (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#h","title":"h","text":"<ul> <li>h (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#i","title":"i","text":"<ul> <li>Initialize (cse491::PacingAgent, walle::AStarAgent, walle::PathAgent, walle::RandomAgent, walle::TrackingAgent)</li> <li>IncrementIndex (walle::PathAgent)</li> <li>index_ (walle::PathAgent)</li> <li>index (walle::PathAgentData)</li> <li>inner_ (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#m","title":"m","text":"<ul> <li>moving (walle::RandomAgent)</li> <li>MakeAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#n","title":"n","text":"<ul> <li>name (walle::BaseAgentData)</li> <li>Node (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#o","title":"o","text":"<ul> <li>operator() (walle::CompareNodes)</li> <li>offsets_ (walle::PathAgent, walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#p","title":"p","text":"<ul> <li>PacingAgent (cse491::PacingAgent)</li> <li>path (walle::AStarAgent)</li> <li>position (walle::BaseAgentData, walle::Node)</li> <li>parent (walle::Node)</li> <li>PathAgent (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#r","title":"r","text":"<ul> <li>reverse (cse491::PacingAgent)</li> <li>RecalculatePath (walle::AStarAgent)</li> <li>recalculate_after_x_turns (walle::AStarAgent, walle::AStarAgentData)</li> <li>RemoveAgent (walle::Alerter)</li> <li>ResetIndex (walle::PathAgent)</li> <li>RandomAgent (walle::RandomAgent)</li> <li>random_val (walle::RandomAgent)</li> <li>RemoveFromAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#s","title":"s","text":"<ul> <li>SelectAction (cse491::PacingAgent, walle::AStarAgent, walle::PathAgent, walle::RandomAgent, walle::TrackingAgent)</li> <li>SetVertical (cse491::PacingAgent)</li> <li>SetGoalPosition (walle::AStarAgent)</li> <li>SetRecalculate (walle::AStarAgent)</li> <li>symbol (walle::BaseAgentData)</li> <li>SetPath (walle::PathAgent, walle::TrackingAgent)</li> <li>string_path (walle::PathAgentData, walle::TrackingAgentData)</li> <li>SetDirection (walle::RandomAgent)</li> <li>SetMoving (walle::RandomAgent)</li> <li>SelectInnerAction (walle::TrackingAgent)</li> <li>SetStartPosition (walle::TrackingAgent)</li> <li>SetTarget (walle::TrackingAgent)</li> <li>SetTrackingDistance (walle::TrackingAgent)</li> <li>SetWorld (walle::TrackingAgent)</li> <li>start_pos_ (walle::TrackingAgent)</li> <li>state_ (walle::TrackingAgent)</li> <li>start_pos (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#t","title":"t","text":"<ul> <li>TrackingAgent (walle::TrackingAgent)</li> <li>target_ (walle::TrackingAgent)</li> <li>tracking_distance_ (walle::TrackingAgent)</li> <li>TrackingAgentData (walle::TrackingAgentData)</li> <li>target (walle::TrackingAgentData)</li> <li>tracking_distance (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#u","title":"u","text":"<ul> <li>UpdateAndGetNextPos (walle::PathAgent)</li> <li>UpdateState (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#v","title":"v","text":"<ul> <li>vertical (cse491::PacingAgent, walle::PacingAgentData)</li> <li>vector_path (walle::PathAgentData, walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#w","title":"w","text":"<ul> <li>world (walle::AgentFactory)</li> <li>world_ptr_ (walle::Alerter)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#_1","title":"~","text":"<ul> <li>~PacingAgent (cse491::PacingAgent)</li> <li>~AStarAgent (walle::AStarAgent)</li> <li>~PathAgent (walle::PathAgent)</li> <li>~RandomAgent (walle::RandomAgent)</li> <li>~TrackingAgent (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#a","title":"a","text":"<ul> <li>AStarAgent (walle::AStarAgent)</li> <li>AddAStarAgent (walle::AgentFactory)</li> <li>AddPacingAgent (walle::AgentFactory)</li> <li>AddPathAgent (walle::AgentFactory)</li> <li>AddTrackingAgent (walle::AgentFactory)</li> <li>AgentFactory (walle::AgentFactory)</li> <li>AddAgent (walle::Alerter)</li> <li>AlertAllTrackingAgents (walle::Alerter)</li> <li>Alerter (walle::Alerter)</li> <li>AddToAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#c","title":"c","text":"<ul> <li>CalcNextPos (walle::PathAgent)</li> <li>CalculateRandom (walle::RandomAgent)</li> <li>CallAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#d","title":"d","text":"<ul> <li>DecrementIndex (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#f","title":"f","text":"<ul> <li>f (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#g","title":"g","text":"<ul> <li>GetVertical (cse491::PacingAgent)</li> <li>GetGoalPosition (walle::AStarAgent)</li> <li>GetNextPosition (walle::AStarAgent, walle::PathAgent, walle::TrackingAgent)</li> <li>GetPathLength (walle::AStarAgent)</li> <li>GetRecalculateValue (walle::AStarAgent)</li> <li>GetNetworkSet (walle::Alerter)</li> <li>GetIndex (walle::PathAgent)</li> <li>GetPath (walle::PathAgent, walle::TrackingAgent)</li> <li>GetMoving (walle::RandomAgent)</li> <li>GetRandom (walle::RandomAgent)</li> <li>GetAlerter (walle::TrackingAgent)</li> <li>GetState (walle::TrackingAgent)</li> <li>GetTarget (walle::TrackingAgent)</li> <li>GetTrackingDistance (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (cse491::PacingAgent, walle::AStarAgent, walle::PathAgent, walle::RandomAgent, walle::TrackingAgent)</li> <li>IncrementIndex (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#m","title":"m","text":"<ul> <li>MakeAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#n","title":"n","text":"<ul> <li>Node (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#o","title":"o","text":"<ul> <li>operator() (walle::CompareNodes)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#p","title":"p","text":"<ul> <li>PacingAgent (cse491::PacingAgent)</li> <li>PathAgent (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#r","title":"r","text":"<ul> <li>RecalculatePath (walle::AStarAgent)</li> <li>RemoveAgent (walle::Alerter)</li> <li>ResetIndex (walle::PathAgent)</li> <li>RandomAgent (walle::RandomAgent)</li> <li>RemoveFromAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (cse491::PacingAgent, walle::AStarAgent, walle::PathAgent, walle::RandomAgent, walle::TrackingAgent)</li> <li>SetVertical (cse491::PacingAgent)</li> <li>SetGoalPosition (walle::AStarAgent)</li> <li>SetRecalculate (walle::AStarAgent)</li> <li>SetPath (walle::PathAgent, walle::TrackingAgent)</li> <li>SetDirection (walle::RandomAgent)</li> <li>SetMoving (walle::RandomAgent)</li> <li>SelectInnerAction (walle::TrackingAgent)</li> <li>SetStartPosition (walle::TrackingAgent)</li> <li>SetTarget (walle::TrackingAgent)</li> <li>SetTrackingDistance (walle::TrackingAgent)</li> <li>SetWorld (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#t","title":"t","text":"<ul> <li>TrackingAgent (walle::TrackingAgent)</li> <li>TrackingAgentData (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#u","title":"u","text":"<ul> <li>UpdateAndGetNextPos (walle::PathAgent)</li> <li>UpdateState (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~PacingAgent (cse491::PacingAgent)</li> <li>~AStarAgent (walle::AStarAgent)</li> <li>~PathAgent (walle::PathAgent)</li> <li>~RandomAgent (walle::RandomAgent)</li> <li>~TrackingAgent (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#a","title":"a","text":"<ul> <li>agent_network_set_ (walle::Alerter)</li> <li>alerter_ (walle::TrackingAgent)</li> <li>alerter (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#c","title":"c","text":"<ul> <li>current_move_num (walle::AStarAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#g","title":"g","text":"<ul> <li>goal_position (walle::AStarAgent)</li> <li>goal_pos (walle::AStarAgentData)</li> <li>g (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#h","title":"h","text":"<ul> <li>h (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#i","title":"i","text":"<ul> <li>index_ (walle::PathAgent)</li> <li>index (walle::PathAgentData)</li> <li>inner_ (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#m","title":"m","text":"<ul> <li>moving (walle::RandomAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#n","title":"n","text":"<ul> <li>name (walle::BaseAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#o","title":"o","text":"<ul> <li>offsets_ (walle::PathAgent, walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#p","title":"p","text":"<ul> <li>path (walle::AStarAgent)</li> <li>position (walle::BaseAgentData, walle::Node)</li> <li>parent (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#r","title":"r","text":"<ul> <li>reverse (cse491::PacingAgent)</li> <li>recalculate_after_x_turns (walle::AStarAgent, walle::AStarAgentData)</li> <li>random_val (walle::RandomAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#s","title":"s","text":"<ul> <li>symbol (walle::BaseAgentData)</li> <li>string_path (walle::PathAgentData, walle::TrackingAgentData)</li> <li>start_pos_ (walle::TrackingAgent)</li> <li>state_ (walle::TrackingAgent)</li> <li>start_pos (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#t","title":"t","text":"<ul> <li>target_ (walle::TrackingAgent)</li> <li>tracking_distance_ (walle::TrackingAgent)</li> <li>target (walle::TrackingAgentData)</li> <li>tracking_distance (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#v","title":"v","text":"<ul> <li>vertical (cse491::PacingAgent, walle::PacingAgentData)</li> <li>vector_path (walle::PathAgentData, walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#w","title":"w","text":"<ul> <li>world (walle::AgentFactory)</li> <li>world_ptr_ (walle::Alerter)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Agent%20Library%28Group%201%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Agent%20Library%28Group%201%29/namespace_members/","title":"Namespace Members","text":""},{"location":"Agent%20Library%28Group%201%29/namespace_members/#d","title":"d","text":"<ul> <li>DownCastAgent (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_members/#g","title":"g","text":"<ul> <li>GetShortestPath (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_members/#s","title":"s","text":"<ul> <li>StrToOffsets (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_members/#t","title":"t","text":"<ul> <li>TrackingState (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"Agent%20Library%28Group%201%29/namespace_member_functions/#d","title":"d","text":"<ul> <li>DownCastAgent (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_functions/#g","title":"g","text":"<ul> <li>GetShortestPath (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_functions/#s","title":"s","text":"<ul> <li>StrToOffsets (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"Agent%20Library%28Group%201%29/namespace_member_enums/#t","title":"t","text":"<ul> <li>TrackingState (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Agent%20Library%28Group%201%29/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Agent%20Library%28Group%201%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Agent%20Library%28Group%201%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace DataCollection <ul> <li>class AgentData Represents data collected for an agent, including their name, actions, positions, and associated IDs. </li> <li>class AgentInteractionCollector A data collector class to quantify agent interactions. </li> <li>class AgentReceiver Data receiver class specialized for storing AgentData objects. </li> <li>class DamageCollector A data collector class for damage of game items. </li> <li>class DamageData Represents damage related data between an agent and other entities (agents, items, grids, etc) </li> <li>class DamageReceiver Data receiver class specialized for storing DamageData objects.</li> <li>class DataManager Represents a data control system to hold all related receivers and collectors. </li> <li>class DataReceiver Generic data receiver template class. </li> <li>class GameData </li> <li>class GameReceiver Represents a receiver specifically designed to handle game-related data. </li> <li>class ItemUseCollector A data collector class for usage amount of game items. </li> <li>class JsonBuilder Builds a JSON object from the data collected for an agent. </li> </ul> </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir DataCollection <ul> <li>file AgentData.hpp </li> <li>file AgentInteractionCollector.hpp </li> <li>file AgentReciever.hpp </li> <li>file DamageCollector.hpp </li> <li>file DamageData.hpp </li> <li>file DamageReceiver.hpp </li> <li>file DataManager.hpp </li> <li>file DataReceiver.hpp </li> <li>file GameData.hpp </li> <li>file GameReceiver.hpp </li> <li>file ItemUseCollector.hpp </li> <li>file JsonBuilder.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/namespace_data_collection/","title":"Namespace DataCollection","text":"<p>Namespace List &gt; DataCollection</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_data_collection/#classes","title":"Classes","text":"Type Name class AgentData Represents data collected for an agent, including their name, actions, positions, and associated IDs. class AgentInteractionCollector A data collector class to quantify agent interactions. class AgentReceiver Data receiver class specialized for storing AgentData objects. class DamageCollector A data collector class for damage of game items. class DamageData Represents damage related data between an agent and other entities (agents, items, grids, etc) class DamageReceiver Data receiver class specialized for storing DamageData objects. class DataManager Represents a data control system to hold all related receivers and collectors. class DataReceiver &lt;typename T&gt;Generic data receiver template class. class GameData class GameReceiver Represents a receiver specifically designed to handle game-related data. class ItemUseCollector A data collector class for usage amount of game items. class JsonBuilder Builds a JSON object from the data collected for an agent. <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/","title":"Class DataCollection::AgentData","text":"<p>ClassList &gt; DataCollection &gt; AgentData</p> <p>Represents data collected for an agent, including their name, actions, positions, and associated IDs. </p> <ul> <li><code>#include &lt;AgentData.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#public-functions","title":"Public Functions","text":"Type Name AgentData (std::string name) Default constructor for AgentData class. int GetActionSize () const auto &amp; GetActions () Retrieves the stored actions. auto GetAgentIds () constGets the agent IDs associated with the stored actions. std::string GetName () const int GetPositionSize () constGets the size of the stored grid positions. std::vector&lt; cse491::GridPosition &gt; GetPositions () const void SetActions (const std::vector&lt; std::unordered_map&lt; std::string, size_t &gt; &gt; &amp; newActions) Sets the stored actions to a new set of actions. void StoreAction (std::unordered_map&lt; std::string, size_t &gt; action) Stores an action for the agent. void StoreAgentId (int id) Stores an agent ID associated with an action. void StorePositions (cse491::GridPosition pos) Stores a grid position for the agent. ~AgentData () = defaultDestructor for AgentData class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-agentdata","title":"function AgentData","text":"<pre><code>inline DataCollection::AgentData::AgentData (\n    std::string name\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getactionsize","title":"function GetActionSize","text":"<pre><code>inline int DataCollection::AgentData::GetActionSize () const\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getactions","title":"function GetActions","text":"<p>Retrieves the stored actions. </p> <pre><code>inline auto &amp; DataCollection::AgentData::GetActions () \n</code></pre> <p>Returns:</p> <p>Reference to the vector of action maps. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getagentids","title":"function GetAgentIds","text":"<p>Gets the agent IDs associated with the stored actions. </p> <pre><code>inline auto DataCollection::AgentData::GetAgentIds () const\n</code></pre> <p>Returns:</p> <p>The vector of agent IDs. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getname","title":"function GetName","text":"<pre><code>inline std::string DataCollection::AgentData::GetName () const\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getpositionsize","title":"function GetPositionSize","text":"<p>Gets the size of the stored grid positions. </p> <pre><code>inline int DataCollection::AgentData::GetPositionSize () const\n</code></pre> <p>Returns:</p> <p>The number of stored grid positions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getpositions","title":"function GetPositions","text":"<pre><code>inline std::vector&lt; cse491::GridPosition &gt; DataCollection::AgentData::GetPositions () const\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-setactions","title":"function SetActions","text":"<p>Sets the stored actions to a new set of actions. </p> <pre><code>inline void DataCollection::AgentData::SetActions (\n    const std::vector&lt; std::unordered_map&lt; std::string, size_t &gt; &gt; &amp; newActions\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>newActions</code> The new set of actions to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-storeaction","title":"function StoreAction","text":"<p>Stores an action for the agent. </p> <pre><code>inline void DataCollection::AgentData::StoreAction (\n    std::unordered_map&lt; std::string, size_t &gt; action\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>action</code> The action to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-storeagentid","title":"function StoreAgentId","text":"<p>Stores an agent ID associated with an action. </p> <pre><code>inline void DataCollection::AgentData::StoreAgentId (\n    int id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> The agent ID to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-storepositions","title":"function StorePositions","text":"<p>Stores a grid position for the agent. </p> <pre><code>inline void DataCollection::AgentData::StorePositions (\n    cse491::GridPosition pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-agentdata_1","title":"function ~AgentData","text":"<pre><code>DataCollection::AgentData::~AgentData () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/","title":"Class DataCollection::AgentInteractionCollector","text":"<p>ClassList &gt; DataCollection &gt; AgentInteractionCollector</p> <p>A data collector class to quantify agent interactions. More...</p> <ul> <li><code>#include &lt;AgentInteractionCollector.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#public-functions","title":"Public Functions","text":"Type Name AgentInteractionCollector () = defaultData storage map of agent name to interactions. const std::unordered_map&lt; std::string, int &gt; &amp; GetInteractionData ()  size_t GetUniqueInteractions ()  void RecordInteraction (const std::string &amp; agentName)  void WriteToInteractionFile (const std::string filename)"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#detailed-description","title":"Detailed Description","text":"<p>Useful for setting up graphs for common interactions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-agentinteractioncollector","title":"function AgentInteractionCollector","text":"<p>Data storage map of agent name to interactions. </p> <pre><code>DataCollection::AgentInteractionCollector::AgentInteractionCollector () = default\n</code></pre> <p>Default constructor for AgentInteractionCollector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-getinteractiondata","title":"function GetInteractionData","text":"<pre><code>inline const std::unordered_map&lt; std::string, int &gt; &amp; DataCollection::AgentInteractionCollector::GetInteractionData () \n</code></pre> <p>Getter for interaction data </p> <p>Returns:</p> <p>Const reference to the interaction data storage. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-getuniqueinteractions","title":"function GetUniqueInteractions","text":"<pre><code>inline size_t DataCollection::AgentInteractionCollector::GetUniqueInteractions () \n</code></pre> <p>Get the amount of unique agents that occured </p> <p>Returns:</p> <p>int amount of agent occurances </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-recordinteraction","title":"function RecordInteraction","text":"<pre><code>inline void DataCollection::AgentInteractionCollector::RecordInteraction (\n    const std::string &amp; agentName\n) \n</code></pre> <p>Increment occurance amount for a certain agent. </p> <p>Parameters:</p> <ul> <li><code>agentName</code> Agent name to record new interaction with </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-writetointeractionfile","title":"function WriteToInteractionFile","text":"<pre><code>inline void DataCollection::AgentInteractionCollector::WriteToInteractionFile (\n    const std::string filename\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentInteractionCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/","title":"Class DataCollection::AgentReceiver","text":"<p>ClassList &gt; DataCollection &gt; AgentReceiver</p> <p>Data receiver class specialized for storing AgentData objects.More...</p> <ul> <li><code>#include &lt;AgentReciever.hpp&gt;</code></li> </ul> <p>Inherits the following classes: DataCollection::DataReceiver</p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#public-functions","title":"Public Functions","text":"Type Name void AddAgent (const std::string &amp; name) Stores agent data into the storage and writes to a json file. std::shared_ptr&lt; AgentData &gt; GetAgent (const std::string &amp; name)  AgentData GetAgentData (const std::string &amp; name)  void StoreData (std::string name, cse491::GridPosition pos, int last_action) Stores a grid position and last action ID associated with an agent. void WriteToPositionFile (std::string path) Writes the stored AgentData Positions to a JSON file."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#public-functions-inherited-from-datacollectiondatareceiver","title":"Public Functions inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name DataReceiver () = defaultDefault constructor for DataReceiver class. bool IsEmpty () Checks if the storage is empty. void StoreIntoStorage (T obj) Store a data object into the storage. std::vector&lt; T &gt; &amp; getStorage () Retrieves the stored data objects. virtual ~DataReceiver () = defaultVirtual destructor for DataReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#protected-attributes-inherited-from-datacollectiondatareceiver","title":"Protected Attributes inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name std::vector&lt; T &gt; storage Vector to store shared_ptr data objects of type T."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#detailed-description","title":"Detailed Description","text":"<p>This class extends DataReceiver class and provides specific functionality for storing AgentData objects along with grid positions and last action IDs. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-addagent","title":"function AddAgent","text":"<p>Stores agent data into the storage and writes to a json file. </p> <pre><code>inline void DataCollection::AgentReceiver::AddAgent (\n    const std::string &amp; name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> the name of the agent </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-getagent","title":"function GetAgent","text":"<pre><code>inline std::shared_ptr&lt; AgentData &gt; DataCollection::AgentReceiver::GetAgent (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-getagentdata","title":"function GetAgentData","text":"<pre><code>inline AgentData DataCollection::AgentReceiver::GetAgentData (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-storedata","title":"function StoreData","text":"<p>Stores a grid position and last action ID associated with an agent. </p> <pre><code>inline void DataCollection::AgentReceiver::StoreData (\n    std::string name,\n    cse491::GridPosition pos,\n    int last_action\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position to be stored. </li> <li><code>last_action</code> The last action ID associated with the agent. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-writetopositionfile","title":"function WriteToPositionFile","text":"<p>Writes the stored AgentData Positions to a JSON file.</p> <pre><code>inline void DataCollection::AgentReceiver::WriteToPositionFile (\n    std::string path\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The AgentData Position to be stored. </li> </ul> <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentReciever.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/","title":"Class DataCollection::DamageCollector","text":"<p>ClassList &gt; DataCollection &gt; DamageCollector</p> <p>A data collector class for damage of game items. More...</p> <ul> <li><code>#include &lt;DamageCollector.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#public-functions","title":"Public Functions","text":"Type Name double CalculateAverageDamage (const std::string &amp; itemName)  DamageCollector () = defaultDefault constructor for DamageCollector . std::vector&lt; double &gt; &amp; GetDamageAmounts (std::string itemName)  void RecordDamageResult (const std::string &amp; itemName, double damageAmt)  void WriteToDamageFile (std::string path)"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#detailed-description","title":"Detailed Description","text":"<p>Useful for setting up graphs for analysis of item balancing. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-calculateaveragedamage","title":"function CalculateAverageDamage","text":"<pre><code>inline double DataCollection::DamageCollector::CalculateAverageDamage (\n    const std::string &amp; itemName\n) \n</code></pre> <p>Calculate average damage for a certain item </p> <p>Parameters:</p> <ul> <li><code>itemName</code> Item name to calculate average for </li> </ul> <p>Returns:</p> <p>The average damage as a double, -1 if the item does not exist </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-damagecollector","title":"function DamageCollector","text":"<pre><code>DataCollection::DamageCollector::DamageCollector () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-getdamageamounts","title":"function GetDamageAmounts","text":"<pre><code>inline std::vector&lt; double &gt; &amp; DataCollection::DamageCollector::GetDamageAmounts (\n    std::string itemName\n) \n</code></pre> <p>Get the damage amounts for a certain item. </p> <p>Parameters:</p> <ul> <li><code>itemName</code> Name of the item to get damage amounts for </li> </ul> <p>Returns:</p> <p>Reference to the vector of damage amounts </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-recorddamageresult","title":"function RecordDamageResult","text":"<pre><code>inline void DataCollection::DamageCollector::RecordDamageResult (\n    const std::string &amp; itemName,\n    double damageAmt\n) \n</code></pre> <p>Store a damage amount for a certain item. </p> <p>Parameters:</p> <ul> <li><code>itemName</code> Name of the item to store the damage for </li> <li><code>damageAmt</code> Amount of damage this item did </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-writetodamagefile","title":"function WriteToDamageFile","text":"<pre><code>inline void DataCollection::DamageCollector::WriteToDamageFile (\n    std::string path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/","title":"Class DataCollection::DamageData","text":"<p>ClassList &gt; DataCollection &gt; DamageData</p> <p>Represents damage related data between an agent and other entities (agents, items, grids, etc) </p> <ul> <li><code>#include &lt;DamageData.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/#public-functions","title":"Public Functions","text":"Type Name DamageData (std::shared_ptr&lt; cse491::AgentBase &gt; agnt, std::shared_ptr&lt; cse491::Entity &gt; src, int amt) The amount of damage taken from this source. ~DamageData () = defaultDestructor for DamageData class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/#function-damagedata","title":"function DamageData","text":"<p>The amount of damage taken from this source. </p> <pre><code>inline DataCollection::DamageData::DamageData (\n    std::shared_ptr&lt; cse491::AgentBase &gt; agnt,\n    std::shared_ptr&lt; cse491::Entity &gt; src,\n    int amt\n) \n</code></pre> <p>Default constructor for a DamageData </p> <p>Parameters:</p> <ul> <li><code>src</code> Damage source entity </li> <li><code>amt</code> Amount of damage taken </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/#function-damagedata_1","title":"function ~DamageData","text":"<pre><code>DataCollection::DamageData::~DamageData () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_receiver/","title":"Class DataCollection::DamageReceiver","text":"<p>ClassList &gt; DataCollection &gt; DamageReceiver</p> <p>Data receiver class specialized for storing DamageData objects.More...</p> <ul> <li><code>#include &lt;DamageReceiver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: DataCollection::DataReceiver</p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_receiver/#public-functions-inherited-from-datacollectiondatareceiver","title":"Public Functions inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name DataReceiver () = defaultDefault constructor for DataReceiver class. bool IsEmpty () Checks if the storage is empty. void StoreIntoStorage (T obj) Store a data object into the storage. std::vector&lt; T &gt; &amp; getStorage () Retrieves the stored data objects. virtual ~DataReceiver () = defaultVirtual destructor for DataReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_receiver/#protected-attributes-inherited-from-datacollectiondatareceiver","title":"Protected Attributes inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name std::vector&lt; T &gt; storage Vector to store shared_ptr data objects of type T."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_receiver/#detailed-description","title":"Detailed Description","text":"<p>This class extends DataReceiver class and provides specific functionality for storing DamageData objects along with damage sources and amounts. </p> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/","title":"Class DataCollection::DataManager","text":"<p>ClassList &gt; DataCollection &gt; DataManager</p> <p>Represents a data control system to hold all related receivers and collectors. More...</p> <ul> <li><code>#include &lt;DataManager.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#public-functions","title":"Public Functions","text":"Type Name AgentInteractionCollector &amp; GetAgentInteractionCollector ()  AgentReceiver &amp; GetAgentReceiver ()  const DamageCollector &amp; GetDamageCollector ()  const GameReceiver &amp; GetGameReceiver ()  ItemUseCollector &amp; GetItemUseCollector ()  void WriteToJson ()  ~DataManager () = default"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#public-static-functions","title":"Public Static Functions","text":"Type Name DataManager &amp; GetInstance ()"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#detailed-description","title":"Detailed Description","text":"<p>World should report back relevant data here and it will be stored appropriately. Also manages graphing utilities. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getagentinteractioncollector","title":"function GetAgentInteractionCollector","text":"<pre><code>inline AgentInteractionCollector &amp; DataCollection::DataManager::GetAgentInteractionCollector () \n</code></pre> <p>Get a handle to the agent interaction collector </p> <p>Returns:</p> <p>Reference to the agent interaction collector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getagentreceiver","title":"function GetAgentReceiver","text":"<pre><code>inline AgentReceiver &amp; DataCollection::DataManager::GetAgentReceiver () \n</code></pre> <p>Get a handle to the agent receiver </p> <p>Returns:</p> <p>Reference to the agent receiver </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getdamagecollector","title":"function GetDamageCollector","text":"<pre><code>inline const DamageCollector &amp; DataCollection::DataManager::GetDamageCollector () \n</code></pre> <p>Get a handle to the damage collector </p> <p>Returns:</p> <p>Const reference to the damage collector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getgamereceiver","title":"function GetGameReceiver","text":"<pre><code>inline const GameReceiver &amp; DataCollection::DataManager::GetGameReceiver () \n</code></pre> <p>Get a handle to the game receiver </p> <p>Returns:</p> <p>Const reference to the game receiver </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getitemusecollector","title":"function GetItemUseCollector","text":"<pre><code>inline ItemUseCollector &amp; DataCollection::DataManager::GetItemUseCollector () \n</code></pre> <p>Get a handle to the item use collector </p> <p>Returns:</p> <p>Reference to the item use collector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-writetojson","title":"function WriteToJson","text":"<pre><code>inline void DataCollection::DataManager::WriteToJson () \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-datamanager","title":"function ~DataManager","text":"<pre><code>DataCollection::DataManager::~DataManager () = default\n</code></pre> <p>Destructor </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getinstance","title":"function GetInstance","text":"<pre><code>static inline DataManager &amp; DataCollection::DataManager::GetInstance () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DataManager.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/","title":"Class DataCollection::DataReceiver","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; DataCollection &gt; DataReceiver</p> <p>Generic data receiver template class. More...</p> <ul> <li><code>#include &lt;DataReceiver.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#public-functions","title":"Public Functions","text":"Type Name DataReceiver () = defaultDefault constructor for DataReceiver class. bool IsEmpty () Checks if the storage is empty. void StoreIntoStorage (T obj) Store a data object into the storage. std::vector&lt; T &gt; &amp; getStorage () Retrieves the stored data objects. virtual ~DataReceiver () = defaultVirtual destructor for DataReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; T &gt; storage Vector to store shared_ptr data objects of type T."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#detailed-description","title":"Detailed Description","text":"<p>This class provides a template for storing and retrieving data objects of a specified type. </p> <p>Template parameters:</p> <ul> <li><code>T</code> The type of data to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-datareceiver","title":"function DataReceiver","text":"<pre><code>DataCollection::DataReceiver::DataReceiver () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-isempty","title":"function IsEmpty","text":"<p>Checks if the storage is empty. </p> <pre><code>inline bool DataCollection::DataReceiver::IsEmpty () \n</code></pre> <p>Returns:</p> <p>True if the storage is empty, false otherwise. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-storeintostorage","title":"function StoreIntoStorage","text":"<p>Store a data object into the storage. </p> <pre><code>inline void DataCollection::DataReceiver::StoreIntoStorage (\n    T obj\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>obj</code> The data object to store </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-getstorage","title":"function getStorage","text":"<p>Retrieves the stored data objects. </p> <pre><code>inline std::vector&lt; T &gt; &amp; DataCollection::DataReceiver::getStorage () \n</code></pre> <p>Returns:</p> <p>Reference to the vector containing stored data objects. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-datareceiver_1","title":"function ~DataReceiver","text":"<pre><code>virtual DataCollection::DataReceiver::~DataReceiver () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#variable-storage","title":"variable storage","text":"<pre><code>std::vector&lt;T&gt; storage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DataReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/","title":"Class DataCollection::GameData","text":"<p>ClassList &gt; DataCollection &gt; GameData</p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#public-functions","title":"Public Functions","text":"Type Name GameData () = defaultDefault constructor for AgentData class. const std::vector&lt; int &gt; &amp; GetCollisions () constRetrieve the stored collisions data. const std::vector&lt; size_t &gt; &amp; GetShortestPathActions () constRetrieve the stored shortest path actions. const std::vector&lt; cse491::GridPosition &gt; GetShortestPathPos () constRetrieve the stored shortest path positions. void StoreCollision (int collision) Store collision data. void StoreShortestPathAction (size_t action) Store a shortest path action. void StoreShortestPathPos (const cse491::GridPosition pos) Store a shortest path position. int getNumOfCol () constGet the number of collisions. void setNumOfCol (int value) Set the number of collisions. ~GameData () = defaultDestructor for AgentData class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-gamedata","title":"function GameData","text":"<pre><code>DataCollection::GameData::GameData () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-getcollisions","title":"function GetCollisions","text":"<p>Retrieve the stored collisions data. </p> <pre><code>inline const std::vector&lt; int &gt; &amp; DataCollection::GameData::GetCollisions () const\n</code></pre> <p>Returns:</p> <p>A constant reference to the vector of collisions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-getshortestpathactions","title":"function GetShortestPathActions","text":"<p>Retrieve the stored shortest path actions. </p> <pre><code>inline const std::vector&lt; size_t &gt; &amp; DataCollection::GameData::GetShortestPathActions () const\n</code></pre> <p>Returns:</p> <p>A constant reference to the vector of shortest path actions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-getshortestpathpos","title":"function GetShortestPathPos","text":"<p>Retrieve the stored shortest path positions. </p> <pre><code>inline const std::vector&lt; cse491::GridPosition &gt; DataCollection::GameData::GetShortestPathPos () const\n</code></pre> <p>Returns:</p> <p>A constant reference to the vector of shortest path positions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-storecollision","title":"function StoreCollision","text":"<p>Store collision data. </p> <pre><code>inline void DataCollection::GameData::StoreCollision (\n    int collision\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>collision</code> Collision data to store. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-storeshortestpathaction","title":"function StoreShortestPathAction","text":"<p>Store a shortest path action. </p> <pre><code>inline void DataCollection::GameData::StoreShortestPathAction (\n    size_t action\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>action</code> Shortest path action to store. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-storeshortestpathpos","title":"function StoreShortestPathPos","text":"<p>Store a shortest path position. </p> <pre><code>inline void DataCollection::GameData::StoreShortestPathPos (\n    const cse491::GridPosition pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>position</code> Shortest path position to store. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-getnumofcol","title":"function getNumOfCol","text":"<p>Get the number of collisions. </p> <pre><code>inline int DataCollection::GameData::getNumOfCol () const\n</code></pre> <p>Returns:</p> <p>Number of collisions. -----------These member functions are generated by Chatgpt </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-setnumofcol","title":"function setNumOfCol","text":"<p>Set the number of collisions. </p> <pre><code>inline void DataCollection::GameData::setNumOfCol (\n    int value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The value to set. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-gamedata_1","title":"function ~GameData","text":"<pre><code>DataCollection::GameData::~GameData () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/GameData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/","title":"Class DataCollection::GameReceiver","text":"<p>ClassList &gt; DataCollection &gt; GameReceiver</p> <p>Represents a receiver specifically designed to handle game-related data. More...</p> <ul> <li><code>#include &lt;GameReceiver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: DataCollection::DataReceiver</p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#public-functions","title":"Public Functions","text":"Type Name GameReceiver () = defaultDefault constructor for the GameReceiver class. void store_GameData (const GameData &amp; gameData) Store a GameData object into the receiver's storage. ~GameReceiver () overrideDestructor for the GameReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#public-functions-inherited-from-datacollectiondatareceiver","title":"Public Functions inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name DataReceiver () = defaultDefault constructor for DataReceiver class. bool IsEmpty () Checks if the storage is empty. void StoreIntoStorage (T obj) Store a data object into the storage. std::vector&lt; T &gt; &amp; getStorage () Retrieves the stored data objects. virtual ~DataReceiver () = defaultVirtual destructor for DataReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#protected-attributes-inherited-from-datacollectiondatareceiver","title":"Protected Attributes inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name std::vector&lt; T &gt; storage Vector to store shared_ptr data objects of type T."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#detailed-description","title":"Detailed Description","text":"<p>GameReceiver is an extension of the generic DataReceiver, specialized to handle data related to games. It provides methods for storing and processing game-specific data types such as GameData. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#function-gamereceiver","title":"function GameReceiver","text":"<pre><code>DataCollection::GameReceiver::GameReceiver () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#function-store_gamedata","title":"function store_GameData","text":"<p>Store a GameData object into the receiver's storage.</p> <pre><code>inline void DataCollection::GameReceiver::store_GameData (\n    const GameData &amp; gameData\n) \n</code></pre> <p>This method allows for the addition of game-specific data into the receiver's storage for further processing or analysis.</p> <p>Parameters:</p> <ul> <li><code>gameData</code> The GameData object to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#function-gamereceiver_1","title":"function ~GameReceiver","text":"<pre><code>DataCollection::GameReceiver::~GameReceiver () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/GameReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/","title":"Class DataCollection::ItemUseCollector","text":"<p>ClassList &gt; DataCollection &gt; ItemUseCollector</p> <p>A data collector class for usage amount of game items. More...</p> <ul> <li><code>#include &lt;ItemUseCollector.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#public-functions","title":"Public Functions","text":"Type Name std::string GetLeastFrequent ()  std::string GetMostFrequent ()  int GetNumberOfItems ()  const std::unordered_map&lt; std::string, int &gt; &amp; GetUsageData ()  void IncrementItemUsage (const std::string &amp; itemName)  ItemUseCollector () = defaultDamage storage map of item name to amount of uses. void WriteToItemUseFile (std::string path)"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#detailed-description","title":"Detailed Description","text":"<p>Useful for setting up graphs for analysis of item balancing. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-getleastfrequent","title":"function GetLeastFrequent","text":"<pre><code>inline std::string DataCollection::ItemUseCollector::GetLeastFrequent () \n</code></pre> <p>Get the least frequently used item in the game. </p> <p>Returns:</p> <p>Name of the least item as a string, empty string if no data </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-getmostfrequent","title":"function GetMostFrequent","text":"<pre><code>inline std::string DataCollection::ItemUseCollector::GetMostFrequent () \n</code></pre> <p>Get the most frequently used item in the game. </p> <p>Returns:</p> <p>Name of the most frequent item as a string, empty string if no data </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-getnumberofitems","title":"function GetNumberOfItems","text":"<pre><code>inline int DataCollection::ItemUseCollector::GetNumberOfItems () \n</code></pre> <p>Get the amount of unique items that are collected </p> <p>Returns:</p> <p>int amount of unique items </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-getusagedata","title":"function GetUsageData","text":"<pre><code>inline const std::unordered_map&lt; std::string, int &gt; &amp; DataCollection::ItemUseCollector::GetUsageData () \n</code></pre> <p>Getter for item usage data </p> <p>Returns:</p> <p>Const reference to the usage data storage. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-incrementitemusage","title":"function IncrementItemUsage","text":"<pre><code>inline void DataCollection::ItemUseCollector::IncrementItemUsage (\n    const std::string &amp; itemName\n) \n</code></pre> <p>Increment usage amount for a certain item. </p> <p>Parameters:</p> <ul> <li><code>itemName</code> Item name to record new usage of </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-itemusecollector","title":"function ItemUseCollector","text":"<p>Damage storage map of item name to amount of uses. </p> <pre><code>DataCollection::ItemUseCollector::ItemUseCollector () = default\n</code></pre> <p>Default constructor for ItemUseCollector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-writetoitemusefile","title":"function WriteToItemUseFile","text":"<pre><code>inline void DataCollection::ItemUseCollector::WriteToItemUseFile (\n    std::string path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/ItemUseCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/","title":"Class DataCollection::JsonBuilder","text":"<p>ClassList &gt; DataCollection &gt; JsonBuilder</p> <p>Builds a JSON object from the data collected for an agent. </p> <ul> <li><code>#include &lt;JsonBuilder.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#public-functions","title":"Public Functions","text":"Type Name void AddDamage (double damage)  void AddInt (std::string title, int usage)  void AddName (std::string name) Adds the agent's name to the JSON object. void AddPosition (cse491::GridPosition pos) Adds a grid position to the JSON object. void Addagentname (std::string name)  void ClearJSON ()  nlohmann::json GetJSON () Retrieves the JSON object. nlohmann::json GetJSONArray ()  void InputToArray (std::string title, nlohmann::json input)  JsonBuilder () = defaultDefault constructor for JSONBuilder class. void StartArray (std::string title)  void WriteToFile (std::ofstream &amp; jsonfilestream, nlohmann::json Json) Writes the JSON object to a file. ~JsonBuilder () = defaultDestructor for JSONBuilder class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-adddamage","title":"function AddDamage","text":"<pre><code>inline void DataCollection::JsonBuilder::AddDamage (\n    double damage\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-addint","title":"function AddInt","text":"<pre><code>inline void DataCollection::JsonBuilder::AddInt (\n    std::string title,\n    int usage\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-addname","title":"function AddName","text":"<p>Adds the agent's name to the JSON object. </p> <pre><code>inline void DataCollection::JsonBuilder::AddName (\n    std::string name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> The agent's name. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-addposition","title":"function AddPosition","text":"<p>Adds a grid position to the JSON object. </p> <pre><code>inline void DataCollection::JsonBuilder::AddPosition (\n    cse491::GridPosition pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position to be added. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-addagentname","title":"function Addagentname","text":"<pre><code>inline void DataCollection::JsonBuilder::Addagentname (\n    std::string name\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-clearjson","title":"function ClearJSON","text":"<pre><code>inline void DataCollection::JsonBuilder::ClearJSON () \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-getjson","title":"function GetJSON","text":"<p>Retrieves the JSON object. </p> <pre><code>inline nlohmann::json DataCollection::JsonBuilder::GetJSON () \n</code></pre> <p>Returns:</p> <p>The JSON object. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-getjsonarray","title":"function GetJSONArray","text":"<pre><code>inline nlohmann::json DataCollection::JsonBuilder::GetJSONArray () \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-inputtoarray","title":"function InputToArray","text":"<pre><code>inline void DataCollection::JsonBuilder::InputToArray (\n    std::string title,\n    nlohmann::json input\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-jsonbuilder","title":"function JsonBuilder","text":"<pre><code>DataCollection::JsonBuilder::JsonBuilder () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-startarray","title":"function StartArray","text":"<pre><code>inline void DataCollection::JsonBuilder::StartArray (\n    std::string title\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-writetofile","title":"function WriteToFile","text":"<pre><code>inline void DataCollection::JsonBuilder::WriteToFile (\n    std::ofstream &amp; jsonfilestream,\n    nlohmann::json Json\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-jsonbuilder_1","title":"function ~JsonBuilder","text":"<pre><code>DataCollection::JsonBuilder::~JsonBuilder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/JsonBuilder.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Data%20Collection%28Group%202%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir DataCollection <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Data%20Collection%28Group%202%29/dir_8adf75fe53ae17187785c216cf2633db/","title":"Dir source/DataCollection","text":"<p>FileList &gt; DataCollection</p>"},{"location":"Data%20Collection%28Group%202%29/dir_8adf75fe53ae17187785c216cf2633db/#files","title":"Files","text":"Type Name file AgentData.hpp file AgentInteractionCollector.hpp file AgentReciever.hpp file DamageCollector.hpp file DamageData.hpp file DamageReceiver.hpp file DataManager.hpp file DataReceiver.hpp file GameData.hpp file GameReceiver.hpp file ItemUseCollector.hpp file JsonBuilder.hpp <p>The documentation for this class was generated from the following file <code>source/DataCollection/</code></p>"},{"location":"Data%20Collection%28Group%202%29/_agent_data_8hpp/","title":"File AgentData.hpp","text":"<p>FileList &gt; DataCollection &gt; AgentData.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_agent_data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_agent_data_8hpp/#classes","title":"Classes","text":"Type Name class AgentData Represents data collected for an agent, including their name, actions, positions, and associated IDs. <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_agent_data_8hpp_source/","title":"File AgentData.hpp","text":"<p>File List &gt; DataCollection &gt; AgentData.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;string&gt;\n#include &lt;list&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include \"../core/GridPosition.hpp\"\n\nnamespace DataCollection\n{\n    class AgentData {\n    private:\n        std::string name;  \n        std::vector&lt;int&gt; actionIds;  \n        std::vector&lt;cse491::GridPosition&gt; position;  \n        std::vector&lt;std::unordered_map&lt;std::string,size_t&gt;&gt; actions;  \n\n    public:\n//        AgentData() = default;\n        AgentData(std::string name) : name(std::move(name)) {}\n\n        ~AgentData() = default;\n\n        void StorePositions(cse491::GridPosition pos) {\n            position.push_back(pos);\n        }\n\n        void StoreAction(std::unordered_map&lt;std::string, size_t&gt; action) {\n            actions.push_back(action);\n        }\n\n        void StoreAgentId(int id) {\n            actionIds.push_back(id);\n        }\n\n        auto&amp; GetActions() {\n            return actions;\n        }\n\n        int GetActionSize() const {\n            return actions.size();\n        }\n\n        void SetActions(const std::vector&lt;std::unordered_map&lt;std::string, size_t&gt;&gt;&amp; newActions) {\n            actions = newActions;\n        }\n\n        int GetPositionSize() const {\n            return position.size();\n        }\n\n        auto GetAgentIds() const {\n            return actionIds;\n        }\n\n        std::string GetName() const {\n            return name;\n        }\n\n        std::vector&lt;cse491::GridPosition&gt; GetPositions() const {\n            return position;\n        }\n    };\n} // namespace DataCollection\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_agent_interaction_collector_8hpp/","title":"File AgentInteractionCollector.hpp","text":"<p>FileList &gt; DataCollection &gt; AgentInteractionCollector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_agent_interaction_collector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_agent_interaction_collector_8hpp/#classes","title":"Classes","text":"Type Name class AgentInteractionCollector A data collector class to quantify agent interactions. <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentInteractionCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_agent_interaction_collector_8hpp_source/","title":"File AgentInteractionCollector.hpp","text":"<p>File List &gt; DataCollection &gt; AgentInteractionCollector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n    class AgentInteractionCollector {\n    private:\n        std::unordered_map&lt;std::string, int&gt; interactionData;  \n    public:\n        AgentInteractionCollector() = default;\n\n        const std::unordered_map&lt;std::string, int&gt;&amp; GetInteractionData() { return interactionData; }\n\n        size_t GetUniqueInteractions() { return interactionData.size(); }\n\n        void RecordInteraction(const std::string&amp; agentName) { interactionData[agentName]++; }\n\n        void WriteToInteractionFile(const std::string filename){\n            JsonBuilder json_builder;\n            std::ofstream jsonfilestream(filename);\n            json_builder.StartArray(\"agentInteractions\");\n            for (auto&amp; [agentName, interactionCount] : interactionData) {\n                json_builder.AddName(agentName);\n                json_builder.AddInt(\"interactionCount\", interactionCount);\n                json_builder.InputToArray(\"agentInteractions\", json_builder.GetJSON());\n                json_builder.ClearJSON();\n            }\n            json_builder.WriteToFile(jsonfilestream, json_builder.GetJSONArray());\n            jsonfilestream.close();\n        }\n\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_agent_reciever_8hpp/","title":"File AgentReciever.hpp","text":"<p>FileList &gt; DataCollection &gt; AgentReciever.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include \"DataReceiver.hpp\"</code></li> <li><code>#include \"AgentData.hpp\"</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_agent_reciever_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_agent_reciever_8hpp/#classes","title":"Classes","text":"Type Name class AgentReceiver Data receiver class specialized for storing AgentData objects. <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentReciever.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_agent_reciever_8hpp_source/","title":"File AgentReciever.hpp","text":"<p>File List &gt; DataCollection &gt; AgentReciever.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;filesystem&gt;\n#include \"DataReceiver.hpp\"\n#include \"AgentData.hpp\"\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n    class AgentReceiver : public DataReceiver&lt;AgentData&gt; {\n    private:\n        std::unordered_map&lt;std::string, std::shared_ptr&lt;AgentData&gt;&gt; agent_map;\n\n    public:\n        void StoreData(std::string name, cse491::GridPosition pos, [[maybe_unused]] int last_action) {\n            std::shared_ptr&lt;AgentData&gt; agent = GetAgent(name);\n            agent-&gt;StorePositions(pos);\n//            agent-&gt;StoreAction(last_action);\n            StoreIntoStorage(*agent);\n        }\n\n//        void StoreIntoStorage(AgentData obj) override {\n//            storage.push_back(obj);\n//        }\n\n        void AddAgent(const std::string&amp; name) {\n            AgentData agent(name);\n            agent_map[name] = std::make_shared&lt;AgentData&gt;(agent);\n\n        }\n\n        std::shared_ptr&lt;AgentData&gt; GetAgent(const std::string&amp; name)\n        {\n            if (agent_map.find(name)==agent_map.end()) {\n                AddAgent(name);\n                return agent_map[name];\n            }\n            else {\n                return agent_map[name];\n            }\n        }\n\n        AgentData GetAgentData(const std::string&amp; name) {\n            return *agent_map[name];\n        }\n\n        void WriteToPositionFile(std::string path) {\n            std::ofstream jsonfilestream(path);\n            JsonBuilder json_builder;\n            json_builder.StartArray(\"AgentPositions\");\n            for (auto&amp; agent : agent_map) {\n                json_builder.Addagentname(agent.first);\n                for (auto&amp; pos: agent.second-&gt;GetPositions()) {\n                    json_builder.AddPosition(pos);\n                }\n                json_builder.InputToArray(\"AgentPositions\", json_builder.GetJSON());\n                json_builder.ClearJSON();\n            }\n            json_builder.WriteToFile(jsonfilestream, json_builder.GetJSONArray());\n            jsonfilestream.close();\n        }\n    };\n} // namespace DataCollection\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_damage_collector_8hpp/","title":"File DamageCollector.hpp","text":"<p>FileList &gt; DataCollection &gt; DamageCollector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_damage_collector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_damage_collector_8hpp/#classes","title":"Classes","text":"Type Name class DamageCollector A data collector class for damage of game items. <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_damage_collector_8hpp_source/","title":"File DamageCollector.hpp","text":"<p>File List &gt; DataCollection &gt; DamageCollector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;fstream&gt;\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n     class DamageCollector {\n     private:\n         std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; damageData;  // Damage storage map of item name to damage amounts\n     public:\n         DamageCollector() = default;\n\n         void RecordDamageResult(const std::string&amp; itemName, double damageAmt) {\n             damageData[itemName].push_back(damageAmt);\n         }\n\n         std::vector&lt;double&gt;&amp; GetDamageAmounts(std::string itemName) {\n             if (damageData.contains(itemName)) {\n                 return damageData[itemName];\n             } else {\n                 // Created only once, subsequent calls will reference this\n                 static std::vector&lt;double&gt; empty;\n                 return empty;\n             }\n         }\n\n        double CalculateAverageDamage(const std::string&amp; itemName) {\n             if (damageData.contains(itemName)) {\n                 std::vector&lt;double&gt;&amp; damages = damageData[itemName];\n                 return std::accumulate(damages.begin(), damages.end(), 0.0) / damages.size();\n             }\n\n             return -1.0;\n         }\n\n         void WriteToDamageFile(std::string path) {\n             std::ofstream jsonfilestream(path);\n             JsonBuilder json_builder;\n             for (auto&amp; damage : damageData) {\n                 json_builder.AddName(damage.first);\n                 for (auto&amp; damageAmt : damage.second) {\n                     json_builder.AddDamage(damageAmt);\n                 }\n             }\n         }\n     };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_damage_data_8hpp/","title":"File DamageData.hpp","text":"<p>FileList &gt; DataCollection &gt; DamageData.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"../core/Entity.hpp\"</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_damage_data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_damage_data_8hpp/#classes","title":"Classes","text":"Type Name class DamageData Represents damage related data between an agent and other entities (agents, items, grids, etc) <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_damage_data_8hpp_source/","title":"File DamageData.hpp","text":"<p>File List &gt; DataCollection &gt; DamageData.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n#include \"../core/Entity.hpp\"\n#include \"../core/AgentBase.hpp\"\n\nnamespace DataCollection {\n\n    class DamageData {\n    private:\n        std::shared_ptr&lt;cse491::AgentBase&gt; agent;   \n        std::shared_ptr&lt;cse491::Entity&gt; source;     \n        int amount;                                 \n\n    public:\n        DamageData(std::shared_ptr&lt;cse491::AgentBase&gt; agnt,\n                   std::shared_ptr&lt;cse491::Entity&gt; src,\n                   int amt) : agent(std::move(agnt)), source(std::move(src)), amount(amt) {}\n\n        ~DamageData() = default;\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_damage_receiver_8hpp/","title":"File DamageReceiver.hpp","text":"<p>FileList &gt; DataCollection &gt; DamageReceiver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"DataReceiver.hpp\"</code></li> <li><code>#include \"DamageData.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_damage_receiver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_damage_receiver_8hpp/#classes","title":"Classes","text":"Type Name class DamageReceiver Data receiver class specialized for storing DamageData objects. <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_damage_receiver_8hpp_source/","title":"File DamageReceiver.hpp","text":"<p>File List &gt; DataCollection &gt; DamageReceiver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include \"DataReceiver.hpp\"\n#include \"DamageData.hpp\"\n\nnamespace DataCollection {\n\n    class DamageReceiver : public DataReceiver&lt;DamageData&gt; {\n\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_data_manager_8hpp/","title":"File DataManager.hpp","text":"<p>FileList &gt; DataCollection &gt; DataManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AgentReciever.hpp\"</code></li> <li><code>#include \"GameReceiver.hpp\"</code></li> <li><code>#include \"DamageCollector.hpp\"</code></li> <li><code>#include \"ItemUseCollector.hpp\"</code></li> <li><code>#include \"AgentInteractionCollector.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_data_manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_data_manager_8hpp/#classes","title":"Classes","text":"Type Name class DataManager Represents a data control system to hold all related receivers and collectors. <p>The documentation for this class was generated from the following file <code>source/DataCollection/DataManager.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_data_manager_8hpp_source/","title":"File DataManager.hpp","text":"<p>File List &gt; DataCollection &gt; DataManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include \"AgentReciever.hpp\"\n#include \"GameReceiver.hpp\"\n#include \"DamageCollector.hpp\"\n#include \"ItemUseCollector.hpp\"\n#include \"AgentInteractionCollector.hpp\"\n\nnamespace DataCollection {\n\n    class DataManager {\n    private:\n        AgentReceiver agentReceiver;                            \n        GameReceiver gameReceiver;                              \n        DamageCollector damageCollector;                        \n        ItemUseCollector itemUseCollector;                      \n        AgentInteractionCollector agentInteractionCollector;    \n        DataManager() {}\n\n        DataManager(const DataManager&amp;) = delete;\n        DataManager&amp; operator=(const DataManager&amp;) = delete;\n    public:\n         ~DataManager() = default;\n\n         static DataManager&amp; GetInstance() {\n             static DataManager instance;\n             return instance;\n         }\n\n         AgentReceiver&amp; GetAgentReceiver() {\n             return agentReceiver;\n         }\n\n        AgentInteractionCollector&amp; GetAgentInteractionCollector() {\n            return agentInteractionCollector;\n        }\n\n         ItemUseCollector&amp; GetItemUseCollector() {\n             return itemUseCollector;\n         }\n\n        const GameReceiver&amp; GetGameReceiver() {\n            return gameReceiver;\n        }\n\n        const DamageCollector&amp; GetDamageCollector() {\n            return damageCollector;\n        }\n\n        void WriteToJson() {\n            std::filesystem::path currentPath = std::filesystem::current_path().parent_path().parent_path();\n            currentPath = currentPath / \"source\" / \"DataCollection\" / \"GRAPH\";\n            // Construct the full path to the data directory and the damage_data.json file\n            std::filesystem::path DamagefilePath = currentPath  / \"damage_data.json\";\n            std::filesystem::path ItemUsefilePath = currentPath  / \"itemUsage.json\";\n            std::filesystem::path ItemdamagefilePath = currentPath  / \"itemDamage.json\";\n            std::filesystem::path PositionfilePath = currentPath  / \"gridPositions.json\";\n            std::filesystem::path InteractionfilePath = currentPath  / \"agentInteractions.json\";\n            agentReceiver.WriteToPositionFile(PositionfilePath.string());\n            itemUseCollector.WriteToItemUseFile(ItemUsefilePath.string());\n            agentInteractionCollector.WriteToInteractionFile(InteractionfilePath.string());\n        }\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_data_receiver_8hpp/","title":"File DataReceiver.hpp","text":"<p>FileList &gt; DataCollection &gt; DataReceiver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_data_receiver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_data_receiver_8hpp/#classes","title":"Classes","text":"Type Name class DataReceiver &lt;typename T&gt;Generic data receiver template class. <p>The documentation for this class was generated from the following file <code>source/DataCollection/DataReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_data_receiver_8hpp_source/","title":"File DataReceiver.hpp","text":"<p>File List &gt; DataCollection &gt; DataReceiver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;vector&gt;\nnamespace DataCollection {\n\n    template &lt;typename T&gt;\n    class DataReceiver {\n    public:\n        DataReceiver() = default;\n\n        virtual ~DataReceiver() = default;\n\n        std::vector&lt;T&gt;&amp; getStorage() {\n            return storage;\n        }\n\n        void StoreIntoStorage(T obj){\n            storage.push_back(obj);\n        }\n\n        bool IsEmpty() {\n            return storage.empty();\n        }\n\n    protected:\n        std::vector&lt;T&gt; storage; \n    };\n} // namespace DataCollection\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_game_data_8hpp/","title":"File GameData.hpp","text":"<p>FileList &gt; DataCollection &gt; GameData.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_game_data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_game_data_8hpp/#classes","title":"Classes","text":"Type Name class GameData <p>The documentation for this class was generated from the following file <code>source/DataCollection/GameData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_game_data_8hpp_source/","title":"File GameData.hpp","text":"<p>File List &gt; DataCollection &gt; GameData.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;vector&gt;\n#include\"../core/GridPosition.hpp\"\nnamespace DataCollection{\n    class GameData{\n    private:\n        /* number of collisions */\n        int numOfCol;\n\n        std::vector&lt;int&gt;collisions;\n        std::vector&lt;size_t&gt;shortestPathAction; \n        std::vector&lt;cse491::GridPosition&gt;shortestPathPos;\n    public:\n        GameData() = default;\n\n        ~GameData() = default;\n\n        int getNumOfCol() const {\n            return numOfCol;\n        }\n\n        void setNumOfCol(int value) {\n            numOfCol = value;\n        }\n\n        void StoreCollision(int collision) {\n            collisions.push_back(collision);\n        }\n\n        const std::vector&lt;int&gt;&amp; GetCollisions() const {\n            return collisions;\n        }\n\n        void StoreShortestPathAction(size_t action) {\n            shortestPathAction.push_back(action);\n        }\n\n        const std::vector&lt;size_t&gt;&amp; GetShortestPathActions() const {\n            return shortestPathAction;\n        }\n\n        void StoreShortestPathPos(const cse491::GridPosition pos) {\n            shortestPathPos.push_back(pos);\n        }\n\n        const std::vector&lt;cse491::GridPosition&gt; GetShortestPathPos() const {\n            return shortestPathPos;\n        }\n    };\n    }\n\n\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_game_receiver_8hpp/","title":"File GameReceiver.hpp","text":"<p>FileList &gt; DataCollection &gt; GameReceiver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"GameData.hpp\"</code></li> <li><code>#include \"DataReceiver.hpp\"</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_game_receiver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_game_receiver_8hpp/#classes","title":"Classes","text":"Type Name class GameReceiver Represents a receiver specifically designed to handle game-related data. <p>The documentation for this class was generated from the following file <code>source/DataCollection/GameReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_game_receiver_8hpp_source/","title":"File GameReceiver.hpp","text":"<p>File List &gt; DataCollection &gt; GameReceiver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;iostream&gt;\n#include \"GameData.hpp\"\n#include \"DataReceiver.hpp\"\n#include \"../core/GridPosition.hpp\"\n#include &lt;unordered_map&gt;\n#include &lt;fstream&gt;\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n    class GameReceiver : public DataReceiver&lt;GameData&gt; {\n    public:\n        GameReceiver() = default;\n\n        ~GameReceiver() override = default;\n\n        void store_GameData(const GameData&amp; gameData) {\n            this-&gt;storage.push_back(gameData);\n        }\n    };\n\n}\n\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_item_use_collector_8hpp/","title":"File ItemUseCollector.hpp","text":"<p>FileList &gt; DataCollection &gt; ItemUseCollector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_item_use_collector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_item_use_collector_8hpp/#classes","title":"Classes","text":"Type Name class ItemUseCollector A data collector class for usage amount of game items. <p>The documentation for this class was generated from the following file <code>source/DataCollection/ItemUseCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_item_use_collector_8hpp_source/","title":"File ItemUseCollector.hpp","text":"<p>File List &gt; DataCollection &gt; ItemUseCollector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n    class ItemUseCollector {\n    private:\n        std::unordered_map&lt;std::string, int&gt; usageData;  \n    public:\n        ItemUseCollector() = default;\n\n        const std::unordered_map&lt;std::string, int&gt;&amp; GetUsageData() {\n            return usageData;\n        }\n\n        int GetNumberOfItems() {\n            return usageData.size();\n        }\n\n        void IncrementItemUsage(const std::string&amp; itemName) {\n            usageData[itemName]++;\n        }\n\n        std::string GetMostFrequent() {\n            if (!usageData.empty()) {\n                auto maxItr = std::max_element(usageData.begin(), usageData.end(),\n                        [](const auto&amp; firstItem, const auto&amp; secondItem) {\n                            return firstItem.second &lt; secondItem.second;\n                        }\n                );\n\n                return maxItr-&gt;first;\n            }\n\n            return \"\";\n        }\n\n        std::string GetLeastFrequent() {\n            if (!usageData.empty()) {\n                auto maxItr = std::min_element(usageData.begin(), usageData.end(),\n                        [](const auto&amp; firstItem, const auto&amp; secondItem) {\n                            return firstItem.second &lt; secondItem.second;\n                        }\n                );\n\n                return maxItr-&gt;first;\n            }\n\n            return \"\";\n        }\n\n        void WriteToItemUseFile(std::string path)\n        {\n            JsonBuilder json_builder;\n            std::ofstream jsonfilestream(path);\n            json_builder.StartArray(\"items\");\n            for (auto&amp; usage: usageData) {\n                json_builder.AddName(usage.first);\n                json_builder.AddInt(\"amountOfUses\", usage.second);\n                json_builder.InputToArray(\"items\", json_builder.GetJSON());\n                json_builder.ClearJSON();\n            }\n            json_builder.WriteToFile(jsonfilestream, json_builder.GetJSONArray());\n            jsonfilestream.close();\n        }\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_json_builder_8hpp/","title":"File JsonBuilder.hpp","text":"<p>FileList &gt; DataCollection &gt; JsonBuilder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_json_builder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_json_builder_8hpp/#classes","title":"Classes","text":"Type Name class JsonBuilder Builds a JSON object from the data collected for an agent. <p>The documentation for this class was generated from the following file <code>source/DataCollection/JsonBuilder.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_json_builder_8hpp_source/","title":"File JsonBuilder.hpp","text":"<p>File List &gt; DataCollection &gt; JsonBuilder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;fstream&gt;\n#include \"../core/GridPosition.hpp\"\n#include &lt;nlohmann/json.hpp&gt;\n\nnamespace DataCollection{\n    class JsonBuilder {\n    private:\n        nlohmann::json json;  \n        nlohmann::json json_array;\n    public:\n        JsonBuilder() = default;\n\n        ~JsonBuilder() = default;\n\n        void StartArray(std::string title) {\n            json_array[title] = nlohmann::json::array();\n        }\n\n        void InputToArray(std::string title, nlohmann::json input) {\n            json_array[title].push_back(input);\n        }\n\n        void AddName(std::string name) {\n            json[\"name\"] = name;\n        }\n\n        void Addagentname(std::string name) {\n            json[\"agentname\"] = name;\n        }\n\n        void AddPosition(cse491::GridPosition pos) {\n            json[\"positions\"].push_back({{\"x\", pos.GetX()}, {\"y\", pos.GetY()}});\n        }\n\n        void AddDamage(double damage) {\n            json[\"damage\"].push_back(damage);\n        }\n\n        nlohmann::json GetJSON() {\n            return json;\n        }\n\n        void ClearJSON() {\n            json.clear();\n        }\n\n        nlohmann::json GetJSONArray() {\n            return json_array;\n        }\n\n        void AddInt(std::string title, int usage) {\n            json[title] = usage;\n        }\n\n        void WriteToFile(std::ofstream &amp;jsonfilestream, nlohmann::json Json)\n        {\n            jsonfilestream &lt;&lt; Json.dump(4);\n        }\n    };\n} // namespace DataCollection\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace DataCollection </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/","title":"Class Index","text":""},{"location":"Data%20Collection%28Group%202%29/classes/#a","title":"a","text":"<ul> <li>AgentData (DataCollection)</li> <li>AgentInteractionCollector (DataCollection)</li> <li>AgentReceiver (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/#d","title":"d","text":"<ul> <li>DamageCollector (DataCollection)</li> <li>DamageData (DataCollection)</li> <li>DamageReceiver (DataCollection)</li> <li>DataManager (DataCollection)</li> <li>DataReceiver (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/#g","title":"g","text":"<ul> <li>GameData (DataCollection)</li> <li>GameReceiver (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/#i","title":"i","text":"<ul> <li>ItemUseCollector (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/#j","title":"j","text":"<ul> <li>JsonBuilder (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class DataCollection::AgentData Represents data collected for an agent, including their name, actions, positions, and associated IDs. </li> <li>class DataCollection::AgentInteractionCollector A data collector class to quantify agent interactions. </li> <li>class DataCollection::DataReceiver Generic data receiver template class. </li> <li>class DataCollection::DamageCollector A data collector class for damage of game items. </li> <li>class DataCollection::DamageData Represents damage related data between an agent and other entities (agents, items, grids, etc) </li> <li>class DataCollection::DataManager Represents a data control system to hold all related receivers and collectors. </li> <li>class DataCollection::GameData </li> <li>class DataCollection::ItemUseCollector A data collector class for usage amount of game items. </li> <li>class DataCollection::JsonBuilder Builds a JSON object from the data collected for an agent. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Data%20Collection%28Group%202%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Data%20Collection%28Group%202%29/class_members/","title":"Class Members","text":""},{"location":"Data%20Collection%28Group%202%29/class_members/#a","title":"a","text":"<ul> <li>AgentData (DataCollection::AgentData)</li> <li>actionIds (DataCollection::AgentData)</li> <li>actions (DataCollection::AgentData)</li> <li>AgentInteractionCollector (DataCollection::AgentInteractionCollector)</li> <li>AddAgent (DataCollection::AgentReceiver)</li> <li>agent_map (DataCollection::AgentReceiver)</li> <li>agent (DataCollection::DamageData)</li> <li>amount (DataCollection::DamageData)</li> <li>agentInteractionCollector (DataCollection::DataManager)</li> <li>agentReceiver (DataCollection::DataManager)</li> <li>AddDamage (DataCollection::JsonBuilder)</li> <li>AddInt (DataCollection::JsonBuilder)</li> <li>AddName (DataCollection::JsonBuilder)</li> <li>AddPosition (DataCollection::JsonBuilder)</li> <li>Addagentname (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#c","title":"c","text":"<ul> <li>CalculateAverageDamage (DataCollection::DamageCollector)</li> <li>collisions (DataCollection::GameData)</li> <li>ClearJSON (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#d","title":"d","text":"<ul> <li>DamageCollector (DataCollection::DamageCollector)</li> <li>damageData (DataCollection::DamageCollector)</li> <li>DamageData (DataCollection::DamageData)</li> <li>DataManager (DataCollection::DataManager)</li> <li>damageCollector (DataCollection::DataManager)</li> <li>DataReceiver (DataCollection::DataReceiver)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#g","title":"g","text":"<ul> <li>GetActionSize (DataCollection::AgentData)</li> <li>GetActions (DataCollection::AgentData)</li> <li>GetAgentIds (DataCollection::AgentData)</li> <li>GetName (DataCollection::AgentData)</li> <li>GetPositionSize (DataCollection::AgentData)</li> <li>GetPositions (DataCollection::AgentData)</li> <li>GetInteractionData (DataCollection::AgentInteractionCollector)</li> <li>GetUniqueInteractions (DataCollection::AgentInteractionCollector)</li> <li>GetAgent (DataCollection::AgentReceiver)</li> <li>GetAgentData (DataCollection::AgentReceiver)</li> <li>GetDamageAmounts (DataCollection::DamageCollector)</li> <li>GetAgentInteractionCollector (DataCollection::DataManager)</li> <li>GetAgentReceiver (DataCollection::DataManager)</li> <li>GetDamageCollector (DataCollection::DataManager)</li> <li>GetGameReceiver (DataCollection::DataManager)</li> <li>GetInstance (DataCollection::DataManager)</li> <li>GetItemUseCollector (DataCollection::DataManager)</li> <li>gameReceiver (DataCollection::DataManager)</li> <li>getStorage (DataCollection::DataReceiver)</li> <li>GameData (DataCollection::GameData)</li> <li>GetCollisions (DataCollection::GameData)</li> <li>GetShortestPathActions (DataCollection::GameData)</li> <li>GetShortestPathPos (DataCollection::GameData)</li> <li>getNumOfCol (DataCollection::GameData)</li> <li>GameReceiver (DataCollection::GameReceiver)</li> <li>GetLeastFrequent (DataCollection::ItemUseCollector)</li> <li>GetMostFrequent (DataCollection::ItemUseCollector)</li> <li>GetNumberOfItems (DataCollection::ItemUseCollector)</li> <li>GetUsageData (DataCollection::ItemUseCollector)</li> <li>GetJSON (DataCollection::JsonBuilder)</li> <li>GetJSONArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#i","title":"i","text":"<ul> <li>interactionData (DataCollection::AgentInteractionCollector)</li> <li>itemUseCollector (DataCollection::DataManager)</li> <li>IsEmpty (DataCollection::DataReceiver)</li> <li>IncrementItemUsage (DataCollection::ItemUseCollector)</li> <li>ItemUseCollector (DataCollection::ItemUseCollector)</li> <li>InputToArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#j","title":"j","text":"<ul> <li>JsonBuilder (DataCollection::JsonBuilder)</li> <li>json (DataCollection::JsonBuilder)</li> <li>json_array (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#n","title":"n","text":"<ul> <li>name (DataCollection::AgentData)</li> <li>numOfCol (DataCollection::GameData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#o","title":"o","text":"<ul> <li>operator= (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#p","title":"p","text":"<ul> <li>position (DataCollection::AgentData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#r","title":"r","text":"<ul> <li>RecordInteraction (DataCollection::AgentInteractionCollector)</li> <li>RecordDamageResult (DataCollection::DamageCollector)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#s","title":"s","text":"<ul> <li>SetActions (DataCollection::AgentData)</li> <li>StoreAction (DataCollection::AgentData)</li> <li>StoreAgentId (DataCollection::AgentData)</li> <li>StorePositions (DataCollection::AgentData)</li> <li>StoreData (DataCollection::AgentReceiver)</li> <li>source (DataCollection::DamageData)</li> <li>StoreIntoStorage (DataCollection::DataReceiver)</li> <li>storage (DataCollection::DataReceiver)</li> <li>StoreCollision (DataCollection::GameData)</li> <li>StoreShortestPathAction (DataCollection::GameData)</li> <li>StoreShortestPathPos (DataCollection::GameData)</li> <li>setNumOfCol (DataCollection::GameData)</li> <li>shortestPathAction (DataCollection::GameData)</li> <li>shortestPathPos (DataCollection::GameData)</li> <li>store_GameData (DataCollection::GameReceiver)</li> <li>StartArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#u","title":"u","text":"<ul> <li>usageData (DataCollection::ItemUseCollector)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#w","title":"w","text":"<ul> <li>WriteToInteractionFile (DataCollection::AgentInteractionCollector)</li> <li>WriteToPositionFile (DataCollection::AgentReceiver)</li> <li>WriteToDamageFile (DataCollection::DamageCollector)</li> <li>WriteToJson (DataCollection::DataManager)</li> <li>WriteToItemUseFile (DataCollection::ItemUseCollector)</li> <li>WriteToFile (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#_1","title":"~","text":"<ul> <li>~AgentData (DataCollection::AgentData)</li> <li>~DamageData (DataCollection::DamageData)</li> <li>~DataManager (DataCollection::DataManager)</li> <li>~DataReceiver (DataCollection::DataReceiver)</li> <li>~GameData (DataCollection::GameData)</li> <li>~GameReceiver (DataCollection::GameReceiver)</li> <li>~JsonBuilder (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#a","title":"a","text":"<ul> <li>AgentData (DataCollection::AgentData)</li> <li>AgentInteractionCollector (DataCollection::AgentInteractionCollector)</li> <li>AddAgent (DataCollection::AgentReceiver)</li> <li>AddDamage (DataCollection::JsonBuilder)</li> <li>AddInt (DataCollection::JsonBuilder)</li> <li>AddName (DataCollection::JsonBuilder)</li> <li>AddPosition (DataCollection::JsonBuilder)</li> <li>Addagentname (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#c","title":"c","text":"<ul> <li>CalculateAverageDamage (DataCollection::DamageCollector)</li> <li>ClearJSON (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#d","title":"d","text":"<ul> <li>DamageCollector (DataCollection::DamageCollector)</li> <li>DamageData (DataCollection::DamageData)</li> <li>DataManager (DataCollection::DataManager)</li> <li>DataReceiver (DataCollection::DataReceiver)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#g","title":"g","text":"<ul> <li>GetActionSize (DataCollection::AgentData)</li> <li>GetActions (DataCollection::AgentData)</li> <li>GetAgentIds (DataCollection::AgentData)</li> <li>GetName (DataCollection::AgentData)</li> <li>GetPositionSize (DataCollection::AgentData)</li> <li>GetPositions (DataCollection::AgentData)</li> <li>GetInteractionData (DataCollection::AgentInteractionCollector)</li> <li>GetUniqueInteractions (DataCollection::AgentInteractionCollector)</li> <li>GetAgent (DataCollection::AgentReceiver)</li> <li>GetAgentData (DataCollection::AgentReceiver)</li> <li>GetDamageAmounts (DataCollection::DamageCollector)</li> <li>GetAgentInteractionCollector (DataCollection::DataManager)</li> <li>GetAgentReceiver (DataCollection::DataManager)</li> <li>GetDamageCollector (DataCollection::DataManager)</li> <li>GetGameReceiver (DataCollection::DataManager)</li> <li>GetInstance (DataCollection::DataManager)</li> <li>GetItemUseCollector (DataCollection::DataManager)</li> <li>getStorage (DataCollection::DataReceiver)</li> <li>GameData (DataCollection::GameData)</li> <li>GetCollisions (DataCollection::GameData)</li> <li>GetShortestPathActions (DataCollection::GameData)</li> <li>GetShortestPathPos (DataCollection::GameData)</li> <li>getNumOfCol (DataCollection::GameData)</li> <li>GameReceiver (DataCollection::GameReceiver)</li> <li>GetLeastFrequent (DataCollection::ItemUseCollector)</li> <li>GetMostFrequent (DataCollection::ItemUseCollector)</li> <li>GetNumberOfItems (DataCollection::ItemUseCollector)</li> <li>GetUsageData (DataCollection::ItemUseCollector)</li> <li>GetJSON (DataCollection::JsonBuilder)</li> <li>GetJSONArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#i","title":"i","text":"<ul> <li>IsEmpty (DataCollection::DataReceiver)</li> <li>IncrementItemUsage (DataCollection::ItemUseCollector)</li> <li>ItemUseCollector (DataCollection::ItemUseCollector)</li> <li>InputToArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#j","title":"j","text":"<ul> <li>JsonBuilder (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#r","title":"r","text":"<ul> <li>RecordInteraction (DataCollection::AgentInteractionCollector)</li> <li>RecordDamageResult (DataCollection::DamageCollector)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#s","title":"s","text":"<ul> <li>SetActions (DataCollection::AgentData)</li> <li>StoreAction (DataCollection::AgentData)</li> <li>StoreAgentId (DataCollection::AgentData)</li> <li>StorePositions (DataCollection::AgentData)</li> <li>StoreData (DataCollection::AgentReceiver)</li> <li>StoreIntoStorage (DataCollection::DataReceiver)</li> <li>StoreCollision (DataCollection::GameData)</li> <li>StoreShortestPathAction (DataCollection::GameData)</li> <li>StoreShortestPathPos (DataCollection::GameData)</li> <li>setNumOfCol (DataCollection::GameData)</li> <li>store_GameData (DataCollection::GameReceiver)</li> <li>StartArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#w","title":"w","text":"<ul> <li>WriteToInteractionFile (DataCollection::AgentInteractionCollector)</li> <li>WriteToPositionFile (DataCollection::AgentReceiver)</li> <li>WriteToDamageFile (DataCollection::DamageCollector)</li> <li>WriteToJson (DataCollection::DataManager)</li> <li>WriteToItemUseFile (DataCollection::ItemUseCollector)</li> <li>WriteToFile (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~AgentData (DataCollection::AgentData)</li> <li>~DamageData (DataCollection::DamageData)</li> <li>~DataManager (DataCollection::DataManager)</li> <li>~DataReceiver (DataCollection::DataReceiver)</li> <li>~GameData (DataCollection::GameData)</li> <li>~GameReceiver (DataCollection::GameReceiver)</li> <li>~JsonBuilder (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#a","title":"a","text":"<ul> <li>actionIds (DataCollection::AgentData)</li> <li>actions (DataCollection::AgentData)</li> <li>agent_map (DataCollection::AgentReceiver)</li> <li>agent (DataCollection::DamageData)</li> <li>amount (DataCollection::DamageData)</li> <li>agentInteractionCollector (DataCollection::DataManager)</li> <li>agentReceiver (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#c","title":"c","text":"<ul> <li>collisions (DataCollection::GameData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#d","title":"d","text":"<ul> <li>damageData (DataCollection::DamageCollector)</li> <li>damageCollector (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#g","title":"g","text":"<ul> <li>gameReceiver (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#i","title":"i","text":"<ul> <li>interactionData (DataCollection::AgentInteractionCollector)</li> <li>itemUseCollector (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#j","title":"j","text":"<ul> <li>json (DataCollection::JsonBuilder)</li> <li>json_array (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#n","title":"n","text":"<ul> <li>name (DataCollection::AgentData)</li> <li>numOfCol (DataCollection::GameData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#p","title":"p","text":"<ul> <li>position (DataCollection::AgentData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#s","title":"s","text":"<ul> <li>source (DataCollection::DamageData)</li> <li>storage (DataCollection::DataReceiver)</li> <li>shortestPathAction (DataCollection::GameData)</li> <li>shortestPathPos (DataCollection::GameData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#u","title":"u","text":"<ul> <li>usageData (DataCollection::ItemUseCollector)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Data%20Collection%28Group%202%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Data%20Collection%28Group%202%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Data%20Collection%28Group%202%29/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Data%20Collection%28Group%202%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Data%20Collection%28Group%202%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cse491 A low-end text interface providing a bare-minimum level of interaction. <ul> <li>class TrashInterface </li> </ul> </li> <li>namespace i_2D <ul> <li>class Button </li> <li>class Inventory </li> <li>class MainInterface Represents the main interface for a 2D maze game. </li> <li>class Menu </li> <li>class MessageBoard </li> <li>class TextBox </li> <li>class TextureHolder </li> </ul> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Interfaces <ul> <li>file Button.cpp </li> <li>file Button.hpp </li> <li>file Inventory.cpp </li> <li>file Inventory.hpp </li> <li>file MainInterface.cpp MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. </li> <li>file MainInterface.hpp MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. </li> <li>file Menu.cpp </li> <li>file Menu.hpp </li> <li>file MessageBoard.cpp </li> <li>file MessageBoard.hpp </li> <li>file TextBox.cpp </li> <li>file TextBox.hpp </li> <li>file TextureHolder.cpp </li> <li>file TextureHolder.hpp </li> <li>file TrashInterface.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>A low-end text interface providing a bare-minimum level of interaction. More...</p>"},{"location":"2D%20Interface%28Group%203%29/namespacecse491/#classes","title":"Classes","text":"Type Name class TrashInterface"},{"location":"2D%20Interface%28Group%203%29/namespacecse491/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TrashInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/","title":"Class cse491::TrashInterface","text":"<p>ClassList &gt; cse491 &gt; TrashInterface</p> <p>Inherits the following classes: InterfaceBase</p>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#public-functions","title":"Public Functions","text":"Type Name bool Initialize () override void Notify (const std::string &amp; message, const std::string &amp;=\"none\") override size_t SelectAction (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) override TrashInterface (size_t id, const std::string &amp; name)  ~TrashInterface () = default"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#protected-attributes","title":"Protected Attributes","text":"Type Name bool wait_for_input   = = trueShould we pause and wait for the user to hit a key?"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#protected-functions","title":"Protected Functions","text":"Type Name void DrawGrid (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map)"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-initialize","title":"function Initialize","text":"<pre><code>inline bool cse491::TrashInterface::Initialize () override\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-notify","title":"function Notify","text":"<pre><code>inline void cse491::TrashInterface::Notify (\n    const std::string &amp; message,\n    const std::string &amp;=\"none\"\n) override\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cse491::TrashInterface::SelectAction (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) override\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-trashinterface","title":"function TrashInterface","text":"<pre><code>inline cse491::TrashInterface::TrashInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-trashinterface_1","title":"function ~TrashInterface","text":"<pre><code>cse491::TrashInterface::~TrashInterface () = default\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#variable-wait_for_input","title":"variable wait_for_input","text":"<pre><code>bool wait_for_input;\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-drawgrid","title":"function DrawGrid","text":"<pre><code>inline void cse491::TrashInterface::DrawGrid (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TrashInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/","title":"Namespace i_2D","text":"<p>Namespace List &gt; i_2D</p> <p>More...</p>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#classes","title":"Classes","text":"Type Name class Button class Inventory class MainInterface Represents the main interface for a 2D maze game. class Menu class MessageBoard class TextBox class TextureHolder"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#public-attributes","title":"Public Attributes","text":"Type Name const int MAX_NUMBER_OF_ITEMS_MENU_ITEMS   = = 3 float elapsedTime   = = 0.0f sf::Clock timer"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>: Team - 3 </p> <p>Date:</p> <p>: 11/02/2023 Button class creates a SF::Rectangle and SF::Text on top</p> <p>Author:</p> <p>: Team - 3 </p> <p>Date:</p> <p>: 11/15/2023 Inventory class creates an array of buttons and uses it as inventory</p> <p>Author:</p> <p>: Team - 3 </p> <p>Date:</p> <p>: 10/3/2023 Menu class creates a menu and displays it in the render window </p>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#variable-max_number_of_items_menu_items","title":"variable MAX_NUMBER_OF_ITEMS_MENU_ITEMS","text":"<pre><code>const int MAX_NUMBER_OF_ITEMS_MENU_ITEMS;\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#variable-elapsedtime","title":"variable elapsedTime","text":"<pre><code>float elapsedTime;\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#variable-timer","title":"variable timer","text":"<pre><code>sf::Clock timer;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Button.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/","title":"Class i_2D::Button","text":"<p>ClassList &gt; i_2D &gt; Button</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#public-functions","title":"Public Functions","text":"Type Name Button (const std::string &amp; t, sf::Vector2f size, sf::Color bgColor, sf::Color textColor, const sf::Font &amp; font) Construct the text with font. Then set text and shape properties with params. void DrawTo (sf::RenderWindow &amp; window) draws the button onto the window bool IsMouseOver (sf::RenderWindow &amp; window) checks if mouse position is in a button void SetBackColor (sf::Color color) set the background color of the button void SetButtonSize (sf::Vector2f size) set the button size void SetFont (const sf::Font &amp; font) set the font of the button void SetMFont (const sf::Font &amp; font) set the font of the button void SetPosition (sf::Vector2f pos) set the position of the button void SetString (const std::string &amp; s) set the string of the button void SetTextColor (sf::Color color) set the text color of the string"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-button","title":"function Button","text":"<p>Construct the text with font. Then set text and shape properties with params. </p> <pre><code>i_2D::Button::Button (\n    const std::string &amp; t,\n    sf::Vector2f size,\n    sf::Color bgColor,\n    sf::Color textColor,\n    const sf::Font &amp; font\n) \n</code></pre> <p>Constructs the button</p> <p>Parameters:</p> <ul> <li><code>t</code> the string to be displayed by button </li> <li><code>size</code> the size of the rectangle shape </li> <li><code>bgColor</code> the background color of the shape </li> <li><code>textColor</code> the color of the text </li> <li><code>font</code> the font style </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-drawto","title":"function DrawTo","text":"<p>draws the button onto the window </p> <pre><code>inline void i_2D::Button::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-ismouseover","title":"function IsMouseOver","text":"<p>checks if mouse position is in a button </p> <pre><code>bool i_2D::Button::IsMouseOver (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> </li> </ul> <p>Returns:</p> <p>returns turn if mouse position is in the button </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setbackcolor","title":"function SetBackColor","text":"<p>set the background color of the button </p> <pre><code>inline void i_2D::Button::SetBackColor (\n    sf::Color color\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>color</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setbuttonsize","title":"function SetButtonSize","text":"<p>set the button size </p> <pre><code>inline void i_2D::Button::SetButtonSize (\n    sf::Vector2f size\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setfont","title":"function SetFont","text":"<p>set the font of the button </p> <pre><code>inline void i_2D::Button::SetFont (\n    const sf::Font &amp; font\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setmfont","title":"function SetMFont","text":"<pre><code>void i_2D::Button::SetMFont (\n    const sf::Font &amp; font\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setposition","title":"function SetPosition","text":"<p>set the position of the button </p> <pre><code>void i_2D::Button::SetPosition (\n    sf::Vector2f pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> position on the window </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setstring","title":"function SetString","text":"<p>set the string of the button </p> <pre><code>inline void i_2D::Button::SetString (\n    const std::string &amp; s\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> label of the button </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-settextcolor","title":"function SetTextColor","text":"<p>set the text color of the string </p> <pre><code>inline void i_2D::Button::SetTextColor (\n    sf::Color color\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>color</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Button.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/","title":"Class i_2D::Inventory","text":"<p>ClassList &gt; i_2D &gt; Inventory</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#public-functions","title":"Public Functions","text":"Type Name void ConstructInventory (sf::Font &amp; font, const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory) Build an inventory window and an inventory list. void DrawTo (sf::RenderWindow &amp; window) Draws the inventory onto the render window. std::string HandleMouseMove (sf::RenderWindow &amp; window) Handle the mouse move event. Inventory (const sf::Vector2f size) Constructor - save the value of the world's dimension. void SetItemDisplay (sf::Texture &amp; texture) Set the Displayed item's texture. void SetSize (const sf::Vector2f size) Set the value saved as the world's dimension."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-constructinventory","title":"function ConstructInventory","text":"<p>Build an inventory window and an inventory list. </p> <pre><code>void i_2D::Inventory::ConstructInventory (\n    sf::Font &amp; font,\n    const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> The font used by the inventory list </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-drawto","title":"function DrawTo","text":"<p>Draws the inventory onto the render window. </p> <pre><code>void i_2D::Inventory::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> The render window of the world </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-handlemousemove","title":"function HandleMouseMove","text":"<p>Handle the mouse move event. </p> <pre><code>std::string i_2D::Inventory::HandleMouseMove (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> The render window of the world </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-inventory","title":"function Inventory","text":"<pre><code>inline explicit i_2D::Inventory::Inventory (\n    const sf::Vector2f size\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-setitemdisplay","title":"function SetItemDisplay","text":"<pre><code>inline void i_2D::Inventory::SetItemDisplay (\n    sf::Texture &amp; texture\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-setsize","title":"function SetSize","text":"<pre><code>inline void i_2D::Inventory::SetSize (\n    const sf::Vector2f size\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Inventory.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/","title":"Class i_2D::MainInterface","text":"<p>ClassList &gt; i_2D &gt; MainInterface</p> <p>Represents the main interface for a 2D maze game. More...</p> <ul> <li><code>#include &lt;MainInterface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: InterfaceBase</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#public-functions","title":"Public Functions","text":"Type Name void CheckLargerGrid ()  std::vector&lt; std::string &gt; CreateVectorMaze (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) Creates a vector representation of the maze grid. void DrawGrid (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) Draws the maze grid and entities on the SFML window. bool Initialize () overrideInitializes the main interface. MainInterface (size_t id, const std::string &amp; name) Constructs a <code>MainInterface</code> object. void Notify (const std::string &amp; message, const std::string &amp;=\"none\") overridenotifies the world if the player have any progress message size_t SelectAction (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) overrideHandles user input for selecting actions. void SetLargeGrid (bool b)  void setMInputWaitTime (double mInputWaitTime)  ~MainInterface () = defaultDestructor for the <code>MainInterface</code> class."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#detailed-description","title":"Detailed Description","text":"<p>This class inherits from <code>InterfaceBase</code> and provides functionality for creating and displaying a 2D maze game world, handling user input, and updating the graphical representation of the game. </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-checklargergrid","title":"function CheckLargerGrid","text":"<pre><code>void i_2D::MainInterface::CheckLargerGrid () \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-createvectormaze","title":"function CreateVectorMaze","text":"<p>Creates a vector representation of the maze grid. </p> <pre><code>std::vector&lt; std::string &gt; i_2D::MainInterface::CreateVectorMaze (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The WorldGrid representing the maze. </li> <li><code>type_options</code> The type options for symbols. </li> <li><code>item_map</code> The map of ids to items in the maze. </li> <li><code>agent_map</code> The map of ids to agents in the maze.</li> </ul> <p>Returns:</p> <p>A vector of strings representing the maze grid. </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-drawgrid","title":"function DrawGrid","text":"<p>Draws the maze grid and entities on the SFML window. </p> <pre><code>void i_2D::MainInterface::DrawGrid (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The WorldGrid representing the maze. </li> <li><code>type_options</code> The type options for symbols. </li> <li><code>item_map</code> The map of ids to items in the maze. </li> <li><code>agent_map</code> The map of ids to agents in t </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-initialize","title":"function Initialize","text":"<p>Initializes the main interface. </p> <pre><code>inline bool i_2D::MainInterface::Initialize () override\n</code></pre> <p>Returns:</p> <p>True if initialization is successful; otherwise, false. </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-maininterface","title":"function MainInterface","text":"<p>Constructs a <code>MainInterface</code> object.</p> <pre><code>i_2D::MainInterface::MainInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> The identifier for this interface. </li> <li><code>name</code> The name of this interface. </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-notify","title":"function Notify","text":"<p>notifies the world if the player have any progress message </p> <pre><code>inline void i_2D::MainInterface::Notify (\n    const std::string &amp; message,\n    const std::string &amp;=\"none\"\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>message</code> that notifies the world </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-selectaction","title":"function SelectAction","text":"<p>Handles user input for selecting actions. </p> <pre><code>size_t i_2D::MainInterface::SelectAction (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The WorldGrid representing the maze. </li> <li><code>type_options</code> The type options for symbols. </li> <li><code>item_map</code> The map of ids to items in the maze. </li> <li><code>agent_map</code> The map of ids to agents in the maze. </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-setlargegrid","title":"function SetLargeGrid","text":"<pre><code>inline void i_2D::MainInterface::SetLargeGrid (\n    bool b\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-setminputwaittime","title":"function setMInputWaitTime","text":"<pre><code>void i_2D::MainInterface::setMInputWaitTime (\n    double mInputWaitTime\n) \n</code></pre> <p>Sets the inputwait time for netwrok interface</p> <p>Parameters:</p> <ul> <li><code>waitTime</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-maininterface_1","title":"function ~MainInterface","text":"<pre><code>i_2D::MainInterface::~MainInterface () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MainInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/","title":"Class i_2D::Menu","text":"<p>ClassList &gt; i_2D &gt; Menu</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#public-functions","title":"Public Functions","text":"Type Name void ConstructInventory (const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory) Builds an inventory. void DeconstructInventory () Destroy the inventory object. void DrawTo (sf::RenderWindow &amp; window) draws each menu button to the window std::vector&lt; std::unique_ptr&lt; Button &gt; &gt; &amp; GetMenu () Getter for MenuBar. void HandleMouseButtonPressed (sf::RenderWindow &amp; window, const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory) check if the mouse click the exit button closes window accordingly std::string HandleMouseMove (sf::RenderWindow &amp; window) check for mouse hoovering over the menu buttons change button color accordingly void Initialize (sf::Font &amp; font, sf::Vector2f size) initialize the buttons at the top of the window bool IsInventoryOpen () Check if the inventory interface is open. void SetInventoryItemDisplay (sf::Texture &amp; texture)  void SetWorldSize (sf::Vector2f size) Keep track of the world's size."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-constructinventory","title":"function ConstructInventory","text":"<pre><code>inline void i_2D::Menu::ConstructInventory (\n    const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-deconstructinventory","title":"function DeconstructInventory","text":"<pre><code>inline void i_2D::Menu::DeconstructInventory () \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-drawto","title":"function DrawTo","text":"<p>draws each menu button to the window </p> <pre><code>void i_2D::Menu::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> the main window of the graphic interface </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-getmenu","title":"function GetMenu","text":"<p>Getter for MenuBar. </p> <pre><code>inline std::vector&lt; std::unique_ptr&lt; Button &gt; &gt; &amp; i_2D::Menu::GetMenu () \n</code></pre> <p>Returns:</p> <p>MenuBar </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-handlemousebuttonpressed","title":"function HandleMouseButtonPressed","text":"<p>check if the mouse click the exit button closes window accordingly </p> <pre><code>void i_2D::Menu::HandleMouseButtonPressed (\n    sf::RenderWindow &amp; window,\n    const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> the main window of the graphic interface </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-handlemousemove","title":"function HandleMouseMove","text":"<p>check for mouse hoovering over the menu buttons change button color accordingly </p> <pre><code>std::string i_2D::Menu::HandleMouseMove (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> the main window of the graphic interface </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-initialize","title":"function Initialize","text":"<pre><code>void i_2D::Menu::Initialize (\n    sf::Font &amp; font,\n    sf::Vector2f size\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-isinventoryopen","title":"function IsInventoryOpen","text":"<p>Check if the inventory interface is open. </p> <pre><code>inline bool i_2D::Menu::IsInventoryOpen () \n</code></pre> <p>Returns:</p> <p>True if inventory interface is on, otherwise false </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-setinventoryitemdisplay","title":"function SetInventoryItemDisplay","text":"<pre><code>inline void i_2D::Menu::SetInventoryItemDisplay (\n    sf::Texture &amp; texture\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>texture</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-setworldsize","title":"function SetWorldSize","text":"<p>Keep track of the world's size. </p> <pre><code>inline void i_2D::Menu::SetWorldSize (\n    sf::Vector2f size\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code> Size of the world </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Menu.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/","title":"Class i_2D::MessageBoard","text":"<p>ClassList &gt; i_2D &gt; MessageBoard</p> <p>More...</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#public-functions","title":"Public Functions","text":"Type Name void DrawTo (sf::RenderWindow &amp; window) Draws the message board onto the render window. MessageBoard (sf::Font &amp; font) Construct the message board. void Send (const std::string &amp; message) Set the text of the message board."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#detailed-description","title":"Detailed Description","text":"<p>is where the backend and users communicate by words </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#function-drawto","title":"function DrawTo","text":"<p>Draws the message board onto the render window. </p> <pre><code>void i_2D::MessageBoard::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> The render window to be drawn on </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#function-messageboard","title":"function MessageBoard","text":"<p>Construct the message board. </p> <pre><code>explicit i_2D::MessageBoard::MessageBoard (\n    sf::Font &amp; font\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> The font used by message borad </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#function-send","title":"function Send","text":"<p>Set the text of the message board. </p> <pre><code>inline void i_2D::MessageBoard::Send (\n    const std::string &amp; message\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>message</code> The message to set the text to </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MessageBoard.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/","title":"Class i_2D::TextBox","text":"<p>ClassList &gt; i_2D &gt; TextBox</p> <p>More...</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#public-functions","title":"Public Functions","text":"Type Name bool Contains (sf::Vector2f point) constChecks if a point is within the TextBox . void DrawTo (sf::RenderWindow &amp; window) Draws the text to the render window. std::string GetText () Get the string that was input by user. bool IsSelected () constChecks if TextBox is active. void SetFont (const sf::Font &amp; font) Set the font of the TextBox . void SetLimit (bool ToF) Set the limit of the TextBox . void SetLimit (bool ToF, int lim) Set the limit of the TextBox . void SetPosition (sf::Vector2f pos) The position of the TextBox . void SetSelected (bool sel) Setter for isSelected, updates the text displayed in the box. void SetString (const std::string &amp; s) Set the string of the text. TextBox () = default TextBox (const sf::Font &amp; font, int size=25, sf::Color color=sf::Color::Red, bool sel=false) Constructor. void TypedOn (sf::Event input) TypedOn event handler."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#detailed-description","title":"Detailed Description","text":"<p>is where users write to interface and the world </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-contains","title":"function Contains","text":"<p>Checks if a point is within the TextBox .</p> <pre><code>inline bool i_2D::TextBox::Contains (\n    sf::Vector2f point\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>point</code> an xy point to check the location of </li> </ul> <p>Returns:</p> <p>True if the point is in bounds, False otherwise </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-drawto","title":"function DrawTo","text":"<p>Draws the text to the render window. </p> <pre><code>void i_2D::TextBox::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> The render window to be drawn on </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-gettext","title":"function GetText","text":"<p>Get the string that was input by user. </p> <pre><code>inline std::string i_2D::TextBox::GetText () \n</code></pre> <p>Returns:</p> <p>Return the string </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-isselected","title":"function IsSelected","text":"<p>Checks if TextBox is active.</p> <pre><code>inline bool i_2D::TextBox::IsSelected () const\n</code></pre> <p>Returns:</p> <p>True if active, else False </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setfont","title":"function SetFont","text":"<p>Set the font of the TextBox .</p> <pre><code>inline void i_2D::TextBox::SetFont (\n    const sf::Font &amp; font\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> The font to be set to </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setlimit-12","title":"function SetLimit [1/2]","text":"<p>Set the limit of the TextBox .</p> <pre><code>inline void i_2D::TextBox::SetLimit (\n    bool ToF\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ToF</code> True of False </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setlimit-22","title":"function SetLimit [2/2]","text":"<p>Set the limit of the TextBox .</p> <pre><code>inline void i_2D::TextBox::SetLimit (\n    bool ToF,\n    int lim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ToF</code> True or False </li> <li><code>lim</code> The limit of the TextBox </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setposition","title":"function SetPosition","text":"<p>The position of the TextBox .</p> <pre><code>inline void i_2D::TextBox::SetPosition (\n    sf::Vector2f pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The position to be set to </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setselected","title":"function SetSelected","text":"<p>Setter for isSelected, updates the text displayed in the box. </p> <pre><code>void i_2D::TextBox::SetSelected (\n    bool sel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>sel</code> whether the TextBox is to be set selected or not </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setstring","title":"function SetString","text":"<p>Set the string of the text. </p> <pre><code>void i_2D::TextBox::SetString (\n    const std::string &amp; s\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The string to be set to </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-textbox-12","title":"function TextBox [1/2]","text":"<pre><code>i_2D::TextBox::TextBox () = default\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-textbox-22","title":"function TextBox [2/2]","text":"<p>Constructor. </p> <pre><code>explicit i_2D::TextBox::TextBox (\n    const sf::Font &amp; font,\n    int size=25,\n    sf::Color color=sf::Color::Red,\n    bool sel=false\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> The font used by TextBox </li> <li><code>size</code> The size of the text </li> <li><code>color</code> The color of the text </li> <li><code>sel</code> Set the activity of TextBox </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-typedon","title":"function TypedOn","text":"<p>TypedOn event handler. </p> <pre><code>void i_2D::TextBox::TypedOn (\n    sf::Event input\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>input</code> the new text that has been typed into the TextBox </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextBox.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/","title":"Class i_2D::TextureHolder","text":"<p>ClassList &gt; i_2D &gt; TextureHolder</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#public-functions","title":"Public Functions","text":"Type Name std::map&lt; char, sf::Texture &gt; GenerativeWorldTexture () This function loads texture for the generative world images group 6. const sf::Texture &amp; GetTexture (std::string id) Returns a held texture matching the given id. void LoadTexture (std::string id, std::string file_name) Stores a texture under the given id/name;. std::map&lt; char, sf::Texture &gt; ManualWorldTexture () This function loads texture for the manual world images group 8. std::map&lt; char, sf::Texture &gt; MazeTexture () This function loads texture for the maze world images - Default maze. std::map&lt; char, sf::Texture &gt; SecondWorldTexture () This function loads texture for the second world images group 4. TextureHolder () = default ~TextureHolder () = default"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-generativeworldtexture","title":"function GenerativeWorldTexture","text":"<p>This function loads texture for the generative world images group 6. </p> <pre><code>std::map&lt; char, sf::Texture &gt; i_2D::TextureHolder::GenerativeWorldTexture () \n</code></pre> <p>Returns:</p> <p>std::map&lt; name, texture&gt; returns the map, key is the name of the texture and values is the actual texture </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-gettexture","title":"function GetTexture","text":"<p>Returns a held texture matching the given id. </p> <pre><code>const sf::Texture &amp; i_2D::TextureHolder::GetTexture (\n    std::string id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> Identifier/Name of the texture stored. </li> </ul> <p>Returns:</p> <p>The sf::Texture matching the id. </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-loadtexture","title":"function LoadTexture","text":"<p>Stores a texture under the given id/name;. </p> <pre><code>void i_2D::TextureHolder::LoadTexture (\n    std::string id,\n    std::string file_name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> Identifier used to reference this texture in the future. </li> <li><code>file_name</code> File to load the texture from. </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-manualworldtexture","title":"function ManualWorldTexture","text":"<p>This function loads texture for the manual world images group 8. </p> <pre><code>std::map&lt; char, sf::Texture &gt; i_2D::TextureHolder::ManualWorldTexture () \n</code></pre> <p>Returns:</p> <p>std::map&lt; name, texture&gt; returns the map, key is the name of the texture and values is the actual texture </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-mazetexture","title":"function MazeTexture","text":"<p>This function loads texture for the maze world images - Default maze. </p> <pre><code>std::map&lt; char, sf::Texture &gt; i_2D::TextureHolder::MazeTexture () \n</code></pre> <p>Returns:</p> <p>std::map&lt; name, texture&gt; returns the map, key is the name of the texture and values is the actual texture </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-secondworldtexture","title":"function SecondWorldTexture","text":"<p>This function loads texture for the second world images group 4. </p> <pre><code>std::map&lt; char, sf::Texture &gt; i_2D::TextureHolder::SecondWorldTexture () \n</code></pre> <p>Returns:</p> <p>std::map&lt; name, texture&gt; returns the map, key is the name of the texture and values is the actual texture </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-textureholder","title":"function TextureHolder","text":"<pre><code>i_2D::TextureHolder::TextureHolder () = default\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-textureholder_1","title":"function ~TextureHolder","text":"<pre><code>i_2D::TextureHolder::~TextureHolder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextureHolder.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"2D%20Interface%28Group%203%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Interfaces <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"2D%20Interface%28Group%203%29/dir_e52260c07c5ca641bf485ae92612dd08/","title":"Dir source/Interfaces","text":"<p>FileList &gt; Interfaces</p>"},{"location":"2D%20Interface%28Group%203%29/dir_e52260c07c5ca641bf485ae92612dd08/#files","title":"Files","text":"Type Name file Button.cpp file Button.hpp file Inventory.cpp file Inventory.hpp file MainInterface.cpp MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. file MainInterface.hpp MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. file Menu.cpp file Menu.hpp file MessageBoard.cpp file MessageBoard.hpp file TextBox.cpp file TextBox.hpp file TextureHolder.cpp file TextureHolder.hpp file TrashInterface.hpp <p>The documentation for this class was generated from the following file <code>source/Interfaces/</code></p>"},{"location":"2D%20Interface%28Group%203%29/_button_8cpp/","title":"File Button.cpp","text":"<p>FileList &gt; Interfaces &gt; Button.cpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"Button.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_button_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_button_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>muiph </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Button.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_button_8cpp_source/","title":"File Button.cpp","text":"<p>File List &gt; Interfaces &gt; Button.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"Button.hpp\"\n\nnamespace i_2D {\n    Button::Button(const std::string &amp;t, sf::Vector2f size, sf::Color bgColor,\n                   sf::Color textColor, const sf::Font &amp;font) {\n        text = std::make_unique&lt;sf::Text&gt;(font);\n\n        text-&gt;setString(t);\n        text-&gt;setFillColor(textColor);\n\n        button.setSize(size);\n        button.setFillColor(bgColor);\n    }\n\n    void Button::SetMFont(const sf::Font &amp;font) {\n        text = std::make_unique&lt;sf::Text&gt;(font);\n    }\n\n    void Button::SetPosition(sf::Vector2f pos) {\n        button.setPosition(pos);\n        float xPos = (pos.x + button.getGlobalBounds().width / 2) - (text-&gt;getLocalBounds().width / 2);\n        float yPos = (pos.y + button.getGlobalBounds().height / 2) - (text-&gt;getLocalBounds().height / 2);\n        text-&gt;setPosition({xPos, yPos});\n    }\n\n    bool Button::IsMouseOver(sf::RenderWindow &amp;window) {\n        float mouseX = sf::Mouse::getPosition(window).x;\n        float mouseY = sf::Mouse::getPosition(window).y;\n\n        float btnPosX = button.getPosition().x;\n        float btnPosY = button.getPosition().y;\n\n        float btnXPosWidth = button.getPosition().x + button.getLocalBounds().width;\n        float btnYPosHeight = button.getPosition().y + button.getLocalBounds().height;\n\n        if (mouseX &lt; btnXPosWidth &amp;&amp; mouseX &gt; btnPosX &amp;&amp; mouseY &lt; btnYPosHeight &amp;&amp; mouseY &gt; btnPosY) {\n            return true;\n        }\n        return false;\n    }\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_button_8hpp/","title":"File Button.hpp","text":"<p>FileList &gt; Interfaces &gt; Button.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_button_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_button_8hpp/#classes","title":"Classes","text":"Type Name class Button <p>The documentation for this class was generated from the following file <code>source/Interfaces/Button.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_button_8hpp_source/","title":"File Button.hpp","text":"<p>File List &gt; Interfaces &gt; Button.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;memory&gt;\n\nnamespace i_2D {\n    /***\n     * @class Button\n     *\n     * @brief Simple RectangleShape and a Text inside the shape\n     * Responsive rectangles on the Renderwindow that handles mouse's hover and click events\n     */\n    class Button {\n    private:\n        sf::RectangleShape button;\n        std::unique_ptr&lt;sf::Text&gt; text;\n\n\n    public:\n        Button(const std::string &amp;t, sf::Vector2f size, sf::Color bgColor,\n               sf::Color textColor, const sf::Font &amp;font);\n\n        void SetString(const std::string &amp;s){\n            text-&gt;setString(s);\n        }\n\n        void SetMFont(const sf::Font &amp;font);\n\n        void SetFont(const sf::Font &amp;font) {\n            text-&gt;setFont(font);\n        }\n\n        void SetButtonSize(sf::Vector2f size){\n            button.setSize(size);\n        }\n\n        void SetBackColor(sf::Color color){\n            button.setFillColor(color);\n        }\n\n        void SetTextColor(sf::Color color){\n            text-&gt;setFillColor(color);\n        }\n\n        void SetPosition(sf::Vector2f pos);\n\n        void DrawTo(sf::RenderWindow &amp;window){\n            window.draw(button);\n            window.draw(*text);\n        }\n\n        bool IsMouseOver(sf::RenderWindow &amp;window);\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8cpp/","title":"File Inventory.cpp","text":"<p>FileList &gt; Interfaces &gt; Inventory.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"Inventory.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D <p>The documentation for this class was generated from the following file <code>source/Interfaces/Inventory.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8cpp_source/","title":"File Inventory.cpp","text":"<p>File List &gt; Interfaces &gt; Inventory.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include &lt;algorithm&gt;\n#include \"Inventory.hpp\"\n\nnamespace i_2D {\n    void Inventory::ConstructInventory(sf::Font &amp;font, const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory) {\n        mCanvas = std::make_unique&lt;sf::RectangleShape&gt;();\n        mCanvas-&gt;setSize({mWorldSize.x, mWorldSize.y / 2});\n        mCanvas-&gt;setFillColor(sf::Color::Black);\n        mCanvas-&gt;setPosition(sf::Vector2f{0.f, 50.f});\n\n        mItems.clear();\n        mItems.resize(interfaceAgentInventory.size());\n        std::copy(interfaceAgentInventory.begin(), interfaceAgentInventory.end(), \n            mItems.begin());\n\n        // Set row &amp; col sizes\n        if (mWorldSize.x &gt; 1800) {\n            mCol = 5;\n        } else mCol = 3;\n        if (mWorldSize.y &gt; 900) {\n            mRow = 4;\n        } else mRow = 3;\n\n        // Create 2d vector of buttons\n        size_t Index = 0;\n        for (int i = 0; i &lt; mRow; i++) {\n            std::vector&lt;std::unique_ptr&lt;Button&gt;&gt; v1;\n            for (int j = 0; j &lt; mCol; j++) {\n                v1.push_back(std::make_unique&lt;Button&gt;(\n                        \"\", sf::Vector2f{(mWorldSize.x) / mCol, (mWorldSize.y / 2 - 50) / mRow},\n                        sf::Color::Black, sf::Color::White, font));\n                if (Index &lt; mItems.size()) {\n                    v1[j]-&gt;SetString(mItems[Index]);\n                    ++Index;\n                } else {\n                    v1[j]-&gt;SetString(\"empty\");\n                }\n                v1[j]-&gt;SetPosition(sf::Vector2f{j * (mWorldSize.x / mCol),\n                                                mWorldSize.y / 2 + 50 + i * (mWorldSize.y / 2 - 50) / mRow});\n            }\n            mListOfButtons.push_back(std::move(v1));\n        }\n    }\n\n    void Inventory::DrawTo(sf::RenderWindow &amp;window) {\n        window.draw(*mCanvas);\n        for (const auto &amp;x: mListOfButtons) {\n            for (const auto &amp;y: x) {\n                y-&gt;DrawTo(window);\n            }\n        }\n        if(mItemDisplay) {\n            sf::RectangleShape rect(\n                    sf::Vector2f(window.getSize().x/2-10,(window.getSize().y-50)/2-10));\n            rect.setPosition({5,55});\n            rect.setTexture(&amp;*mItemDisplay);\n            window.draw(rect);\n        }\n    }\n\n    std::string Inventory::HandleMouseMove(sf::RenderWindow &amp;window) {\n        std::string s1 = \"null\";\n        for(int i = 0; i &lt; mListOfButtons.size(); ++i){\n            for(int j = 0; j &lt; mListOfButtons.size(); ++j){\n                if(mListOfButtons[i][j]-&gt;IsMouseOver(window)){\n                    mListOfButtons[i][j]-&gt;SetBackColor(sf::Color::Magenta);\n                    if(i*mCol+j &lt; mItems.size()){\n                        s1 = (mItems[i*mCol+j]);\n                        if(s1 == \"Boots\"){\n                            s1 = s1.substr(0,s1.size()-1);\n                        }\n                        s1[0] = tolower(s1[0]);\n                        s1 += \"Texture\";\n                    }\n                }else{\n                    mListOfButtons[i][j]-&gt;SetBackColor(sf::Color::Black);\n                }\n            }\n        }\n        return s1;\n    }\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8hpp/","title":"File Inventory.hpp","text":"<p>FileList &gt; Interfaces &gt; Inventory.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include \"Button.hpp\"</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_inventory_8hpp/#classes","title":"Classes","text":"Type Name class Inventory <p>The documentation for this class was generated from the following file <code>source/Interfaces/Inventory.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8hpp_source/","title":"File Inventory.hpp","text":"<p>File List &gt; Interfaces &gt; Inventory.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include \"Button.hpp\"\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nnamespace i_2D {\n    /***\n     * @class Inventory\n     *\n     * @brief Represent the inventory of entities.\n     *\n     * An interface/visual representation of an inventory.\n     */\n    class Inventory {\n    private:\n        std::unique_ptr&lt;sf::RectangleShape&gt; mCanvas;\n        std::vector&lt;std::vector&lt;std::unique_ptr&lt;Button&gt;&gt;&gt; mListOfButtons;\n        sf::Vector2f mWorldSize; \n        int mCol=0; \n        int mRow=0; \n\n        std::vector&lt;std::string&gt; mItems; \n        std::unique_ptr&lt;sf::Texture&gt; mItemDisplay; \n\n    public:\n        void SetItemDisplay(sf::Texture &amp;texture){\n            if(mItemDisplay) mItemDisplay.reset();\n            mItemDisplay = std::make_unique&lt;sf::Texture&gt;(texture);\n        }\n        explicit Inventory(const sf::Vector2f size) : mWorldSize(size) {}\n        void SetSize(const sf::Vector2f size) {\n            mWorldSize = size;\n        }\n        void ConstructInventory(sf::Font &amp;font,const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory);\n        void DrawTo(sf::RenderWindow &amp;window);\n        std::string HandleMouseMove(sf::RenderWindow &amp;window);\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8cpp/","title":"File MainInterface.cpp","text":"<p>FileList &gt; Interfaces &gt; MainInterface.cpp</p> <p>Go to the source code of this file</p> <p>MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. More...</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include \"MainInterface.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Authors:</p> <p>Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>10/03/2023  </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MainInterface.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8cpp_source/","title":"File MainInterface.cpp","text":"<p>File List &gt; Interfaces &gt; MainInterface.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include &lt;map&gt;\n#include \"MainInterface.hpp\"\n\nnamespace i_2D {\n\n    sf::Clock timer; // To drawTimer function\n    float elapsedTime = 0.0f; // Sets elapsed time  = 0.0\n\n    MainInterface::MainInterface(size_t id, const std::string &amp;name) : InterfaceBase(id, name),\n                                                                       mWindow(sf::VideoMode({1000, 800}),\n                                                                               \"Maze Window\") {\n        if (!mFont.loadFromFile(\"../../assets/font/ArialNarrow7.ttf\")) {\n            std::cout &lt;&lt; \"Error loading font file: ../assets/font/ArialNarrow7.ttf\" &lt;&lt; std::endl;\n        }\n        mMessageBoard = std::make_unique&lt;MessageBoard&gt;(mFont);\n        mTextBox = std::make_unique&lt;TextBox&gt;(mFont);\n        auto a = mWindow.getSize().x;\n        auto b = mWindow.getSize().y;\n        mMenu.Initialize(mFont, sf::Vector2f{static_cast&lt;float&gt;(a), static_cast&lt;float&gt;(b)});\n        ChooseTexture();\n    }\n\n    std::vector&lt;std::string&gt; MainInterface::CreateVectorMaze(\n            const WorldGrid &amp;grid, const type_options_t &amp;type_options,\n            const item_map_t &amp;item_map, const agent_map_t &amp;agent_map) {\n\n        std::vector&lt;std::string&gt; symbol_grid(grid.GetHeight());\n\n        mGridHeight = grid.GetHeight();\n        mGridWidth = grid.GetWidth();\n\n        // Load the world into the symbol_grid;\n        for (size_t y = 0; y &lt; grid.GetHeight(); ++y) {\n            symbol_grid[y].resize(grid.GetWidth());\n            for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n                symbol_grid[y][x] = type_options[grid.At(x, y)].symbol;\n            }\n        }\n\n        // Add in the entities\n        for (const auto &amp;[id, item_ptr]: item_map) {\n            GridPosition pos = item_ptr-&gt;GetPosition();\n            char c = '+';\n            if (item_ptr-&gt;HasProperty(\"symbol\")) {\n                c = item_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n            }\n            if(pos.CellX() &gt;= 0 &amp;&amp; pos.CellY() &gt;= 0 &amp;&amp; \n                pos.CellX() &lt; grid.GetWidth() &amp;&amp; pos.CellY() &lt; grid.GetHeight() &amp;&amp; \n                !item_ptr-&gt;IsOwned()){\n              symbol_grid[pos.CellY()][pos.CellX()] = c;\n            }\n        }\n\n        // Add in the agents\n        for (const auto &amp;[id, agent_ptr]: agent_map) {\n            GridPosition pos = agent_ptr-&gt;GetPosition();\n            char c = '*';\n            if (agent_ptr-&gt;HasProperty(\"symbol\")) {\n                c = agent_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n            }\n            if (!agent_ptr-&gt;HasProperty(\"deleted\")){\n                symbol_grid[pos.CellY()][pos.CellX()] = c;\n            }\n        }\n        return symbol_grid;\n    }\n\n    sf::Vector2f MainInterface::CalculateCellSize(const WorldGrid &amp;grid) {\n\n        float cellSizeWide, cellSizeTall;\n        if (mGridSizeLarge) {\n            cellSizeWide = mWindow.getSize().x / COL;\n            cellSizeTall = mWindow.getSize().y / ROW;\n        } else {\n            cellSizeWide = mWindow.getSize().x / grid.GetWidth();\n            cellSizeTall = mWindow.getSize().y / grid.GetHeight();\n        }\n\n        float cellSize = std::min(cellSizeWide, cellSizeTall);\n        return sf::Vector2f(cellSize, cellSize);\n    }\n\n    void MainInterface::DrawGrid(const WorldGrid &amp;grid, const type_options_t &amp;type_options, const item_map_t &amp;item_map,\n                                 const agent_map_t &amp;agent_map) {\n        // Clear old drawing\n        mWindow.clear(sf::Color::White);\n\n        // Check player's position\n        mPlayerPosition = sf::Vector2i(this-&gt;position.GetX(), this-&gt;position.GetY());\n\n        // Create grid of symbols representing the world\n        std::vector&lt;std::string&gt; symbol_grid;\n        std::vector&lt;std::string&gt; default_grid = CreateVectorMaze(grid, type_options, item_map, agent_map);\n\n        // Determine cell size\n        sf::Vector2f cellSize = CalculateCellSize(grid);\n        float drawSpaceWidth, drawSpaceHeight, drawCenterX, drawCenterY;\n        CalculateDrawSpace(grid, cellSize.x, drawSpaceWidth,\n                           drawSpaceHeight, drawCenterX, drawCenterY);\n\n        if (mGridSizeLarge) {\n            symbol_grid = LargeDisplayGrid(default_grid);\n        } else {\n            symbol_grid = default_grid;\n        }\n        //CheckLargerGrid();\n        // Create a render texture to draw the grid\n        sf::RenderTexture renderTexture;\n        [[maybe_unused]] bool success =\n          renderTexture.create({static_cast&lt;unsigned int&gt;(drawSpaceWidth), static_cast&lt;unsigned int&gt;(drawSpaceHeight)});\n\n        renderTexture.clear(sf::Color::White);\n\n        for (size_t iterY = 0; iterY &lt; symbol_grid.size(); ++iterY) {\n            for (size_t iterX = 0; iterX &lt; symbol_grid[0].size(); ++iterX) {\n                float cellPosX = static_cast&lt;float&gt;(iterX) * cellSize.x;\n                float cellPosY = static_cast&lt;float&gt;(iterY) * cellSize.y;\n                char symbol = symbol_grid[iterY][iterX];\n\n                sf::RectangleShape cellRect(sf::Vector2f(cellSize.x, cellSize.y));\n                cellRect.setPosition(sf::Vector2f(cellPosX, cellPosY));\n\n                sf::RectangleShape cell(sf::Vector2f(cellSize.x, cellSize.y));\n                cell.setPosition(sf::Vector2f(cellPosX, cellPosY));\n\n                SwitchCellSelect(renderTexture, cellRect, cell, symbol);\n            }\n        }\n        renderTexture.display();\n        DrawTimer();\n        DrawHealthInfo();\n\n        // Draw the texture to the window\n        sf::Sprite sprite(renderTexture.getTexture());\n        sprite.setPosition({drawCenterX, drawCenterY});\n        mWindow.draw(sprite);\n\n        // Display everything\n        mTextBox-&gt;DrawTo(mWindow);\n        mMessageBoard-&gt;DrawTo(mWindow);\n        mMenu.DrawTo(mWindow);\n        mWindow.display();\n    }\n\n    void MainInterface::DrawTimer() {\n        // Get elapsed time in seconds\n        elapsedTime = timer.getElapsedTime().asSeconds();\n\n        // Set up font and location\n        sf::Text timerText(mFont);\n        timerText.setCharacterSize(24);\n        timerText.setPosition({750.0f, 75.0f}); // Adjust position as needed\n\n        // Format the elapsed time with 2 decimal points\n        std::ostringstream stream;\n        stream &lt;&lt; \"Time: \" &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; elapsedTime &lt;&lt; \" S\";\n        std::string formattedTime = stream.str();\n\n        // Create text for current value\n        timerText.setString(formattedTime);\n        timerText.setFillColor(sf::Color::Blue);\n        mWindow.draw(timerText);\n    }\n\n    void MainInterface::DrawHealthInfo() {\n        if(!HasProperty(\"Health\")) return;\n\n        int health = property_map.at(\"Health\")-&gt;ToInt();\n\n        // Set text properties and draw\n        sf::Text healthText(mFont);\n        healthText.setCharacterSize(24);\n        healthText.setPosition({20.0f, 75.0f});\n        healthText.setFillColor(sf::Color::Green);\n        healthText.setString(\"Hp: \" + std::to_string(health));\n        mWindow.draw(healthText);\n    }\n\n    std::vector&lt;std::string&gt; MainInterface::LargeDisplayGrid(const std::vector&lt;std::string&gt; &amp;symbol_grid) {\n        // Determine the top-left corner of the 9x23 window\n        int topLeftX = std::max(0,\n                                std::min(mPlayerPosition.x - COL / 2, static_cast&lt;int&gt;(symbol_grid[0].size()) - COL));\n        int topLeftY = std::max(0, std::min(mPlayerPosition.y - ROW / 2, static_cast&lt;int&gt;(symbol_grid.size()) - ROW));\n\n        // Create a new symbol grid for the 9x23 display window\n        std::vector&lt;std::string&gt; display_grid;\n        for (int iterY = 0; iterY &lt; ROW; ++iterY) {\n            std::string row;\n            for (int iterX = 0; iterX &lt; COL; ++iterX) {\n                int posX = topLeftX + iterX;\n                int posY = topLeftY + iterY;\n\n                // Copy the symbol from symbol_grid to display_grid\n                row.push_back(symbol_grid[posY][posX]);\n            }\n            display_grid.push_back(row);\n        }\n\n        return display_grid;\n    }\n\n    void MainInterface::CalculateDrawSpace(const WorldGrid &amp;grid, float cellSize, float &amp;drawSpaceWidth,\n                                           float &amp;drawSpaceHeight, float &amp;drawCenterX, float &amp;drawCenterY) {\n        if (mGridSizeLarge) {\n            drawSpaceWidth = static_cast&lt;float&gt;(COL) * cellSize;\n            drawSpaceHeight = static_cast&lt;float&gt;(ROW) * cellSize;\n        } else {\n            drawSpaceWidth = static_cast&lt;float&gt;(grid.GetWidth()) * cellSize;\n            drawSpaceHeight = static_cast&lt;float&gt;(grid.GetHeight()) * cellSize;\n        }\n\n        drawCenterX = (mWindow.getSize().x - drawSpaceWidth) / 2.0f;\n        drawCenterY = (mWindow.getSize().y - drawSpaceHeight) / 2.0f;\n    }\n\n    size_t MainInterface::SelectAction(const WorldGrid &amp;grid,\n                                       const type_options_t &amp;type_options,\n                                       const item_map_t &amp;item_map,\n                                       const agent_map_t &amp;agent_map) {\n        // Initialize action_id and timer\n        size_t action_id = 0;\n        timer.restart();\n\n        // While the timer is going\n        while (mWindow.isOpen() &amp;&amp; timer.getElapsedTime().asSeconds() &lt; mInputWaitTime) {\n            sf::Event event;\n\n            // Check through all events generated in this frame\n            while (mWindow.pollEvent(event)) {\n                if (event.type == sf::Event::Closed) {\n                    mWindow.close();\n                    exitCleanup();\n\n                } else if (event.type == sf::Event::TextEntered) {\n                    if (mTextBox-&gt;IsSelected()) {\n                        mTextBox-&gt;TypedOn(event);\n                    }\n\n                } else if (event.type == sf::Event::KeyPressed) {\n                    action_id = HandleKeyEvent(event);\n\n                } else if (event.type == sf::Event::Resized) {\n                    HandleResize(event, grid);\n\n                } else if (event.type == sf::Event::MouseMoved) {\n                    auto textureName = mMenu.HandleMouseMove(mWindow);\n                    if(textureName!=\"null\"){\n                        auto texture = mTextureHolder.GetTexture(textureName);\n                        mMenu.SetInventoryItemDisplay(texture);\n                    }\n                } else if (event.type == sf::Event::MouseButtonPressed) {\n                    MouseClickEvent(event, GetID(), item_map);\n\n                }\n            }\n\n            // Check if a valid action was taken and return that if so\n            if (action_id != 0) {\n                return action_id;\n            }\n\n            // Otherwise update the screen drawing again...\n            DrawGrid(grid, type_options, item_map, agent_map);\n\n        }\n        // The timer has ended or the window has been closed\n        return 0;\n    }\n\n    size_t MainInterface::HandleKeyEvent(const sf::Event &amp;event) {\n        size_t action_id = 0;\n        if (mTextBox-&gt;IsSelected()) {\n            // TextBox is selected, handle specific cases\n            switch (event.key.code) {\n                case sf::Keyboard::Enter:\n                    mMessageBoard-&gt;Send(mTextBox-&gt;GetText());\n                    mTextBox-&gt;SetString(\"\");\n                    mTextBox-&gt;SetSelected(false);\n                    break;\n                case sf::Keyboard::Escape:\n                    mTextBox-&gt;SetString(\"\");\n                    mTextBox-&gt;SetSelected(false);\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            // TextBox is not selected, handle movement keys\n            switch (event.key.code) {\n              case sf::Keyboard::W:\n                  if (mTextBox-&gt;IsSelected())break;\n                  action_id = GetActionID(\"up\");\n                  break;\n              case sf::Keyboard::A:\n                  if (mTextBox-&gt;IsSelected())break;\n                  action_id = GetActionID(\"left\");\n                  break;\n              case sf::Keyboard::S:\n                  if (mTextBox-&gt;IsSelected())break;\n                  action_id = GetActionID(\"down\");\n                  break;\n              case sf::Keyboard::D:\n                  if (mTextBox-&gt;IsSelected())break;\n                  action_id = GetActionID(\"right\");\n                  break;\n              case sf::Keyboard::Up:\n                  action_id = GetActionID(\"up\");\n                  break;\n              case sf::Keyboard::Left:\n                  action_id = GetActionID(\"left\");\n                  break;\n              case sf::Keyboard::Down:\n                  action_id = GetActionID(\"down\");\n                  break;\n              case sf::Keyboard::Right:\n                  action_id = GetActionID(\"right\");\n                  break;\n              case sf::Keyboard::H:\n                  action_id = GetActionID(\"heal\");\n                  break;\n              case sf::Keyboard::T:\n                  if (GetName() == \"Interface\") action_id = GetActionID(\"drop\");\n                  else if (GetName() == \"Interface3\") action_id = GetActionID(\"stats\");\n                  break;\n              case sf::Keyboard::C:\n                  action_id = GetActionID(\"use_axe\");\n                  break;\n              case sf::Keyboard::V:\n                  action_id = GetActionID(\"use_boat\");\n                  break;\n              case sf::Keyboard::F:\n                  action_id = GetActionID(\"attack\");\n                  break;\n              case sf::Keyboard::G:\n                  action_id = GetActionID(\"special\");\n                  break;\n              case sf::Keyboard::B:\n                  action_id = GetActionID(\"buff\");\n                  break;\n              case sf::Keyboard::R:\n                  action_id = GetActionID(\"run\");\n                  break;\n              case sf::Keyboard::Y:\n                  action_id = GetActionID(\"help\");\n                  break;\n              default:\n                  break; // The user pressed an unknown key.\n            }\n        }\n        // If we waited for input, but don't understand it, notify the user.\n        if (action_id == 0 &amp;&amp; !mTextBox-&gt;IsSelected()) {\n            std::cout &lt;&lt; \"Unknown key.\" &lt;&lt; std::endl;\n        }\n        // No action performed\n        return action_id;\n    }\n\n\n    void MainInterface::HandleResize(const sf::Event &amp;event, const WorldGrid &amp;grid) {\n        // Check size limits of window\n        float widthWindow = event.size.width;\n        float heightWindow = event.size.height;\n        float widthMin, heightMin;\n        if (mGridSizeLarge) {\n            widthMin = COL * MIN_SIZE_CELL;\n            heightMin = ROW * MIN_SIZE_CELL;\n        } else {\n            widthMin = grid.GetWidth() * MIN_SIZE_CELL;\n            heightMin = grid.GetHeight() * MIN_SIZE_CELL;\n        }\n\n        widthWindow = std::max(widthWindow, widthMin);\n        heightWindow = std::max(heightWindow, heightMin);\n\n        mMenu.SetWorldSize(sf::Vector2f(widthWindow, heightWindow));\n        if (mMenu.IsInventoryOpen()) {\n\n            mMenu.DeconstructInventory();\n            mMenu.ConstructInventory(mAgentInventory);\n        }\n        // Restrict window size if necessary\n        if (widthWindow &lt;= widthMin || heightWindow &lt;= heightMin) {\n            mWindow.setSize(sf::Vector2u(widthWindow, heightWindow));\n        }\n\n        // Resize the view to match window size to prevent deformation\n        sf::FloatRect viewArea(sf::Vector2f(0, 0), sf::Vector2f(widthWindow, heightWindow));\n        mWindow.setView(sf::View(viewArea));\n\n        // Update TextBox position for resizing\n        if (mTextBox) {\n            // Define the percentage values for the position\n            float xPosPercentage = 0.01f; // 5% of the window width\n            float yPosPercentage = 0.9f;  // 80% of the window height\n\n            // Calculate the actual position based on percentages\n            float xPos = (widthWindow * xPosPercentage);\n            float yPos = (heightWindow * yPosPercentage);\n\n            // Set the position of your textbox\n            mTextBox-&gt;SetPosition({xPos, yPos});\n\n        }\n    }\n\n    /*\n     * This function chooses the world to load the texture for it's images\n     * and sets the current texture map for drawing\n     */\n    void MainInterface::ChooseTexture() {\n        if (GetName() == \"Interface1\") {\n            mTexturesDefault = mTextureHolder.MazeTexture();\n            mTexturesCurrent = mTexturesDefault;\n        } else if (GetName() == \"Interface\") {\n            mTexturesSecondWorld = mTextureHolder.SecondWorldTexture();\n            mTexturesCurrent = mTexturesSecondWorld;\n        } else if (GetName() == \"Interface3\") {\n            mTexturesManualWorld = mTextureHolder.ManualWorldTexture();\n            mTexturesCurrent = mTexturesManualWorld;\n        } else if (GetName() == \"Interface2\") {\n            mTexturesGenerativeWorld = mTextureHolder.GenerativeWorldTexture();\n            mTexturesCurrent = mTexturesGenerativeWorld;\n        }\n\n    }\n\n    void MainInterface::MouseClickEvent(const sf::Event &amp;event, const size_t /*entity_id*/, const item_map_t &amp;item_map) {\n        if (event.mouseButton.button == sf::Mouse::Left) {\n            sf::Vector2f mousePos(static_cast&lt;float&gt;(event.mouseButton.x), static_cast&lt;float&gt;(event.mouseButton.y));\n\n            // Check if the mouse click is inside the TextBox bounds\n            if (mTextBox-&gt;Contains(mousePos)) {\n                // Toggle the selected state of the TextBox\n                mTextBox-&gt;SetSelected(!mTextBox-&gt;IsSelected());\n            } else {\n                // If the click is outside the TextBox, deselect it\n                mTextBox-&gt;SetSelected(false);\n            }\n\n            // Check if the mouse is over specific menu items\n            if (mMenu.GetMenu()[4]-&gt;IsMouseOver(mWindow) ) {\n                SetLargeGrid(true);\n            } else if (mMenu.GetMenu()[3]-&gt;IsMouseOver(mWindow)) {\n                SetLargeGrid(false);\n            } else if (mMenu.GetMenu()[2]-&gt;IsMouseOver(mWindow)) {\n                exitCleanup();\n            } else {\n                // Handle mouse button press for the general menu\n                mAgentInventory.clear();\n                for(const auto &amp;[x,y]:item_map){\n                    if(GetID() == y-&gt;GetOwnerID()){\n                        mAgentInventory.push_back(y-&gt;GetName());\n                    }\n                }\n                mMenu.HandleMouseButtonPressed(mWindow, mAgentInventory);\n            }\n        }\n    }\n\n    void MainInterface::SwitchCellSelect(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect,\n                                         sf::RectangleShape &amp;cell, char symbol) {\n        switch (symbol) {\n            case '#':\n                DrawWall(renderTexture, cellRect, mTexturesCurrent[symbol]);\n                break;\n            default:\n                DrawAgentCell(renderTexture, cellRect, cell, mTexturesCurrent[symbol]);\n                break;\n        }\n    }\n\n    void MainInterface::DrawAgentCell(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect,\n                                      sf::RectangleShape &amp;cell, sf::Texture &amp;agent) {\n        cellRect.setTexture(&amp;agent);\n        cell.setTexture(&amp;mTexturesCurrent[' ']);\n        if (&amp;agent == &amp;mTexturesCurrent['+'] and GetName() == \"Interface\") {\n            cellRect.setFillColor(sf::Color::Green);\n        }\n        renderTexture.draw(cell);\n        renderTexture.draw(cellRect);\n    }\n\n    void MainInterface::DrawWall(sf::RenderTexture &amp;renderTexture,\n                                 sf::RectangleShape &amp;cellRect, sf::Texture &amp;wallTexture) {\n\n        cellRect.setTexture(&amp;wallTexture);\n        renderTexture.draw(cellRect);\n    }\n    void MainInterface::setMInputWaitTime(double waitTime) {\n        MainInterface::mInputWaitTime = waitTime;\n    }\n\n    void MainInterface::CheckLargerGrid()\n    {\n        if (mGridWidth == mGridHeight)\n        {\n            mGridSizeLarge = true;\n        }\n    }\n\n\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp/","title":"File MainInterface.hpp","text":"<p>FileList &gt; Interfaces &gt; MainInterface.hpp</p> <p>Go to the source code of this file</p> <p>MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. More...</p> <ul> <li><code>#include \"SFML/Graphics.hpp\"</code></li> <li><code>#include \"SFML/Graphics/Transformable.hpp\"</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"Button.hpp\"</code></li> <li><code>#include \"Menu.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"../core/Data.hpp\"</code></li> <li><code>#include \"../core/InterfaceBase.hpp\"</code></li> <li><code>#include \"TextureHolder.hpp\"</code></li> <li><code>#include \"TextBox.hpp\"</code></li> <li><code>#include \"MessageBoard.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp/#classes","title":"Classes","text":"Type Name class MainInterface Represents the main interface for a 2D maze game."},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>:Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>: 10/03/2023 </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MainInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp_source/","title":"File MainInterface.hpp","text":"<p>File List &gt; Interfaces &gt; MainInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"SFML/Graphics.hpp\"\n#include \"SFML/Graphics/Transformable.hpp\"\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;sstream&gt;\n#include \"Button.hpp\"\n#include \"Menu.hpp\"\n#include &lt;memory&gt;\n\n#include \"../core/Data.hpp\"\n#include \"../core/InterfaceBase.hpp\"\n#include \"TextureHolder.hpp\"\n#include \"TextBox.hpp\"\n#include \"MessageBoard.hpp\"\n\n\nnamespace i_2D {\n\n    using namespace cse491;\n\n\n    class MainInterface : public virtual InterfaceBase {\n\n    private:\n        sf::RenderWindow mWindow; \n        float const MIN_SIZE_CELL = 16; \n\n        // Menu and message vars\n        Menu mMenu; \n        sf::Font mFont; \n        std::unique_ptr&lt;TextBox&gt; mTextBox; \n        std::unique_ptr&lt;MessageBoard&gt; mMessageBoard; \n        std::vector&lt;std::string&gt; mAgentInventory;\n\n        // Texture vars\n        TextureHolder mTextureHolder; \n        std::map&lt;char, sf::Texture&gt; mTexturesDefault; \n        std::map&lt;char, sf::Texture&gt; mTexturesSecondWorld; \n        std::map&lt;char, sf::Texture&gt; mTexturesManualWorld; \n        std::map&lt;char, sf::Texture&gt; mTexturesGenerativeWorld; \n        std::map&lt;char, sf::Texture&gt; mTexturesCurrent; \n\n        // Render range vars\n        sf::Vector2i mPlayerPosition = sf::Vector2i(0, 0); \n        bool mGridSizeLarge = false; \n        int const ROW = 9; \n        int const COL = 20; \n\n        int mGridWidth = 0; \n        int mGridHeight = 0; \n\n        double mInputWaitTime = 0.5f;  \n\n        size_t HandleKeyEvent(const sf::Event &amp;event);\n\n        void CalculateDrawSpace(const WorldGrid &amp;grid, float cellSize, float &amp;drawSpaceWidth, float &amp;drawSpaceHeight,\n                                float &amp;drawCenterX, float &amp;drawCenterY);\n\n        sf::Vector2f CalculateCellSize(const WorldGrid &amp;grid);\n\n        void HandleResize(const sf::Event &amp;event, const WorldGrid &amp;grid);\n\n        void ChooseTexture();\n\n        std::vector&lt;std::string&gt; LargeDisplayGrid(const std::vector&lt;std::string&gt; &amp;symbol_grid);\n\n        void MouseClickEvent(const sf::Event &amp;event,const size_t entity_id, const item_map_t &amp;item_map);\n\n        void DrawAgentCell(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect, sf::RectangleShape &amp;cell,\n                           sf::Texture &amp;agent);\n\n        void\n        SwitchCellSelect(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect, sf::RectangleShape &amp;cell,\n                         char symbol);\n\n        void DrawWall(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect, sf::Texture &amp;wallTexture);\n\n        void DrawTimer();\n\n        void DrawHealthInfo();\n\n    public:\n        MainInterface(size_t id, const std::string &amp;name);\n\n        ~MainInterface() = default;\n\n\n        std::vector&lt;std::string&gt; CreateVectorMaze(\n                const WorldGrid &amp;grid,\n                const type_options_t &amp;type_options,\n                const item_map_t &amp;item_map,\n                const agent_map_t &amp;agent_map);\n\n        void DrawGrid(const WorldGrid &amp;grid, const type_options_t &amp;type_options,\n                      const item_map_t &amp;item_map, const agent_map_t &amp;agent_map);\n\n        void setMInputWaitTime(double mInputWaitTime);\n        void SetLargeGrid(bool b){ mGridSizeLarge = b; } \n\n        bool Initialize() override {\n            return true;\n        }\n\n        size_t SelectAction(const WorldGrid &amp;grid,\n                            const type_options_t &amp;type_options,\n                            const item_map_t &amp;item_map,\n                            const agent_map_t &amp;agent_map) override;\n\n\n        void Notify(const std::string &amp;message,\n                    const std::string &amp; /*msg_type*/= \"none\") override {\n            std::cout &lt;&lt; message &lt;&lt; std::endl;\n            mMessageBoard-&gt;Send(message);\n        }\n\n        void CheckLargerGrid();\n    };\n\n} // End of namespace 2D\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/","title":"File Menu.cpp","text":"<p>FileList &gt; Interfaces &gt; Menu.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Menu.hpp\"</code></li> <li><code>#include &lt;SFML/Window.hpp&gt;</code></li> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/#public-functions","title":"Public Functions","text":"Type Name const sf::Vector2f MENU_BUTTON_SIZE ({200.f, 50.f})"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/#function-menu_button_size","title":"function MENU_BUTTON_SIZE","text":"<pre><code>const sf::Vector2f MENU_BUTTON_SIZE (\n    {200.f, 50.f}\n) \n</code></pre> <p>Author:</p> <p>: Team - 3 </p> <p>Date:</p> <p>: 10/3/2023 Menu class creates a menu and displays it in the render window </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Menu.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp_source/","title":"File Menu.cpp","text":"<p>File List &gt; Interfaces &gt; Menu.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"Menu.hpp\"\n#include &lt;SFML/Window.hpp&gt;\n#include &lt;SFML/Graphics.hpp&gt;\n\nconst sf::Vector2f MENU_BUTTON_SIZE({200.f,50.f});\nnamespace i_2D {\n\n    void Menu::Initialize(sf::Font &amp;font, sf::Vector2f size) {\n        sf::Color backgroundcolor = sf::Color::Black;\n        sf::Color textcolor = sf::Color::White;\n        mFont = &amp;font;\n        mWorldSize = size;\n\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Menu\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[0]-&gt;SetPosition({0,0});\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Inventory\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[1]-&gt;SetPosition({200,0});\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Exit\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[2]-&gt;SetPosition({400,0});\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Normal\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[3]-&gt;SetPosition({600,0});\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Enlarge\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[4]-&gt;SetPosition({800,0});\n\n    }\n\n    void Menu::DrawTo(sf::RenderWindow &amp;window) {\n        for( const auto &amp;button : mMenuBar){\n            button-&gt;DrawTo(window);\n        }\n        if(mInventory) {\n            mInventory-&gt;DrawTo(window);\n        }\n    }\n\n    std::string Menu::HandleMouseMove(sf::RenderWindow &amp;window) {\n        std::string s1 = \"null\";\n        for (size_t i = 0; i &lt; mMenuBar.size(); ++i) {\n            if (mMenuBar[i]-&gt;IsMouseOver(window)) {\n                mMenuBar[i]-&gt;SetBackColor(sf::Color::Magenta);\n            } else {\n                mMenuBar[i]-&gt;SetBackColor(sf::Color::Black);\n            }\n        }\n        if(mInventory){\n            s1 = mInventory-&gt;HandleMouseMove(window);\n        }\n        return s1;\n    }\n    void Menu::HandleMouseButtonPressed(sf::RenderWindow &amp;window,\n                                        const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory) {\n        if(mMenuBar[1]-&gt;IsMouseOver(window)){\n            if(mInventory){\n                DeconstructInventory();\n            }else {\n                ConstructInventory(interfaceAgentInventory);\n            }\n        }\n\n    }\n}\n\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_menu_8hpp/","title":"File Menu.hpp","text":"<p>FileList &gt; Interfaces &gt; Menu.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include \"Button.hpp\"</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"Inventory.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_menu_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_menu_8hpp/#classes","title":"Classes","text":"Type Name class Menu <p>The documentation for this class was generated from the following file <code>source/Interfaces/Menu.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_menu_8hpp_source/","title":"File Menu.hpp","text":"<p>File List &gt; Interfaces &gt; Menu.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include \"Button.hpp\"\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include \"Inventory.hpp\"\n\nnamespace i_2D {\n    const int MAX_NUMBER_OF_ITEMS_MENU_ITEMS = 3;\n\n    class Menu {\n    private:\n        std::vector&lt;std::unique_ptr&lt;Button&gt;&gt; mMenuBar;\n        std::unique_ptr&lt;Inventory&gt; mInventory; \n        sf::Font * mFont; \n        sf::Vector2f mWorldSize; \n\n    public:\n        void SetInventoryItemDisplay(sf::Texture &amp;texture){\n            if(mInventory) mInventory-&gt;SetItemDisplay(texture);\n        }\n        void Initialize(sf::Font &amp;font,sf::Vector2f size);\n        void DrawTo(sf::RenderWindow &amp;window);\n        std::string HandleMouseMove(sf::RenderWindow &amp;window);\n        void HandleMouseButtonPressed(sf::RenderWindow &amp;window,\n                                      const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory);\n        std::vector&lt;std::unique_ptr&lt;Button&gt;&gt; &amp;GetMenu()\n        {\n            return mMenuBar;\n        }\n        void SetWorldSize(sf::Vector2f size){\n            mWorldSize = size;\n        }\n\n        bool IsInventoryOpen(){\n            if(mInventory){\n                return true;\n            }else return false;\n        }\n\n        void ConstructInventory(const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory){\n            mInventory = std::make_unique&lt;Inventory&gt;(mWorldSize);\n            mInventory-&gt;ConstructInventory(*mFont, interfaceAgentInventory);\n        }\n\n        void DeconstructInventory(){\n            mInventory.reset();\n        }\n\n    };\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8cpp/","title":"File MessageBoard.cpp","text":"<p>FileList &gt; Interfaces &gt; MessageBoard.cpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"MessageBoard.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_message_board_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Authors:</p> <p>Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>: 11/03/2023 MessageBoard class communicate messages to the interface entity </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MessageBoard.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8cpp_source/","title":"File MessageBoard.cpp","text":"<p>File List &gt; Interfaces &gt; MessageBoard.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"MessageBoard.hpp\"\n\nnamespace i_2D {\n\n    MessageBoard::MessageBoard(sf::Font &amp;font) {\n\n        mText = std::make_unique&lt;sf::Text&gt;(font);\n        mText-&gt;setString(\"Welcome!\");\n        mText-&gt;setCharacterSize(35);\n        mText-&gt;setFillColor(sf::Color::Blue);\n        mText-&gt;setPosition({5, 125});\n        mStartTime = std::chrono::system_clock::now();\n    }\n\n    void MessageBoard::DrawTo(sf::RenderWindow &amp;window) {\n        if (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(\n                std::chrono::system_clock::now() - mStartTime).count() &gt; 10000) {\n            mText-&gt;setString(\"\");\n        } else window.draw(*mText);\n    }\n\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8hpp/","title":"File MessageBoard.hpp","text":"<p>FileList &gt; Interfaces &gt; MessageBoard.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_message_board_8hpp/#classes","title":"Classes","text":"Type Name class MessageBoard <p>The documentation for this class was generated from the following file <code>source/Interfaces/MessageBoard.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8hpp_source/","title":"File MessageBoard.hpp","text":"<p>File List &gt; Interfaces &gt; MessageBoard.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;memory&gt;\n#include &lt;chrono&gt;\n\nnamespace i_2D {\n\n    class MessageBoard {\n\n    private:\n        std::unique_ptr&lt;sf::Text&gt; mText;\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; mStartTime;\n\n    public:\n        explicit MessageBoard(sf::Font &amp;font);\n\n        void DrawTo(sf::RenderWindow &amp;window);\n\n        void Send(const std::string &amp;message) {\n            mText-&gt;setString(message);\n            mStartTime = std::chrono::system_clock::now();\n        }\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8cpp/","title":"File TextBox.cpp","text":"<p>FileList &gt; Interfaces &gt; TextBox.cpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"TextBox.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_text_box_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Authors:</p> <p>Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>: 11/02/2023 TextBox class enables interface entity to send message to the MessageBoard and World </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextBox.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8cpp_source/","title":"File TextBox.cpp","text":"<p>File List &gt; Interfaces &gt; TextBox.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"TextBox.hpp\"\n\nnamespace i_2D {\n\n    TextBox::TextBox(const sf::Font &amp;font, int size, sf::Color color, bool sel) {\n\n        mText = std::make_unique&lt;sf::Text&gt;(font);\n        mText-&gt;setCharacterSize(size);\n        mText-&gt;setFillColor(color);\n        mText-&gt;setPosition({10, 650});\n        isSelected = sel;\n        if (!isSelected)\n            mText-&gt;setString(\"Press Click!\");\n\n    }\n\n    void TextBox::SetString(const std::string &amp;s) {\n        mText-&gt;setString(s);\n        mStreamText.str(\"\");\n        mStreamText &lt;&lt; s;\n    }\n\n    void TextBox::SetSelected(bool sel) {\n        isSelected = sel;\n        if (!sel) {\n            std::string t = mStreamText.str();\n            std::string newT;\n            for (char i: t) {\n                newT += i;\n            }\n            mText-&gt;setString((newT));\n        }\n    }\n\n    void TextBox::TypedOn(sf::Event input) {\n        if (isSelected) {\n            int charTyped = static_cast&lt;int&gt;(input.text.unicode);\n            if (charTyped &lt; 128) {\n                if (hasLimit) {\n                    if (static_cast&lt;int&gt;(mStreamText.str().length()) &lt; limit) {\n                        InputLogic(charTyped);\n                    } else if (static_cast&lt;int&gt;(mStreamText.str().length()) &gt;= limit &amp;&amp; charTyped == DELETE_KEY) {\n                        DeleteLastChar();\n                    }\n                } else {\n                    InputLogic(charTyped);\n                }\n            }\n        }\n    }\n\n    void TextBox::InputLogic(int charTyped) {\n        if (isSelected) {\n            if (charTyped != DELETE_KEY &amp;&amp; charTyped != ENTER_KEY &amp;&amp; charTyped != ESCAPE_KEY) {\n                    mStreamText &lt;&lt; static_cast&lt;char&gt;(charTyped);\n            } else if (charTyped == DELETE_KEY) {\n                if (mStreamText.str().length() &gt; 0) {\n                    DeleteLastChar();\n                }\n            }\n        }\n\n        mText-&gt;setString(mStreamText.str() + \"_\");\n    }\n\n    void TextBox::DeleteLastChar() {\n        std::string t = mStreamText.str();\n        mStreamText.str(\"\");\n        mStreamText &lt;&lt; t.substr(0,t.size()-1);\n        mText-&gt;setString(mStreamText.str());\n    }\n\n    void TextBox::DrawTo(sf::RenderWindow &amp;window) {\n\n        mBorderRect.setSize(sf::Vector2f(800, 50));\n        //Subtracts the vector (5, 5) from the position of mTextBox. This creates a new position\n        // slightly to the left and up from the original position, effectively creating a margin.\n\n        mBorderRect.setPosition(mText-&gt;getPosition() - sf::Vector2f(5, 5));\n        mBorderRect.setFillColor(sf::Color(200, 200, 200));\n        mBorderRect.setOutlineThickness(2.0f);  //  thickness of the border\n        mBorderRect.setOutlineColor(sf::Color::Black);\n\n        window.draw(mBorderRect);\n        window.draw(*mText);\n\n    }\n\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/","title":"File TextBox.hpp","text":"<p>FileList &gt; Interfaces &gt; TextBox.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#classes","title":"Classes","text":"Type Name class TextBox"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#macros","title":"Macros","text":"Type Name define DELETE_KEY  8value for delete key define ENTER_KEY  13value for the enter key define ESCAPE_KEY  27value for the escape key"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Authors:</p> <p>Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>: 11/02/2023 TextBox class enables interface entity to send message to the MessageBoard and World </p>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#define-delete_key","title":"define DELETE_KEY","text":"<pre><code>#define DELETE_KEY 8\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#define-enter_key","title":"define ENTER_KEY","text":"<pre><code>#define ENTER_KEY 13\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#define-escape_key","title":"define ESCAPE_KEY","text":"<pre><code>#define ESCAPE_KEY 27\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextBox.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp_source/","title":"File TextBox.hpp","text":"<p>File List &gt; Interfaces &gt; TextBox.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include&lt;iostream&gt;\n#include&lt;SFML/Graphics.hpp&gt;\n#include&lt;sstream&gt;\n\nnamespace i_2D {\n\n#define DELETE_KEY 8 \n#define ENTER_KEY 13 \n#define ESCAPE_KEY 27 \n\n    class TextBox {\n\n    private:\n        std::unique_ptr&lt;sf::Text&gt; mText;\n        std::ostringstream mStreamText; \n        bool isSelected = false; \n        bool hasLimit = true; \n        int limit = 60; \n        // Draw the border around the TextBox\n        sf::RectangleShape mBorderRect;\n\n        void InputLogic(int charTyped);\n\n        void DeleteLastChar();\n\n    public:\n        TextBox() = default;\n\n        explicit TextBox(const sf::Font &amp;font, int size = 25, sf::Color color = sf::Color::Red, bool sel = false);\n\n        void SetString(const std::string &amp;s);\n\n        void SetFont(const sf::Font &amp;font) {\n            mText-&gt;setFont(font);\n        }\n\n        void SetPosition(sf::Vector2f pos) {\n            mText-&gt;setPosition(pos);\n        }\n\n        void SetLimit(bool ToF) {\n            hasLimit = ToF;\n        }\n\n        void SetLimit(bool ToF, int lim) {\n            hasLimit = ToF;\n            limit = lim;\n        }\n\n        void SetSelected(bool sel);\n\n        std::string GetText() {\n            return mStreamText.str();\n        }\n\n        void DrawTo(sf::RenderWindow &amp;window);\n\n        void TypedOn(sf::Event input);\n\n        bool IsSelected() const {\n            return isSelected;\n        }\n\n        bool Contains(sf::Vector2f point) const {\n            return mBorderRect.getGlobalBounds().contains(point);\n        }\n\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8cpp/","title":"File TextureHolder.cpp","text":"<p>FileList &gt; Interfaces &gt; TextureHolder.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"TextureHolder.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextureHolder.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8cpp_source/","title":"File TextureHolder.cpp","text":"<p>File List &gt; Interfaces &gt; TextureHolder.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n//\n// Created by Vincenzo on 10/18/2023.\n//\n\n#include \"TextureHolder.hpp\"\n\nnamespace i_2D\n{\n    void TextureHolder::LoadTexture(std::string id, std::string file_name) {\n        // Load texture to pointer\n        std::unique_ptr&lt;sf::Texture&gt; texture(new sf::Texture());\n        if(!texture-&gt;loadFromFile(file_name))\n        {\n            throw std::runtime_error(\"Failed to load texture from: \" + file_name);\n        }\n\n        // Insert the pointer to map with id as key\n        textures_.insert(std::make_pair(id, std::move(texture)));\n        return;\n    }\n\n    const sf::Texture &amp;TextureHolder::GetTexture(std::string id) {\n        // Find iterator of matching id (avoids copy of unique_ptr)\n        auto got = textures_.find(id);\n        // Return dereference unique_ptr found at iterator pair\n        return *got-&gt;second;\n    }\n\n    std::map&lt;char, sf::Texture&gt; TextureHolder::MazeTexture()\n    {\n\n        std::map&lt;char, sf::Texture&gt; textures;\n\n        // Load textures\n\n        LoadTexture(\"wallTexture\", \"../assets/walls/wall.png\");\n        LoadTexture(\"trollTexture\", \"../assets/agents/troll.png\");\n        LoadTexture(\"agentTexture\", \"../assets/agents/default-the-first.png\");\n        textures['#'] = GetTexture(\"wallTexture\");\n        textures['*'] = GetTexture(\"trollTexture\");\n        textures['@'] = GetTexture(\"agentTexture\");\n        return textures;\n    }\n    std::map&lt;char, sf::Texture&gt; TextureHolder::SecondWorldTexture()\n    {\n\n        std::map&lt;char, sf::Texture&gt; textures;\n\n        // Load textures\n        LoadTexture(\"wallTexture\", \"../assets/walls/wall.png\");\n        LoadTexture(\"trollTexture\", \"../assets/agents/troll.png\");\n        LoadTexture(\"agentTexture\", \"../assets/agents/witch-girl.png\");\n        LoadTexture(\"armourTexture\", \"../assets/weapons/leather_armor.png\");\n        LoadTexture(\"swordTexture\", \"../assets/weapons/longsword.png\");\n        LoadTexture(\"axeTexture\", \"../assets/weapons/w_axe_war.png\");\n        LoadTexture(\"daggerTexture\", \"../assets/weapons/dagger.png\");\n        LoadTexture(\"chestTexture\", \"../assets/weapons/chest_closed.png\");\n        LoadTexture(\"flagTexture\", \"../assets/weapons/flag.png\");\n        LoadTexture(\"pathTexture\", \"../assets/Ground_tiles/Grass2.png\");\n        LoadTexture(\"sword of PowerTexture\", \"../assets/weapons/longsword.png\");\n        LoadTexture(\"axe of HealthTexture\", \"../assets/weapons/w_axe_war.png\");\n        LoadTexture(\"inferno SlicerTexture\", \"../assets/weapons/dagger.png\");\n        LoadTexture(\"electric DaggerTexture\", \"../assets/weapons/dagger.png\");\n        LoadTexture(\"fire DaggerTexture\", \"../assets/weapons/dagger.png\");\n        LoadTexture(\"daedric ArmorTexture\", \"../assets/weapons/leather_armor.png\");\n        LoadTexture(\"leather ArmorTexture\", \"../assets/weapons/leather_armor.png\");\n        LoadTexture(\"hammerTexture\", \"../assets/weapons/w_axe_war.png\");\n        LoadTexture(\"waterTexture\", \"../assets/Ground_tiles/water.jpg\");\n\n        textures['#'] = GetTexture(\"wallTexture\");\n        textures['*'] = GetTexture(\"trollTexture\");\n        textures['@'] = GetTexture(\"agentTexture\");\n        textures['+'] = GetTexture(\"armourTexture\");\n        textures['S'] = GetTexture(\"swordTexture\");\n        textures['A'] = GetTexture(\"axeTexture\");\n        textures['D'] = GetTexture(\"daggerTexture\");\n        textures['C'] = GetTexture(\"chestTexture\");\n        textures['g'] = GetTexture(\"flagTexture\");\n        textures[' '] = GetTexture(\"pathTexture\");\n        textures['w'] = GetTexture(\"waterTexture\");\n        textures['u'] = GetTexture(\"waterTexture\");\n\n        return textures;\n    }\n    std::map&lt;char, sf::Texture&gt; TextureHolder::ManualWorldTexture()\n    {\n\n        std::map&lt;char, sf::Texture&gt; textures;\n\n        // Load textures\n        LoadTexture(\"wallTexture\", \"../assets/walls/brick_wall.png\");\n        LoadTexture(\"trollTexture\", \"../assets/agents/troll.png\");\n        LoadTexture(\"agentTexture\", \"../assets/agents/witch-girl.png\");\n        LoadTexture(\"treeTexture\", \"../assets/trees/tree1.png\");\n        LoadTexture(\"waterTexture\", \"../assets/Ground_tiles/water.jpg\");\n        LoadTexture(\"axeTexture\", \"../assets/weapons/w_axe_war_steel.png\");\n        LoadTexture(\"boatTexture\", \"../assets/weapons/Boat_color1_2.png\");\n        LoadTexture(\"pathTexture\", \"../assets/Ground_tiles/Sand1.png\");\n        LoadTexture(\"portal1Texture\", \"../assets/walls/portal1.png\");\n        LoadTexture(\"portal2Texture\", \"../assets/walls/portal2.png\");\n        LoadTexture(\"portal3Texture\", \"../assets/walls/portal3.png\");\n        LoadTexture(\"portal4Texture\", \"../assets/walls/portal4.png\");\n        LoadTexture(\"healthTexture\", \"../assets/walls/teleport.png\");\n        LoadTexture(\"rockTexture\", \"../assets/walls/gray_wall.png\");\n        LoadTexture(\"swordTexture\", \"../assets/weapons/longsword.png\");\n        textures['P'] = GetTexture(\"axeTexture\");\n        textures['U'] = GetTexture(\"boatTexture\");\n        textures['#'] = GetTexture(\"wallTexture\");\n        textures['*'] = GetTexture(\"trollTexture\");\n        textures['@'] = GetTexture(\"agentTexture\");\n        textures['^'] = GetTexture(\"treeTexture\");\n        textures['~'] = GetTexture(\"waterTexture\");\n        textures[' '] = GetTexture(\"pathTexture\");\n        textures['{'] = GetTexture(\"portal1Texture\");\n        textures['}'] = GetTexture(\"portal2Texture\");\n        textures['('] = GetTexture(\"portal3Texture\");\n        textures[')'] = GetTexture(\"portal4Texture\");\n        textures['j'] = GetTexture(\"healthTexture\");\n        textures['t'] = GetTexture(\"swordTexture\");\n        textures['$'] = GetTexture(\"rockTexture\");\n\n        return textures;\n    }\n    std::map&lt;char, sf::Texture&gt; TextureHolder::GenerativeWorldTexture()\n    {\n\n        std::map&lt;char, sf::Texture&gt; textures;\n\n        // Load textures\n        LoadTexture(\"wallTexture\", \"../assets/walls/stone_wall02.png\");\n        LoadTexture(\"trollTexture\", \"../assets/agents/troll.png\");\n        LoadTexture(\"agentTexture\", \"../assets/agents/Character_03_Front.png\");\n        LoadTexture(\"tarTexture\", \"../assets/Ground_tiles/tar.jpg\");\n        LoadTexture(\"doorTexture\", \"../assets/walls/castledoors.png\");\n        LoadTexture(\"spikeTexture\", \"../assets/weapons/Individual_Spike.png\");\n        LoadTexture(\"keyTexture\", \"../assets/weapons/key.png\");\n        LoadTexture(\"pathTexture\", \"../assets/Ground_tiles/Dirt1.png\");\n        LoadTexture(\"bootTexture\", \"../assets/weapons/2.png\");\n        LoadTexture(\"shieldTexture\", \"../assets/weapons/shield.png\");\n        LoadTexture(\"teleportTexture\", \"../assets/walls/teleport.png\");\n        LoadTexture(\"armoryTexture\", \"../assets/weapons/steel_armor.png\");\n        LoadTexture(\"waterTexture\", \"../assets/Ground_tiles/water.jpg\");\n        LoadTexture(\"sandTexture\", \"../assets/Ground_tiles/Sand1.png\");\n        LoadTexture(\"grassTexture\", \"../assets/Ground_tiles/Grass2.png\");\n        LoadTexture(\"dirtTexture\", \"../assets/Ground_tiles/Dirt1.png\");\n        textures['~'] = GetTexture(\"dirtTexture\");\n        textures['M'] = GetTexture(\"grassTexture\");\n        textures['-'] = GetTexture(\"sandTexture\");\n        textures['W'] = GetTexture(\"waterTexture\");\n        textures['B'] = GetTexture(\"bootTexture\");\n        textures['X'] = GetTexture(\"spikeTexture\");\n        textures['O'] = GetTexture(\"tarTexture\");\n        textures['#'] = GetTexture(\"wallTexture\");\n        textures['*'] = GetTexture(\"trollTexture\");\n        textures['@'] = GetTexture(\"agentTexture\");\n        textures['D'] = GetTexture(\"doorTexture\");\n        textures['K'] = GetTexture(\"keyTexture\");\n        textures[' '] = GetTexture(\"pathTexture\");\n        textures['S'] = GetTexture(\"shieldTexture\");\n        textures['T'] = GetTexture(\"teleportTexture\");\n        textures['A'] = GetTexture(\"armoryTexture\");\n\n        return textures;\n    }\n\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8hpp/","title":"File TextureHolder.hpp","text":"<p>FileList &gt; Interfaces &gt; TextureHolder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include \"SFML/Graphics.hpp\"</code></li> <li><code>#include \"../core/Data.hpp\"</code></li> <li><code>#include \"../core/InterfaceBase.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8hpp/#classes","title":"Classes","text":"Type Name class TextureHolder <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextureHolder.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8hpp_source/","title":"File TextureHolder.hpp","text":"<p>File List &gt; Interfaces &gt; TextureHolder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n//\n// Created by Vincenzo on 10/18/2023.\n//\n\n#pragma once\n\n#include &lt;map&gt;\n#include \"SFML/Graphics.hpp\"\n#include \"../core/Data.hpp\"\n#include \"../core/InterfaceBase.hpp\"\n\nnamespace i_2D\n{\n    using namespace cse491;\n    class TextureHolder {\n\n    private:\n        std::unordered_map&lt;std::string, std::unique_ptr&lt;sf::Texture&gt;&gt; textures_;\n\n    public:\n        TextureHolder() = default;\n        ~TextureHolder() = default;\n        void LoadTexture(std::string id, std::string file_name);\n        const sf::Texture&amp; GetTexture(std::string id);\n        std::map&lt;char, sf::Texture&gt; MazeTexture();\n        std::map&lt;char, sf::Texture&gt; SecondWorldTexture();\n        std::map&lt;char, sf::Texture&gt; ManualWorldTexture();\n        std::map&lt;char, sf::Texture&gt; GenerativeWorldTexture();\n\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_trash_interface_8hpp/","title":"File TrashInterface.hpp","text":"<p>FileList &gt; Interfaces &gt; TrashInterface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../core/Data.hpp\"</code></li> <li><code>#include \"../core/InterfaceBase.hpp\"</code></li> <li><code>#include \"../DataCollection/DataManager.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_trash_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A low-end text interface providing a bare-minimum level of interaction."},{"location":"2D%20Interface%28Group%203%29/_trash_interface_8hpp/#classes","title":"Classes","text":"Type Name class TrashInterface <p>The documentation for this class was generated from the following file <code>source/Interfaces/TrashInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_trash_interface_8hpp_source/","title":"File TrashInterface.hpp","text":"<p>File List &gt; Interfaces &gt; TrashInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#include \"../core/Data.hpp\"\n#include \"../core/InterfaceBase.hpp\"\n#include \"../DataCollection/DataManager.hpp\"\n\nnamespace cse491 {\n\n  class TrashInterface : public InterfaceBase {\n  protected:\n    bool wait_for_input = true;  \n\n    // -- Helper Functions --\n    void DrawGrid(const WorldGrid &amp; grid, const type_options_t &amp; type_options,\n                  const item_map_t &amp; item_map, const agent_map_t &amp; agent_map)\n    {\n      std::vector&lt;std::string&gt; symbol_grid(grid.GetHeight());\n\n      // Load the world into the symbol_grid;\n      for (size_t y=0; y &lt; grid.GetHeight(); ++y) {\n        symbol_grid[y].resize(grid.GetWidth());\n        for (size_t x=0; x &lt; grid.GetWidth(); ++x) {\n          symbol_grid[y][x] = type_options[ grid.At(x,y) ].symbol;\n        }\n      }\n\n      // Add in the agents / entities\n      for (const auto &amp; [id, item_ptr] : item_map) {\n        GridPosition pos = item_ptr-&gt;GetPosition();\n\n        if (pos.IsValid() &amp;&amp; !item_ptr-&gt;IsOwned()) {\n          char c = '+';\n          if (item_ptr-&gt;HasProperty(\"symbol\")) {\n            c = item_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n          }\n          if (grid.IsValid(pos)){\n            symbol_grid[pos.CellY()][pos.CellX()] = c;\n          }\n        }\n      }\n\n      for (const auto &amp; [id, agent_ptr] : agent_map) {\n        GridPosition pos = agent_ptr-&gt;GetPosition();\n        char c = '*';\n        if(agent_ptr-&gt;HasProperty(\"symbol\")){\n          c = agent_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n        }\n        if (!agent_ptr-&gt;HasProperty(\"deleted\")){\n          symbol_grid[pos.CellY()][pos.CellX()] = c;\n        }\n      }\n\n      // Print out the symbol_grid with a box around it.\n      std::cout &lt;&lt; '+' &lt;&lt; std::string(grid.GetWidth(),'-') &lt;&lt; \"+\\n\";\n      for (const auto &amp; row : symbol_grid) {\n        std::cout &lt;&lt; \"|\";\n        for (char cell : row) {\n          // std::cout &lt;&lt; ' ' &lt;&lt; cell;\n          std::cout &lt;&lt; cell;\n        }\n        std::cout &lt;&lt; \"|\\n\";\n      }\n      std::cout &lt;&lt; '+' &lt;&lt; std::string(grid.GetWidth(),'-') &lt;&lt; \"+\\n\";\n      std::cout &lt;&lt; \"\\nYour move? \";\n      std::cout.flush();\n    }\n\n  public:\n    TrashInterface(size_t id, const std::string &amp; name) : InterfaceBase(id, name) { }\n    ~TrashInterface() = default; // Already virtual from Entity\n\n    // -- AgentBase overrides --\n\n    bool Initialize() override {\n      return true;\n    }\n\n      size_t SelectAction(const WorldGrid &amp; grid,\n                        const type_options_t &amp; type_options,\n                        const item_map_t &amp; item_map,\n                        const agent_map_t &amp; agent_map) override\n    {\n      // Update the current state of the world.\n      DrawGrid(grid, type_options, item_map, agent_map);\n\n      // See if there are any keys waiting in standard input (wait if needed)\n      char input;\n      do {\n        std::cin &gt;&gt; input;\n      } while (!std::cin &amp;&amp; wait_for_input);\n\n      // Respond to the user input...\n      size_t action_id = 0;\n      switch (input) {\n        case 'w': case 'W': action_id = GetActionID(\"up\");    break;\n        case 'a': case 'A': action_id = GetActionID(\"left\");  break;\n        case 's': case 'S': action_id = GetActionID(\"down\");  break;\n        case 'd': case 'D': action_id = GetActionID(\"right\"); break;\n        case 't': case 'T': action_id = GetActionID(\"drop\");  break;\n        case 'h': case 'H': action_id = GetActionID(\"heal\"); break;\n        // Can't have 2 cases for T, so we'll have to decide which one to change.\n        //case 't': case 'T': action_id = GetActionID(\"stats\"); break;\n        case 'c': case 'C': action_id = GetActionID(\"use_axe\"); break;\n        case 'v': case 'V': action_id = GetActionID(\"use_boat\"); break;\n        case 'f': case 'F': action_id = GetActionID(\"attack\"); break;\n        case 'g': case 'G': action_id = GetActionID(\"special\"); break;\n        case 'b': case 'B': action_id = GetActionID(\"buff\"); break;\n        case 'r': case 'R': action_id = GetActionID(\"run\"); break;\n        case 'y': case 'Y': action_id = GetActionID(\"help\"); break;\n        case 'q': case 'Q': exitCleanup(); // Quit!\n      }\n\n      // If we waited for input, but don't understand it, notify the user.\n      if (wait_for_input &amp;&amp; action_id == 0) {\n        std::cout &lt;&lt; \"Unknown key '\" &lt;&lt; input &lt;&lt; \"'.\" &lt;&lt; std::endl;\n      }\n\n      // Do the action!\n      return action_id;\n    }\n\n    void Notify(const std::string &amp; message,\n                const std::string &amp; /*msg_type*/=\"none\") override\n    {\n      std::cout &lt;&lt; message &lt;&lt; std::endl;\n    }\n  };\n\n\n} // End of namespace cse491\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cse491 A low-end text interface providing a bare-minimum level of interaction. </li> <li>namespace i_2D </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classes/","title":"Class Index","text":""},{"location":"2D%20Interface%28Group%203%29/classes/#b","title":"b","text":"<ul> <li>Button (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classes/#i","title":"i","text":"<ul> <li>Inventory (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classes/#m","title":"m","text":"<ul> <li>MainInterface (i_2D)</li> <li>Menu (i_2D)</li> <li>MessageBoard (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classes/#t","title":"t","text":"<ul> <li>TextBox (i_2D)</li> <li>TextureHolder (i_2D)</li> <li>TrashInterface (cse491)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class i_2D::Button </li> <li>class i_2D::Inventory </li> <li>class i_2D::Menu </li> <li>class i_2D::MessageBoard </li> <li>class i_2D::TextBox </li> <li>class i_2D::TextureHolder </li> <li>class InterfaceBase <ul> <li>class cse491::TrashInterface </li> <li>class i_2D::MainInterface Represents the main interface for a 2D maze game. </li> </ul> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"2D%20Interface%28Group%203%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"2D%20Interface%28Group%203%29/class_members/","title":"Class Members","text":""},{"location":"2D%20Interface%28Group%203%29/class_members/#b","title":"b","text":"<ul> <li>Button (i_2D::Button)</li> <li>button (i_2D::Button)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#c","title":"c","text":"<ul> <li>ConstructInventory (i_2D::Inventory, i_2D::Menu)</li> <li>COL (i_2D::MainInterface)</li> <li>CalculateCellSize (i_2D::MainInterface)</li> <li>CalculateDrawSpace (i_2D::MainInterface)</li> <li>CheckLargerGrid (i_2D::MainInterface)</li> <li>ChooseTexture (i_2D::MainInterface)</li> <li>CreateVectorMaze (i_2D::MainInterface)</li> <li>Contains (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#d","title":"d","text":"<ul> <li>DrawGrid (cse491::TrashInterface, i_2D::MainInterface)</li> <li>DrawTo (i_2D::Button, i_2D::Inventory, i_2D::Menu, i_2D::MessageBoard, i_2D::TextBox)</li> <li>DrawAgentCell (i_2D::MainInterface)</li> <li>DrawHealthInfo (i_2D::MainInterface)</li> <li>DrawTimer (i_2D::MainInterface)</li> <li>DrawWall (i_2D::MainInterface)</li> <li>DeconstructInventory (i_2D::Menu)</li> <li>DeleteLastChar (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#g","title":"g","text":"<ul> <li>GetMenu (i_2D::Menu)</li> <li>GetText (i_2D::TextBox)</li> <li>GenerativeWorldTexture (i_2D::TextureHolder)</li> <li>GetTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#h","title":"h","text":"<ul> <li>HandleMouseMove (i_2D::Inventory, i_2D::Menu)</li> <li>HandleKeyEvent (i_2D::MainInterface)</li> <li>HandleResize (i_2D::MainInterface)</li> <li>HandleMouseButtonPressed (i_2D::Menu)</li> <li>hasLimit (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#i","title":"i","text":"<ul> <li>Initialize (cse491::TrashInterface, i_2D::MainInterface, i_2D::Menu)</li> <li>IsMouseOver (i_2D::Button)</li> <li>Inventory (i_2D::Inventory)</li> <li>IsInventoryOpen (i_2D::Menu)</li> <li>InputLogic (i_2D::TextBox)</li> <li>IsSelected (i_2D::TextBox)</li> <li>isSelected (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#l","title":"l","text":"<ul> <li>LargeDisplayGrid (i_2D::MainInterface)</li> <li>limit (i_2D::TextBox)</li> <li>LoadTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#m","title":"m","text":"<ul> <li>mCanvas (i_2D::Inventory)</li> <li>mCol (i_2D::Inventory)</li> <li>mItemDisplay (i_2D::Inventory)</li> <li>mItems (i_2D::Inventory)</li> <li>mListOfButtons (i_2D::Inventory)</li> <li>mRow (i_2D::Inventory)</li> <li>mWorldSize (i_2D::Inventory, i_2D::Menu)</li> <li>MIN_SIZE_CELL (i_2D::MainInterface)</li> <li>MainInterface (i_2D::MainInterface)</li> <li>MouseClickEvent (i_2D::MainInterface)</li> <li>mAgentInventory (i_2D::MainInterface)</li> <li>mFont (i_2D::MainInterface, i_2D::Menu)</li> <li>mGridHeight (i_2D::MainInterface)</li> <li>mGridSizeLarge (i_2D::MainInterface)</li> <li>mGridWidth (i_2D::MainInterface)</li> <li>mInputWaitTime (i_2D::MainInterface)</li> <li>mMenu (i_2D::MainInterface)</li> <li>mMessageBoard (i_2D::MainInterface)</li> <li>mPlayerPosition (i_2D::MainInterface)</li> <li>mTextBox (i_2D::MainInterface)</li> <li>mTextureHolder (i_2D::MainInterface)</li> <li>mTexturesCurrent (i_2D::MainInterface)</li> <li>mTexturesDefault (i_2D::MainInterface)</li> <li>mTexturesGenerativeWorld (i_2D::MainInterface)</li> <li>mTexturesManualWorld (i_2D::MainInterface)</li> <li>mTexturesSecondWorld (i_2D::MainInterface)</li> <li>mWindow (i_2D::MainInterface)</li> <li>mInventory (i_2D::Menu)</li> <li>mMenuBar (i_2D::Menu)</li> <li>MessageBoard (i_2D::MessageBoard)</li> <li>mStartTime (i_2D::MessageBoard)</li> <li>mText (i_2D::MessageBoard, i_2D::TextBox)</li> <li>mBorderRect (i_2D::TextBox)</li> <li>mStreamText (i_2D::TextBox)</li> <li>ManualWorldTexture (i_2D::TextureHolder)</li> <li>MazeTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#n","title":"n","text":"<ul> <li>Notify (cse491::TrashInterface, i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#r","title":"r","text":"<ul> <li>ROW (i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#s","title":"s","text":"<ul> <li>SelectAction (cse491::TrashInterface, i_2D::MainInterface)</li> <li>SetBackColor (i_2D::Button)</li> <li>SetButtonSize (i_2D::Button)</li> <li>SetFont (i_2D::Button, i_2D::TextBox)</li> <li>SetMFont (i_2D::Button)</li> <li>SetPosition (i_2D::Button, i_2D::TextBox)</li> <li>SetString (i_2D::Button, i_2D::TextBox)</li> <li>SetTextColor (i_2D::Button)</li> <li>SetItemDisplay (i_2D::Inventory)</li> <li>SetSize (i_2D::Inventory)</li> <li>SetLargeGrid (i_2D::MainInterface)</li> <li>SwitchCellSelect (i_2D::MainInterface)</li> <li>setMInputWaitTime (i_2D::MainInterface)</li> <li>SetInventoryItemDisplay (i_2D::Menu)</li> <li>SetWorldSize (i_2D::Menu)</li> <li>Send (i_2D::MessageBoard)</li> <li>SetLimit (i_2D::TextBox)</li> <li>SetSelected (i_2D::TextBox)</li> <li>SecondWorldTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#t","title":"t","text":"<ul> <li>TrashInterface (cse491::TrashInterface)</li> <li>text (i_2D::Button)</li> <li>TextBox (i_2D::TextBox)</li> <li>TypedOn (i_2D::TextBox)</li> <li>TextureHolder (i_2D::TextureHolder)</li> <li>textures_ (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#w","title":"w","text":"<ul> <li>wait_for_input (cse491::TrashInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#_1","title":"~","text":"<ul> <li>~TrashInterface (cse491::TrashInterface)</li> <li>~MainInterface (i_2D::MainInterface)</li> <li>~TextureHolder (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#b","title":"b","text":"<ul> <li>Button (i_2D::Button)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#c","title":"c","text":"<ul> <li>ConstructInventory (i_2D::Inventory, i_2D::Menu)</li> <li>CalculateCellSize (i_2D::MainInterface)</li> <li>CalculateDrawSpace (i_2D::MainInterface)</li> <li>CheckLargerGrid (i_2D::MainInterface)</li> <li>ChooseTexture (i_2D::MainInterface)</li> <li>CreateVectorMaze (i_2D::MainInterface)</li> <li>Contains (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#d","title":"d","text":"<ul> <li>DrawGrid (cse491::TrashInterface, i_2D::MainInterface)</li> <li>DrawTo (i_2D::Button, i_2D::Inventory, i_2D::Menu, i_2D::MessageBoard, i_2D::TextBox)</li> <li>DrawAgentCell (i_2D::MainInterface)</li> <li>DrawHealthInfo (i_2D::MainInterface)</li> <li>DrawTimer (i_2D::MainInterface)</li> <li>DrawWall (i_2D::MainInterface)</li> <li>DeconstructInventory (i_2D::Menu)</li> <li>DeleteLastChar (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#g","title":"g","text":"<ul> <li>GetMenu (i_2D::Menu)</li> <li>GetText (i_2D::TextBox)</li> <li>GenerativeWorldTexture (i_2D::TextureHolder)</li> <li>GetTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#h","title":"h","text":"<ul> <li>HandleMouseMove (i_2D::Inventory, i_2D::Menu)</li> <li>HandleKeyEvent (i_2D::MainInterface)</li> <li>HandleResize (i_2D::MainInterface)</li> <li>HandleMouseButtonPressed (i_2D::Menu)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (cse491::TrashInterface, i_2D::MainInterface, i_2D::Menu)</li> <li>IsMouseOver (i_2D::Button)</li> <li>Inventory (i_2D::Inventory)</li> <li>IsInventoryOpen (i_2D::Menu)</li> <li>InputLogic (i_2D::TextBox)</li> <li>IsSelected (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#l","title":"l","text":"<ul> <li>LargeDisplayGrid (i_2D::MainInterface)</li> <li>LoadTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#m","title":"m","text":"<ul> <li>MainInterface (i_2D::MainInterface)</li> <li>MouseClickEvent (i_2D::MainInterface)</li> <li>MessageBoard (i_2D::MessageBoard)</li> <li>ManualWorldTexture (i_2D::TextureHolder)</li> <li>MazeTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#n","title":"n","text":"<ul> <li>Notify (cse491::TrashInterface, i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (cse491::TrashInterface, i_2D::MainInterface)</li> <li>SetBackColor (i_2D::Button)</li> <li>SetButtonSize (i_2D::Button)</li> <li>SetFont (i_2D::Button, i_2D::TextBox)</li> <li>SetMFont (i_2D::Button)</li> <li>SetPosition (i_2D::Button, i_2D::TextBox)</li> <li>SetString (i_2D::Button, i_2D::TextBox)</li> <li>SetTextColor (i_2D::Button)</li> <li>SetItemDisplay (i_2D::Inventory)</li> <li>SetSize (i_2D::Inventory)</li> <li>SetLargeGrid (i_2D::MainInterface)</li> <li>SwitchCellSelect (i_2D::MainInterface)</li> <li>setMInputWaitTime (i_2D::MainInterface)</li> <li>SetInventoryItemDisplay (i_2D::Menu)</li> <li>SetWorldSize (i_2D::Menu)</li> <li>Send (i_2D::MessageBoard)</li> <li>SetLimit (i_2D::TextBox)</li> <li>SetSelected (i_2D::TextBox)</li> <li>SecondWorldTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#t","title":"t","text":"<ul> <li>TrashInterface (cse491::TrashInterface)</li> <li>TextBox (i_2D::TextBox)</li> <li>TypedOn (i_2D::TextBox)</li> <li>TextureHolder (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~TrashInterface (cse491::TrashInterface)</li> <li>~MainInterface (i_2D::MainInterface)</li> <li>~TextureHolder (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#b","title":"b","text":"<ul> <li>button (i_2D::Button)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#c","title":"c","text":"<ul> <li>COL (i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#h","title":"h","text":"<ul> <li>hasLimit (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#i","title":"i","text":"<ul> <li>isSelected (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#l","title":"l","text":"<ul> <li>limit (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#m","title":"m","text":"<ul> <li>mCanvas (i_2D::Inventory)</li> <li>mCol (i_2D::Inventory)</li> <li>mItemDisplay (i_2D::Inventory)</li> <li>mItems (i_2D::Inventory)</li> <li>mListOfButtons (i_2D::Inventory)</li> <li>mRow (i_2D::Inventory)</li> <li>mWorldSize (i_2D::Inventory, i_2D::Menu)</li> <li>MIN_SIZE_CELL (i_2D::MainInterface)</li> <li>mAgentInventory (i_2D::MainInterface)</li> <li>mFont (i_2D::MainInterface, i_2D::Menu)</li> <li>mGridHeight (i_2D::MainInterface)</li> <li>mGridSizeLarge (i_2D::MainInterface)</li> <li>mGridWidth (i_2D::MainInterface)</li> <li>mInputWaitTime (i_2D::MainInterface)</li> <li>mMenu (i_2D::MainInterface)</li> <li>mMessageBoard (i_2D::MainInterface)</li> <li>mPlayerPosition (i_2D::MainInterface)</li> <li>mTextBox (i_2D::MainInterface)</li> <li>mTextureHolder (i_2D::MainInterface)</li> <li>mTexturesCurrent (i_2D::MainInterface)</li> <li>mTexturesDefault (i_2D::MainInterface)</li> <li>mTexturesGenerativeWorld (i_2D::MainInterface)</li> <li>mTexturesManualWorld (i_2D::MainInterface)</li> <li>mTexturesSecondWorld (i_2D::MainInterface)</li> <li>mWindow (i_2D::MainInterface)</li> <li>mInventory (i_2D::Menu)</li> <li>mMenuBar (i_2D::Menu)</li> <li>mStartTime (i_2D::MessageBoard)</li> <li>mText (i_2D::MessageBoard, i_2D::TextBox)</li> <li>mBorderRect (i_2D::TextBox)</li> <li>mStreamText (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#r","title":"r","text":"<ul> <li>ROW (i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#t","title":"t","text":"<ul> <li>text (i_2D::Button)</li> <li>textures_ (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#w","title":"w","text":"<ul> <li>wait_for_input (cse491::TrashInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"2D%20Interface%28Group%203%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"2D%20Interface%28Group%203%29/namespace_members/","title":"Namespace Members","text":""},{"location":"2D%20Interface%28Group%203%29/namespace_members/#e","title":"e","text":"<ul> <li>elapsedTime (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_members/#m","title":"m","text":"<ul> <li>MAX_NUMBER_OF_ITEMS_MENU_ITEMS (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_members/#t","title":"t","text":"<ul> <li>timer (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"2D%20Interface%28Group%203%29/namespace_member_variables/#e","title":"e","text":"<ul> <li>elapsedTime (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_NUMBER_OF_ITEMS_MENU_ITEMS (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_variables/#t","title":"t","text":"<ul> <li>timer (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"2D%20Interface%28Group%203%29/functions/","title":"Functions","text":""},{"location":"2D%20Interface%28Group%203%29/functions/#m","title":"m","text":"<ul> <li>MENU_BUTTON_SIZE (Menu.cpp)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/macros/","title":"Macros","text":""},{"location":"2D%20Interface%28Group%203%29/macros/#d","title":"d","text":"<ul> <li>DELETE_KEY (TextBox.hpp)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/macros/#e","title":"e","text":"<ul> <li>ENTER_KEY (TextBox.hpp)</li> <li>ESCAPE_KEY (TextBox.hpp)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"2D%20Interface%28Group%203%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Networks%20%28Group%205%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cse491 </li> <li>namespace i_2D </li> <li>namespace netWorth A networking interface that allows information to be sent across a network. <ul> <li>class ClientInterface </li> <li>class ClientManager </li> <li>class ControlledAgent </li> <li>class NetworkingInterface </li> <li>class ServerInterface </li> <li>class ServerManager </li> </ul> </li> <li>namespace sf </li> </ul>"},{"location":"Networks%20%28Group%205%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Interfaces <ul> <li>dir NetWorth <ul> <li>file NetworkInterface.hpp </li> <li>dir client <ul> <li>file ClientInterface.hpp </li> <li>file ClientManager.hpp </li> <li>file ControlledAgent.hpp </li> </ul> </li> <li>dir server <ul> <li>file ServerInterface.hpp </li> <li>file ServerManager.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"Networks%20%28Group%205%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Networks%20%28Group%205%29/namespacei__2_d/","title":"Namespace i_2D","text":"<p>Namespace List &gt; i_2D</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Networks%20%28Group%205%29/namespacenet_worth/","title":"Namespace netWorth","text":"<p>Namespace List &gt; netWorth</p> <p>A networking interface that allows information to be sent across a network. More...</p>"},{"location":"Networks%20%28Group%205%29/namespacenet_worth/#classes","title":"Classes","text":"Type Name class ClientInterface class ClientManager class ControlledAgent class NetworkingInterface class ServerInterface class ServerManager"},{"location":"Networks%20%28Group%205%29/namespacenet_worth/#detailed-description","title":"Detailed Description","text":"<p>An Agent that will walk back and forth along a row or column.</p> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROTOTYPE</p> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/","title":"Class netWorth::ClientInterface","text":"<p>ClassList &gt; netWorth &gt; ClientInterface</p> <p>Inherits the following classes: netWorth::NetworkingInterface,  MainInterface</p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#public-functions","title":"Public Functions","text":"Type Name ClientInterface (size_t id, const std::string &amp; name)  bool Initialize () override size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; typeOptions, const cse491::item_map_t &amp; itemMap, const cse491::agent_map_t &amp; agentMap) override"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#public-functions-inherited-from-networthnetworkinginterface","title":"Public Functions inherited from netWorth::NetworkingInterface","text":"<p>See netWorth::NetworkingInterface</p> Type Name NetworkingInterface (size_t id, const std::string &amp; name) the destination port of the machine this communicates with virtual bool bindSocket (UdpSocket &amp; socket, unsigned short port)  virtual UdpSocket * getSocket ()  virtual bool receivePacket (Packet &amp; pkt, std::optional&lt; IpAddress &gt; &amp; sender, unsigned short &amp; port)  virtual bool sendPacket (Packet packet, IpAddress destAddr, const unsigned short port)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#protected-attributes-inherited-from-networthnetworkinginterface","title":"Protected Attributes inherited from netWorth::NetworkingInterface","text":"<p>See netWorth::NetworkingInterface</p> Type Name std::optional&lt; IpAddress &gt; m_ip The socket we are going to make our connection. unsigned short m_port   = = 0the destination IP of the machine this communicates with UdpSocket m_socket"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#function-clientinterface","title":"function ClientInterface","text":"<pre><code>inline netWorth::ClientInterface::ClientInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#function-initialize","title":"function Initialize","text":"<pre><code>inline bool netWorth::ClientInterface::Initialize () override\n</code></pre> <p>Establish connection with server, initializing interface </p> <p>Returns:</p> <p>True if successful, false if error </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t netWorth::ClientInterface::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; typeOptions,\n    const cse491::item_map_t &amp; itemMap,\n    const cse491::agent_map_t &amp; agentMap\n) override\n</code></pre> <p>Choose action for player agent </p> <p>Parameters:</p> <ul> <li><code>grid</code> the client-side grid </li> <li><code>typeOptions</code> different cell types of the world </li> <li><code>item_map</code> the items that may be apart of the grid </li> <li><code>agent_map</code> the agents that may be apart of the grid </li> </ul> <p>Returns:</p> <p>action ID of the interface </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/","title":"Class netWorth::ClientManager","text":"<p>ClassList &gt; netWorth &gt; ClientManager</p> <p>More...</p> <ul> <li><code>#include &lt;ClientManager.hpp&gt;</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#public-functions","title":"Public Functions","text":"Type Name ClientManager () = defaultId of client. void clearActionMap ()  size_t getActionID (size_t id)  size_t getClientID () const std::string getSerializedAgents ()  bool iDPresent (size_t id)  void packetToActionMap (sf::Packet pkt)  void setClientID (size_t id)  void setUpdatePort (unsigned short port)  void setupGameUpdateSocket (sf::UdpSocket * socket)  void setupSocket (sf::UdpSocket * socket, std::optional&lt; sf::IpAddress &gt; ip)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#detailed-description","title":"Detailed Description","text":"<p>The server that will be running and that allows clients to connect to </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-clientmanager","title":"function ClientManager","text":"<p>Id of client. </p> <pre><code>netWorth::ClientManager::ClientManager () = default\n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-clearactionmap","title":"function clearActionMap","text":"<pre><code>inline void netWorth::ClientManager::clearActionMap () \n</code></pre> <p>Clear action map after ClientInterface moves </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-getactionid","title":"function getActionID","text":"<pre><code>inline size_t netWorth::ClientManager::getActionID (\n    size_t id\n) \n</code></pre> <p>Return action ID correspoding to agent ID </p> <p>Parameters:</p> <ul> <li><code>id</code> Agent ID </li> </ul> <p>Returns:</p> <p>action ID </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-getclientid","title":"function getClientID","text":"<pre><code>inline size_t netWorth::ClientManager::getClientID () const\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-getserializedagents","title":"function getSerializedAgents","text":"<pre><code>inline std::string netWorth::ClientManager::getSerializedAgents () \n</code></pre> <p>Receive serialized agent data for midgame updates </p> <p>Returns:</p> <p>serialized data (or empty if no update) </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-idpresent","title":"function iDPresent","text":"<pre><code>inline bool netWorth::ClientManager::iDPresent (\n    size_t id\n) \n</code></pre> <p>Check if Agent ID is present in agent action map </p> <p>Parameters:</p> <ul> <li><code>id</code> Agent ID </li> </ul> <p>Returns:</p> <p>true if ID is present </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-packettoactionmap","title":"function packetToActionMap","text":"<pre><code>inline void netWorth::ClientManager::packetToActionMap (\n    sf::Packet pkt\n) \n</code></pre> <p>Turn packet from server into action map for ControlledAgents </p> <p>Parameters:</p> <ul> <li><code>pkt</code> received packet </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-setclientid","title":"function setClientID","text":"<pre><code>inline void netWorth::ClientManager::setClientID (\n    size_t id\n) \n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-setupdateport","title":"function setUpdatePort","text":"<pre><code>inline void netWorth::ClientManager::setUpdatePort (\n    unsigned short port\n) \n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-setupgameupdatesocket","title":"function setupGameUpdateSocket","text":"<pre><code>inline void netWorth::ClientManager::setupGameUpdateSocket (\n    sf::UdpSocket * socket\n) \n</code></pre> <p>Set socket for game updates </p> <p>Parameters:</p> <ul> <li><code>socket</code> pointer to socket </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-setupsocket","title":"function setupSocket","text":"<pre><code>inline void netWorth::ClientManager::setupSocket (\n    sf::UdpSocket * socket,\n    std::optional&lt; sf::IpAddress &gt; ip\n) \n</code></pre> <p>Set receiving socket for action map and IP/port info </p> <p>Parameters:</p> <ul> <li><code>socket</code> pointer to ClientInterface's socket </li> <li><code>ip</code> server IP </li> <li><code>port</code> server port </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientManager.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/","title":"Class netWorth::ControlledAgent","text":"<p>ClassList &gt; netWorth &gt; ControlledAgent</p> <p>Inherits the following classes: AgentBase</p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#public-functions","title":"Public Functions","text":"Type Name ControlledAgent (size_t id, const std::string &amp; name) Client manager to access agent action map. bool Initialize () overrideThis agent needs a specific set of actions to function. size_t SelectAction (const cse491::WorldGrid &amp;, const cse491::type_options_t &amp;, const cse491::item_map_t &amp;, const cse491::agent_map_t &amp;) overrideChoose the action to take a step in the appropriate direction."},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#function-controlledagent","title":"function ControlledAgent","text":"<pre><code>inline netWorth::ControlledAgent::ControlledAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool netWorth::ControlledAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t netWorth::ControlledAgent::SelectAction (\n    const cse491::WorldGrid &amp;,\n    const cse491::type_options_t &amp;,\n    const cse491::item_map_t &amp;,\n    const cse491::agent_map_t &amp;\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ControlledAgent.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/","title":"Class netWorth::NetworkingInterface","text":"<p>ClassList &gt; netWorth &gt; NetworkingInterface</p> <p>Inherits the following classes: InterfaceBase</p> <p>Inherited by the following classes: netWorth::ClientInterface,  netWorth::ServerInterface</p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#public-functions","title":"Public Functions","text":"Type Name NetworkingInterface (size_t id, const std::string &amp; name) the destination port of the machine this communicates with virtual bool bindSocket (UdpSocket &amp; socket, unsigned short port)  virtual UdpSocket * getSocket ()  virtual bool receivePacket (Packet &amp; pkt, std::optional&lt; IpAddress &gt; &amp; sender, unsigned short &amp; port)  virtual bool sendPacket (Packet packet, IpAddress destAddr, const unsigned short port)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#protected-attributes","title":"Protected Attributes","text":"Type Name std::optional&lt; IpAddress &gt; m_ip The socket we are going to make our connection. unsigned short m_port   = = 0the destination IP of the machine this communicates with UdpSocket m_socket"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-networkinginterface","title":"function NetworkingInterface","text":"<p>the destination port of the machine this communicates with </p> <pre><code>inline netWorth::NetworkingInterface::NetworkingInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-bindsocket","title":"function bindSocket","text":"<pre><code>inline virtual bool netWorth::NetworkingInterface::bindSocket (\n    UdpSocket &amp; socket,\n    unsigned short port\n) \n</code></pre> <p>Bind socket to port number </p> <p>Parameters:</p> <ul> <li><code>socket</code> Socket to be bound </li> <li><code>port</code> Port number </li> </ul> <p>Returns:</p> <p>true if successful </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-getsocket","title":"function getSocket","text":"<pre><code>inline virtual UdpSocket * netWorth::NetworkingInterface::getSocket () \n</code></pre> <p>Receives a socket that has been connected between client and server </p> <p>Returns:</p> <p>the udp socket </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-receivepacket","title":"function receivePacket","text":"<pre><code>inline virtual bool netWorth::NetworkingInterface::receivePacket (\n    Packet &amp; pkt,\n    std::optional&lt; IpAddress &gt; &amp; sender,\n    unsigned short &amp; port\n) \n</code></pre> <p>Starts the connection by receiving the first packet </p> <p>Parameters:</p> <ul> <li><code>sender</code> IP of sending machine </li> <li><code>port</code> port number of sending machine </li> </ul> <p>Returns:</p> <p>received packet </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-sendpacket","title":"function sendPacket","text":"<pre><code>inline virtual bool netWorth::NetworkingInterface::sendPacket (\n    Packet packet,\n    IpAddress destAddr,\n    const unsigned short port\n) \n</code></pre> <p>Sends a packet across the socket </p> <p>Parameters:</p> <ul> <li><code>packet</code> the packet we want to send </li> <li><code>destAddr</code> the destination address we want to send to </li> <li><code>port</code> the port of the connection </li> </ul> <p>Returns:</p> <p>true if successfully sent </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#variable-m_ip","title":"variable m_ip","text":"<pre><code>std::optional&lt;IpAddress&gt; m_ip;\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#variable-m_port","title":"variable m_port","text":"<pre><code>unsigned short m_port;\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#variable-m_socket","title":"variable m_socket","text":"<pre><code>UdpSocket m_socket;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/NetworkInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/","title":"Class netWorth::ServerInterface","text":"<p>ClassList &gt; netWorth &gt; ServerInterface</p> <p>More...</p> <ul> <li><code>#include &lt;ServerInterface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: netWorth::NetworkingInterface</p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-functions","title":"Public Functions","text":"Type Name bool Initialize () override size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; typeOptions, const cse491::item_map_t &amp; itemMap, const cse491::agent_map_t &amp; agentMap) override ServerInterface (size_t id, const std::string &amp; name) Port used by server manager to handle world updates."},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-functions-inherited-from-networthnetworkinginterface","title":"Public Functions inherited from netWorth::NetworkingInterface","text":"<p>See netWorth::NetworkingInterface</p> Type Name NetworkingInterface (size_t id, const std::string &amp; name) the destination port of the machine this communicates with virtual bool bindSocket (UdpSocket &amp; socket, unsigned short port)  virtual UdpSocket * getSocket ()  virtual bool receivePacket (Packet &amp; pkt, std::optional&lt; IpAddress &gt; &amp; sender, unsigned short &amp; port)  virtual bool sendPacket (Packet packet, IpAddress destAddr, const unsigned short port)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-static-functions","title":"Public Static Functions","text":"Type Name Packet gridToPacket (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; typeOptions, const cse491::item_map_t &amp; itemMap, const cse491::agent_map_t &amp; agentMap)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#protected-attributes-inherited-from-networthnetworkinginterface","title":"Protected Attributes inherited from netWorth::NetworkingInterface","text":"<p>See netWorth::NetworkingInterface</p> Type Name std::optional&lt; IpAddress &gt; m_ip The socket we are going to make our connection. unsigned short m_port   = = 0the destination IP of the machine this communicates with UdpSocket m_socket"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#detailed-description","title":"Detailed Description","text":"<p>The server that will be running and that allows clients to connect to, acts as a sort of clone </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#function-initialize","title":"function Initialize","text":"<pre><code>inline bool netWorth::ServerInterface::Initialize () override\n</code></pre> <p>Function that initializes server interface </p> <p>Returns:</p> <p>boolean stating whether initialization was successful or not </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t netWorth::ServerInterface::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; typeOptions,\n    const cse491::item_map_t &amp; itemMap,\n    const cse491::agent_map_t &amp; agentMap\n) override\n</code></pre> <p>Choose action for player agent (mirror client agent) </p> <p>Parameters:</p> <ul> <li><code>grid</code> the server-side grid </li> <li><code>typeOptions</code> different cell types of the world </li> <li><code>itemMap</code> the items that may be apart of the grid </li> <li><code>agentMap</code> the agents that may be apart of the grid </li> </ul> <p>Returns:</p> <p>action ID of the interface </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#function-serverinterface","title":"function ServerInterface","text":"<p>Port used by server manager to handle world updates. </p> <pre><code>inline netWorth::ServerInterface::ServerInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#function-gridtopacket","title":"function gridToPacket","text":"<pre><code>static inline Packet netWorth::ServerInterface::gridToPacket (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; typeOptions,\n    const cse491::item_map_t &amp; itemMap,\n    const cse491::agent_map_t &amp; agentMap\n) \n</code></pre> <p>The grid that will be sent to the client from the server after the connection so the client can start asking to make moves </p> <p>Parameters:</p> <ul> <li><code>grid</code> the grid to send to the server </li> <li><code>typeOptions</code> different cell types of the world </li> <li><code>itemMap</code> the items that may be apart of the grid </li> <li><code>agentMap</code> the agents that may be apart of the grid </li> </ul> <p>Returns:</p> <p>the grid that will be sent to the client </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/ServerInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/","title":"Class netWorth::ServerManager","text":"<p>ClassList &gt; netWorth &gt; ServerManager</p> <p>More...</p> <ul> <li><code>#include &lt;ServerManager.hpp&gt;</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-attributes","title":"Public Attributes","text":"Type Name unsigned short m_max_client_port   = = 55000Port for initial client connection."},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const constexpr unsigned short m_init_connection_port   = = 55000Boolean that states if there are interfaces present on the server."},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-functions","title":"Public Functions","text":"Type Name ServerManager () = defaultPort that is incremented for client thread handoff. sf::Packet actionMapToPacket ()  void addToInterfaceSet (size_t agent_id)  void addToUpdatePairs (sf::IpAddress ip, unsigned short port)  std::string getSerializedAgents ()  bool hasAgentsPresent () const void increasePort ()  void removeFromActionMap (size_t key)  void removeFromUpdatePairs (sf::IpAddress ip, unsigned short port)  void removeInterface (size_t id)  void sendGameUpdates ()  void setNewAgent (bool hasNewAgent)  void setSerializedAgents (std::string &amp; serializedAgents)  void writeToActionMap (size_t key, size_t val)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#detailed-description","title":"Detailed Description","text":"<p>The server that will be running and that allows clients to connect to </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#variable-m_max_client_port","title":"variable m_max_client_port","text":"<pre><code>unsigned short m_max_client_port;\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#variable-m_init_connection_port","title":"variable m_init_connection_port","text":"<pre><code>const constexpr unsigned short m_init_connection_port;\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-servermanager","title":"function ServerManager","text":"<p>Port that is incremented for client thread handoff. </p> <pre><code>netWorth::ServerManager::ServerManager () = default\n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-actionmaptopacket","title":"function actionMapToPacket","text":"<pre><code>inline sf::Packet netWorth::ServerManager::actionMapToPacket () \n</code></pre> <p>Convert action map to packet to send to client </p> <p>Returns:</p> <p>packet containing action map as series of integers </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-addtointerfaceset","title":"function addToInterfaceSet","text":"<pre><code>inline void netWorth::ServerManager::addToInterfaceSet (\n    size_t agent_id\n) \n</code></pre> <p>Adds and interface to the interface set </p> <p>Parameters:</p> <ul> <li><code>agent_id</code> </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-addtoupdatepairs","title":"function addToUpdatePairs","text":"<pre><code>inline void netWorth::ServerManager::addToUpdatePairs (\n    sf::IpAddress ip,\n    unsigned short port\n) \n</code></pre> <p>Adds an IP and port to a vector for group update </p> <p>Parameters:</p> <ul> <li><code>ip</code> IP address of client receiving updates </li> <li><code>port</code> port of client receiving updates </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-getserializedagents","title":"function getSerializedAgents","text":"<pre><code>inline std::string netWorth::ServerManager::getSerializedAgents () \n</code></pre> <p>Returns the current serialized agents </p> <p>Returns:</p> <p>a string of the current serialized agents </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-hasagentspresent","title":"function hasAgentsPresent","text":"<pre><code>inline bool netWorth::ServerManager::hasAgentsPresent () const\n</code></pre> <p>Returns if there are agents present on the server as a boolean </p> <p>Returns:</p> <p>boolean representing if there are agents present on the server </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-increaseport","title":"function increasePort","text":"<pre><code>inline void netWorth::ServerManager::increasePort () \n</code></pre> <p>Increases the max client port </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-removefromactionmap","title":"function removeFromActionMap","text":"<pre><code>inline void netWorth::ServerManager::removeFromActionMap (\n    size_t key\n) \n</code></pre> <p>Removes an interface from action map by key </p> <p>Parameters:</p> <ul> <li><code>key</code> </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-removefromupdatepairs","title":"function removeFromUpdatePairs","text":"<pre><code>inline void netWorth::ServerManager::removeFromUpdatePairs (\n    sf::IpAddress ip,\n    unsigned short port\n) \n</code></pre> <p>Removes ip and port from the update vector </p> <p>Parameters:</p> <ul> <li><code>ip</code> ip to remove </li> <li><code>port</code> port to remove </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-removeinterface","title":"function removeInterface","text":"<pre><code>inline void netWorth::ServerManager::removeInterface (\n    size_t id\n) \n</code></pre> <p>Removes an interface by ID </p> <p>Parameters:</p> <ul> <li><code>id</code> </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-sendgameupdates","title":"function sendGameUpdates","text":"<pre><code>inline void netWorth::ServerManager::sendGameUpdates () \n</code></pre> <p>Sends game updates to all clients when a new agent joins </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-setnewagent","title":"function setNewAgent","text":"<pre><code>inline void netWorth::ServerManager::setNewAgent (\n    bool hasNewAgent\n) \n</code></pre> <p>Sets a boolean stating if the server has received a new agent </p> <p>Parameters:</p> <ul> <li><code>hasNewAgent</code> boolean stating that a new agent has joined </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-setserializedagents","title":"function setSerializedAgents","text":"<pre><code>inline void netWorth::ServerManager::setSerializedAgents (\n    std::string &amp; serializedAgents\n) \n</code></pre> <p>Sets the current serialized agents of the server </p> <p>Parameters:</p> <ul> <li><code>serializedAgents</code> string reference representing the serialized agents </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-writetoactionmap","title":"function writeToActionMap","text":"<pre><code>inline void netWorth::ServerManager::writeToActionMap (\n    size_t key,\n    size_t val\n) \n</code></pre> <p>Writes to the action map </p> <p>Parameters:</p> <ul> <li><code>key</code> to reference </li> <li><code>val</code> to write </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/ServerManager.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/namespacesf/","title":"Namespace sf","text":"<p>Namespace List &gt; sf</p> <p>More...</p>"},{"location":"Networks%20%28Group%205%29/namespacesf/#detailed-description","title":"Detailed Description","text":"<p>The interface of our client that will be interacting and connection with our server </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Networks%20%28Group%205%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Interfaces <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Networks%20%28Group%205%29/dir_e52260c07c5ca641bf485ae92612dd08/","title":"Dir source/Interfaces","text":"<p>FileList &gt; Interfaces</p>"},{"location":"Networks%20%28Group%205%29/dir_e52260c07c5ca641bf485ae92612dd08/#directories","title":"Directories","text":"Type Name dir NetWorth <p>The documentation for this class was generated from the following file <code>source/Interfaces/</code></p>"},{"location":"Networks%20%28Group%205%29/dir_0121daa1f68cbca759acb74b3e906cff/","title":"Dir source/Interfaces/NetWorth","text":"<p>FileList &gt; Interfaces &gt; NetWorth</p>"},{"location":"Networks%20%28Group%205%29/dir_0121daa1f68cbca759acb74b3e906cff/#files","title":"Files","text":"Type Name file NetworkInterface.hpp"},{"location":"Networks%20%28Group%205%29/dir_0121daa1f68cbca759acb74b3e906cff/#directories","title":"Directories","text":"Type Name dir client dir server <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/</code></p>"},{"location":"Networks%20%28Group%205%29/_network_interface_8hpp/","title":"File NetworkInterface.hpp","text":"<p>FileList &gt; Interfaces &gt; NetWorth &gt; NetworkInterface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;SFML/Network/UdpSocket.hpp&gt;</code></li> <li><code>#include &lt;SFML/Network/Packet.hpp&gt;</code></li> <li><code>#include \"../../core/InterfaceBase.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_network_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_network_interface_8hpp/#classes","title":"Classes","text":"Type Name class NetworkingInterface <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/NetworkInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_network_interface_8hpp_source/","title":"File NetworkInterface.hpp","text":"<p>File List &gt; Interfaces &gt; NetWorth &gt; NetworkInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n#include &lt;SFML/Network/UdpSocket.hpp&gt;\n#include &lt;SFML/Network/Packet.hpp&gt;\n#include \"../../core/InterfaceBase.hpp\"\n\nnamespace netWorth{\n\n    using namespace sf;\n\n    class NetworkingInterface : public virtual cse491::InterfaceBase {\n        private:\n\n        protected:\n            UdpSocket m_socket;             \n            std::optional&lt;IpAddress&gt; m_ip;  \n            unsigned short m_port = 0;      \n\n        public:\n            NetworkingInterface(size_t id, const std::string &amp; name) : cse491::InterfaceBase(id, name) {\n\n            }\n\n            virtual UdpSocket * getSocket(){\n                return &amp;m_socket;\n            }\n\n            virtual bool bindSocket(UdpSocket &amp;socket, unsigned short port) {\n                std::cout &lt;&lt; \"Binding socket on port: \" &lt;&lt; port &lt;&lt; std::endl;\n                if (socket.bind(port) != Socket::Status::Done) {\n                    std::cerr &lt;&lt; \"Failed to bind socket\" &lt;&lt; std::endl;\n                    return false;\n                }\n                return true;\n            }\n\n            virtual bool sendPacket(Packet packet, IpAddress destAddr, const unsigned short port){\n                if (m_socket.send(packet, destAddr, port) != Socket::Status::Done) {\n                    std::cerr &lt;&lt; \"Could not connect to\" &lt;&lt; destAddr &lt;&lt; \" at port \" &lt;&lt; port &lt;&lt; std::endl;\n                    return false;\n                }\n                return true;\n            }\n\n            virtual bool receivePacket(Packet &amp; pkt, std::optional&lt;IpAddress&gt; &amp;sender, unsigned short &amp;port){\n                if (m_socket.receive(pkt, sender,port) != Socket::Status::Done) {\n                    std::cerr &lt;&lt; \"Failed to receive\" &lt;&lt; std::endl;\n                    return false;\n                }\n                return true;\n            }\n\n        }; // End of NetworkingInterface\n} // End of namespace netWorth\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/dir_d63376ef77eb621cc9b73f8097e771f8/","title":"Dir source/Interfaces/NetWorth/client","text":"<p>FileList &gt; client</p>"},{"location":"Networks%20%28Group%205%29/dir_d63376ef77eb621cc9b73f8097e771f8/#files","title":"Files","text":"Type Name file ClientInterface.hpp file ClientManager.hpp file ControlledAgent.hpp <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/</code></p>"},{"location":"Networks%20%28Group%205%29/_client_interface_8hpp/","title":"File ClientInterface.hpp","text":"<p>FileList &gt; client &gt; ClientInterface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Interfaces/NetWorth/NetworkInterface.hpp\"</code></li> <li><code>#include \"Interfaces/TrashInterface.hpp\"</code></li> <li><code>#include \"Interfaces/MainInterface.hpp\"</code></li> <li><code>#include \"ClientManager.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_client_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network. namespace sf"},{"location":"Networks%20%28Group%205%29/_client_interface_8hpp/#classes","title":"Classes","text":"Type Name class ClientInterface <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_client_interface_8hpp_source/","title":"File ClientInterface.hpp","text":"<p>File List &gt; client &gt; ClientInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"Interfaces/NetWorth/NetworkInterface.hpp\"\n#include \"Interfaces/TrashInterface.hpp\"\n#include \"Interfaces/MainInterface.hpp\"\n#include \"ClientManager.hpp\"\n\nnamespace netWorth{\n    using namespace sf;\n\n    class ClientInterface : public NetworkingInterface, i_2D::MainInterface {\n        private:\n            netWorth::ClientManager *m_manager = nullptr;\n\n        protected:\n\n        public:\n            ClientInterface(size_t id, const std::string &amp; name) : cse491::InterfaceBase(id, name),\n                                                                   NetworkingInterface(id, name),\n                                                                   i_2D::MainInterface(id, name) {}\n\n            bool Initialize() override {\n                // resolve port and IP from entity properties\n                m_ip = sf::IpAddress::resolve(NetworkingInterface::GetProperty&lt;std::string&gt;(\"server_ip\"));\n                m_port = NetworkingInterface::GetProperty&lt;unsigned short&gt;(\"server_port\");\n                m_manager = GetProperty&lt;netWorth::ClientManager *&gt;(\"manager\");\n                m_manager-&gt;setupSocket(&amp;m_socket, m_ip);\n                m_manager-&gt;setClientID(id);\n\n                Packet sendPkt, recvPkt,twoPkt;\n                setMInputWaitTime(0.25f);\n\n                // send request message\n                sendPkt &lt;&lt; \"New client requesting connection.\";\n                auto ip = m_ip.value();\n                if (!sendPacket(sendPkt, ip, m_port)) return false;\n\n                // receive from server\n                if (!receivePacket(recvPkt, m_ip, m_port)) return false;\n                // print received string (Connection established.)\n                std::string msg;\n                recvPkt &gt;&gt; msg;\n                std::cout &lt;&lt; msg &lt;&lt; std::endl;\n\n                // request map to start send/receive loop\n                sendPkt.clear();\n                sendPkt &lt;&lt; \"Requesting start\";\n                if (!sendPacket(sendPkt, m_ip.value(), m_port)) return false;\n\n\n                // receive action map from server for previous agents\n                receivePacket(recvPkt, m_ip, m_port);\n                m_manager-&gt;packetToActionMap(recvPkt);\n\n                return true;\n            }\n\n            size_t SelectAction(const cse491::WorldGrid &amp; grid,\n                                const cse491::type_options_t &amp; typeOptions,\n                                const cse491::item_map_t &amp; itemMap,\n                                const cse491::agent_map_t &amp; agentMap) override\n            {\n                // Receive and draw map\n                sf::Packet sendPkt, recvPkt;\n\n                // grab action ID from MainInterface\n                size_t actionID = i_2D::MainInterface::SelectAction(grid, typeOptions,\n                            itemMap, agentMap);\n\n                // Send instruction to server\n                sendPkt &lt;&lt; static_cast&lt;uint64_t&gt;(actionID);\n                sendPacket(sendPkt, m_ip.value(), m_port);\n\n                m_manager-&gt;clearActionMap();\n                DrawGrid(grid, typeOptions, itemMap, agentMap);\n\n                // await action map from server\n                receivePacket(recvPkt, m_ip, m_port);\n                m_manager-&gt;packetToActionMap(recvPkt);\n\n                // Do the action!\n                return actionID;\n            }\n\n    }; // End of ClientInterface\n} // End of namespace NetWorth\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/_client_manager_8hpp/","title":"File ClientManager.hpp","text":"<p>FileList &gt; client &gt; ClientManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_client_manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_client_manager_8hpp/#classes","title":"Classes","text":"Type Name class ClientManager <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientManager.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_client_manager_8hpp_source/","title":"File ClientManager.hpp","text":"<p>File List &gt; client &gt; ClientManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n\nnamespace netWorth{\n    using namespace sf;\n\n    class ClientManager {\n    private:\n        sf::UdpSocket *m_socket = nullptr;                \n        sf::UdpSocket *m_game_update_socket = nullptr;    \n        std::optional&lt;sf::IpAddress&gt; m_ip;      \n        unsigned short m_update_port = 0; \n        std::unordered_map&lt;size_t, size_t&gt; m_action_map;     \n        size_t m_client_id = 0;     \n    protected:\n\n    public:\n\n        ClientManager()= default;\n\n        void setUpdatePort(unsigned short port) {m_update_port = port;}\n\n        void packetToActionMap(sf::Packet pkt) {\n            uint64_t dataSize, agentID, actionID;\n            pkt &gt;&gt; dataSize;\n            for (size_t i = 0; i &lt; dataSize; i++) {\n                pkt &gt;&gt; agentID &gt;&gt; actionID;\n                m_action_map[agentID] = actionID;\n            }\n        }\n\n        void setupSocket(sf::UdpSocket *socket, std::optional&lt;sf::IpAddress&gt; ip) {\n            m_socket = socket;\n            m_ip = ip;\n        }\n\n        void setupGameUpdateSocket(sf::UdpSocket *socket) {\n            m_game_update_socket = socket;\n            m_game_update_socket-&gt;setBlocking(false);\n            if (m_game_update_socket-&gt;bind(m_update_port) != Socket::Status::Done){\n                std::cerr &lt;&lt; \"Failed to setup game update socket\" &lt;&lt; std::endl;\n            }\n        }\n\n        bool iDPresent(size_t id) {\n            return m_action_map.contains(id);\n        }\n\n        size_t getActionID(size_t id) {\n            return m_action_map[id];\n        }\n\n        void clearActionMap() {\n            m_action_map.clear();\n        }\n\n        std::string getSerializedAgents() {\n            sf::Packet recvPkt;\n            std::optional&lt;sf::IpAddress&gt; tempIP;\n            unsigned short tempPort;\n            if (m_game_update_socket-&gt;receive(recvPkt, tempIP, tempPort) == sf::Socket::Status::Done) {\n                std::string data;\n                recvPkt &gt;&gt; data;\n                return data;\n            }\n            return \"\";\n        }\n\n\n        void setClientID(size_t id) {\n            m_client_id = id;\n        }\n\n        size_t getClientID() const{\n            return m_client_id;\n        }\n\n    }; // End of class ClientManager\n} // End of namespace netWorth\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/_controlled_agent_8hpp/","title":"File ControlledAgent.hpp","text":"<p>FileList &gt; client &gt; ControlledAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"../../../core/AgentBase.hpp\"</code></li> <li><code>#include \"ClientManager.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_controlled_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_controlled_agent_8hpp/#classes","title":"Classes","text":"Type Name class ControlledAgent <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ControlledAgent.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_controlled_agent_8hpp_source/","title":"File ControlledAgent.hpp","text":"<p>File List &gt; client &gt; ControlledAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"../../../core/AgentBase.hpp\"\n#include \"ClientManager.hpp\"\n\nnamespace netWorth\n{\n\n    class ControlledAgent : public cse491::AgentBase\n    {\n    private:\n        ClientManager* m_manager = nullptr;       \n\n    protected:\n\n    public:\n        ControlledAgent(size_t id, const std::string&amp; name) : AgentBase(id, name)\n        {\n        }\n\n        bool Initialize() override\n        {\n            m_manager = GetProperty&lt;ClientManager*&gt;(\"manager\");\n            return HasAction(\"up\") &amp;&amp; HasAction(\"down\") &amp;&amp; HasAction(\"left\") &amp;&amp; HasAction(\"right\");\n        }\n\n        size_t SelectAction(const cse491::WorldGrid&amp; /* grid*/,\n            const cse491::type_options_t&amp; /* type_options*/,\n            const cse491::item_map_t&amp; /* item_map*/,\n            const cse491::agent_map_t&amp; /* agent_map*/) override\n        {\n            if (!m_manager-&gt;iDPresent(id))\n            {\n                return 0;\n            }\n            return m_manager-&gt;getActionID(id);\n        }\n\n    };\n\n} // End of namespace cse491\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/dir_1ea711888d2c31b2ee5b33ee0d19cbd8/","title":"Dir source/Interfaces/NetWorth/server","text":"<p>FileList &gt; Interfaces &gt; NetWorth &gt; server</p>"},{"location":"Networks%20%28Group%205%29/dir_1ea711888d2c31b2ee5b33ee0d19cbd8/#files","title":"Files","text":"Type Name file ServerInterface.hpp file ServerManager.hpp <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/</code></p>"},{"location":"Networks%20%28Group%205%29/_server_interface_8hpp/","title":"File ServerInterface.hpp","text":"<p>FileList &gt; Interfaces &gt; NetWorth &gt; server &gt; ServerInterface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ServerManager.hpp\"</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"Interfaces/NetWorth/NetworkInterface.hpp\"</code></li> <li><code>#include \"Worlds/MazeWorld.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_server_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_server_interface_8hpp/#classes","title":"Classes","text":"Type Name class ServerInterface <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/ServerInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_server_interface_8hpp_source/","title":"File ServerInterface.hpp","text":"<p>File List &gt; Interfaces &gt; NetWorth &gt; server &gt; ServerInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"ServerManager.hpp\"\n#include &lt;thread&gt;\n#include &lt;sstream&gt;\n#include \"Interfaces/NetWorth/NetworkInterface.hpp\"\n#include \"Worlds/MazeWorld.hpp\"\n\nnamespace netWorth\n{\n    using namespace sf;\n\n    class ServerInterface : public NetworkingInterface\n    {\n    private:\n        ServerManager* m_manager = nullptr; \n\n        unsigned short m_world_update_port = 0;  \n    protected:\n\n    public:\n        ServerInterface(size_t id, const std::string&amp; name)\n            : cse491::InterfaceBase(id, name),\n              NetworkingInterface(id, name)\n        {\n\n        }\n\n        bool Initialize() override\n        {\n            // resolve port and IP from entity properties\n            m_ip = sf::IpAddress::resolve(NetworkingInterface::GetProperty&lt;std::string&gt;(\"client_ip\"));\n            m_world_update_port = NetworkingInterface::GetProperty&lt;unsigned short&gt;(\"client_port\");\n            m_manager = GetProperty&lt;netWorth::ServerManager*&gt;(\"server_manager\");\n\n            Packet sendPkt, recvPkt;\n            std::string str;\n\n            bindSocket(m_socket, GetProperty&lt;unsigned short&gt;(\"server_port\"));\n\n            // Await client\n            if (!receivePacket(recvPkt, m_ip, m_port))\n                return false;\n\n            std::cout &lt;&lt; m_ip.value() &lt;&lt; \" has connected successfully.\" &lt;&lt; std::endl;\n\n            // Acknowledge client\n            sendPkt &lt;&lt; \"Connection established.\";\n            if (!sendPacket(sendPkt, m_ip.value(), m_port))\n                return false;\n\n            recvPkt.clear();\n            // await request for map\n            if (!receivePacket(recvPkt, m_ip, m_port))\n                return false;\n\n            GetWorld().SetWorldRunning(true);\n            return true;\n        }\n\n        static Packet gridToPacket(const cse491::WorldGrid&amp; grid,\n            const cse491::type_options_t&amp; typeOptions,\n            const cse491::item_map_t&amp; itemMap,\n            const cse491::agent_map_t&amp; agentMap)\n        {\n            std::vector&lt;std::string&gt; packetGrid(grid.GetHeight());\n\n            // Load the world into the symbol_grid;\n            for (size_t y = 0; y &lt; grid.GetHeight(); ++y)\n            {\n                packetGrid[y].resize(grid.GetWidth());\n                for (size_t x = 0; x &lt; grid.GetWidth(); ++x)\n                {\n                    packetGrid[y][x] = typeOptions[grid.At(x, y)].symbol;\n                }\n            }\n\n            // Add in the agents / entities\n            for (const auto&amp; [id, entityPtr] : itemMap)\n            {\n                cse491::GridPosition pos = entityPtr-&gt;GetPosition();\n        if(!std::isnan(pos.GetX()) &amp;&amp; !std::isnan(pos.GetY())\n            &amp;&amp; pos.CellX() &lt; grid.GetWidth() &amp;&amp; pos.CellY() &lt; grid.GetHeight()){\n          packetGrid[pos.CellY()][pos.CellX()] = '+';\n        }\n            }\n\n            for (const auto&amp; [id, agent_ptr] : agentMap)\n            {\n                cse491::GridPosition pos = agent_ptr-&gt;GetPosition();\n                char c = '*';\n                if (agent_ptr-&gt;HasProperty(\"symbol\"))\n                {\n                    c = agent_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n                }\n        if(!std::isnan(pos.GetX()) &amp;&amp; !std::isnan(pos.GetY())\n            &amp;&amp; pos.CellX() &lt; grid.GetWidth() &amp;&amp; pos.CellY() &lt; grid.GetHeight()){\n                  packetGrid[pos.CellY()][pos.CellX()] = c;\n        }\n            }\n\n            // Print out the symbol_grid with a box around it.\n            std::ostringstream oss;\n            oss &lt;&lt; '+' &lt;&lt; std::string(grid.GetWidth(), '-') &lt;&lt; \"+\\n\";\n            for (const auto&amp; row : packetGrid)\n            {\n                oss &lt;&lt; \"|\";\n                for (char cell : row)\n                {\n                    oss &lt;&lt; cell;\n                }\n                oss &lt;&lt; \"|\\n\";\n            }\n            oss &lt;&lt; '+' &lt;&lt; std::string(grid.GetWidth(), '-') &lt;&lt; \"+\\n\";\n            std::string gridString = oss.str();\n\n            Packet gridPacket;\n            gridPacket &lt;&lt; gridString;\n\n            return gridPacket;\n        }\n\n        size_t SelectAction(const cse491::WorldGrid&amp; grid,\n            const cse491::type_options_t&amp; typeOptions,\n            const cse491::item_map_t&amp; itemMap,\n            const cse491::agent_map_t&amp; agentMap) override\n        {\n            // send action map to client\n            sf::Packet sendPkt = m_manager-&gt;actionMapToPacket();\n            std::cout &lt;&lt; \"Sending action map to \" &lt;&lt; m_ip.value().toString() &lt;&lt; \" on port \" &lt;&lt; m_port &lt;&lt; std::endl;\n            sendPacket(sendPkt, m_ip.value(), m_port);\n\n            // print server-side map (for test purposes)\n            sf::Packet mapPkt = gridToPacket(grid, typeOptions, itemMap, agentMap);\n            std::string map;\n            mapPkt &gt;&gt; map;\n            std::cout &lt;&lt; map &lt;&lt; std::endl;\n\n            // receive player input\n            sf::Packet recvPkt;\n            uint64_t actionID;\n            receivePacket(recvPkt, m_ip, m_port);\n            recvPkt &gt;&gt; actionID;\n\n            // handle leaving client\n            if (actionID == 9999)\n            {\n                m_manager-&gt;removeInterface(GetID());\n                m_manager-&gt;removeFromActionMap(GetID());\n                m_manager-&gt;removeFromUpdatePairs(m_ip.value(), m_world_update_port);\n            }\n\n            // return actionId\n            return actionID;\n        }\n\n    }; // End of class ServerInterface\n// End of namespace netWorth\n}\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/_server_manager_8hpp/","title":"File ServerManager.hpp","text":"<p>FileList &gt; Interfaces &gt; NetWorth &gt; server &gt; ServerManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Interfaces/NetWorth/NetworkInterface.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_server_manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_server_manager_8hpp/#classes","title":"Classes","text":"Type Name class ServerManager <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/ServerManager.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_server_manager_8hpp_source/","title":"File ServerManager.hpp","text":"<p>File List &gt; Interfaces &gt; NetWorth &gt; server &gt; ServerManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n#include &lt;thread&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include \"Interfaces/NetWorth/NetworkInterface.hpp\"\n\nnamespace netWorth{\n    using namespace sf;\n\n    class ServerManager {\n    private:\n\n        sf::UdpSocket m_manager_socket;\n\n        std::set&lt;size_t&gt; m_interface_set;   \n\n        std::map&lt;size_t, size_t&gt; m_action_map; \n\n        std::string m_current_serialized_agents; \n\n        std::vector&lt;std::pair&lt;sf::IpAddress, unsigned short&gt;&gt; m_update_vec; \n\n        bool m_has_new_agent = false; \n\n        bool m_interfaces_present = false; \n\n    protected:\n\n    public:\n        const static constexpr unsigned short m_init_connection_port = 55000; \n\n        unsigned short m_max_client_port = 55000; \n\n        ServerManager() = default;\n\n        std::string getSerializedAgents(){return m_current_serialized_agents;}\n\n        void setSerializedAgents(std::string &amp; serializedAgents) { m_current_serialized_agents = serializedAgents;}\n\n        [[nodiscard]] bool hasAgentsPresent() const {return m_interfaces_present;}\n\n        void setNewAgent(bool hasNewAgent){ m_has_new_agent = hasNewAgent;}\n\n        sf::Packet actionMapToPacket()\n        {\n            sf::Packet pkt;\n\n            // serialize action map\n            pkt &lt;&lt; static_cast&lt;uint64_t&gt;(m_action_map.size());\n            for (auto [agent_id, action_id]: m_action_map) {\n                pkt &lt;&lt; static_cast&lt;uint64_t&gt;(agent_id) &lt;&lt; static_cast&lt;uint64_t&gt;(action_id);\n            }\n\n            return pkt;\n        }\n\n        void increasePort(){++m_max_client_port;}\n\n        void removeInterface(size_t id){\n            m_interface_set.erase(id);\n            if (m_interface_set.empty()) m_interfaces_present = false;\n        }\n\n        void addToUpdatePairs(sf::IpAddress ip, unsigned short port){\n            m_update_vec.emplace_back(ip, port);\n        }\n\n         void sendGameUpdates(){\n            if (m_has_new_agent)\n            {\n                sf::Packet serializedAgentPkt;\n                serializedAgentPkt &lt;&lt; getSerializedAgents();\n                //Loops through all pairs of IP and port and sends serialized agents\n                for (auto client: m_update_vec){\n                    std::cout &lt;&lt; \"sending game updates to IP: \" &lt;&lt; client.first.toString() &lt;&lt; \" with port \" &lt;&lt;\n                    client.second &lt;&lt; std::endl;\n                    if (m_manager_socket.send(serializedAgentPkt, client.first, client.second) != sf::Socket::Status::Done) {\n                        std::cerr &lt;&lt; \"Error sending updates to client at \" &lt;&lt; client.first.toString() &lt;&lt; \" port \" &lt;&lt; client.second &lt;&lt; std::endl;\n                    }\n                }\n                m_has_new_agent = false;\n            }\n        }\n\n        void removeFromActionMap(size_t key){\n            m_action_map.erase(key);\n        }\n\n        void removeFromUpdatePairs(sf::IpAddress ip, unsigned short port){\n            m_update_vec.erase(std::remove_if(m_update_vec.begin(), m_update_vec.end(),\n                [ip, port](std::pair&lt;sf::IpAddress, unsigned short&gt; pair){\n                return (pair.first == ip &amp;&amp; pair.second == port);\n            }), m_update_vec.end());\n        }\n\n        void writeToActionMap(size_t key, size_t val){\n            m_action_map.insert_or_assign(key, val);\n        }\n\n        void addToInterfaceSet(size_t agent_id){\n            m_interface_set.insert(agent_id);\n            m_interfaces_present = true;\n        }\n\n    }; // End of class ServerManager\n} // End of namespace netWorth\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cse491 </li> <li>namespace i_2D </li> <li>namespace netWorth A networking interface that allows information to be sent across a network. </li> <li>namespace sf </li> </ul>"},{"location":"Networks%20%28Group%205%29/classes/","title":"Class Index","text":""},{"location":"Networks%20%28Group%205%29/classes/#c","title":"c","text":"<ul> <li>ClientInterface (netWorth)</li> <li>ClientManager (netWorth)</li> <li>ControlledAgent (netWorth)</li> </ul>"},{"location":"Networks%20%28Group%205%29/classes/#n","title":"n","text":"<ul> <li>NetworkingInterface (netWorth)</li> </ul>"},{"location":"Networks%20%28Group%205%29/classes/#s","title":"s","text":"<ul> <li>ServerInterface (netWorth)</li> <li>ServerManager (netWorth)</li> </ul>"},{"location":"Networks%20%28Group%205%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class netWorth::ClientManager </li> <li>class netWorth::ServerManager </li> <li>class InterfaceBase <ul> <li>class netWorth::NetworkingInterface <ul> <li>class netWorth::ClientInterface </li> <li>class netWorth::ServerInterface </li> </ul> </li> <li>class netWorth::NetworkingInterface <ul> <li>class netWorth::ClientInterface </li> <li>class netWorth::ServerInterface </li> </ul> </li> <li>class netWorth::NetworkingInterface <ul> <li>class netWorth::ClientInterface </li> <li>class netWorth::ServerInterface </li> </ul> </li> </ul> </li> <li>class MainInterface <ul> <li>class netWorth::ClientInterface </li> </ul> </li> <li>class AgentBase <ul> <li>class netWorth::ControlledAgent </li> </ul> </li> </ul>"},{"location":"Networks%20%28Group%205%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Networks%20%28Group%205%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Networks%20%28Group%205%29/class_members/","title":"Class Members","text":""},{"location":"Networks%20%28Group%205%29/class_members/#a","title":"a","text":"<ul> <li>actionMapToPacket (netWorth::ServerManager)</li> <li>addToInterfaceSet (netWorth::ServerManager)</li> <li>addToUpdatePairs (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#b","title":"b","text":"<ul> <li>bindSocket (netWorth::NetworkingInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#c","title":"c","text":"<ul> <li>ClientInterface (netWorth::ClientInterface)</li> <li>ClientManager (netWorth::ClientManager)</li> <li>clearActionMap (netWorth::ClientManager)</li> <li>ControlledAgent (netWorth::ControlledAgent)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#g","title":"g","text":"<ul> <li>getActionID (netWorth::ClientManager)</li> <li>getClientID (netWorth::ClientManager)</li> <li>getSerializedAgents (netWorth::ClientManager, netWorth::ServerManager)</li> <li>getSocket (netWorth::NetworkingInterface)</li> <li>gridToPacket (netWorth::ServerInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#h","title":"h","text":"<ul> <li>hasAgentsPresent (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#i","title":"i","text":"<ul> <li>Initialize (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>iDPresent (netWorth::ClientManager)</li> <li>increasePort (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#m","title":"m","text":"<ul> <li>m_manager (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>m_action_map (netWorth::ClientManager, netWorth::ServerManager)</li> <li>m_client_id (netWorth::ClientManager)</li> <li>m_game_update_socket (netWorth::ClientManager)</li> <li>m_ip (netWorth::ClientManager, netWorth::NetworkingInterface)</li> <li>m_socket (netWorth::ClientManager, netWorth::NetworkingInterface)</li> <li>m_update_port (netWorth::ClientManager)</li> <li>m_port (netWorth::NetworkingInterface)</li> <li>m_world_update_port (netWorth::ServerInterface)</li> <li>m_current_serialized_agents (netWorth::ServerManager)</li> <li>m_has_new_agent (netWorth::ServerManager)</li> <li>m_init_connection_port (netWorth::ServerManager)</li> <li>m_interface_set (netWorth::ServerManager)</li> <li>m_interfaces_present (netWorth::ServerManager)</li> <li>m_manager_socket (netWorth::ServerManager)</li> <li>m_max_client_port (netWorth::ServerManager)</li> <li>m_update_vec (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#n","title":"n","text":"<ul> <li>NetworkingInterface (netWorth::NetworkingInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#p","title":"p","text":"<ul> <li>packetToActionMap (netWorth::ClientManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#r","title":"r","text":"<ul> <li>receivePacket (netWorth::NetworkingInterface)</li> <li>removeFromActionMap (netWorth::ServerManager)</li> <li>removeFromUpdatePairs (netWorth::ServerManager)</li> <li>removeInterface (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#s","title":"s","text":"<ul> <li>SelectAction (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>setClientID (netWorth::ClientManager)</li> <li>setUpdatePort (netWorth::ClientManager)</li> <li>setupGameUpdateSocket (netWorth::ClientManager)</li> <li>setupSocket (netWorth::ClientManager)</li> <li>sendPacket (netWorth::NetworkingInterface)</li> <li>ServerInterface (netWorth::ServerInterface)</li> <li>ServerManager (netWorth::ServerManager)</li> <li>sendGameUpdates (netWorth::ServerManager)</li> <li>setNewAgent (netWorth::ServerManager)</li> <li>setSerializedAgents (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#w","title":"w","text":"<ul> <li>writeToActionMap (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Networks%20%28Group%205%29/class_member_functions/#a","title":"a","text":"<ul> <li>actionMapToPacket (netWorth::ServerManager)</li> <li>addToInterfaceSet (netWorth::ServerManager)</li> <li>addToUpdatePairs (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#b","title":"b","text":"<ul> <li>bindSocket (netWorth::NetworkingInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#c","title":"c","text":"<ul> <li>ClientInterface (netWorth::ClientInterface)</li> <li>ClientManager (netWorth::ClientManager)</li> <li>clearActionMap (netWorth::ClientManager)</li> <li>ControlledAgent (netWorth::ControlledAgent)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#g","title":"g","text":"<ul> <li>getActionID (netWorth::ClientManager)</li> <li>getClientID (netWorth::ClientManager)</li> <li>getSerializedAgents (netWorth::ClientManager, netWorth::ServerManager)</li> <li>getSocket (netWorth::NetworkingInterface)</li> <li>gridToPacket (netWorth::ServerInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#h","title":"h","text":"<ul> <li>hasAgentsPresent (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>iDPresent (netWorth::ClientManager)</li> <li>increasePort (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#n","title":"n","text":"<ul> <li>NetworkingInterface (netWorth::NetworkingInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#p","title":"p","text":"<ul> <li>packetToActionMap (netWorth::ClientManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#r","title":"r","text":"<ul> <li>receivePacket (netWorth::NetworkingInterface)</li> <li>removeFromActionMap (netWorth::ServerManager)</li> <li>removeFromUpdatePairs (netWorth::ServerManager)</li> <li>removeInterface (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>setClientID (netWorth::ClientManager)</li> <li>setUpdatePort (netWorth::ClientManager)</li> <li>setupGameUpdateSocket (netWorth::ClientManager)</li> <li>setupSocket (netWorth::ClientManager)</li> <li>sendPacket (netWorth::NetworkingInterface)</li> <li>ServerInterface (netWorth::ServerInterface)</li> <li>ServerManager (netWorth::ServerManager)</li> <li>sendGameUpdates (netWorth::ServerManager)</li> <li>setNewAgent (netWorth::ServerManager)</li> <li>setSerializedAgents (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#w","title":"w","text":"<ul> <li>writeToActionMap (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Networks%20%28Group%205%29/class_member_variables/#m","title":"m","text":"<ul> <li>m_manager (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>m_action_map (netWorth::ClientManager, netWorth::ServerManager)</li> <li>m_client_id (netWorth::ClientManager)</li> <li>m_game_update_socket (netWorth::ClientManager)</li> <li>m_ip (netWorth::ClientManager, netWorth::NetworkingInterface)</li> <li>m_socket (netWorth::ClientManager, netWorth::NetworkingInterface)</li> <li>m_update_port (netWorth::ClientManager)</li> <li>m_port (netWorth::NetworkingInterface)</li> <li>m_world_update_port (netWorth::ServerInterface)</li> <li>m_current_serialized_agents (netWorth::ServerManager)</li> <li>m_has_new_agent (netWorth::ServerManager)</li> <li>m_init_connection_port (netWorth::ServerManager)</li> <li>m_interface_set (netWorth::ServerManager)</li> <li>m_interfaces_present (netWorth::ServerManager)</li> <li>m_manager_socket (netWorth::ServerManager)</li> <li>m_max_client_port (netWorth::ServerManager)</li> <li>m_update_vec (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Networks%20%28Group%205%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Networks%20%28Group%205%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Networks%20%28Group%205%29/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Networks%20%28Group%205%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Networks%20%28Group%205%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cowboys An Agent based on genetic programming. <ul> <li>class CGPAgent An agent based on cartesian genetic programming. </li> <li>class CGPGenotype Holds all the information that uniquely defines a cartesian graph. </li> <li>struct CGPNodeGene Holds the representation of a cartesian graph node. </li> <li>struct CGPParameters Holds the parameters that define the structure of a cartesian graph. </li> <li>class GPAgent </li> <li>class GPAgentAnalyzer </li> <li>class GPAgentBase </li> <li>class GPAgentRegisters Class to hold the registers of the agent. <ul> <li>class iterator Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator. </li> </ul> </li> <li>class GPTrainingLoop <ul> <li>struct SaveDataParams </li> </ul> </li> <li>class Graph A graph of nodes that can be used to make decisions. </li> <li>class GraphBuilder A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs. </li> <li>class GraphNode A node in a decision graph. </li> <li>class LGPAgent </li> <li>struct NodeFunction A function pointer wrapper that holds extra arguments for the function pointer. </li> <li>class Sensors </li> <li>namespace base64 A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x)). </li> </ul> </li> <li>namespace cse491 </li> <li>namespace std </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Agents <ul> <li>dir GP <ul> <li>file CGPAgent.hpp </li> <li>file CGPGenotype.hpp </li> <li>file GPAgent.hpp </li> <li>file GPAgentAnalyze.h </li> <li>file GPAgentBase.hpp </li> <li>file GPAgentSensors.hpp </li> <li>file GPAgentsRegisters.hpp </li> <li>file GPTrainingLoop.hpp </li> <li>file Graph.hpp </li> <li>file GraphBuilder.hpp </li> <li>file GraphNode.hpp </li> <li>file LGPAgent.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/","title":"Namespace cowboys","text":"<p>Namespace List &gt; cowboys</p> <p>An Agent based on genetic programming. More...</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#namespaces","title":"Namespaces","text":"Type Name namespace base64 A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x))."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#classes","title":"Classes","text":"Type Name class CGPAgent An agent based on cartesian genetic programming. class CGPGenotype Holds all the information that uniquely defines a cartesian graph. struct CGPNodeGene Holds the representation of a cartesian graph node. struct CGPParameters Holds the parameters that define the structure of a cartesian graph. class GPAgent class GPAgentAnalyzer class GPAgentBase class GPAgentRegisters Class to hold the registers of the agent. class GPTrainingLoop &lt;class AgentType, class EnvironmentType&gt; class Graph A graph of nodes that can be used to make decisions. class GraphBuilder A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs. class GraphNode A node in a decision graph. class LGPAgent struct NodeFunction A function pointer wrapper that holds extra arguments for the function pointer. class Sensors"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; GraphLayer typedef double(*)(const GraphNode &amp;, const cse491::AgentBase &amp;) InnerFunction Function pointer for a node function. enum SensorDirection"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-attributes","title":"Public Attributes","text":"Type Name constexpr char HEADER_END   = = ';'The separator between the header and the genotype. constexpr char HEADER_SEP   = = ','The separator between each parameter in the header, defining the cartesian graph. constexpr size_t INPUT_SIZE   = = 9Don't know the maximum size a state can be, arbitrary large number. constexpr size_t LAYERS_BACK   = = 2The number of layers preceding a node's layer that the node can reference. const int LISTSIZE   = = 100 constexpr char NODE_GENE_SEP   = = '.'The separator between each attribute in a node. constexpr char NODE_SEP   = = ':'The separator between each node in the genotype. constexpr size_t NUM_LAYERS   = = 3Number of computational layers for each agent. constexpr size_t NUM_NODES_PER_LAYER   = = 2The number of nodes in each layer. constexpr unsigned int TRAINING_SEED   = = 0If this is 0, then a random seed will be used."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const std::vector&lt; InnerFunction &gt; FUNCTION_SET   = =  { std::vector&lt;InnerFunction&gt; functions; functions.reserve(NODE_FUNCTION_SET.size() + SENSOR_FUNCTION_SET.size()); functions.insert(functions.cend(), NODE_FUNCTION_SET.cbegin(), NODE_FUNCTION_SET.cend()); functions.insert(functions.cend(), SENSOR_FUNCTION_SET.cbegin(), SENSOR_FUNCTION_SET.cend()); return functions; }()A vector of all the node functions and sensors. const std::vector&lt; InnerFunction &gt; NODE_FUNCTION_SET   = { nullptr,  Sum,         And, AnyEq, Not,    Gate,   Sin,      Cos,      Product, Exp, LessThan, GreaterThan, Max, Min,   NegSum, Square, PosClamp, NegClamp, Sqrt}A vector of all the node functions. const std::vector&lt; InnerFunction &gt; SENSOR_FUNCTION_SET   = {WallDistanceUp, WallDistanceDown, WallDistanceLeft, WallDistanceRight, AStarDistance}A vector of all the sensor functions. constexpr int WALL   = = 2"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-functions","title":"Public Functions","text":"Type Name double AStarDistance (const GraphNode &amp; node, const cse491::AgentBase &amp; agent) Returns the distance to the grid position represented by the first two inputs using A*. double And (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if all inputs are not equal to 0, 0 otherwise. double AnyEq (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if any of the inputs besides the first are equal to the first input, 0 otherwise. double Cos (const GraphNode &amp; node, const cse491::AgentBase &amp;) Sums the cos(x) of all inputs. std::vector&lt; size_t &gt; EncodeActions (const std::unordered_map&lt; std::string, size_t &gt; &amp; action_map) Encodes the actions from an agent's action map into a vector of size_t, representing action IDs. std::vector&lt; double &gt; EncodeState (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp;, const cse491::item_map_t &amp;, const cse491::agent_map_t &amp;, const cse491::AgentBase * agent, const std::unordered_map&lt; std::string, double &gt; &amp; extra_agent_state) Translates state into nodes for the decision graph. double Exp (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of the exp(x) of all inputs. double Gate (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the input with index 0 if the condition (input with index 1) is not 0. double GreaterThan (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if all inputs are in ascending, 0 otherwise. If only one input, then defaults to 1. double LessThan (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if all inputs are in ascending, 0 otherwise. If only one input, then defaults to 1. double Max (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the maximum value of all inputs. double Min (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the minimum value of all inputs. double NegClamp (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of negatively clamped inputs. double NegSum (const GraphNode &amp; node, const cse491::AgentBase &amp; agent) Returns the sum of negated inputs. double Not (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if the first input is equal to 0 or there are no inputs, 0 otherwise. double PosClamp (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of positively clamped inputs. double Product (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the product of all inputs. double Reciprocal (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of the reciprocal of all inputs. double Sin (const GraphNode &amp; node, const cse491::AgentBase &amp;) Sums the sin(x) of all inputs. double Sqrt (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of square root of positively clamped inputs. double Square (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of squared inputs. double Sum (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum all inputs. double WallDistanceDown (const GraphNode &amp;, const cse491::AgentBase &amp; agent) Returns the distance to the nearest obstruction downwards from the agent. double WallDistanceLeft (const GraphNode &amp;, const cse491::AgentBase &amp; agent) Returns the distance to the nearest obstruction to the left of the agent. double WallDistanceRight (const GraphNode &amp;, const cse491::AgentBase &amp; agent) Returns the distance to the nearest obstruction to the right of the agent. double WallDistanceUp (const GraphNode &amp;, const cse491::AgentBase &amp; agent) Returns the distance to the nearest obstruction upwards from the agent."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#detailed-description","title":"Detailed Description","text":"<p>An Agent based on linear genetic programming.</p> <p>yeeeeeeeehaaaaaaaaa</p> <p>Namespace for GPAgent and its related classes.</p> <p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Note:</p> <p>yeeeeeeeehaaaaaaaaa \ud83e\udd20</p> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL</p> <p>currently a static class</p> <p>Author:</p> <p>@amantham20</p> <p>currenly supports only wall distance sensors for left, right, top and bottom. this is library of sensors for a given agent return </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#typedef-graphlayer","title":"typedef GraphLayer","text":"<pre><code>using GraphLayer =  std::vector&lt;std::shared_ptr&lt;GraphNode&gt; &gt;;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#typedef-innerfunction","title":"typedef InnerFunction","text":"<p>Function pointer for a node function. </p> <pre><code>using InnerFunction =  double (*)(const GraphNode &amp;, const cse491::AgentBase &amp;);\n</code></pre> <p>Forward declaration of GraphNode </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#enum-sensordirection","title":"enum SensorDirection","text":"<pre><code>enum cowboys::SensorDirection {\n    LEFT,\n    RIGHT,\n    ABOVE,\n    BELOW\n};\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-header_end","title":"variable HEADER_END","text":"<pre><code>constexpr char HEADER_END;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-header_sep","title":"variable HEADER_SEP","text":"<pre><code>constexpr char HEADER_SEP;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-input_size","title":"variable INPUT_SIZE","text":"<pre><code>constexpr size_t INPUT_SIZE;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-layers_back","title":"variable LAYERS_BACK","text":"<pre><code>constexpr size_t LAYERS_BACK;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-listsize","title":"variable LISTSIZE","text":"<pre><code>const int LISTSIZE;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-node_gene_sep","title":"variable NODE_GENE_SEP","text":"<pre><code>constexpr char NODE_GENE_SEP;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-node_sep","title":"variable NODE_SEP","text":"<pre><code>constexpr char NODE_SEP;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-num_layers","title":"variable NUM_LAYERS","text":"<pre><code>constexpr size_t NUM_LAYERS;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-num_nodes_per_layer","title":"variable NUM_NODES_PER_LAYER","text":"<pre><code>constexpr size_t NUM_NODES_PER_LAYER;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-training_seed","title":"variable TRAINING_SEED","text":"<pre><code>constexpr unsigned int TRAINING_SEED;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-function_set","title":"variable FUNCTION_SET","text":"<pre><code>const std::vector&lt;InnerFunction&gt; FUNCTION_SET;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-node_function_set","title":"variable NODE_FUNCTION_SET","text":"<pre><code>const std::vector&lt;InnerFunction&gt; NODE_FUNCTION_SET;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-sensor_function_set","title":"variable SENSOR_FUNCTION_SET","text":"<pre><code>const std::vector&lt;InnerFunction&gt; SENSOR_FUNCTION_SET;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-wall","title":"variable WALL","text":"<pre><code>constexpr int WALL;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-astardistance","title":"function AStarDistance","text":"<p>Returns the distance to the grid position represented by the first two inputs using A*. </p> <pre><code>double cowboys::AStarDistance (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the grid position using A* </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-and","title":"function And","text":"<p>Returns 1 if all inputs are not equal to 0, 0 otherwise. </p> <pre><code>double cowboys::And (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-anyeq","title":"function AnyEq","text":"<p>Returns 1 if any of the inputs besides the first are equal to the first input, 0 otherwise. </p> <pre><code>double cowboys::AnyEq (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-cos","title":"function Cos","text":"<p>Sums the cos(x) of all inputs. </p> <pre><code>double cowboys::Cos (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-encodeactions","title":"function EncodeActions","text":"<p>Encodes the actions from an agent's action map into a vector of size_t, representing action IDs. </p> <pre><code>std::vector&lt; size_t &gt; cowboys::EncodeActions (\n    const std::unordered_map&lt; std::string, size_t &gt; &amp; action_map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>action_map</code> The action map from the agent. </li> </ul> <p>Returns:</p> <p>A vector of size_t, representing action IDs. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-encodestate","title":"function EncodeState","text":"<p>Translates state into nodes for the decision graph. </p> <pre><code>std::vector&lt; double &gt; cowboys::EncodeState (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp;,\n    const cse491::item_map_t &amp;,\n    const cse491::agent_map_t &amp;,\n    const cse491::AgentBase * agent,\n    const std::unordered_map&lt; std::string, double &gt; &amp; extra_agent_state\n) \n</code></pre> <p>Returns:</p> <p>A vector of doubles for the decision graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-exp","title":"function Exp","text":"<p>Returns the sum of the exp(x) of all inputs. </p> <pre><code>double cowboys::Exp (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-gate","title":"function Gate","text":"<p>Returns the input with index 0 if the condition (input with index 1) is not 0. </p> <pre><code>double cowboys::Gate (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-greaterthan","title":"function GreaterThan","text":"<p>Returns 1 if all inputs are in ascending, 0 otherwise. If only one input, then defaults to 1. </p> <pre><code>double cowboys::GreaterThan (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-lessthan","title":"function LessThan","text":"<p>Returns 1 if all inputs are in ascending, 0 otherwise. If only one input, then defaults to 1. </p> <pre><code>double cowboys::LessThan (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-max","title":"function Max","text":"<p>Returns the maximum value of all inputs. </p> <pre><code>double cowboys::Max (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-min","title":"function Min","text":"<p>Returns the minimum value of all inputs. </p> <pre><code>double cowboys::Min (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-negclamp","title":"function NegClamp","text":"<p>Returns the sum of negatively clamped inputs. </p> <pre><code>double cowboys::NegClamp (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-negsum","title":"function NegSum","text":"<p>Returns the sum of negated inputs. </p> <pre><code>double cowboys::NegSum (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-not","title":"function Not","text":"<p>Returns 1 if the first input is equal to 0 or there are no inputs, 0 otherwise. </p> <pre><code>double cowboys::Not (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-posclamp","title":"function PosClamp","text":"<p>Returns the sum of positively clamped inputs. </p> <pre><code>double cowboys::PosClamp (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-product","title":"function Product","text":"<p>Returns the product of all inputs. </p> <pre><code>double cowboys::Product (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-reciprocal","title":"function Reciprocal","text":"<p>Returns the sum of the reciprocal of all inputs. </p> <pre><code>double cowboys::Reciprocal (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-sin","title":"function Sin","text":"<p>Sums the sin(x) of all inputs. </p> <pre><code>double cowboys::Sin (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-sqrt","title":"function Sqrt","text":"<p>Returns the sum of square root of positively clamped inputs. </p> <pre><code>double cowboys::Sqrt (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-square","title":"function Square","text":"<p>Returns the sum of squared inputs. </p> <pre><code>double cowboys::Square (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-sum","title":"function Sum","text":"<p>Returns the sum all inputs. </p> <pre><code>double cowboys::Sum (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-walldistancedown","title":"function WallDistanceDown","text":"<p>Returns the distance to the nearest obstruction downwards from the agent. </p> <pre><code>double cowboys::WallDistanceDown (\n    const GraphNode &amp;,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the nearest obstruction downwards. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-walldistanceleft","title":"function WallDistanceLeft","text":"<p>Returns the distance to the nearest obstruction to the left of the agent. </p> <pre><code>double cowboys::WallDistanceLeft (\n    const GraphNode &amp;,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the nearest obstruction to the left. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-walldistanceright","title":"function WallDistanceRight","text":"<p>Returns the distance to the nearest obstruction to the right of the agent. </p> <pre><code>double cowboys::WallDistanceRight (\n    const GraphNode &amp;,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the nearest obstruction to the right. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-walldistanceup","title":"function WallDistanceUp","text":"<p>Returns the distance to the nearest obstruction upwards from the agent. </p> <pre><code>double cowboys::WallDistanceUp (\n    const GraphNode &amp;,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the nearest obstruction upwards. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/","title":"Class cowboys::CGPAgent","text":"<p>ClassList &gt; cowboys &gt; CGPAgent</p> <p>An agent based on cartesian genetic programming. </p> <ul> <li><code>#include &lt;CGPAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: cowboys::GPAgentBase</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#public-functions","title":"Public Functions","text":"Type Name CGPAgent (size_t id, const std::string &amp; name)  CGPAgent (size_t id, const std::string &amp; name, const CGPGenotype &amp; genotype)  void Configure (const CGPAgent &amp; other) Copies the genotype and behavior of another CGPAgent into this agent. virtual void Copy (const GPAgentBase &amp; other) overrideCopy the behavior of another agent into this agent. virtual std::string Export () overrideExport the genotype for this agent. virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) override double GetComplexity () constThe complexity of this agent. Used for fitness. const CGPGenotype &amp; GetGenotype () constGet the genotype for this agent. virtual void Import (const std::string &amp; genotype) overrideLoad in the string representation of a genotype and configure this agent based on it. bool Initialize () overrideSetup graph. virtual void MutateAgent (double mutation_rate=0.8) overrideMutate this agent. virtual void PrintAgent () override virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) overrideSerialize this agent to XML."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#public-functions-inherited-from-cowboysgpagentbase","title":"Public Functions inherited from cowboys::GPAgentBase","text":"<p>See cowboys::GPAgentBase</p> Type Name virtual void Copy (const GPAgentBase &amp; other) = 0Copy the behavior of another agent into this agent. virtual std::string Export ()  GPAgentBase (size_t id, const std::string &amp; name)  virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) = 0 const std::unordered_map&lt; std::string, double &gt; GetExtraState () constGet a map of extra state information. double GetRandom () Return a uniform random value between 0.0 and 1.0. double GetRandom (double max) Return a uniform random value between 0.0 and max. double GetRandom (double min, double max) Return a uniform random value between min and max. double GetRandomNormal () Return a gaussian random value with mean 0.0 and sd 1.0. double GetRandomNormal (double mean, double sd=1.0) Return a gaussian random value with provided mean and sd. size_t GetRandomULL (size_t max) Return a uniform random unsigned long long between 0 (inclusive) and max (exclusive) unsigned int GetSeed () constGet the seed used to initialize this RNG. virtual void Import (const std::string &amp; genotype) = 0 bool Initialize () overrideSetup graph. virtual void MutateAgent (double mutation_rate=0.8) = 0Mutate this agent. virtual void PrintAgent ()  virtual void Reset (bool=false)  size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) overrideChoose the action to take a step in the appropriate direction. virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) = 0 void SetSeed (unsigned int seed) Set the seed used to initialize this RNG. ~GPAgentBase () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name std::unique_ptr&lt; Graph &gt; decision_graph The decision graph for this agent. CGPGenotype genotype The genotype for this agent."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#protected-attributes-inherited-from-cowboysgpagentbase","title":"Protected Attributes inherited from cowboys::GPAgentBase","text":"<p>See cowboys::GPAgentBase</p> Type Name std::unordered_map&lt; std::string, double &gt; extra_state A map of extra state information. std::normal_distribution&lt; double &gt; norm_dist Normal distribution. std::mt19937 rng   = {seed}Random number generator. unsigned int seed   = = 0Seed for the random number generator. std::uniform_real_distribution&lt; double &gt; uni_dist Uniform distribution."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-cgpagent-12","title":"function CGPAgent [1/2]","text":"<pre><code>inline cowboys::CGPAgent::CGPAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-cgpagent-22","title":"function CGPAgent [2/2]","text":"<pre><code>inline cowboys::CGPAgent::CGPAgent (\n    size_t id,\n    const std::string &amp; name,\n    const CGPGenotype &amp; genotype\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-configure","title":"function Configure","text":"<p>Copies the genotype and behavior of another CGPAgent into this agent.</p> <pre><code>inline void cowboys::CGPAgent::Configure (\n    const CGPAgent &amp; other\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The CGPAgent to copy. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-copy","title":"function Copy","text":"<p>Copy the behavior of another agent into this agent. </p> <pre><code>inline virtual void cowboys::CGPAgent::Copy (\n    const GPAgentBase &amp; other\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The agent to copy. </li> </ul> <p>Implements cowboys::GPAgentBase::Copy</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-export","title":"function Export","text":"<p>Export the genotype for this agent. </p> <pre><code>inline virtual std::string cowboys::CGPAgent::Export () override\n</code></pre> <p>Returns:</p> <p>The string representation of the genotype for this agent. </p> <p>Implements cowboys::GPAgentBase::Export</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-getaction","title":"function GetAction","text":"<pre><code>inline virtual size_t cowboys::CGPAgent::GetAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_set,\n    const cse491::agent_map_t &amp; agent_set\n) override\n</code></pre> <p>Implements cowboys::GPAgentBase::GetAction</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-getcomplexity","title":"function GetComplexity","text":"<p>The complexity of this agent. Used for fitness. </p> <pre><code>inline double cowboys::CGPAgent::GetComplexity () const\n</code></pre> <p>Returns:</p> <p>The complexity of this agent. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-getgenotype","title":"function GetGenotype","text":"<p>Get the genotype for this agent. </p> <pre><code>inline const CGPGenotype &amp; cowboys::CGPAgent::GetGenotype () const\n</code></pre> <p>Returns:</p> <p>A const reference to the genotype for this agent. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-import","title":"function Import","text":"<p>Load in the string representation of a genotype and configure this agent based on it. </p> <pre><code>inline virtual void cowboys::CGPAgent::Import (\n    const std::string &amp; genotype\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>genotype</code> The string representation of a genotype. </li> </ul> <p>Implements cowboys::GPAgentBase::Import</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-initialize","title":"function Initialize","text":"<p>Setup graph. </p> <pre><code>inline bool cowboys::CGPAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-mutateagent","title":"function MutateAgent","text":"<p>Mutate this agent. </p> <pre><code>inline virtual void cowboys::CGPAgent::MutateAgent (\n    double mutation_rate=0.8\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The mutation rate. Between 0 and 1. </li> </ul> <p>Implements cowboys::GPAgentBase::MutateAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-printagent","title":"function PrintAgent","text":"<pre><code>inline virtual void cowboys::CGPAgent::PrintAgent () override\n</code></pre> <p>Implements cowboys::GPAgentBase::PrintAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-serializegp","title":"function SerializeGP","text":"<p>Serialize this agent to XML. </p> <pre><code>inline virtual void cowboys::CGPAgent::SerializeGP (\n    tinyxml2::XMLDocument &amp; doc,\n    tinyxml2::XMLElement * parentElem,\n    double fitness=-1\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>doc</code> The XML document to serialize to. </li> <li><code>parentElem</code> The parent element to serialize to. </li> <li><code>fitness</code> The fitness of this agent to write to the XML. </li> </ul> <p>Implements cowboys::GPAgentBase::SerializeGP</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#variable-decision_graph","title":"variable decision_graph","text":"<pre><code>std::unique_ptr&lt;Graph&gt; decision_graph;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#variable-genotype","title":"variable genotype","text":"<pre><code>CGPGenotype genotype;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/","title":"Class cowboys::CGPGenotype","text":"<p>ClassList &gt; cowboys &gt; CGPGenotype</p> <p>Holds all the information that uniquely defines a cartesian graph. </p> <ul> <li><code>#include &lt;CGPGenotype.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#public-functions","title":"Public Functions","text":"Type Name CGPGenotype () = defaultDefault constructor for the cartesian graph genotype. Will have 0 functional nodes. CGPGenotype (const CGPParameters &amp; parameters) Constructor for the cartesian graph genotype. Initializes the genotype with the given parameters and leaves everything default (nodes will be unconnected). CGPGenotype (const CGPGenotype &amp; other) Copy constructor for the cartesian graph genotype. CGPGenotype (CGPGenotype &amp;&amp; other) noexceptMove constructor for the cartesian graph genotype. CGPGenotype &amp; Configure (const std::string &amp; encoded_genotype) Configures this genotype from an encoded string. std::string Export () constExports this genotype into a string representation. std::string ExportRaw () constExports this genotype into a string representation. size_t GetLayersBack () constReturns the number of layers backward that a node can connect to. size_t GetNumConnections () constReturns the number of connected connections in the graph. size_t GetNumFunctionalNodes () constReturns the number of functional (non-input) nodes in the graph. size_t GetNumInputs () constReturns the number of inputs to the graph. size_t GetNumLayers () constReturns the number of middle layers in the graph. size_t GetNumNodesPerLayer () constReturns the number of nodes per middle layer. size_t GetNumOutputs () constReturns the number of outputs from the graph. size_t GetNumPossibleConnections () constReturns the number of possible connections in the graph. bool HasInputConnections () constIdentify if the genome has any non-zero input connections in it. void InitGenotype () Initializes an empty genotype with the cartesian graph parameters. CGPGenotype &amp; Mutate (double mutation_rate, GPAgentBase &amp; agent, std::function&lt; void(CGPNodeGene &amp;)&gt; mutation) Mutates the genotype. CGPGenotype &amp; MutateConnections (double mutation_rate, GPAgentBase &amp; agent) Mutates the input connections of the genotype. CGPGenotype &amp; MutateDefault (double mutation_rate, GPAgentBase &amp; agent, size_t num_functions=FUNCTION_SET.size()) Performs a mutation on the genotype with default parameters. CGPGenotype &amp; MutateFunctions (double mutation_rate, size_t num_functions, GPAgentBase &amp; agent) Mutates the genotype by changing the function of each node with a given probability between 0 and 1. CGPGenotype &amp; MutateHeader (double mutation_rate, GPAgentBase &amp; agent) Mutates the header of the genotype. CGPGenotype &amp; MutateOutputs (double mutation_rate, double mean, double std, GPAgentBase &amp; agent, bool additive=true) Mutates the genotype, changing the default output of nodes with probability between 0 and 1. void SetParameters (const CGPParameters &amp; params) Set the parameters of the cartesian graph. std::vector&lt; CGPNodeGene &gt;::iterator begin () Returns the iterator to the beginning of the node configurations. std::vector&lt; CGPNodeGene &gt;::const_iterator begin () constReturns the const iterator to the beginning of the node configurations. std::vector&lt; CGPNodeGene &gt;::const_iterator cbegin () constReturns the const iterator to the beginning of the node configurations. std::vector&lt; CGPNodeGene &gt;::const_iterator cend () constReturns the const iterator to the end of the node configurations. std::vector&lt; CGPNodeGene &gt;::iterator end () Returns the iterator to the end of the node configurations. std::vector&lt; CGPNodeGene &gt;::const_iterator end () constReturns the const iterator to the end of the node configurations. CGPGenotype &amp; operator= (const CGPGenotype &amp; other) Copy assignment operator for the cartesian graph genotype. CGPGenotype &amp; operator= (CGPGenotype &amp;&amp; other) noexceptMove assignment operator for the cartesian graph genotype. bool operator== (const CGPGenotype &amp; other) constCheck if two CGPGenotypes are equal. CGPParameters and CGPNodeGenes should be equal. ~CGPGenotype () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; CGPNodeGene &gt; nodes The node configurations. CGPParameters params The parameters of the cartesian graph."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype-14","title":"function CGPGenotype [1/4]","text":"<pre><code>cowboys::CGPGenotype::CGPGenotype () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype-24","title":"function CGPGenotype [2/4]","text":"<p>Constructor for the cartesian graph genotype. Initializes the genotype with the given parameters and leaves everything default (nodes will be unconnected). </p> <pre><code>inline cowboys::CGPGenotype::CGPGenotype (\n    const CGPParameters &amp; parameters\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parameters</code> The parameters of the cartesian graph. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype-34","title":"function CGPGenotype [3/4]","text":"<p>Copy constructor for the cartesian graph genotype. </p> <pre><code>inline cowboys::CGPGenotype::CGPGenotype (\n    const CGPGenotype &amp; other\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other cartesian graph genotype to copy from. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype-44","title":"function CGPGenotype [4/4]","text":"<p>Move constructor for the cartesian graph genotype. </p> <pre><code>inline cowboys::CGPGenotype::CGPGenotype (\n    CGPGenotype &amp;&amp; other\n) noexcept\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other cartesian graph genotype to move from. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-configure","title":"function Configure","text":"<p>Configures this genotype from an encoded string. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::Configure (\n    const std::string &amp; encoded_genotype\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>encoded_genotype</code> The encoded genotype. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-export","title":"function Export","text":"<p>Exports this genotype into a string representation. </p> <pre><code>inline std::string cowboys::CGPGenotype::Export () const\n</code></pre> <p>Returns:</p> <p>The string representation of this genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-exportraw","title":"function ExportRaw","text":"<p>Exports this genotype into a string representation. </p> <pre><code>inline std::string cowboys::CGPGenotype::ExportRaw () const\n</code></pre> <p>Returns:</p> <p>The string representation of this genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getlayersback","title":"function GetLayersBack","text":"<p>Returns the number of layers backward that a node can connect to. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetLayersBack () const\n</code></pre> <p>Returns:</p> <p>The number of layers backward that a node can connect to. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumconnections","title":"function GetNumConnections","text":"<p>Returns the number of connected connections in the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumConnections () const\n</code></pre> <p>Returns:</p> <p>The number of connected connections in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumfunctionalnodes","title":"function GetNumFunctionalNodes","text":"<p>Returns the number of functional (non-input) nodes in the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumFunctionalNodes () const\n</code></pre> <p>Returns:</p> <p>The number of functional (non-input) nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnuminputs","title":"function GetNumInputs","text":"<p>Returns the number of inputs to the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumInputs () const\n</code></pre> <p>Returns:</p> <p>The number of inputs to the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumlayers","title":"function GetNumLayers","text":"<p>Returns the number of middle layers in the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumLayers () const\n</code></pre> <p>Returns:</p> <p>The number of middle layers in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumnodesperlayer","title":"function GetNumNodesPerLayer","text":"<p>Returns the number of nodes per middle layer. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumNodesPerLayer () const\n</code></pre> <p>Returns:</p> <p>The number of nodes per middle layer. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumoutputs","title":"function GetNumOutputs","text":"<p>Returns the number of outputs from the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumOutputs () const\n</code></pre> <p>Returns:</p> <p>The number of outputs from the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumpossibleconnections","title":"function GetNumPossibleConnections","text":"<p>Returns the number of possible connections in the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumPossibleConnections () const\n</code></pre> <p>Returns:</p> <p>The number of possible connections in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-hasinputconnections","title":"function HasInputConnections","text":"<p>Identify if the genome has any non-zero input connections in it. </p> <pre><code>inline bool cowboys::CGPGenotype::HasInputConnections () const\n</code></pre> <p>Returns:</p> <p>Bool value to indicate if any input connections non-zero. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-initgenotype","title":"function InitGenotype","text":"<pre><code>inline void cowboys::CGPGenotype::InitGenotype () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutate","title":"function Mutate","text":"<p>Mutates the genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::Mutate (\n    double mutation_rate,\n    GPAgentBase &amp; agent,\n    std::function&lt; void( CGPNodeGene &amp;)&gt; mutation\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> Value between 0 and 1 representing the probability of mutating a value. </li> <li><code>mutation</code> The function to use for mutating the output. The function will receive the node gene as a parameter. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutateconnections","title":"function MutateConnections","text":"<p>Mutates the input connections of the genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateConnections (\n    double mutation_rate,\n    GPAgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The probability of mutating a connection. For a given connection, if it is chosen to be mutated, there is a 50% chance it will stay the same. </li> <li><code>agent</code> The agent to use for random number generation. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutatedefault","title":"function MutateDefault","text":"<p>Performs a mutation on the genotype with default parameters. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateDefault (\n    double mutation_rate,\n    GPAgentBase &amp; agent,\n    size_t num_functions=FUNCTION_SET.size()\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> Value between 0 and 1 representing the probability of mutating each value. </li> <li><code>agent</code> The agent to use for random number generation. </li> <li><code>num_functions</code> The number of functions available to the nodes. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutatefunctions","title":"function MutateFunctions","text":"<p>Mutates the genotype by changing the function of each node with a given probability between 0 and 1. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateFunctions (\n    double mutation_rate,\n    size_t num_functions,\n    GPAgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The probability of changing the function of a node. </li> <li><code>num_functions</code> The number of functions available to the nodes. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutateheader","title":"function MutateHeader","text":"<p>Mutates the header of the genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateHeader (\n    double mutation_rate,\n    GPAgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> Value between 0 and 1 representing the probability of mutating each value. </li> <li><code>agent</code> The agent to use for random number generation. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutateoutputs","title":"function MutateOutputs","text":"<p>Mutates the genotype, changing the default output of nodes with probability between 0 and 1. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateOutputs (\n    double mutation_rate,\n    double mean,\n    double std,\n    GPAgentBase &amp; agent,\n    bool additive=true\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> Value between 0 and 1 representing the probability of mutating each value. </li> <li><code>min</code> The minimum value to generate for mutation. </li> <li><code>max</code> The maximum value to generate for mutation. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-setparameters","title":"function SetParameters","text":"<p>Set the parameters of the cartesian graph. </p> <pre><code>inline void cowboys::CGPGenotype::SetParameters (\n    const CGPParameters &amp; params\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>params</code> The parameters of the cartesian graph. Basically a 5-tuple. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-begin-12","title":"function begin [1/2]","text":"<p>Returns the iterator to the beginning of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::iterator cowboys::CGPGenotype::begin () \n</code></pre> <p>Returns:</p> <p>The iterator to the beginning of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-begin-22","title":"function begin [2/2]","text":"<p>Returns the const iterator to the beginning of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::const_iterator cowboys::CGPGenotype::begin () const\n</code></pre> <p>Returns:</p> <p>The const iterator to the beginning of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cbegin","title":"function cbegin","text":"<p>Returns the const iterator to the beginning of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::const_iterator cowboys::CGPGenotype::cbegin () const\n</code></pre> <p>Returns:</p> <p>The const iterator to the beginning of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cend","title":"function cend","text":"<p>Returns the const iterator to the end of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::const_iterator cowboys::CGPGenotype::cend () const\n</code></pre> <p>Returns:</p> <p>The const iterator to the end of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-end-12","title":"function end [1/2]","text":"<p>Returns the iterator to the end of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::iterator cowboys::CGPGenotype::end () \n</code></pre> <p>Returns:</p> <p>The iterator to the end of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-end-22","title":"function end [2/2]","text":"<p>Returns the const iterator to the end of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::const_iterator cowboys::CGPGenotype::end () const\n</code></pre> <p>Returns:</p> <p>The const iterator to the end of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-operator","title":"function operator=","text":"<p>Copy assignment operator for the cartesian graph genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::operator= (\n    const CGPGenotype &amp; other\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other cartesian graph genotype to copy from. </li> </ul> <p>Returns:</p> <p>This cartesian graph genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-operator_1","title":"function operator=","text":"<p>Move assignment operator for the cartesian graph genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::operator= (\n    CGPGenotype &amp;&amp; other\n) noexcept\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other cartesian graph genotype to move from. </li> </ul> <p>Returns:</p> <p>This cartesian graph genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-operator_2","title":"function operator==","text":"<p>Check if two CGPGenotypes are equal. CGPParameters and CGPNodeGenes should be equal.</p> <pre><code>inline bool cowboys::CGPGenotype::operator== (\n    const CGPGenotype &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other CGPGenotype to compare to. </li> </ul> <p>Returns:</p> <p>True if the two CGPGenotypes are equal, false otherwise. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype","title":"function ~CGPGenotype","text":"<pre><code>cowboys::CGPGenotype::~CGPGenotype () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#variable-nodes","title":"variable nodes","text":"<pre><code>std::vector&lt;CGPNodeGene&gt; nodes;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#variable-params","title":"variable params","text":"<pre><code>CGPParameters params;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#friends-documentation","title":"Friends Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#friend-operator","title":"friend operator&lt;&lt;","text":"<p>Write the genotype representation to an output stream. </p> <pre><code>inline std::ostream &amp; cowboys::CGPGenotype::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const CGPGenotype &amp; genotype\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> The output stream to write to. </li> <li><code>genotype</code> The genotype to write. </li> </ul> <p>Returns:</p> <p>The output stream. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/","title":"Struct cowboys::CGPNodeGene","text":"<p>ClassList &gt; cowboys &gt; CGPNodeGene</p> <p>Holds the representation of a cartesian graph node. </p> <ul> <li><code>#include &lt;CGPGenotype.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#public-attributes","title":"Public Attributes","text":"Type Name double default_output   = {0}The default output of the node. size_t function_idx   = {0}The index of the function the node uses. std::vector&lt; char &gt; input_connections   = {}The input connections of this node. '1' means connected, '0' means not connected."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#public-functions","title":"Public Functions","text":"Type Name bool operator== (const CGPNodeGene &amp; other) constCompare two CGPNodeGenes for equality."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#variable-default_output","title":"variable default_output","text":"<pre><code>double default_output;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#variable-function_idx","title":"variable function_idx","text":"<pre><code>size_t function_idx;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#variable-input_connections","title":"variable input_connections","text":"<pre><code>std::vector&lt;char&gt; input_connections;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#function-operator","title":"function operator==","text":"<p>Compare two CGPNodeGenes for equality. </p> <pre><code>inline bool cowboys::CGPNodeGene::operator== (\n    const CGPNodeGene &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other CGPNodeGene to compare to. </li> </ul> <p>Returns:</p> <p>True if the two CGPNodeGenes are equal, false otherwise. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/","title":"Struct cowboys::CGPParameters","text":"<p>ClassList &gt; cowboys &gt; CGPParameters</p> <p>Holds the parameters that define the structure of a cartesian graph. </p> <ul> <li><code>#include &lt;CGPGenotype.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#public-attributes","title":"Public Attributes","text":"Type Name size_t layers_back   = {0}The number of layers backward that a node can connect to. size_t num_inputs   = {0}The number of inputs to the graph. size_t num_layers   = {0}The number of middle layers in the graph. size_t num_nodes_per_layer   = {0}The number of nodes per middle layer. size_t num_outputs   = {0}The number of outputs from the graph."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#public-functions","title":"Public Functions","text":"Type Name CGPParameters () = default CGPParameters (size_t num_inputs, size_t num_outputs, size_t num_layers, size_t num_nodes_per_layer, size_t layers_back) Constructor for the cartesian graph parameters. size_t GetFunctionalNodeCount () constReturns the number of functional nodes in the graph. bool operator== (const CGPParameters &amp; other) constCheck if two CGPParameters are equal."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-layers_back","title":"variable layers_back","text":"<pre><code>size_t layers_back;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-num_inputs","title":"variable num_inputs","text":"<pre><code>size_t num_inputs;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-num_layers","title":"variable num_layers","text":"<pre><code>size_t num_layers;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-num_nodes_per_layer","title":"variable num_nodes_per_layer","text":"<pre><code>size_t num_nodes_per_layer;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-num_outputs","title":"variable num_outputs","text":"<pre><code>size_t num_outputs;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#function-cgpparameters-12","title":"function CGPParameters [1/2]","text":"<pre><code>cowboys::CGPParameters::CGPParameters () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#function-cgpparameters-22","title":"function CGPParameters [2/2]","text":"<pre><code>inline cowboys::CGPParameters::CGPParameters (\n    size_t num_inputs,\n    size_t num_outputs,\n    size_t num_layers,\n    size_t num_nodes_per_layer,\n    size_t layers_back\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#function-getfunctionalnodecount","title":"function GetFunctionalNodeCount","text":"<p>Returns the number of functional nodes in the graph. </p> <pre><code>inline size_t cowboys::CGPParameters::GetFunctionalNodeCount () const\n</code></pre> <p>Returns:</p> <p>The number of functional nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#function-operator","title":"function operator==","text":"<p>Check if two CGPParameters are equal.</p> <pre><code>inline bool cowboys::CGPParameters::operator== (\n    const CGPParameters &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other CGPParameters to compare to. </li> </ul> <p>Returns:</p> <p>True if the two CGPParameters are equal, false otherwise. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/","title":"Class cowboys::GPAgent","text":"<p>ClassList &gt; cowboys &gt; GPAgent</p> <p>Inherits the following classes: AgentBase</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#public-functions","title":"Public Functions","text":"Type Name GPAgent (size_t id, const std::string &amp; name)  bool Initialize () overrideThis agent needs a specific set of actions to function. size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_map, const cse491::agent_map_t &amp; agent_map) overrideChoose the action to take a step in the appropriate direction. ~GPAgent () override"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t movementIndex   = = 0current move of the agent const std::vector&lt; std::string &gt; predefinedMovement   = = { \"down\",  \"down\",  \"down\",  \"down\",  \"right\", \"right\", \"up\",    \"up\", \"up\",    \"up\",    \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"left\",  \"left\",  \"left\"}"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#function-gpagent","title":"function GPAgent","text":"<pre><code>inline cowboys::GPAgent::GPAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool cowboys::GPAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cowboys::GPAgent::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_map,\n    const cse491::agent_map_t &amp; agent_map\n) override\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#function-gpagent_1","title":"function ~GPAgent","text":"<pre><code>cowboys::GPAgent::~GPAgent () override\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#variable-movementindex","title":"variable movementIndex","text":"<pre><code>size_t movementIndex;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#variable-predefinedmovement","title":"variable predefinedMovement","text":"<pre><code>const std::vector&lt;std::string&gt; predefinedMovement;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/","title":"Class cowboys::GPAgentAnalyzer","text":"<p>ClassList &gt; cowboys &gt; GPAgentAnalyzer</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#public-functions","title":"Public Functions","text":"Type Name GPAgentAnalyzer () = defaultConstruct a new GP Agent Analyzer object. void addAverageFitness (double fitness) Adds the average fitness of the best agent. void addAverageScore (double score) Adds the average score of the best agent. void addEliteScore (double score) Adds the weighted score of the best agent. void addMaxFitness (double fitness) Adds the max fitness of the best agent. void addNumAgentsWithMaxFitness (double num_agents) Adds the number of agents with the max fitness. void saveToFile () Saves the data to a csv file. ~GPAgentAnalyzer () = defaultDestroy the GP Agent Analyzer object."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-gpagentanalyzer","title":"function GPAgentAnalyzer","text":"<pre><code>cowboys::GPAgentAnalyzer::GPAgentAnalyzer () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addaveragefitness","title":"function addAverageFitness","text":"<p>Adds the average fitness of the best agent. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addAverageFitness (\n    double fitness\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>fitness</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addaveragescore","title":"function addAverageScore","text":"<p>Adds the average score of the best agent. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addAverageScore (\n    double score\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>score</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addelitescore","title":"function addEliteScore","text":"<p>Adds the weighted score of the best agent. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addEliteScore (\n    double score\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>score</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addmaxfitness","title":"function addMaxFitness","text":"<p>Adds the max fitness of the best agent. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addMaxFitness (\n    double fitness\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>fitness</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addnumagentswithmaxfitness","title":"function addNumAgentsWithMaxFitness","text":"<p>Adds the number of agents with the max fitness. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addNumAgentsWithMaxFitness (\n    double num_agents\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>num_agents</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-savetofile","title":"function saveToFile","text":"<pre><code>inline void cowboys::GPAgentAnalyzer::saveToFile () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-gpagentanalyzer_1","title":"function ~GPAgentAnalyzer","text":"<pre><code>cowboys::GPAgentAnalyzer::~GPAgentAnalyzer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentAnalyze.h</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/","title":"Class cowboys::GPAgentBase","text":"<p>ClassList &gt; cowboys &gt; GPAgentBase</p> <p>Inherits the following classes: AgentBase</p> <p>Inherited by the following classes: cowboys::CGPAgent,  cowboys::LGPAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#public-functions","title":"Public Functions","text":"Type Name virtual void Copy (const GPAgentBase &amp; other) = 0Copy the behavior of another agent into this agent. virtual std::string Export ()  GPAgentBase (size_t id, const std::string &amp; name)  virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) = 0 const std::unordered_map&lt; std::string, double &gt; GetExtraState () constGet a map of extra state information. double GetRandom () Return a uniform random value between 0.0 and 1.0. double GetRandom (double max) Return a uniform random value between 0.0 and max. double GetRandom (double min, double max) Return a uniform random value between min and max. double GetRandomNormal () Return a gaussian random value with mean 0.0 and sd 1.0. double GetRandomNormal (double mean, double sd=1.0) Return a gaussian random value with provided mean and sd. size_t GetRandomULL (size_t max) Return a uniform random unsigned long long between 0 (inclusive) and max (exclusive) unsigned int GetSeed () constGet the seed used to initialize this RNG. virtual void Import (const std::string &amp; genotype) = 0 bool Initialize () overrideSetup graph. virtual void MutateAgent (double mutation_rate=0.8) = 0Mutate this agent. virtual void PrintAgent ()  virtual void Reset (bool=false)  size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) overrideChoose the action to take a step in the appropriate direction. virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) = 0 void SetSeed (unsigned int seed) Set the seed used to initialize this RNG. ~GPAgentBase () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#protected-attributes","title":"Protected Attributes","text":"Type Name std::unordered_map&lt; std::string, double &gt; extra_state A map of extra state information. std::normal_distribution&lt; double &gt; norm_dist Normal distribution. std::mt19937 rng   = {seed}Random number generator. unsigned int seed   = = 0Seed for the random number generator. std::uniform_real_distribution&lt; double &gt; uni_dist Uniform distribution."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-copy","title":"function Copy","text":"<p>Copy the behavior of another agent into this agent. </p> <pre><code>virtual void cowboys::GPAgentBase::Copy (\n    const GPAgentBase &amp; other\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The agent to copy. Should be the same type. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-export","title":"function Export","text":"<pre><code>inline virtual std::string cowboys::GPAgentBase::Export () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-gpagentbase","title":"function GPAgentBase","text":"<pre><code>inline cowboys::GPAgentBase::GPAgentBase (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getaction","title":"function GetAction","text":"<pre><code>virtual size_t cowboys::GPAgentBase::GetAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_set,\n    const cse491::agent_map_t &amp; agent_set\n) = 0\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getextrastate","title":"function GetExtraState","text":"<p>Get a map of extra state information. </p> <pre><code>inline const std::unordered_map&lt; std::string, double &gt; cowboys::GPAgentBase::GetExtraState () const\n</code></pre> <p>Returns:</p> <p>Map of extra state information </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandom-13","title":"function GetRandom [1/3]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandom () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandom-23","title":"function GetRandom [2/3]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandom (\n    double max\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandom-33","title":"function GetRandom [3/3]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandom (\n    double min,\n    double max\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandomnormal-12","title":"function GetRandomNormal [1/2]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandomNormal () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandomnormal-22","title":"function GetRandomNormal [2/2]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandomNormal (\n    double mean,\n    double sd=1.0\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandomull","title":"function GetRandomULL","text":"<pre><code>inline size_t cowboys::GPAgentBase::GetRandomULL (\n    size_t max\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getseed","title":"function GetSeed","text":"<pre><code>inline unsigned int cowboys::GPAgentBase::GetSeed () const\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-import","title":"function Import","text":"<pre><code>virtual void cowboys::GPAgentBase::Import (\n    const std::string &amp; genotype\n) = 0\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-initialize","title":"function Initialize","text":"<p>Setup graph. </p> <pre><code>inline bool cowboys::GPAgentBase::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-mutateagent","title":"function MutateAgent","text":"<p>Mutate this agent. </p> <pre><code>virtual void cowboys::GPAgentBase::MutateAgent (\n    double mutation_rate=0.8\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The mutation rate. Between 0 and 1. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-printagent","title":"function PrintAgent","text":"<pre><code>inline virtual void cowboys::GPAgentBase::PrintAgent () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-reset","title":"function Reset","text":"<pre><code>inline virtual void cowboys::GPAgentBase::Reset (\n    bool=false\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cowboys::GPAgentBase::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_set,\n    const cse491::agent_map_t &amp; agent_set\n) override\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-serializegp","title":"function SerializeGP","text":"<pre><code>virtual void cowboys::GPAgentBase::SerializeGP (\n    tinyxml2::XMLDocument &amp; doc,\n    tinyxml2::XMLElement * parentElem,\n    double fitness=-1\n) = 0\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-setseed","title":"function SetSeed","text":"<pre><code>inline void cowboys::GPAgentBase::SetSeed (\n    unsigned int seed\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-gpagentbase_1","title":"function ~GPAgentBase","text":"<pre><code>cowboys::GPAgentBase::~GPAgentBase () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-extra_state","title":"variable extra_state","text":"<pre><code>std::unordered_map&lt;std::string, double&gt; extra_state;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-norm_dist","title":"variable norm_dist","text":"<pre><code>std::normal_distribution&lt;double&gt; norm_dist;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-rng","title":"variable rng","text":"<pre><code>std::mt19937 rng;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-seed","title":"variable seed","text":"<pre><code>unsigned int seed;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-uni_dist","title":"variable uni_dist","text":"<pre><code>std::uniform_real_distribution&lt;double&gt; uni_dist;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentBase.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/","title":"Class cowboys::GPAgentRegisters","text":"<p>ClassList &gt; cowboys &gt; GPAgentRegisters</p> <p>Class to hold the registers of the agent. </p> <ul> <li><code>#include &lt;GPAgentsRegisters.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#classes","title":"Classes","text":"Type Name class iterator Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#public-functions","title":"Public Functions","text":"Type Name GPAgentRegisters (int numRegisters=16) Number of registers Default is 16. iterator begin ()  iterator end ()  size_t getNumRegisters () Get the number of registers. std::optional&lt; size_t &gt; getRegister (size_t index) Get the Register object. bool setRegister (size_t index, size_t value) Set the Register object. size_t size ()  ~GPAgentRegisters () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-gpagentregisters","title":"function GPAgentRegisters","text":"<p>Number of registers Default is 16. </p> <pre><code>inline cowboys::GPAgentRegisters::GPAgentRegisters (\n    int numRegisters=16\n) \n</code></pre> <p>Constructor for GPAgentRegisters </p> <p>Parameters:</p> <ul> <li><code>numRegisters</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-begin","title":"function begin","text":"<pre><code>inline iterator cowboys::GPAgentRegisters::begin () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-end","title":"function end","text":"<pre><code>inline iterator cowboys::GPAgentRegisters::end () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-getnumregisters","title":"function getNumRegisters","text":"<p>Get the number of registers. </p> <pre><code>inline size_t cowboys::GPAgentRegisters::getNumRegisters () \n</code></pre> <p>Returns:</p> <p>size of the registers </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-getregister","title":"function getRegister","text":"<p>Get the Register object. </p> <pre><code>inline std::optional&lt; size_t &gt; cowboys::GPAgentRegisters::getRegister (\n    size_t index\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>index</code> Index of the register </li> </ul> <p>Returns:</p> <p>std::optional&lt;size_t&gt; Returns the value of the register if it exists </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-setregister","title":"function setRegister","text":"<p>Set the Register object. </p> <pre><code>inline bool cowboys::GPAgentRegisters::setRegister (\n    size_t index,\n    size_t value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>index</code> </li> <li><code>value</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-size","title":"function size","text":"<pre><code>inline size_t cowboys::GPAgentRegisters::size () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-gpagentregisters_1","title":"function ~GPAgentRegisters","text":"<pre><code>cowboys::GPAgentRegisters::~GPAgentRegisters () = default\n</code></pre> <p>Destructor for GPAgentRegisters </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentsRegisters.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/","title":"Class cowboys::GPAgentRegisters::iterator","text":"<p>ClassList &gt; cowboys &gt; GPAgentRegisters &gt; iterator</p> <p>Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator.</p> <ul> <li><code>#include &lt;GPAgentsRegisters.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#public-functions","title":"Public Functions","text":"Type Name iterator (size_t index, GPAgentRegisters &amp; regs)  bool operator!= (const iterator &amp; other) constOverload not equal operator. size_t &amp; operator* ()  iterator &amp; operator++ ()  bool operator== (const iterator &amp; other) constOverload post-increment operator."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-iterator","title":"function iterator","text":"<pre><code>inline cowboys::GPAgentRegisters::iterator::iterator (\n    size_t index,\n    GPAgentRegisters &amp; regs\n) \n</code></pre> <p>Constructor for iterator </p> <p>Parameters:</p> <ul> <li><code>index</code> </li> <li><code>regs</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-operator","title":"function operator!=","text":"<p>Overload not equal operator. </p> <pre><code>inline bool cowboys::GPAgentRegisters::iterator::operator!= (\n    const iterator &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-operator_1","title":"function operator*","text":"<pre><code>inline size_t &amp; cowboys::GPAgentRegisters::iterator::operator* () \n</code></pre> <p>Overload dereference operator </p> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-operator_2","title":"function operator++","text":"<pre><code>inline iterator &amp; cowboys::GPAgentRegisters::iterator::operator++ () \n</code></pre> <p>Overload pre-increment operator </p> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-operator_3","title":"function operator==","text":"<p>Overload post-increment operator. </p> <pre><code>inline bool cowboys::GPAgentRegisters::iterator::operator== (\n    const iterator &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul> <p>Returns:</p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentsRegisters.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/","title":"Class cowboys::GPTrainingLoop","text":"<p>template &lt;class AgentType class AgentType, class EnvironmentType class EnvironmentType&gt;</p> <p>ClassList &gt; cowboys &gt; GPTrainingLoop</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#classes","title":"Classes","text":"Type Name struct SaveDataParams"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-attributes","title":"Public Attributes","text":"Type Name bool ScavengerQueuing   = = false"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-functions","title":"Public Functions","text":"Type Name double AStarFitnessFunction (const cse491::GridPosition &amp; startpos, const cse491::GridPosition &amp; endpos, int arena, int a)  int AgentsAnalysisComputationsAndPrint (int generation, double deltaForMaxFitness=0.1)  std::string FormatPosition (const cse491::GridPosition &amp; pos, int precision=0)  std::filesystem::path FullLoadGrabLatestGeneration ()  GPTrainingLoop (const bool scavengerQueuing=false) : constructor size_t Get_A_StarDistance (const cse491::GridPosition &amp; startpos, const cse491::GridPosition &amp; endpos, int arenaIDX, int agentIDX)  void GpLoopMutateHelper () Helper function for the GP loop mutate function. void InitTEMPAgentFitness () : initialize the TEMP agent fitness vector void Initialize (size_t numArenas=5, size_t NumAgentsForArena=100) Initialize the training loop with a number of environments and agents per environment. void MemGOBYE () Clears the memory of the training loop. void MutateAgents (int start, int end, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; sortedAgents, std::vector&lt; std::vector&lt; cowboys::GPAgentBase * &gt; &gt; &amp; agents, double mutationRate) Helper function for the GP loop mutate function. This function mutates the agents. This function is called in a thread. void MutateAndCopyAgents (int start, int end, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; sortedAgents, std::vector&lt; std::vector&lt; cowboys::GPAgentBase * &gt; &gt; &amp; agents, int elitePopulationSize) Helper function for the GP loop mutate function. This function copies the elite agents and mutates them. This function is called in a thread. for th. void Printgrid (const std::vector&lt; cse491::GridPosition &gt; &amp; positions, char symbol='S') Prints the grid for a single arena. void ResetMainTagLastGenerations ()  void Run (size_t numGenerations, size_t numberOfTurns=100, size_t maxThreads=0, bool saveData=false) : runs the Genetic Programming training loop for a number of generations to evolve the agents void RunArena (size_t arena, size_t numberOfTurns) Runs the training loop for a single arena. This function is called in a thread. Each arena is run in a separate thread. void SaveDataCheckPoint (const SaveDataParams &amp; params)  void SerializeAgents (int generation, tinyxml2::XMLElement * rootElement, tinyxml2::XMLDocument &amp; paramDocument, size_t topN=5) : Serializes the agents to an XML file. double SimpleFitnessFunction (cse491::AgentBase &amp; agent, cse491::GridPosition startPosition)  void SortThemAgents () : sort the agents based on their fitness void ThreadTrainLoop (size_t maxThreads=1, int numberOfTurns=100)  void loadLastGeneration ()  void resetEnvironments () Resets the environments to their initial state. This function is called after each generation. This function currently only soft resets the environments. void saveXMLDoc (tinyxml2::XMLDocument &amp; paramdoc, std::string fullPath)  ~GPTrainingLoop () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-static-functions","title":"Public Static Functions","text":"Type Name std::string getDateStr ()  std::filesystem::path getSystemPath ()"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#variable-scavengerqueuing","title":"variable ScavengerQueuing","text":"<pre><code>bool ScavengerQueuing;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-astarfitnessfunction","title":"function AStarFitnessFunction","text":"<pre><code>inline double cowboys::GPTrainingLoop::AStarFitnessFunction (\n    const cse491::GridPosition &amp; startpos,\n    const cse491::GridPosition &amp; endpos,\n    int arena,\n    int a\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-agentsanalysiscomputationsandprint","title":"function AgentsAnalysisComputationsAndPrint","text":"<pre><code>inline int cowboys::GPTrainingLoop::AgentsAnalysisComputationsAndPrint (\n    int generation,\n    double deltaForMaxFitness=0.1\n) \n</code></pre> <p>Computes agents analysis metrics</p> <p>Parameters:</p> <ul> <li><code>generation</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-formatposition","title":"function FormatPosition","text":"<pre><code>inline std::string cowboys::GPTrainingLoop::FormatPosition (\n    const cse491::GridPosition &amp; pos,\n    int precision=0\n) \n</code></pre> <p>Helper function to format the data analysis </p> <p>Parameters:</p> <ul> <li><code>pos</code> </li> <li><code>precision</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-fullloadgrablatestgeneration","title":"function FullLoadGrabLatestGeneration","text":"<pre><code>inline std::filesystem::path cowboys::GPTrainingLoop::FullLoadGrabLatestGeneration () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-gptrainingloop","title":"function GPTrainingLoop","text":"<pre><code>inline cowboys::GPTrainingLoop::GPTrainingLoop (\n    const bool scavengerQueuing=false\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-get_a_stardistance","title":"function Get_A_StarDistance","text":"<pre><code>inline size_t cowboys::GPTrainingLoop::Get_A_StarDistance (\n    const cse491::GridPosition &amp; startpos,\n    const cse491::GridPosition &amp; endpos,\n    int arenaIDX,\n    int agentIDX\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-gploopmutatehelper","title":"function GpLoopMutateHelper","text":"<pre><code>inline void cowboys::GPTrainingLoop::GpLoopMutateHelper () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-inittempagentfitness","title":"function InitTEMPAgentFitness","text":"<pre><code>inline void cowboys::GPTrainingLoop::InitTEMPAgentFitness () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-initialize","title":"function Initialize","text":"<p>Initialize the training loop with a number of environments and agents per environment. </p> <pre><code>inline void cowboys::GPTrainingLoop::Initialize (\n    size_t numArenas=5,\n    size_t NumAgentsForArena=100\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>numArenas</code> </li> <li><code>NumAgentsForArena</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-memgobye","title":"function MemGOBYE","text":"<pre><code>inline void cowboys::GPTrainingLoop::MemGOBYE () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-mutateagents","title":"function MutateAgents","text":"<p>Helper function for the GP loop mutate function. This function mutates the agents. This function is called in a thread. </p> <pre><code>inline void cowboys::GPTrainingLoop::MutateAgents (\n    int start,\n    int end,\n    const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; sortedAgents,\n    std::vector&lt; std::vector&lt; cowboys::GPAgentBase * &gt; &gt; &amp; agents,\n    double mutationRate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>start</code> : The start index of the agents to mutate. </li> <li><code>end</code> : The end index of the agents to mutate. </li> <li><code>sortedAgents</code> : The sorted agents' index vector. </li> <li><code>agents</code> : The agents vector. </li> <li><code>mutationRate</code> The mutation rate. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-mutateandcopyagents","title":"function MutateAndCopyAgents","text":"<p>Helper function for the GP loop mutate function. This function copies the elite agents and mutates them. This function is called in a thread. for th. </p> <pre><code>inline void cowboys::GPTrainingLoop::MutateAndCopyAgents (\n    int start,\n    int end,\n    const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; sortedAgents,\n    std::vector&lt; std::vector&lt; cowboys::GPAgentBase * &gt; &gt; &amp; agents,\n    int elitePopulationSize\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>start</code> </li> <li><code>end</code> </li> <li><code>sortedAgents</code> </li> <li><code>agents</code> </li> <li><code>elitePopulationSize</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-printgrid","title":"function Printgrid","text":"<p>Prints the grid for a single arena. </p> <pre><code>inline void cowboys::GPTrainingLoop::Printgrid (\n    const std::vector&lt; cse491::GridPosition &gt; &amp; positions,\n    char symbol='S'\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>arenaId</code> </li> </ul> <p>Author:</p> <p>: @amantham20 </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-resetmaintaglastgenerations","title":"function ResetMainTagLastGenerations","text":"<pre><code>inline void cowboys::GPTrainingLoop::ResetMainTagLastGenerations () \n</code></pre> <p>Resets the xml for data that needs to be overwritten </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-run","title":"function Run","text":"<p>: runs the Genetic Programming training loop for a number of generations to evolve the agents </p> <pre><code>inline void cowboys::GPTrainingLoop::Run (\n    size_t numGenerations,\n    size_t numberOfTurns=100,\n    size_t maxThreads=0,\n    bool saveData=false\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>numGenerations</code> </li> <li><code>numberOfTurns</code> </li> <li><code>maxThreads</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-runarena","title":"function RunArena","text":"<p>Runs the training loop for a single arena. This function is called in a thread. Each arena is run in a separate thread. </p> <pre><code>inline void cowboys::GPTrainingLoop::RunArena (\n    size_t arena,\n    size_t numberOfTurns\n) \n</code></pre> <p>Author:</p> <p>: @amantham20 </p> <p>Parameters:</p> <ul> <li><code>arena</code> : The arena to run. </li> <li><code>numberOfTurns</code> : The number of turns to run the arena for. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-savedatacheckpoint","title":"function SaveDataCheckPoint","text":"<pre><code>inline void cowboys::GPTrainingLoop::SaveDataCheckPoint (\n    const SaveDataParams &amp; params\n) \n</code></pre> <p>Saves checkpoint data to XML files everyso often </p> <p>Parameters:</p> <ul> <li><code>params</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-serializeagents","title":"function SerializeAgents","text":"<p>: Serializes the agents to an XML file. </p> <pre><code>inline void cowboys::GPTrainingLoop::SerializeAgents (\n    int generation,\n    tinyxml2::XMLElement * rootElement,\n    tinyxml2::XMLDocument &amp; paramDocument,\n    size_t topN=5\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>countMaxAgents</code> </li> <li><code>generation</code> </li> <li><code>topN</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-simplefitnessfunction","title":"function SimpleFitnessFunction","text":"<pre><code>inline double cowboys::GPTrainingLoop::SimpleFitnessFunction (\n    cse491::AgentBase &amp; agent,\n    cse491::GridPosition startPosition\n) \n</code></pre> <p>Simple and temporary fitness function </p> <p>Parameters:</p> <ul> <li><code>agent</code> </li> <li><code>startPosition</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-sortthemagents","title":"function SortThemAgents","text":"<pre><code>inline void cowboys::GPTrainingLoop::SortThemAgents () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-threadtrainloop","title":"function ThreadTrainLoop","text":"<pre><code>inline void cowboys::GPTrainingLoop::ThreadTrainLoop (\n    size_t maxThreads=1,\n    int numberOfTurns=100\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>maxThreads</code> </li> <li><code>numberOfTurns</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-loadlastgeneration","title":"function loadLastGeneration","text":"<pre><code>inline void cowboys::GPTrainingLoop::loadLastGeneration () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-resetenvironments","title":"function resetEnvironments","text":"<pre><code>inline void cowboys::GPTrainingLoop::resetEnvironments () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-savexmldoc","title":"function saveXMLDoc","text":"<pre><code>inline void cowboys::GPTrainingLoop::saveXMLDoc (\n    tinyxml2::XMLDocument &amp; paramdoc,\n    std::string fullPath\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-gptrainingloop_1","title":"function ~GPTrainingLoop","text":"<pre><code>cowboys::GPTrainingLoop::~GPTrainingLoop () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-getdatestr","title":"function getDateStr","text":"<pre><code>static inline std::string cowboys::GPTrainingLoop::getDateStr () \n</code></pre> <p>Gets the date and time as a string </p> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-getsystempath","title":"function getSystemPath","text":"<pre><code>static inline std::filesystem::path cowboys::GPTrainingLoop::getSystemPath () \n</code></pre> <p>Gets the path of the save location </p> <p>Returns:</p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPTrainingLoop.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/","title":"Struct cowboys::GPTrainingLoop::SaveDataParams","text":"<p>ClassList &gt; cowboys &gt; GPTrainingLoop &gt; SaveDataParams</p> <p>More...</p> <ul> <li><code>#include &lt;GPTrainingLoop.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#public-attributes","title":"Public Attributes","text":"Type Name size_t checkPointEvery   = = 5 size_t countMaxAgents   = = 0 std::string dateTimeStr   = = getDateStr() size_t generation std::filesystem::path normalizedAbsolutePath   = = getSystemPath() bool save   = = false bool saveAllAgentData   = = false bool saveLastGenerations   = = false bool saveMetaData   = = true bool saveTopAgents   = = false"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#public-functions","title":"Public Functions","text":"Type Name SaveDataParams (size_t gen)  void updateGeneration (size_t gen)"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#detailed-description","title":"Detailed Description","text":"<p>SaveDataParams for saving data in checkpoints </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-checkpointevery","title":"variable checkPointEvery","text":"<pre><code>size_t checkPointEvery;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-countmaxagents","title":"variable countMaxAgents","text":"<pre><code>size_t countMaxAgents;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-datetimestr","title":"variable dateTimeStr","text":"<pre><code>std::string dateTimeStr;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-generation","title":"variable generation","text":"<pre><code>size_t generation;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-normalizedabsolutepath","title":"variable normalizedAbsolutePath","text":"<pre><code>std::filesystem::path normalizedAbsolutePath;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-save","title":"variable save","text":"<pre><code>bool save;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-saveallagentdata","title":"variable saveAllAgentData","text":"<pre><code>bool saveAllAgentData;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-savelastgenerations","title":"variable saveLastGenerations","text":"<pre><code>bool saveLastGenerations;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-savemetadata","title":"variable saveMetaData","text":"<pre><code>bool saveMetaData;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-savetopagents","title":"variable saveTopAgents","text":"<pre><code>bool saveTopAgents;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#function-savedataparams","title":"function SaveDataParams","text":"<pre><code>inline cowboys::GPTrainingLoop::SaveDataParams::SaveDataParams (\n    size_t gen\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#function-updategeneration","title":"function updateGeneration","text":"<pre><code>inline void cowboys::GPTrainingLoop::SaveDataParams::updateGeneration (\n    size_t gen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPTrainingLoop.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/","title":"Class cowboys::Graph","text":"<p>ClassList &gt; cowboys &gt; Graph</p> <p>A graph of nodes that can be used to make decisions. </p> <ul> <li><code>#include &lt;Graph.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#public-functions","title":"Public Functions","text":"Type Name void AddLayer (const GraphLayer &amp; layer) Add a layer to the graph. Purely organizational, but important for CGP for determining the \"layers back\" parameter. std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; GetFunctionalNodes () constReturns a vector of functional (non-input) nodes in the graph. size_t GetLayerCount () constGet the number of layers in the graph. size_t GetNodeCount () constGet the number of nodes in the graph. std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; GetNodes () constReturns a vector of all nodes in the graph. Graph () = default size_t MakeDecision (const std::vector&lt; double &gt; &amp; inputs, const std::vector&lt; size_t &gt; &amp; actions) Makes a decision based on the inputs and the action vector. ~Graph () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; GraphLayer &gt; layers Layers of nodes in the graph."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-addlayer","title":"function AddLayer","text":"<p>Add a layer to the graph. Purely organizational, but important for CGP for determining the \"layers back\" parameter. </p> <pre><code>inline void cowboys::Graph::AddLayer (\n    const GraphLayer &amp; layer\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>layer</code> The layer of nodes to add. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-getfunctionalnodes","title":"function GetFunctionalNodes","text":"<p>Returns a vector of functional (non-input) nodes in the graph. </p> <pre><code>inline std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; cowboys::Graph::GetFunctionalNodes () const\n</code></pre> <p>Returns:</p> <p>A vector of functional nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-getlayercount","title":"function GetLayerCount","text":"<p>Get the number of layers in the graph. </p> <pre><code>inline size_t cowboys::Graph::GetLayerCount () const\n</code></pre> <p>Returns:</p> <p>The number of layers in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-getnodecount","title":"function GetNodeCount","text":"<p>Get the number of nodes in the graph. </p> <pre><code>inline size_t cowboys::Graph::GetNodeCount () const\n</code></pre> <p>Returns:</p> <p>The number of nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-getnodes","title":"function GetNodes","text":"<p>Returns a vector of all nodes in the graph. </p> <pre><code>inline std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; cowboys::Graph::GetNodes () const\n</code></pre> <p>Returns:</p> <p>A vector of all nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-graph","title":"function Graph","text":"<pre><code>cowboys::Graph::Graph () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-makedecision","title":"function MakeDecision","text":"<p>Makes a decision based on the inputs and the action vector. </p> <pre><code>inline size_t cowboys::Graph::MakeDecision (\n    const std::vector&lt; double &gt; &amp; inputs,\n    const std::vector&lt; size_t &gt; &amp; actions\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>inputs</code> The inputs to the graph. </li> <li><code>action_vec</code> The action vector. </li> </ul> <p>Returns:</p> <p>The action to take. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-graph_1","title":"function ~Graph","text":"<pre><code>cowboys::Graph::~Graph () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#variable-layers","title":"variable layers","text":"<pre><code>std::vector&lt;GraphLayer&gt; layers;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/Graph.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/","title":"Class cowboys::GraphBuilder","text":"<p>ClassList &gt; cowboys &gt; GraphBuilder</p> <p>A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs.</p> <ul> <li><code>#include &lt;GraphBuilder.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#public-functions","title":"Public Functions","text":"Type Name std::unique_ptr&lt; Graph &gt; CartesianGraph (const CGPGenotype &amp; genotype, const std::vector&lt; InnerFunction &gt; &amp; function_set, const cse491::AgentBase * agent=nullptr) Creates a decision graph from a CGP genotype. GraphBuilder () = default std::unique_ptr&lt; Graph &gt; VerticalPacer () Creates a decision graph for pacing up and down in a MazeWorld. Assumes that the inputs are in the format: prev_action, current_state, above_state, below_state, left_state, right_state. ~GraphBuilder () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#function-cartesiangraph","title":"function CartesianGraph","text":"<p>Creates a decision graph from a CGP genotype. </p> <pre><code>inline std::unique_ptr&lt; Graph &gt; cowboys::GraphBuilder::CartesianGraph (\n    const CGPGenotype &amp; genotype,\n    const std::vector&lt; InnerFunction &gt; &amp; function_set,\n    const cse491::AgentBase * agent=nullptr\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>genotype</code> The genotype to create the decision graph from. </li> <li><code>function_set</code> The set of functions available to the decision graph. </li> <li><code>agent</code> The agent that will be using the decision graph. </li> </ul> <p>Returns:</p> <p>The decision graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#function-graphbuilder","title":"function GraphBuilder","text":"<pre><code>cowboys::GraphBuilder::GraphBuilder () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#function-verticalpacer","title":"function VerticalPacer","text":"<p>Creates a decision graph for pacing up and down in a MazeWorld. Assumes that the inputs are in the format: prev_action, current_state, above_state, below_state, left_state, right_state. </p> <pre><code>inline std::unique_ptr&lt; Graph &gt; cowboys::GraphBuilder::VerticalPacer () \n</code></pre> <p>Parameters:</p> <ul> <li><code>action_vec</code> Assumes that the action outputs are in the format: up, down, left, right </li> </ul> <p>Returns:</p> <p>The decision graph for a vertical pacer. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#function-graphbuilder_1","title":"function ~GraphBuilder","text":"<pre><code>cowboys::GraphBuilder::~GraphBuilder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphBuilder.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/","title":"Class cowboys::GraphNode","text":"<p>ClassList &gt; cowboys &gt; GraphNode</p> <p>A node in a decision graph. More...</p> <ul> <li><code>#include &lt;GraphNode.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::enable_shared_from_this&lt; GraphNode &gt;</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#public-functions","title":"Public Functions","text":"Type Name void AddInput (std::shared_ptr&lt; GraphNode &gt; node) Add an input node to this node. void AddInputs (const std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; &amp; nodes) Append nodes in a vector to this node's list of inputs. double GetDefaultOutput () constGet the default output of this node. std::vector&lt; double &gt; GetInputValues () constGet the output values of the inputs of this node. std::optional&lt; std::vector&lt; double &gt; &gt; GetInputValues (const std::array&lt; size_t, N &gt; &amp; indices) constGet the output values of the inputs of this node given an array of indices. double GetOutput () constGet the output of this node. Performs caching. GraphNode () = default GraphNode (double default_value) TODO: Check guidelines for this. GraphNode (NodeFunction function)  GraphNode (InnerFunction function)  bool IsCacheValid () constCheck if the cached output is valid. void SetDefaultOutput (double value) Set the default output of this node. void SetFunctionPointer (NodeFunction function) Set the function pointer of this node. void SetFunctionPointer (InnerFunction inner_function) Set the function pointer of this node. void SetInputs (std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; nodes) Set the input nodes of this node. ~GraphNode () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#protected-attributes","title":"Protected Attributes","text":"Type Name double cached_output   = {0}The cached output of this node. bool cached_output_valid   = {false}Flag indicating whether the cached output is valid. double default_output   = {0}The default output of this node. NodeFunction function_pointer The function that operates on the outputs from a node's input nodes. std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; inputs The input nodes to this node. std::vector&lt; GraphNode * &gt; outputs The nodes connected to this node's output."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#protected-functions","title":"Protected Functions","text":"Type Name void AddOutput (GraphNode * node) Add an output node to this node. Used for cache invalidation. void RecursiveInvalidateCache () constInvalidates this node's cache and the caches of all nodes that depend on this node."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>This should always be a shared pointer. Caching will not work otherwise. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-addinput","title":"function AddInput","text":"<p>Add an input node to this node. </p> <pre><code>inline void cowboys::GraphNode::AddInput (\n    std::shared_ptr&lt; GraphNode &gt; node\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to add as an input. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-addinputs","title":"function AddInputs","text":"<p>Append nodes in a vector to this node's list of inputs. </p> <pre><code>inline void cowboys::GraphNode::AddInputs (\n    const std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; &amp; nodes\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nodes</code> The nodes to add as inputs. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-getdefaultoutput","title":"function GetDefaultOutput","text":"<p>Get the default output of this node. </p> <pre><code>inline double cowboys::GraphNode::GetDefaultOutput () const\n</code></pre> <p>Returns:</p> <p>The default output. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-getinputvalues-12","title":"function GetInputValues [1/2]","text":"<p>Get the output values of the inputs of this node. </p> <pre><code>inline std::vector&lt; double &gt; cowboys::GraphNode::GetInputValues () const\n</code></pre> <p>Returns:</p> <p>A vector of doubles representing the input values. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-getinputvalues-22","title":"function GetInputValues [2/2]","text":"<p>Get the output values of the inputs of this node given an array of indices. </p> <pre><code>template&lt;size_t N&gt;\ninline std::optional&lt; std::vector&lt; double &gt; &gt; cowboys::GraphNode::GetInputValues (\n    const std::array&lt; size_t, N &gt; &amp; indices\n) const\n</code></pre> <p>Template parameters:</p> <ul> <li><code>N</code> The size of the indices array. </li> </ul> <p>Parameters:</p> <ul> <li><code>indices</code> The indices of the inputs to get the output values of. </li> </ul> <p>Returns:</p> <p>A vector of doubles representing the input values in the same order of the indices. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-getoutput","title":"function GetOutput","text":"<p>Get the output of this node. Performs caching. </p> <pre><code>inline double cowboys::GraphNode::GetOutput () const\n</code></pre> <p>Returns:</p> <p>The output of this node. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode-14","title":"function GraphNode [1/4]","text":"<pre><code>cowboys::GraphNode::GraphNode () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode-24","title":"function GraphNode [2/4]","text":"<pre><code>inline cowboys::GraphNode::GraphNode (\n    double default_value\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode-34","title":"function GraphNode [3/4]","text":"<pre><code>inline cowboys::GraphNode::GraphNode (\n    NodeFunction function\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode-44","title":"function GraphNode [4/4]","text":"<pre><code>inline cowboys::GraphNode::GraphNode (\n    InnerFunction function\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-iscachevalid","title":"function IsCacheValid","text":"<p>Check if the cached output is valid. </p> <pre><code>inline bool cowboys::GraphNode::IsCacheValid () const\n</code></pre> <p>Returns:</p> <p>True if the cached output is valid, false otherwise. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-setdefaultoutput","title":"function SetDefaultOutput","text":"<p>Set the default output of this node. </p> <pre><code>inline void cowboys::GraphNode::SetDefaultOutput (\n    double value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The new default output. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-setfunctionpointer-12","title":"function SetFunctionPointer [1/2]","text":"<p>Set the function pointer of this node. </p> <pre><code>inline void cowboys::GraphNode::SetFunctionPointer (\n    NodeFunction function\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>function</code> The function for this node to use. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-setfunctionpointer-22","title":"function SetFunctionPointer [2/2]","text":"<p>Set the function pointer of this node. </p> <pre><code>inline void cowboys::GraphNode::SetFunctionPointer (\n    InnerFunction inner_function\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>inner_function</code> The inner function for this node to use. Will be wrapped in a NodeFunction. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-setinputs","title":"function SetInputs","text":"<p>Set the input nodes of this node. </p> <pre><code>inline void cowboys::GraphNode::SetInputs (\n    std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; nodes\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nodes</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode","title":"function ~GraphNode","text":"<pre><code>cowboys::GraphNode::~GraphNode () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-cached_output","title":"variable cached_output","text":"<pre><code>double cached_output;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-cached_output_valid","title":"variable cached_output_valid","text":"<pre><code>bool cached_output_valid;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-default_output","title":"variable default_output","text":"<pre><code>double default_output;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-function_pointer","title":"variable function_pointer","text":"<pre><code>NodeFunction function_pointer;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-inputs","title":"variable inputs","text":"<pre><code>std::vector&lt;std::shared_ptr&lt;GraphNode&gt; &gt; inputs;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-outputs","title":"variable outputs","text":"<pre><code>std::vector&lt;GraphNode *&gt; outputs;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-addoutput","title":"function AddOutput","text":"<p>Add an output node to this node. Used for cache invalidation. </p> <pre><code>inline void cowboys::GraphNode::AddOutput (\n    GraphNode * node\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to add as an output. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-recursiveinvalidatecache","title":"function RecursiveInvalidateCache","text":"<pre><code>inline void cowboys::GraphNode::RecursiveInvalidateCache () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphNode.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/","title":"Class cowboys::LGPAgent","text":"<p>ClassList &gt; cowboys &gt; LGPAgent</p> <p>Inherits the following classes: cowboys::GPAgentBase</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-functions","title":"Public Functions","text":"Type Name void Configure (const LGPAgent &amp; other) Copies the behavior of another LGPAgent into this agent. virtual void Copy (const GPAgentBase &amp; other) overrideCopy the behavior of another agent into this agent. virtual std::string Export () overrideExport the agent to a string. void GenerateRandomActionList () Generate a random list of instructions from a list of possible instructions. virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) overrideGet the action to take. const std::vector&lt; std::tuple&lt; std::string, int, int &gt; &gt; &amp; GetInstructionsList () Get the instruction list for this agent. virtual void Import (const std::string &amp; encodedLists) overrideLoad in the string representation of an LGP agent and configure this agent based on it. bool Initialize () overrideInitialize the agent after being given an action map. LGPAgent (size_t id, const std::string &amp; name)  virtual void MutateAgent (double mutation_rate=0.01) overrideMutate this agent. virtual void PrintAgent () overridePrint the agent. virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) overrideSerialize this agent to XML."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-functions-inherited-from-cowboysgpagentbase","title":"Public Functions inherited from cowboys::GPAgentBase","text":"<p>See cowboys::GPAgentBase</p> Type Name virtual void Copy (const GPAgentBase &amp; other) = 0Copy the behavior of another agent into this agent. virtual std::string Export ()  GPAgentBase (size_t id, const std::string &amp; name)  virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) = 0 const std::unordered_map&lt; std::string, double &gt; GetExtraState () constGet a map of extra state information. double GetRandom () Return a uniform random value between 0.0 and 1.0. double GetRandom (double max) Return a uniform random value between 0.0 and max. double GetRandom (double min, double max) Return a uniform random value between min and max. double GetRandomNormal () Return a gaussian random value with mean 0.0 and sd 1.0. double GetRandomNormal (double mean, double sd=1.0) Return a gaussian random value with provided mean and sd. size_t GetRandomULL (size_t max) Return a uniform random unsigned long long between 0 (inclusive) and max (exclusive) unsigned int GetSeed () constGet the seed used to initialize this RNG. virtual void Import (const std::string &amp; genotype) = 0 bool Initialize () overrideSetup graph. virtual void MutateAgent (double mutation_rate=0.8) = 0Mutate this agent. virtual void PrintAgent ()  virtual void Reset (bool=false)  size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) overrideChoose the action to take a step in the appropriate direction. virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) = 0 void SetSeed (unsigned int seed) Set the seed used to initialize this RNG. ~GPAgentBase () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-static-functions","title":"Public Static Functions","text":"Type Name std::vector&lt; std::string &gt; EncodeActions (const std::unordered_map&lt; std::string, size_t &gt; &amp; action_map, const std::vector&lt; std::string &gt; &amp; sensorsNamesList, const std::vector&lt; std::string &gt; &amp; operationsList, std::vector&lt; std::string &gt; &amp; actionsList) Encodes the actions from an agent's action map into a vector of string, representing action names."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; std::string &gt; actionsList   = = {} size_t currentInstructionIndex   = = 0 std::mt19937 gen std::vector&lt; std::tuple&lt; std::string, int, int &gt; &gt; instructionsList   = = {} std::vector&lt; std::string &gt; operationsList   = = {\"lessthan\", \"greaterthan\", \"equals\"} std::vector&lt; std::string &gt; possibleInstructionsList   = = {} std::random_device rd std::vector&lt; int &gt; resultsList std::vector&lt; std::string &gt; sensorsNamesList   = = {\"getLeft\", \"getRight\", \"getUp\", \"getDown\"}"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#protected-attributes-inherited-from-cowboysgpagentbase","title":"Protected Attributes inherited from cowboys::GPAgentBase","text":"<p>See cowboys::GPAgentBase</p> Type Name std::unordered_map&lt; std::string, double &gt; extra_state A map of extra state information. std::normal_distribution&lt; double &gt; norm_dist Normal distribution. std::mt19937 rng   = {seed}Random number generator. unsigned int seed   = = 0Seed for the random number generator. std::uniform_real_distribution&lt; double &gt; uni_dist Uniform distribution."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-configure","title":"function Configure","text":"<p>Copies the behavior of another LGPAgent into this agent.</p> <pre><code>inline void cowboys::LGPAgent::Configure (\n    const LGPAgent &amp; other\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The LGPAgent to copy. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-copy","title":"function Copy","text":"<p>Copy the behavior of another agent into this agent. </p> <pre><code>inline virtual void cowboys::LGPAgent::Copy (\n    const GPAgentBase &amp; other\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The agent to copy. </li> </ul> <p>Implements cowboys::GPAgentBase::Copy</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-export","title":"function Export","text":"<p>Export the agent to a string. </p> <pre><code>inline virtual std::string cowboys::LGPAgent::Export () override\n</code></pre> <p>Returns:</p> <p>The string representation of the agent </p> <p>Implements cowboys::GPAgentBase::Export</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-generaterandomactionlist","title":"function GenerateRandomActionList","text":"<p>Generate a random list of instructions from a list of possible instructions. </p> <pre><code>inline void cowboys::LGPAgent::GenerateRandomActionList () \n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-getaction","title":"function GetAction","text":"<p>Get the action to take. </p> <pre><code>inline virtual size_t cowboys::LGPAgent::GetAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_set,\n    const cse491::agent_map_t &amp; agent_set\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The world grid. </li> <li><code>type_options</code> The available types of cells in the grid. </li> <li><code>item_set</code> The set of items in the world. </li> <li><code>agent_set</code> The set of agents in the world. </li> </ul> <p>Returns:</p> <p>A size_t corresponding to the action chosen </p> <p>Implements cowboys::GPAgentBase::GetAction</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-getinstructionslist","title":"function GetInstructionsList","text":"<p>Get the instruction list for this agent. </p> <pre><code>inline const std::vector&lt; std::tuple&lt; std::string, int, int &gt; &gt; &amp; cowboys::LGPAgent::GetInstructionsList () \n</code></pre> <p>Returns:</p> <p>A const reference to the instruction list for this agent. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-import","title":"function Import","text":"<p>Load in the string representation of an LGP agent and configure this agent based on it. </p> <pre><code>inline virtual void cowboys::LGPAgent::Import (\n    const std::string &amp; encodedLists\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>genotype</code> The string representation of an LGP agent. </li> </ul> <p>Implements cowboys::GPAgentBase::Import</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-initialize","title":"function Initialize","text":"<p>Initialize the agent after being given an action map. </p> <pre><code>inline bool cowboys::LGPAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-lgpagent","title":"function LGPAgent","text":"<pre><code>inline cowboys::LGPAgent::LGPAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-mutateagent","title":"function MutateAgent","text":"<p>Mutate this agent. </p> <pre><code>inline virtual void cowboys::LGPAgent::MutateAgent (\n    double mutation_rate=0.01\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The probability of any instruction being changed </li> </ul> <p>Implements cowboys::GPAgentBase::MutateAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-printagent","title":"function PrintAgent","text":"<pre><code>inline virtual void cowboys::LGPAgent::PrintAgent () override\n</code></pre> <p>Implements cowboys::GPAgentBase::PrintAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-serializegp","title":"function SerializeGP","text":"<p>Serialize this agent to XML. </p> <pre><code>inline virtual void cowboys::LGPAgent::SerializeGP (\n    tinyxml2::XMLDocument &amp; doc,\n    tinyxml2::XMLElement * parentElem,\n    double fitness=-1\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>doc</code> The XML document to serialize to. </li> <li><code>parentElem</code> The parent element to serialize to. </li> <li><code>fitness</code> The fitness of this agent to write to the XML. </li> </ul> <p>Implements cowboys::GPAgentBase::SerializeGP</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-encodeactions","title":"function EncodeActions","text":"<p>Encodes the actions from an agent's action map into a vector of string, representing action names. </p> <pre><code>static inline std::vector&lt; std::string &gt; cowboys::LGPAgent::EncodeActions (\n    const std::unordered_map&lt; std::string, size_t &gt; &amp; action_map,\n    const std::vector&lt; std::string &gt; &amp; sensorsNamesList,\n    const std::vector&lt; std::string &gt; &amp; operationsList,\n    std::vector&lt; std::string &gt; &amp; actionsList\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>action_map</code> The action map from the agent. </li> <li><code>sensorsNamesList</code> The list of sensors from the agent. </li> <li><code>operationsList</code> The list of operations from the agent. </li> <li><code>actionsList</code> The list of actions from the agent. </li> </ul> <p>Returns:</p> <p>A vector of strings, representing action names. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-actionslist","title":"variable actionsList","text":"<pre><code>std::vector&lt;std::string&gt; actionsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-currentinstructionindex","title":"variable currentInstructionIndex","text":"<pre><code>size_t currentInstructionIndex;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-gen","title":"variable gen","text":"<pre><code>std::mt19937 gen;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-instructionslist","title":"variable instructionsList","text":"<pre><code>std::vector&lt;std::tuple&lt;std::string, int, int&gt; &gt; instructionsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-operationslist","title":"variable operationsList","text":"<pre><code>std::vector&lt;std::string&gt; operationsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-possibleinstructionslist","title":"variable possibleInstructionsList","text":"<pre><code>std::vector&lt;std::string&gt; possibleInstructionsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-rd","title":"variable rd","text":"<pre><code>std::random_device rd;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-resultslist","title":"variable resultsList","text":"<pre><code>std::vector&lt;int&gt; resultsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-sensorsnameslist","title":"variable sensorsNamesList","text":"<pre><code>std::vector&lt;std::string&gt; sensorsNamesList;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/LGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/","title":"Struct cowboys::NodeFunction","text":"<p>ClassList &gt; cowboys &gt; NodeFunction</p> <p>A function pointer wrapper that holds extra arguments for the function pointer. </p> <ul> <li><code>#include &lt;GraphNode.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#public-attributes","title":"Public Attributes","text":"Type Name const cse491::AgentBase * agent   = {nullptr} InnerFunction function   = {nullptr}"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#public-functions","title":"Public Functions","text":"Type Name bool IsNull () const double operator() (const GraphNode &amp; node) const"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#variable-agent","title":"variable agent","text":"<pre><code>const cse491::AgentBase* agent;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#variable-function","title":"variable function","text":"<pre><code>InnerFunction function;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#function-isnull","title":"function IsNull","text":"<pre><code>inline bool cowboys::NodeFunction::IsNull () const\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#function-operator","title":"function operator()","text":"<pre><code>inline double cowboys::NodeFunction::operator() (\n    const GraphNode &amp; node\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphNode.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/","title":"Class cowboys::Sensors","text":"<p>ClassList &gt; cowboys &gt; Sensors</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#public-functions","title":"Public Functions","text":"Type Name Sensors () = defaultConstructor. ~Sensors () = defaultDestructor."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#public-static-functions","title":"Public Static Functions","text":"Type Name SensorDirection getSensorDirectionEnum (const std::string &amp; direction)  int wallDistance (const cse491::WorldGrid &amp; grid, const cse491::AgentBase &amp; agent, SensorDirection direction) returns the distance to the wall in a given direction from the agent"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#function-sensors","title":"function Sensors","text":"<pre><code>cowboys::Sensors::Sensors () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#function-sensors_1","title":"function ~Sensors","text":"<pre><code>cowboys::Sensors::~Sensors () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#function-getsensordirectionenum","title":"function getSensorDirectionEnum","text":"<pre><code>static inline SensorDirection cowboys::Sensors::getSensorDirectionEnum (\n    const std::string &amp; direction\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#function-walldistance","title":"function wallDistance","text":"<p>returns the distance to the wall in a given direction from the agent </p> <pre><code>static inline int cowboys::Sensors::wallDistance (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::AgentBase &amp; agent,\n    SensorDirection direction\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> grid maze of the world </li> <li><code>agent</code> agent to find the distance from </li> <li><code>direction</code> direction to find the distance (LEFT, RIGHT, ABOVE, BELOW) </li> </ul> <p>Returns:</p> <p>distance to the wall </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentSensors.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/","title":"Namespace cowboys::base64","text":"<p>Namespace List &gt; cowboys &gt; base64</p> <p>A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x)).</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr char CHARS   = = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/\"The characters used to represent digits in base64 . constexpr std::array&lt; size_t, MAX_CHAR+1 &gt; CHAR_TO_IDX   = =  { std::array&lt;size_t, MAX_CHAR + 1&gt; indices{}; for (size_t i = 0; i &lt; 64; ++i) { indices[CHARS[i]] = i; } return indices; }() constexpr size_t MAX_CHAR   = = *std::max_element(CHARS, CHARS + 64)"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#public-static-functions","title":"Public Static Functions","text":"Type Name std::string B2ToB64 (const std::string &amp; binary) Converts a binary string to a base64 string. std::string B64ToB2 (std::string base64) Converts a base64 string to a binary string. double B64ToDouble (const std::string &amp; value) Converts a base64 string to a double. See DoubleToB64 for precision issues. size_t B64ToULL (std::string num_base64) Converts a number in base64 to base10. std::string DoubleToB64 (double value) Converts a double to a base64 string. Assumes that the stoull(to_string(value)) is possible. Only guarantees that x ~= b64_inv(b64(x)) due to precision errors. Empirically accurate up to 3 decimal places, e.g. round(x, 3) = round(b64_inv(b64(x)), 3). std::string ULLToB64 (size_t ull) Converts a number in base10 to base64 ."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#variable-chars","title":"variable CHARS","text":"<pre><code>constexpr char CHARS[];\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#variable-char_to_idx","title":"variable CHAR_TO_IDX","text":"<pre><code>constexpr std::array&lt;size_t, MAX_CHAR + 1&gt; CHAR_TO_IDX;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#variable-max_char","title":"variable MAX_CHAR","text":"<pre><code>constexpr size_t MAX_CHAR;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-b2tob64","title":"function B2ToB64","text":"<p>Converts a binary string to a base64 string.</p> <pre><code>static std::string cowboys::base64::B2ToB64 (\n    const std::string &amp; binary\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>binary</code> A string of 1s and 0s representing binary. </li> </ul> <p>Returns:</p> <p>The binary string in base64. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-b64tob2","title":"function B64ToB2","text":"<p>Converts a base64 string to a binary string.</p> <pre><code>static std::string cowboys::base64::B64ToB2 (\n    std::string base64\n) \n</code></pre> <p>Parameters:</p> <ul> <li>base64 A string of base64 characters. </li> </ul> <p>Returns:</p> <p>The base64 string in binary. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-b64todouble","title":"function B64ToDouble","text":"<p>Converts a base64 string to a double. See DoubleToB64 for precision issues.</p> <pre><code>static double cowboys::base64::B64ToDouble (\n    const std::string &amp; value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The base64 string to convert. </li> </ul> <p>Returns:</p> <p>The base64 string as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-b64toull","title":"function B64ToULL","text":"<p>Converts a number in base64 to base10.</p> <pre><code>static size_t cowboys::base64::B64ToULL (\n    std::string num_base64\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>num_base64</code> The number in base64 as a string. </li> </ul> <p>Returns:</p> <p>The number in base10. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-doubletob64","title":"function DoubleToB64","text":"<p>Converts a double to a base64 string. Assumes that the stoull(to_string(value)) is possible. Only guarantees that x ~= b64_inv(b64(x)) due to precision errors. Empirically accurate up to 3 decimal places, e.g. round(x, 3) = round(b64_inv(b64(x)), 3).</p> <pre><code>static std::string cowboys::base64::DoubleToB64 (\n    double value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The double to convert. </li> </ul> <p>Returns:</p> <p>The double in base64. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-ulltob64","title":"function ULLToB64","text":"<p>Converts a number in base10 to base64 .</p> <pre><code>static std::string cowboys::base64::ULLToB64 (\n    size_t ull\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ull</code> The number to convert. </li> </ul> <p>Returns:</p> <p>The number in base64 as a string. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Agents <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_425e53e3c77c59c8573ea1fd0ff9622a/","title":"Dir source/Agents","text":"<p>FileList &gt; Agents</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_425e53e3c77c59c8573ea1fd0ff9622a/#directories","title":"Directories","text":"Type Name dir GP <p>The documentation for this class was generated from the following file <code>source/Agents/</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_24320de467b989ce68b31a9ae5cbbd05/","title":"Dir source/Agents/GP","text":"<p>FileList &gt; Agents &gt; GP</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_24320de467b989ce68b31a9ae5cbbd05/#files","title":"Files","text":"Type Name file CGPAgent.hpp file CGPGenotype.hpp file GPAgent.hpp file GPAgentAnalyze.h file GPAgentBase.hpp file GPAgentSensors.hpp file GPAgentsRegisters.hpp file GPTrainingLoop.hpp file Graph.hpp file GraphBuilder.hpp file GraphNode.hpp file LGPAgent.hpp <p>The documentation for this class was generated from the following file <code>source/Agents/GP/</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_agent_8hpp/","title":"File CGPAgent.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; CGPAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"GPAgentBase.hpp\"</code></li> <li><code>#include \"GraphBuilder.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_agent_8hpp/#classes","title":"Classes","text":"Type Name class CGPAgent An agent based on cartesian genetic programming. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_agent_8hpp_source/","title":"File CGPAgent.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; CGPAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;random&gt;\n#include &lt;string&gt;\n\n#include \"GPAgentBase.hpp\"\n#include \"GraphBuilder.hpp\"\n\nnamespace cowboys {\n  constexpr size_t INPUT_SIZE = 9;\n\n  constexpr size_t NUM_LAYERS = 3;\n\n  constexpr size_t NUM_NODES_PER_LAYER = 2;\n\n  constexpr size_t LAYERS_BACK = 2;\n\n  class CGPAgent : public GPAgentBase {\n  protected:\n    CGPGenotype genotype;\n\n    std::unique_ptr&lt;Graph&gt; decision_graph;\n\n\n\n  public:\n    CGPAgent(size_t id, const std::string &amp;name) : GPAgentBase(id, name) {}\n    CGPAgent(size_t id, const std::string &amp;name, const CGPGenotype &amp;genotype)\n        : GPAgentBase(id, name), genotype(genotype) {}\n\n\n    void PrintAgent() override {\n      std::cout &lt;&lt; \"Genotype: \" &lt;&lt; genotype.Export() &lt;&lt; std::endl;\n    }\n\n    void MutateAgent(double mutation = 0.8) override {\n      auto graph_builder = GraphBuilder();\n\n      genotype.MutateDefault(mutation, *this);\n\n      decision_graph = graph_builder.CartesianGraph(genotype, FUNCTION_SET, this);\n    }\n    bool Initialize() override {\n\n      // Create a default genotype if none was provided in the constructor\n      if (genotype.GetNumFunctionalNodes() == 0) {\n        genotype = CGPGenotype({INPUT_SIZE, action_map.size(), NUM_LAYERS, NUM_NODES_PER_LAYER, LAYERS_BACK});\n      }\n\n      // Mutate the beginning genotype, might not want this.\n      MutateAgent(0.2);\n\n      return true;\n    }\n\n    size_t GetAction(const cse491::WorldGrid &amp;grid, const cse491::type_options_t &amp;type_options,\n                     const cse491::item_map_t &amp;item_set, const cse491::agent_map_t &amp;agent_set) override {\n      auto inputs = EncodeState(grid, type_options, item_set, agent_set, this, extra_state);\n      size_t action_to_take = decision_graph-&gt;MakeDecision(inputs, EncodeActions(action_map));\n      return action_to_take;\n    }\n\n    void SerializeGP(tinyxml2::XMLDocument &amp;doc, tinyxml2::XMLElement *parentElem, double fitness = -1) override {\n      auto agentElem = doc.NewElement(\"CGPAgent\");\n      parentElem-&gt;InsertEndChild(agentElem);\n\n      auto genotypeElem = doc.NewElement(\"genotype\");\n      genotypeElem-&gt;SetText(genotype.Export().c_str());\n      if (fitness != -1)\n        genotypeElem-&gt;SetAttribute(\"fitness\", fitness);\n\n      genotypeElem-&gt;SetAttribute(\"seed\" , seed);\n\n      agentElem-&gt;InsertEndChild(genotypeElem);\n\n    }\n\n    std::string Export() override { return genotype.Export(); }\n\n    void Import(const std::string &amp;genotype) override {\n      this-&gt;genotype.Configure(genotype);\n      decision_graph = GraphBuilder().CartesianGraph(this-&gt;genotype, FUNCTION_SET, this);\n    }\n\n    const CGPGenotype &amp;GetGenotype() const { return genotype; }\n\n\n    void Configure(const CGPAgent &amp;other) {\n      genotype = other.GetGenotype();\n      decision_graph = GraphBuilder().CartesianGraph(genotype, FUNCTION_SET, this);\n    }\n\n    void Copy(const GPAgentBase &amp;other) override {\n      assert(dynamic_cast&lt;const CGPAgent *&gt;(&amp;other) != nullptr);\n      Configure(dynamic_cast&lt;const CGPAgent &amp;&gt;(other));\n    }\n\n    double GetComplexity() const {\n      double connection_complexity =\n          static_cast&lt;double&gt;(genotype.GetNumConnections()) / genotype.GetNumPossibleConnections();\n\n      double functional_nodes = genotype.GetNumFunctionalNodes();\n\n      // Just needed some function such that connection_complexity + node_complexity grows as the number of nodes grows, this function makes the increase more gradual.\n      double node_complexity = std::log(functional_nodes) / 5;\n\n      double complexity = connection_complexity + node_complexity;\n      return complexity;\n    }\n  };\n\n} // End of namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_genotype_8hpp/","title":"File CGPGenotype.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; CGPGenotype.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../../core/WorldBase.hpp\"</code></li> <li><code>#include \"GPAgentBase.hpp\"</code></li> <li><code>#include \"GraphNode.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_genotype_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming. namespace base64 A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x))."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_genotype_8hpp/#classes","title":"Classes","text":"Type Name class CGPGenotype Holds all the information that uniquely defines a cartesian graph. struct CGPNodeGene Holds the representation of a cartesian graph node. struct CGPParameters Holds the parameters that define the structure of a cartesian graph. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_genotype_8hpp_source/","title":"File CGPGenotype.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; CGPGenotype.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;ranges&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"../../core/WorldBase.hpp\"\n#include \"GPAgentBase.hpp\"\n#include \"GraphNode.hpp\"\n\nnamespace cowboys {\n\n  constexpr char HEADER_SEP = ',';\n  constexpr char HEADER_END = ';';\n  constexpr char NODE_GENE_SEP = '.';\n  constexpr char NODE_SEP = ':';\n\n  namespace base64 {\n    static constexpr char CHARS[] = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/\";\n    static constexpr size_t MAX_CHAR = *std::max_element(CHARS, CHARS + 64);\n    static constexpr std::array&lt;size_t, MAX_CHAR + 1&gt; CHAR_TO_IDX = []() {\n      std::array&lt;size_t, MAX_CHAR + 1&gt; indices{};\n      for (size_t i = 0; i &lt; 64; ++i) {\n        indices[CHARS[i]] = i;\n      }\n      return indices;\n    }();\n\n    static std::string ULLToB64(size_t ull) {\n      if (ull == 0)\n        return \"0\";\n      // Range of numbers represented by n digits of base b excluding 0: b^(n-1) &lt;= x &lt;= b^n - 1\n      // -&gt; n-1 &lt;= log_b(x) -&gt; n-1 = floor(log_b(x)) -&gt; n = 1 + floor(log_b(x))\n      // Or x + 1 &lt;= b^n -&gt; log_b(x + 1) &lt;= n -&gt; ceil(log_b(x + 1)) = n; But this can cause an overflow when adding 1 to\n      // the max value of size_t\n      size_t n = 1 + std::floor(std::log(ull) / std::log(64));\n      std::string result(n, ' ');\n      for (size_t i = 0; ull &gt; 0; ++i) {\n        result[n - 1 - i] = CHARS[ull % 64];\n        ull /= 64;\n      }\n      return result;\n    }\n\n    static size_t B64ToULL(std::string num_base64) {\n      size_t result = 0;\n      for (size_t i = 0; i &lt; num_base64.size(); ++i) {\n        const char ch = num_base64[i];\n        const size_t coeff = std::pow(64, num_base64.size() - i - 1);\n        result += CHAR_TO_IDX[ch] * coeff;\n      }\n      return result;\n    }\n\n    static std::string B2ToB64(const std::string &amp;binary) {\n      // 2^6 = 64, so we can encode 6 bits at a time\n\n      size_t remainder = binary.size() % 6;\n      if (remainder != 0) {\n        // Pad the binary string with 0s to make it divisible by 6\n        return B2ToB64(std::string(6 - remainder, '0') + binary);\n      }\n\n      std::string result;\n      result.reserve(binary.size() / 6);\n      bool all_zeros = true;\n      for (size_t i = 0; i &lt; binary.size(); i += 6) {\n        std::string buffer = binary.substr(i, 6);\n        size_t ull = std::bitset&lt;6&gt;(buffer).to_ulong();\n        result += CHARS[ull];\n        if (ull != 0)\n          all_zeros = false;\n      }\n      if (all_zeros) // If all 0s, compress to 1 character\n        return std::string(1, CHARS[0]);\n      return result;\n    }\n\n    static std::string B64ToB2(std::string base64) {\n      std::string result = \"\";\n      for (size_t i = 0; i &lt; base64.size(); ++i) {\n        const char ch = base64[i];\n        const size_t ull = CHAR_TO_IDX[ch];\n        result += std::bitset&lt;6&gt;(ull).to_string();\n      }\n      // Remove leading 0s and return result: https://stackoverflow.com/a/31226728/13430191\n      return result.erase(0, std::min(result.find_first_not_of(CHARS[0]), result.size() - 1));\n    }\n\n    static std::string DoubleToB64(double value) {\n      std::string double_str = std::to_string(value);\n\n      // Sign\n      // Store if it is positive or negative using the first base64 character or the second\n      char sign_b64 = CHARS[0];\n      if (value &lt; 0) {\n        sign_b64 = CHARS[1];\n        // Remove the negative sign\n        double_str.erase(0, 1);\n      }\n\n      // Decimal point\n      size_t decimal_loc = std::min(double_str.find('.'), double_str.size());\n      // Remove the decimal point (does nothing if decimal_loc == double_str.size())\n      double_str.erase(decimal_loc, 1);\n      // Location of the decimal from the right end of the string, so that leading 0s that are dropped can be recovered\n      size_t decimal_loc_from_right = double_str.size() - decimal_loc;\n      // Store decimal location using 1 base64 character (arbitrary choice, assumes decimal_loc &lt; 64)\n      char decimal_loc_b64 = CHARS[decimal_loc_from_right];\n\n      // ULL\n      // Take the rest of the string as a ULL\n      size_t ull = std::stoull(double_str);\n      // Convert to base64\n      std::string ull_b64 = ULLToB64(ull);\n      // Return decimal location and ULL\n      return std::string({decimal_loc_b64, sign_b64}) + ull_b64;\n    }\n\n    static double B64ToDouble(const std::string &amp;value) {\n      assert(value.size() &gt; 0);\n      // Get decimal location\n      size_t decimal_loc_from_right = CHAR_TO_IDX[value[0]];\n      // Get sign\n      double sign = value[1] == CHARS[0] ? 1 : -1;\n      // Get ULL\n      std::string ull = std::to_string(B64ToULL(value.substr(2)));\n      if (ull.size() &lt; decimal_loc_from_right)\n        ull = std::string(decimal_loc_from_right - ull.size() + 1, CHARS[0]) + ull;\n      // Insert decimal point\n      ull.insert(ull.size() - decimal_loc_from_right, \".\");\n      // Return double\n      return sign * std::stod(ull);\n    }\n  } // namespace base64\n\n  struct CGPNodeGene {\n    std::vector&lt;char&gt; input_connections{};\n\n    size_t function_idx{0};\n\n    double default_output{0};\n\n    inline bool operator==(const CGPNodeGene &amp;other) const {\n      return input_connections == other.input_connections &amp;&amp; function_idx == other.function_idx &amp;&amp;\n             default_output == other.default_output;\n    }\n  };\n\n  struct CGPParameters {\n    size_t num_inputs{0};\n    size_t num_outputs{0};\n    size_t num_layers{0};\n    size_t num_nodes_per_layer{0};\n    size_t layers_back{0};\n\n    CGPParameters() = default;\n\n    CGPParameters(size_t num_inputs, size_t num_outputs, size_t num_layers, size_t num_nodes_per_layer,\n                  size_t layers_back)\n        : num_inputs(num_inputs), num_outputs(num_outputs), num_layers(num_layers),\n          num_nodes_per_layer(num_nodes_per_layer), layers_back(layers_back) {}\n\n    size_t GetFunctionalNodeCount() const { return num_layers * num_nodes_per_layer + num_outputs; }\n\n    inline bool operator==(const CGPParameters &amp;other) const {\n      return num_inputs == other.num_inputs &amp;&amp; num_outputs == other.num_outputs &amp;&amp; num_layers == other.num_layers &amp;&amp;\n             num_nodes_per_layer == other.num_nodes_per_layer &amp;&amp; layers_back == other.layers_back;\n    }\n  };\n\n  class CGPGenotype {\n  protected:\n    CGPParameters params;\n\n    std::vector&lt;CGPNodeGene&gt; nodes;\n\n  private:\n\n    std::string EncodeHeader() const {\n      std::string header;\n      header += std::to_string(params.num_inputs);\n      header += HEADER_SEP;\n      header += std::to_string(params.num_outputs);\n      header += HEADER_SEP;\n      header += std::to_string(params.num_layers);\n      header += HEADER_SEP;\n      header += std::to_string(params.num_nodes_per_layer);\n      header += HEADER_SEP;\n      header += std::to_string(params.layers_back);\n      return header;\n    }\n\n    void DecodeHeader(const std::string &amp;header) {\n      // Parse header and save to member variables\n      std::vector&lt;size_t&gt; header_parts;\n      size_t start_pos = 0;\n      size_t comma_pos = header.find(HEADER_SEP, start_pos);\n      while (comma_pos != std::string::npos) {\n        header_parts.push_back(std::stoull(header.substr(start_pos, comma_pos - start_pos)));\n        start_pos = comma_pos + 1;\n        comma_pos = header.find(HEADER_SEP, start_pos);\n      }\n      header_parts.push_back(std::stoull(header.substr(start_pos)));\n\n      if (header_parts.size() != 5) {\n        std::string message;\n        message += \"Invalid genotype: Header should have 5 parameters but found \";\n        message += std::to_string(header_parts.size());\n        message += \".\";\n        throw std::runtime_error(message);\n      }\n      params.num_inputs = header_parts.at(0);\n      params.num_outputs = header_parts.at(1);\n      params.num_layers = header_parts.at(2);\n      params.num_nodes_per_layer = header_parts.at(3);\n      params.layers_back = header_parts.at(4);\n    }\n\n    std::string EncodeGenotype() const {\n      std::string genotype = \"\";\n      for (const CGPNodeGene &amp;node : nodes) {\n        // Input Connections\n        genotype += base64::B2ToB64(std::string(node.input_connections.cbegin(), node.input_connections.cend()));\n        genotype += NODE_GENE_SEP;\n        // Function index\n        genotype += base64::ULLToB64(node.function_idx);\n        genotype += NODE_GENE_SEP;\n        // Default output\n        genotype += base64::DoubleToB64(node.default_output);\n        // End of node\n        genotype += NODE_SEP;\n      }\n      return genotype;\n    }\n\n    std::string EncodeGenotypeRaw() const {\n      std::string genotype = \"\";\n      for (const CGPNodeGene &amp;node : nodes) {\n        // Input Connections\n        genotype += std::string(node.input_connections.cbegin(), node.input_connections.cend());\n        genotype += NODE_GENE_SEP;\n        // Function index\n        genotype += std::to_string(node.function_idx);\n        genotype += NODE_GENE_SEP;\n        // Default output\n        genotype += std::to_string(node.default_output);\n        // End of node\n        genotype += NODE_SEP;\n      }\n      return genotype;\n    }\n\n    void DecodeGenotype(const std::string &amp;genotype) {\n      size_t node_gene_start = 0;\n      size_t node_gene_end = genotype.find(NODE_SEP, node_gene_start);\n      size_t node_idx = 0;\n      while (node_gene_end != std::string::npos) {\n        // Parse the node gene\n        std::string node_gene = genotype.substr(node_gene_start, node_gene_end - node_gene_start);\n        assert(node_idx &lt; nodes.size());\n        auto &amp;current_node = nodes[node_idx];\n\n        //\n        // Input Connections\n        //\n        size_t sep_pos = node_gene.find(NODE_GENE_SEP);\n        assert(sep_pos != std::string::npos);\n        std::string input_connections_b64 = node_gene.substr(0, sep_pos);\n        std::string input_connections_b2 = base64::B64ToB2(input_connections_b64);\n        auto &amp;input_connections = current_node.input_connections;\n        // If there were leading bits that were 0 when converted to base 64, they were dropped. Add them back.\n        std::string input_connections_str = std::string(input_connections.cbegin(), input_connections.cend());\n        assert(input_connections.size() &gt;= input_connections_b2.size()); // Invalid genotype if this fails\n        input_connections_b2 =\n            std::string(input_connections.size() - input_connections_b2.size(), '0') + input_connections_b2;\n        assert(input_connections.size() == input_connections_b2.size());\n        for (size_t i = 0; i &lt; input_connections_b2.size(); ++i) {\n          input_connections[i] = input_connections_b2[i];\n        }\n        node_gene = node_gene.substr(sep_pos + 1);\n\n        //\n        // Function index\n        //\n        sep_pos = node_gene.find(NODE_GENE_SEP);\n        std::string function_idx_str = node_gene.substr(0, std::min(sep_pos, node_gene.size()));\n        current_node.function_idx = base64::B64ToULL(function_idx_str);\n        node_gene = node_gene.substr(sep_pos + 1);\n\n        //\n        // Default output\n        //\n        sep_pos = node_gene.find(NODE_GENE_SEP);\n        assert(sep_pos == std::string::npos); // Should be the last attribute\n        std::string default_output_str = node_gene.substr(0, std::min(sep_pos, node_gene.size()));\n        current_node.default_output = base64::B64ToDouble(default_output_str);\n\n        // Move to next node gene\n        node_gene_start = node_gene_end + 1;\n        node_gene_end = genotype.find(NODE_SEP, node_gene_start);\n        ++node_idx;\n      }\n    }\n\n  public:\n    CGPGenotype() = default;\n    CGPGenotype(const CGPParameters &amp;parameters) : params(parameters) { InitGenotype(); }\n\n    // Rule of 5\n    ~CGPGenotype() = default;\n    CGPGenotype(const CGPGenotype &amp;other) { Configure(other.Export()); }\n    CGPGenotype &amp;operator=(const CGPGenotype &amp;other) {\n      Configure(other.Export());\n      return *this;\n    }\n    CGPGenotype(CGPGenotype &amp;&amp;other) noexcept {\n      params = other.params;\n      nodes = std::move(other.nodes);\n    }\n    CGPGenotype &amp;operator=(CGPGenotype &amp;&amp;other) noexcept {\n      params = other.params;\n      nodes = std::move(other.nodes);\n      return *this;\n    }\n\n    CGPGenotype &amp;Configure(const std::string &amp;encoded_genotype) {\n      // Separate header and genotype\n      size_t newline_pos = encoded_genotype.find(HEADER_END);\n      if (newline_pos == std::string::npos)\n        throw std::runtime_error(\"Invalid genotype: No newline character found.\");\n      std::string header = encoded_genotype.substr(0, newline_pos);\n      std::string genotype = encoded_genotype.substr(newline_pos + 1);\n\n      // Parse header and save to member variables\n      DecodeHeader(header);\n\n      // Initialize the genotype\n      InitGenotype();\n\n      // Decode genotype\n      DecodeGenotype(genotype);\n\n      // Check if the number of functional nodes is correct\n      assert(nodes.size() == params.GetFunctionalNodeCount());\n\n      return *this;\n    }\n\n    std::vector&lt;CGPNodeGene&gt;::iterator begin() { return nodes.begin(); }\n\n    std::vector&lt;CGPNodeGene&gt;::iterator end() { return nodes.end(); }\n\n    std::vector&lt;CGPNodeGene&gt;::const_iterator begin() const { return nodes.begin(); }\n\n    std::vector&lt;CGPNodeGene&gt;::const_iterator end() const { return nodes.end(); }\n\n    std::vector&lt;CGPNodeGene&gt;::const_iterator cbegin() const { return nodes.cbegin(); }\n\n    std::vector&lt;CGPNodeGene&gt;::const_iterator cend() const { return nodes.cend(); }\n\n    size_t GetNumPossibleConnections() const {\n      size_t num_connections = 0;\n      for (const CGPNodeGene &amp;node : nodes) {\n        num_connections += node.input_connections.size();\n      }\n      return num_connections;\n    }\n\n    size_t GetNumConnections() const {\n      size_t num_connections = 0;\n      for (const CGPNodeGene &amp;node : nodes) {\n        for (char con : node.input_connections) {\n          if (con == '1')\n            ++num_connections;\n        }\n      }\n      return num_connections;\n    }\n\n    void SetParameters(const CGPParameters &amp;params) { this-&gt;params = params; }\n\n    size_t GetNumInputs() const { return params.num_inputs; }\n\n    size_t GetNumOutputs() const { return params.num_outputs; }\n\n    size_t GetNumLayers() const { return params.num_layers; }\n\n    size_t GetNumNodesPerLayer() const { return params.num_nodes_per_layer; }\n\n    size_t GetLayersBack() const { return params.layers_back; }\n\n    size_t GetNumFunctionalNodes() const { return nodes.size(); }\n\n    bool HasInputConnections() const {\n      for (auto it = begin(); it != end(); ++it) {\n        if (std::any_of(it-&gt;input_connections.begin(), it-&gt;input_connections.end(), [](char c) { return c != '0'; }))\n          return true;\n      }\n      return false;\n    }\n\n    void InitGenotype() {\n      // Clear node configurations\n      nodes.clear();\n\n      // Input nodes won't have any inputs and no function, so they are skipped\n\n      // Start at 1 to account for the input layer\n      for (size_t i = 1; i &lt;= params.num_layers + 1; ++i) {\n        size_t layer_size = i == params.num_layers + 1 ? params.num_outputs : params.num_nodes_per_layer;\n        for (size_t j = 0; j &lt; layer_size; ++j) {\n          // Count up possible input connections from each layer backwards\n          size_t valid_layers_back = std::min(params.layers_back, i);\n          size_t num_input_connections = valid_layers_back * params.num_nodes_per_layer;\n          if (i &lt;= params.layers_back) {\n            num_input_connections -= params.num_nodes_per_layer;\n            num_input_connections += params.num_inputs;\n          }\n          // Create node gene using empty connections\n          std::vector&lt;char&gt; input_connections(num_input_connections, '0');\n          // Add the node configuration. With default values\n          nodes.push_back({input_connections});\n        }\n      }\n    }\n\n    std::string Export() const {\n      std::string header = EncodeHeader();\n      std::string genotype = EncodeGenotype();\n      return header + HEADER_END + genotype;\n    }\n\n    std::string ExportRaw() const {\n      std::string header = EncodeHeader();\n      std::string genotype = EncodeGenotypeRaw();\n      return header + HEADER_END + genotype;\n    }\n\n    CGPGenotype &amp;Mutate(double mutation_rate, GPAgentBase &amp;agent, std::function&lt;void(CGPNodeGene &amp;)&gt; mutation) {\n      assert(mutation_rate &gt;= 0.0 &amp;&amp; mutation_rate &lt;= 1.0);\n      for (CGPNodeGene &amp;node : nodes)\n        if (agent.GetRandom() &lt; mutation_rate)\n          mutation(node);\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateConnections(double mutation_rate, GPAgentBase &amp;agent) {\n      std::uniform_int_distribution&lt;size_t&gt; dist(0, 1);\n      Mutate(mutation_rate, agent, [&amp;agent](CGPNodeGene &amp;node) {\n        for (char &amp;con : node.input_connections) {\n          con = agent.GetRandomULL(2) == 0 ? '0' : '1';\n        }\n      });\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateFunctions(double mutation_rate, size_t num_functions, GPAgentBase &amp;agent) {\n      Mutate(mutation_rate, agent,\n             [num_functions, &amp;agent](CGPNodeGene &amp;node) { node.function_idx = agent.GetRandomULL(num_functions); });\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateOutputs(double mutation_rate, double mean, double std, GPAgentBase &amp;agent,\n                               bool additive = true) {\n      Mutate(mutation_rate, agent, [mean, std, &amp;agent, additive](CGPNodeGene &amp;node) {\n        double mutation = agent.GetRandomNormal(mean, std);\n        if (additive) {\n          node.default_output += mutation;\n          // Clamp to prevent overflow during genotype export\n          double min = std::numeric_limits&lt;double&gt;::lowest();\n          double max = std::numeric_limits&lt;double&gt;::max();\n          // Wrap random double in stod(to_string(.)) to reliably export and import genotype from string.\n          node.default_output = std::stod(std::to_string(std::clamp(node.default_output, min, max)));\n        } else {\n          node.default_output = std::stod(std::to_string(mutation));\n        }\n      });\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateHeader(double mutation_rate, GPAgentBase &amp;agent) {\n\n      // Must expand the genotype in a way so that the behavior is preserved\n\n      // Can mutate number of inputs and outputs to adapt to changing state and action spaces, but not doing it for\n      // now\n\n      // Mutate layers back\n      if (agent.GetRandom() &lt; mutation_rate) {\n        // Update params\n        params.layers_back += 1;\n        // Add empty connections to each node at the front\n        // Start at 1 to account for the input layer\n        for (size_t i = 1; i &lt;= params.num_layers + 1; ++i) {\n          size_t layer_size = i == params.num_layers + 1 ? params.num_outputs : params.num_nodes_per_layer;\n          for (size_t j = 0; j &lt; layer_size; ++j) {\n\n            // Get the old number of input connections\n            auto &amp;curr_connections = nodes[(i - 1) * params.num_nodes_per_layer + j].input_connections;\n            size_t old_num_input_connections = curr_connections.size();\n\n            // Get the new number of input connections\n            size_t valid_layers_back = std::min(params.layers_back, i);\n            size_t num_input_connections = valid_layers_back * params.num_nodes_per_layer;\n            if (i &lt;= params.layers_back) {\n              num_input_connections -= params.num_nodes_per_layer;\n              num_input_connections += params.num_inputs;\n            }\n\n            // Push empty connections to the front of the vector of input connections\n            size_t num_needed = num_input_connections - old_num_input_connections;\n            if (num_needed &gt; 0) {\n              // Create empty connections\n              std::vector&lt;char&gt; input_connections(num_needed, '0');\n              // Insert the empty connections into the front of the vector\n              curr_connections.insert(curr_connections.cbegin(), input_connections.cbegin(), input_connections.cend());\n            }\n          }\n        }\n      }\n\n      // Mutate number of nodes in each layer\n      if (agent.GetRandom() &lt; mutation_rate) {\n        // Add a node to each middle layer and update connections for middle and output layers\n        std::vector&lt;CGPNodeGene&gt; new_nodes;\n        for (size_t i = 1; i &lt;= params.num_layers + 1; ++i) {\n          // Add the nodes in this layer to the new node vector\n          size_t layer_start = (i - 1) * params.num_nodes_per_layer;\n          size_t layer_size = i == params.num_layers + 1 ? params.num_outputs : params.num_nodes_per_layer;\n          size_t layer_end = layer_start + layer_size;\n          size_t valid_layers_back = std::min(params.layers_back, i);\n\n          // Get the number of connections for the new node\n          size_t new_num_connections = valid_layers_back * (params.num_nodes_per_layer + 1);\n          if (i &lt;= params.layers_back) {\n            new_num_connections -= params.num_nodes_per_layer + 1;\n            new_num_connections += params.num_inputs;\n          }\n          size_t num_needed = new_num_connections - nodes[layer_start].input_connections.size();\n          new_nodes.insert(new_nodes.cend(), nodes.cbegin() + layer_start, nodes.cbegin() + layer_end);\n\n          // For middle layers, add a new node\n          if (i != params.num_layers + 1) {\n            auto newNode = std::vector&lt;char&gt;(new_num_connections, '0');\n            new_nodes.push_back({newNode});\n          }\n\n          // Add the extra connections for each node in this layer\n          if (i == 1)\n            // First layer doesn't have any connections to add because the input layer is unchanged\n            continue;\n\n          size_t new_layer_start = (i - 1) * (params.num_nodes_per_layer + 1);\n          for (size_t j = 0; j &lt; layer_size; ++j) {\n            // Add an empty connection at the end of each layer of connections in the valid layers back\n            assert(new_layer_start + j &lt; new_nodes.size());\n            auto &amp;connections = new_nodes[new_layer_start + j].input_connections;\n            // Only iterate over the valid layers back that are middle layers, not including the input layer\n            for (size_t k = 0; k &lt; num_needed; ++k) {\n              // Insert in reverse order to keep indices correct\n              size_t insert_pos = params.num_nodes_per_layer * (num_needed - k);\n              connections.insert(connections.cbegin() + insert_pos, '0');\n              assert(*(connections.cbegin() + insert_pos) == '0');\n            }\n          }\n        }\n        // Update params\n        params.num_nodes_per_layer += 1;\n        nodes = std::move(new_nodes);\n        // Check if everything is correct\n        assert(nodes.size() == params.GetFunctionalNodeCount());\n        for (size_t i = 1; i &lt; params.num_layers + 1; ++i) {\n          [[maybe_unused]] size_t layer_start = (i - 1) * params.num_nodes_per_layer;\n          size_t layer_size = i == params.num_layers + 1 ? params.num_outputs : params.num_nodes_per_layer;\n          size_t valid_layers_back = std::min(params.layers_back, i);\n          for (size_t j = 0; j &lt; layer_size; ++j) {\n            // Check that the number of connections is correct\n            [[maybe_unused]] size_t num_connections =\n              valid_layers_back * params.num_nodes_per_layer;\n            if (i &lt;= params.layers_back) {\n              num_connections -= params.num_nodes_per_layer;\n              num_connections += params.num_inputs;\n            }\n            assert(nodes[layer_start + j].input_connections.size() == num_connections);\n          }\n        }\n      }\n\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateDefault(double mutation_rate, GPAgentBase &amp;agent, size_t num_functions = FUNCTION_SET.size()) {\n      MutateHeader(mutation_rate, agent);\n      MutateConnections(mutation_rate, agent);\n      MutateFunctions(mutation_rate, num_functions, agent);\n      MutateOutputs(mutation_rate, 0, 1, agent);\n      return *this;\n    }\n\n    inline bool operator==(const CGPGenotype &amp;other) const {\n      if (params != other.params) // Compare CGPParameters for equality\n        return false;\n      if (nodes.size() != other.nodes.size()) // # of genes should be equal\n        return false;\n      bool all_same = true;\n      for (auto it = cbegin(), it2 = other.cbegin(); it != cend(); ++it, ++it2) {\n        all_same = all_same &amp;&amp; (*it == *it2); // Compare CGPNodeGenes for equality\n      }\n      return all_same;\n    }\n\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const CGPGenotype &amp;genotype) {\n      os &lt;&lt; genotype.ExportRaw();\n      return os;\n    }\n  };\n} // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_8hpp/","title":"File GPAgent.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"./GPAgentSensors.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_8hpp/#classes","title":"Classes","text":"Type Name class GPAgent <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_8hpp_source/","title":"File GPAgent.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;random&gt;\n#include &lt;string&gt;\n\n#include \"../../core/AgentBase.hpp\"\n#include \"./GPAgentSensors.hpp\"\n\nnamespace cowboys {\n\nclass GPAgent : public cse491::AgentBase {\n protected:\n  const std::vector&lt;std::string&gt; predefinedMovement = {\n      \"down\",  \"down\",  \"down\",  \"down\",  \"right\", \"right\", \"up\",    \"up\",\n      \"up\",    \"up\",    \"right\", \"right\", \"right\", \"right\", \"right\", \"right\",\n      \"right\", \"right\", \"right\", \"right\", \"right\", \"left\",  \"left\",  \"left\"};\n\n  size_t movementIndex = 0;  \n\n public:\n  GPAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    std::uniform_int_distribution&lt;int&gt; dist(\n        0,\n        3);  // size of the random set to 3 as we only have 4 actions initally\n  }\n  ~GPAgent() override = default;\n\n  bool Initialize() override { return true; }\n\n  size_t SelectAction(\n      [[maybe_unused]] const cse491::WorldGrid &amp;grid,\n      [[maybe_unused]] const cse491::type_options_t &amp;type_options,\n      [[maybe_unused]] const cse491::item_map_t &amp;item_map,\n      [[maybe_unused]] const cse491::agent_map_t &amp;agent_map) override {\n    if (movementIndex &gt;= predefinedMovement.size()) {\n      return 0;  // do nothing if it is out of bound for defined movement\n    }\n\n    Sensors::wallDistance(grid, *this, SensorDirection::LEFT);\n    Sensors::wallDistance(grid, *this, SensorDirection::RIGHT);\n    Sensors::wallDistance(grid, *this, SensorDirection::ABOVE);\n    Sensors::wallDistance(grid, *this, SensorDirection::BELOW);\n\n    auto action = action_map[predefinedMovement[movementIndex++]];\n    return action;\n  }\n};\n\n}  // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_analyze_8h/","title":"File GPAgentAnalyze.h","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgentAnalyze.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_analyze_8h/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_analyze_8h/#classes","title":"Classes","text":"Type Name class GPAgentAnalyzer <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentAnalyze.h</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_analyze_8h_source/","title":"File GPAgentAnalyze.h","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgentAnalyze.h</p> <p>Go to the documentation of this file</p> <pre><code>\n//\n// A class that analyzes the data of the best agent in the GP algorithm\n// and saves it to a csv file\n//\n\n#pragma once\n\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nnamespace cowboys {\n\n    class GPAgentAnalyzer {\n    private:\n        std::vector&lt;double&gt; average_fitness;\n\n        std::vector&lt;double&gt; max_fitness;\n\n        std::vector&lt;double&gt; elite_score;\n\n        std::vector&lt;double&gt; average_score;\n\n        std::vector&lt;double&gt; max_agents;\n\n    public:\n        GPAgentAnalyzer() = default;\n\n        ~GPAgentAnalyzer() = default;\n\n        void addAverageFitness(double fitness) {\n            average_fitness.push_back(fitness);\n        }\n\n        void addMaxFitness(double fitness) {\n            max_fitness.push_back(fitness);\n        }\n\n        void addEliteScore(double score) {\n            elite_score.push_back(score);\n        }\n\n        void addAverageScore(double score) {\n            average_score.push_back(score);\n        }\n\n        void addNumAgentsWithMaxFitness(double num_agents) {\n            max_agents.push_back(num_agents);\n        }\n\n        void saveToFile() {\n            // create a new file\n            std::ofstream file(\"gp_agent_analyzer.csv\");\n\n            // write the data to the file\n            file &lt;&lt; \"average_fitness,max_fitness,average_elite_score,best_agent_weighted_score,agents_with_max_fitness\\n\";\n\n            for (size_t i = 0; i &lt; average_fitness.size(); i++) {\n                file &lt;&lt; average_fitness[i] &lt;&lt; \",\" &lt;&lt; max_fitness[i] &lt;&lt; \",\" &lt;&lt; elite_score[i] &lt;&lt; \",\" &lt;&lt; average_score[i] &lt;&lt; \",\" &lt;&lt; max_agents[i] &lt;&lt; \"\\n\";\n            }\n            std::cout &lt;&lt; \"Saved GP Agent Analyzer data to gp_agent_analyzer.csv\" &lt;&lt; std::endl;\n\n            // close the file\n            file.close();\n        }\n    };\n\n}  // namespace cowboys\n\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_base_8hpp/","title":"File GPAgentBase.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgentBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"tinyxml2.h\"</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_base_8hpp/#classes","title":"Classes","text":"Type Name class GPAgentBase <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentBase.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_base_8hpp_source/","title":"File GPAgentBase.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgentBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\n#include \"tinyxml2.h\"\n\n#include \"../../core/AgentBase.hpp\"\n\nnamespace cowboys {\n  class GPAgentBase : public cse491::AgentBase {\n  protected:\n    std::unordered_map&lt;std::string, double&gt; extra_state; \n    unsigned int seed = 0;                               \n    std::mt19937 rng{seed};                              \n    std::uniform_real_distribution&lt;double&gt; uni_dist;     \n    std::normal_distribution&lt;double&gt; norm_dist;          \n\n  public:\n    GPAgentBase(size_t id, const std::string &amp;name) : AgentBase(id, name) {\n      Reset();\n    }\n    ~GPAgentBase() = default;\n\n    bool Initialize() override { return true; }\n\n    size_t SelectAction(const cse491::WorldGrid &amp;grid, const cse491::type_options_t &amp;type_options,\n                        const cse491::item_map_t &amp;item_set, const cse491::agent_map_t &amp;agent_set) override {\n      // Update extra state information before action\n      if (extra_state[\"starting_x\"] == std::numeric_limits&lt;double&gt;::max()) {\n        auto pos = GetPosition();\n        extra_state[\"starting_x\"] = pos.GetX();\n        extra_state[\"starting_y\"] = pos.GetY();\n      }\n\n      size_t action = GetAction(grid, type_options, item_set, agent_set);\n\n      // Update extra state information after action\n      extra_state[\"previous_action\"] = action;\n\n      return action;\n    }\n\n    virtual size_t GetAction(const cse491::WorldGrid &amp;grid, const cse491::type_options_t &amp;type_options,\n                             const cse491::item_map_t &amp;item_set, const cse491::agent_map_t &amp;agent_set) = 0;\n\n    const std::unordered_map&lt;std::string, double&gt; GetExtraState() const { return extra_state; }\n\n    virtual void MutateAgent(double mutation_rate = 0.8) = 0;\n\n    virtual void Copy(const GPAgentBase &amp;other) = 0;\n\n    virtual void PrintAgent(){\n\n    };\n\n    virtual void SerializeGP(tinyxml2::XMLDocument &amp;doc, tinyxml2::XMLElement *parentElem, double fitness = -1) = 0;\n\n    virtual std::string Export() { return \"\"; }\n\n    virtual void Reset(bool /*hard*/ = false) {\n      extra_state[\"previous_action\"] = 0;\n      extra_state[\"starting_x\"] = std::numeric_limits&lt;double&gt;::max();\n      extra_state[\"starting_y\"] = std::numeric_limits&lt;double&gt;::max();\n    };\n\n    //    virtual void crossover(const GPAgentBase &amp;other) {};\n    virtual void Import(const std::string &amp;genotype) = 0;\n\n    // -- Random Number Generation --\n\n    void SetSeed(unsigned int seed) {\n      this-&gt;seed = seed;\n      rng.seed(seed);\n    }\n\n    unsigned int GetSeed() const { return seed; }\n\n    double GetRandom() { return uni_dist(rng); }\n\n    double GetRandom(double max) { return GetRandom() * max; }\n\n    double GetRandom(double min, double max) {\n      assert(max &gt; min);\n      return min + GetRandom(max - min);\n    }\n\n    size_t GetRandomULL(size_t max) { return static_cast&lt;size_t&gt;(GetRandom(max)); }\n\n    double GetRandomNormal() { return norm_dist(rng); }\n\n    double GetRandomNormal(double mean, double sd = 1.0) {\n      assert(sd &gt; 0);\n      return mean + norm_dist(rng) * sd;\n    }\n  };\n\n} // End of namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_sensors_8hpp/","title":"File GPAgentSensors.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgentSensors.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../core/WorldGrid.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_sensors_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_sensors_8hpp/#classes","title":"Classes","text":"Type Name class Sensors <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentSensors.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_sensors_8hpp_source/","title":"File GPAgentSensors.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgentSensors.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../../core/WorldGrid.hpp\"\n\n// #define DEBUG\n\nnamespace cowboys {\n\nstatic constexpr int WALL =\n    2;  // TODO: work with world teams to better define impenetrable objects\n// FIXME: Group 1 has made a class that can check if a position is penetrable\n// or not. We This will be used instead\n\nenum SensorDirection { LEFT, RIGHT, ABOVE, BELOW };\n\nclass Sensors {\n private:\n  [[maybe_unused]] static void debugPosition(const std::string &amp;/*printstring*/) {\n#ifndef NDEBUG\n//    std::cout &lt;&lt; printstring &lt;&lt; std::endl;\n#endif\n  }\n\n public:\n  Sensors() = default;\n\n  ~Sensors() = default;\n\n  static int wallDistance(const cse491::WorldGrid &amp;grid,\n                          const cse491::AgentBase &amp;agent,\n                          SensorDirection direction) {\n    int distance = 0;\n    cse491::GridPosition position = agent.GetPosition();\n\n    while (grid.IsValid(position) &amp;&amp; grid.At(position) != WALL) {\n      if (direction == LEFT) {\n        position = position.ToLeft();\n      } else if (direction == RIGHT) {\n        position = position.ToRight();\n      } else if (direction == ABOVE) {\n        position = position.Above();\n      } else if (direction == BELOW) {\n        position = position.Below();\n      }\n      distance++;\n    }\n\n    std::string directionStr;\n    if (direction == LEFT) {\n      directionStr = \"left\";\n    } else if (direction == RIGHT) {\n      directionStr = \"right\";\n    } else if (direction == ABOVE) {\n      directionStr = \"top\";\n    } else if (direction == BELOW) {\n      directionStr = \"bottom\";\n    }\n\n    debugPosition(directionStr +\n                  \" distance to the wall:  \" + std::to_string(distance - 1));\n\n    return distance - 1;\n  }\n\n  // make a function that takes in a string and maps the SensorDirectionEnum\n  static SensorDirection getSensorDirectionEnum(const std::string &amp;direction) {\n    if (direction == \"getLeft\") {\n      return SensorDirection::LEFT;\n    } else if (direction == \"getRight\") {\n      return SensorDirection::RIGHT;\n    } else if (direction == \"getUp\") {\n      return SensorDirection::ABOVE;\n    } else if (direction == \"getDown\") {\n      return SensorDirection::BELOW;\n    }\n\n    throw std::invalid_argument(\"Invalid direction\");\n    return SensorDirection::LEFT;\n  }\n};\n}  // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agents_registers_8hpp/","title":"File GPAgentsRegisters.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgentsRegisters.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;assert.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agents_registers_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agents_registers_8hpp/#classes","title":"Classes","text":"Type Name class GPAgentRegisters Class to hold the registers of the agent. class iterator Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentsRegisters.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agents_registers_8hpp_source/","title":"File GPAgentsRegisters.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgentsRegisters.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n// #include &lt;array&gt;\n#include &lt;assert.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nnamespace cowboys {\n\nclass GPAgentRegisters {\n private:\n  std::vector&lt;size_t&gt; registers;\n\n\n public:\n  GPAgentRegisters(int numRegisters = 16) : registers(numRegisters) {}\n  ~GPAgentRegisters() = default;\n\n  bool setRegister(size_t index, size_t value) {\n    if (index &gt;= registers.size()) {\n      assert(index &gt;= registers.size());\n      return false;\n    }\n\n    registers[index] = value;\n    return true;\n  }\n\n  std::optional&lt;size_t&gt; getRegister(size_t index) {\n    if (index &gt;= registers.size()) {\n      return std::nullopt;  // Indicates that the value is absent\n    }\n    return registers[index];\n  }\n\n  size_t getNumRegisters() { return registers.size(); }\n\n  size_t size() { return registers.size(); }\n\n  class iterator {\n   private:\n    size_t index;\n\n    GPAgentRegisters &amp;registers;\n\n   public:\n    iterator(size_t index, GPAgentRegisters &amp;regs)\n        : index(index), registers(regs) {}\n\n    size_t &amp;operator*() { return registers.registers[index]; }\n\n    iterator &amp;operator++() {\n      ++index;\n      return *this;\n    }\n\n    bool operator==(const iterator &amp;other) const {\n      return index == other.index;\n    }\n\n    bool operator!=(const iterator &amp;other) const {\n      return index != other.index;\n    }\n  };\n\n  // Begin iterator\n  iterator begin() { return iterator(0, *this); }\n\n  // End iterator\n  iterator end() { return iterator(size(), *this); }\n};\n\n}  // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_training_loop_8hpp/","title":"File GPTrainingLoop.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPTrainingLoop.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"../../core/WorldBase.hpp\"</code></li> <li><code>#include \"GPAgentBase.hpp\"</code></li> <li><code>#include \"CGPAgent.hpp\"</code></li> <li><code>#include \"LGPAgent.hpp\"</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"tinyxml2.h\"</code></li> <li><code>#include \"GPAgentAnalyze.h\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_training_loop_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_training_loop_8hpp/#classes","title":"Classes","text":"Type Name class GPTrainingLoop &lt;class AgentType, class EnvironmentType&gt; struct SaveDataParams <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPTrainingLoop.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_training_loop_8hpp_source/","title":"File GPTrainingLoop.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPTrainingLoop.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../../core/AgentBase.hpp\"\n#include \"../../core/WorldBase.hpp\"\n//#include \"GPAgent.hpp\"\n#include \"GPAgentBase.hpp\"\n\n\n#include \"CGPAgent.hpp\"\n#include \"LGPAgent.hpp\"\n\n#include &lt;thread&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;ranges&gt;\n#include &lt;cmath&gt;\n#include &lt;filesystem&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n\n\n#include \"tinyxml2.h\"\n#include \"GPAgentAnalyze.h\"\n\n\nnamespace cowboys {\n\n    constexpr unsigned int TRAINING_SEED = 0; \n\n    template&lt;class AgentType, class EnvironmentType&gt;\n    class GPTrainingLoop {\n    private:\n\n        std::vector&lt;std::unique_ptr&lt;cse491::WorldBase&gt;&gt; environments;\n        std::vector&lt;std::vector&lt;cowboys::GPAgentBase *&gt;&gt; agents;\n        std::vector&lt;std::vector&lt;double&gt;&gt; TEMPAgentFitness;\n\n        GPAgentAnalyzer analyzer;\n\n        tinyxml2::XMLDocument topAgentsDoc;\n        tinyxml2::XMLDocument lastGenerationsTopAgentsDoc; // &lt;- Saves the last 5 generations\n        tinyxml2::XMLDocument allOfLastGeneration;\n        tinyxml2::XMLDocument metaData;\n\n\n        tinyxml2::XMLElement *rootTopAllGenerations = topAgentsDoc.NewElement(\"GPLoopTopOfAllGeneration\");\n        tinyxml2::XMLElement *rootTopLastGenerations = lastGenerationsTopAgentsDoc.NewElement(\"GPLoopLastNGeneration\");\n        tinyxml2::XMLElement *rootAllOfLastGeneration = allOfLastGeneration.NewElement(\"GPLoopAllOfLastGeneration\");\n        tinyxml2::XMLElement *rootMetaData = metaData.NewElement(\"GPLoopMetaData\");\n\n\n        std::vector&lt;std::pair&lt;int, int&gt;&gt; sortedAgents = std::vector&lt;std::pair&lt;int, int&gt;&gt;();\n\n        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,0), cse491::GridPosition(22,5) , cse491::GridPosition(22,1) , cse491::GridPosition(0,8), cse491::GridPosition(22,8)};\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,0), cse491::GridPosition(22,5) };\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(22,5) };\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,0)};\n\n\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,2), cse491::GridPosition(49,2) , cse491::GridPosition(49,19) , cse491::GridPosition(4,19), cse491::GridPosition(28,10)};\n\n\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,0), cse491::GridPosition(50,0) , cse491::GridPosition(0,28) , cse491::GridPosition(50,28)};\n\n        std::vector&lt;std::vector&lt;std::vector&lt;cse491::GridPosition&gt;&gt;&gt; endPositions = std::vector&lt;std::vector&lt;std::vector&lt;cse491::GridPosition&gt;&gt;&gt;();\n        std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt; independentAgentFitness = std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;();\n\n        int global_max_threads = std::thread::hardware_concurrency();\n        int rollingRandomSeed = 0;\n\n        double ELITE_POPULATION_PERCENT = 0.1;\n        double UNFIT_POPULATION_PERCENT = 0.2;\n\n    public:\n        bool ScavengerQueuing = false;\n\n        GPTrainingLoop(const bool scavengerQueuing = false) : ScavengerQueuing(scavengerQueuing) {\n\n          topAgentsDoc.InsertFirstChild(rootTopAllGenerations);\n\n          rootMetaData = metaData.NewElement(\"GPLoopMetaData\");\n          metaData.InsertFirstChild(rootMetaData);\n          srand(TRAINING_SEED);\n          ResetMainTagLastGenerations();\n        }\n\n        void ResetMainTagLastGenerations() {\n          rootTopLastGenerations = lastGenerationsTopAgentsDoc.NewElement(\"GPLoop\");\n          lastGenerationsTopAgentsDoc.InsertFirstChild(rootTopLastGenerations);\n\n          rootAllOfLastGeneration = allOfLastGeneration.NewElement(\"GPLoopAllOfLastGeneration\");\n          allOfLastGeneration.InsertFirstChild(rootAllOfLastGeneration);\n        }\n\n        void Initialize(size_t numArenas = 5, size_t NumAgentsForArena = 100) {\n\n          unsigned int seed = TRAINING_SEED;\n          if (seed == 0) {\n            seed = std::random_device()();\n          }\n          std::cout &lt;&lt; \"Using seed: \" &lt;&lt; seed &lt;&lt; std::endl;\n\n\n          for (size_t i = 0; i &lt; numArenas; ++i) {\n            // instantiate a new environment\n            environments.emplace_back(std::make_unique&lt;EnvironmentType&gt;(seed));\n\n\n            agents.push_back(std::vector&lt;cowboys::GPAgentBase *&gt;());\n\n            endPositions.push_back(std::vector&lt;std::vector&lt;cse491::GridPosition&gt;&gt;());\n            independentAgentFitness.push_back(std::vector&lt;std::vector&lt;double&gt;&gt;());\n\n            for (size_t j = 0; j &lt; NumAgentsForArena; ++j) {\n\n              endPositions[i].push_back(std::vector&lt;cse491::GridPosition&gt;());\n              independentAgentFitness[i].push_back(std::vector&lt;double&gt;());\n\n              for (size_t k = 0; k &lt; STARTPOSITIONS.size(); ++k) {\n                endPositions[i][j].push_back(cse491::GridPosition(0, 0));\n                independentAgentFitness[i][j].push_back(0);\n              }\n\n              cowboys::GPAgentBase &amp;addedAgent = static_cast&lt;cowboys::GPAgentBase &amp;&gt;(environments[i]-&gt;template AddAgent&lt;AgentType&gt;(\n                      \"Agent \" + std::to_string(j)));\n              addedAgent.SetPosition(0, 0);\n              addedAgent.SetSeed(seed);\n\n              agents[i].emplace_back(&amp;addedAgent);\n\n            }\n\n          }\n\n          loadLastGeneration();\n\n          Printgrid(STARTPOSITIONS);\n\n\n          const size_t numAgents = numArenas * NumAgentsForArena;\n\n          std::stringstream ss;\n          // ss.imbue(std::locale(\"\"));\n          ss &lt;&lt; std::fixed &lt;&lt; numAgents;\n\n          std::cout &lt;&lt; \"number of agents \" &lt;&lt; std::fixed &lt;&lt; ss.str() &lt;&lt; std::endl;\n\n        }\n\n\n        void loadLastGeneration() {\n          if (ScavengerQueuing)\n          {\n\n            auto lastFile = FullLoadGrabLatestGeneration();\n\n            if (lastFile == \"NOTTAFILE\")\n            {\n              std::cout &lt;&lt; \"No last file found\" &lt;&lt; std::endl;\n              return;\n            }\n\n            allOfLastGeneration.LoadFile(lastFile.string().c_str());\n            rootAllOfLastGeneration = allOfLastGeneration.FirstChildElement(\"GPLoopAllOfLastGeneration\");\n\n            std::cout &lt;&lt; \"Loaded last file\" &lt;&lt; std::endl;\n\n//            if (auto agentType = dynamic_cast&lt;CGPAgent *&gt;(&amp;agents[0][0])) {\n//              std::cout &lt;&lt; \"Agent Type is CGPAgent\" &lt;&lt; std::endl;\n//              agentType-&gt;Import(lastFile.string());\n//            }\n//            else if (auto agentType = dynamic_cast&lt;LGPAgent *&gt;(&amp;agents[0][0])) {\n//              std::cout &lt;&lt; \"Agent Type is LGPAgent\" &lt;&lt; std::endl;\n//              agentType-&gt;Import(lastFile.string());\n//            }\n//            else {\n//              std::cout &lt;&lt; \"Agent Type is not CGPAgent or LGPAgent\" &lt;&lt; std::endl;\n//            }\n//              use typetraits to check the type of the agent\n            if (std::is_same&lt;AgentType, CGPAgent&gt;::value) {\n              std::cout &lt;&lt; \"Agent Type is CGPAgent\" &lt;&lt; std::endl;\n            }\n            else if (std::is_same&lt;AgentType, LGPAgent&gt;::value) {\n              std::cout &lt;&lt; \"Agent Type is LGPAgent\" &lt;&lt; std::endl;\n              assert(false); //TODO: Agent not implemented for import\n            }\n            else {\n              std::cout &lt;&lt; \"Agent Type is not CGPAgent or LGPAgent\" &lt;&lt; std::endl;\n            }\n\n\n            auto *latestGenerationElem = rootAllOfLastGeneration-&gt;FirstChildElement();\n            std::cout &lt;&lt; latestGenerationElem-&gt;Name() &lt;&lt; std::endl;\n            auto *agentElem = latestGenerationElem-&gt;FirstChildElement();\n            tinyxml2::XMLElement* generationElem = nullptr;\n\n            std::cout &lt;&lt; agentElem-&gt;Name() &lt;&lt; std::endl;\n            size_t numArenas = agents.size();\n            size_t NumAgentsForArena = agents.at(0).size();\n            for (size_t i = 0; i &lt; numArenas; ++i) {\n              for (size_t j = 0; j &lt; NumAgentsForArena; ++j) {\n\n                generationElem = agentElem-&gt;FirstChildElement();\n                const char *genotypeData = generationElem-&gt;GetText();\n                agents.at(i).at(j)-&gt;Import(genotypeData);\n                agentElem = agentElem-&gt;NextSiblingElement();\n              }\n            }\n\n            std::cout &lt;&lt; \"Agents LoadComplete\" &lt;&lt; std::endl;\n\n          }\n        }\n\n        std::filesystem::path FullLoadGrabLatestGeneration() {\n          std::filesystem::path normalizedAbsolutePath = getSystemPath();\n\n          std::string lastGenerationsPrefix = \"allAgentData_\";\n          std::string lastGenerationsFilenameExtension = \".xml\";\n\n          std::vector&lt;std::filesystem::path&gt; matchingFiles;\n          for (const auto &amp; entry : std::filesystem::directory_iterator(normalizedAbsolutePath))\n          {\n            if (entry.path().extension() == lastGenerationsFilenameExtension &amp;&amp; entry.path().filename().string().find(lastGenerationsPrefix) != std::string::npos)\n            {\n              matchingFiles.push_back(entry.path());\n            }\n          }\n          std::sort(matchingFiles.begin(), matchingFiles.end());\n\n          if (matchingFiles.empty())\n          {\n            return \"NOTTAFILE\";\n          }\n\n          std::filesystem::path lastFile = matchingFiles.back();\n\n          std::cout &lt;&lt; \"Last File: \" &lt;&lt; lastFile &lt;&lt; std::endl;\n\n          return lastFile;\n        }\n\n\n        double SimpleFitnessFunction(cse491::AgentBase &amp;agent, cse491::GridPosition startPosition) {\n          double fitness = 0;\n\n          // Euclidean distance\n          cse491::GridPosition currentPosition = agent.GetPosition();\n          double distance = std::sqrt(std::pow(currentPosition.GetX() - startPosition.GetX(), 2) +\n                                      std::pow(currentPosition.GetY() - startPosition.GetY(), 2));\n\n          double score = distance;\n\n          fitness += score;\n\n          // Agent complexity, temporarily doing this in a bad way\n          if (auto *cgp = dynamic_cast&lt;CGPAgent *&gt;(&amp;agent)) {\n            fitness -= cgp-&gt;GetComplexity();\n          }\n\n          return fitness;\n        }\n\n//        STARTPOSITIONS[startPos_idx], agents[arena][a]-&gt;GetPosition(), arena, a\n        double AStarFitnessFunction(const cse491::GridPosition  &amp; startpos, const cse491::GridPosition &amp; endpos, int arena, int a)\n        {\n          double fitness = 0;\n\n          // Euclidean distance\n          cse491::GridPosition currentPosition = endpos;\n          double distance = static_cast&lt;double&gt;(\n                  Get_A_StarDistance(startpos, currentPosition, arena, a)\n                  );\n\n\n          double score = distance;\n\n          fitness += score;\n\n          cse491::AgentBase &amp;agent = *agents[arena][a];\n          // Agent complexity, temporarily doing this in a bad way\n          if (auto *cgp = dynamic_cast&lt;CGPAgent *&gt;(&amp;agent)){\n            fitness -= cgp-&gt;GetComplexity();\n          }\n\n          return fitness;\n        }\n\n        static std::filesystem::path getSystemPath() {\n          std::string relativePath = \"../../savedata/GPAgent/\";\n          std::filesystem::path absolutePath = std::filesystem::absolute(relativePath);\n          std::filesystem::path normalizedAbsolutePath = std::filesystem::canonical(absolutePath);\n          return normalizedAbsolutePath;\n        }\n\n        static std::string getDateStr() {\n          auto now = std::chrono::system_clock::now();\n          std::time_t now_time = std::chrono::system_clock::to_time_t(now);\n\n          // Format the date and time as a string (hour-minute-second)\n          std::tm tm_time = *std::localtime(&amp;now_time);\n          std::ostringstream oss;\n          oss &lt;&lt; std::put_time(&amp;tm_time, \"%Y-%m-%d__%H_%M_%S\");\n          std::string dateTimeStr = oss.str();\n\n          return dateTimeStr;\n        }\n\n        void ThreadTrainLoop(size_t maxThreads = 1, int numberOfTurns = 100) {\n          std::vector&lt;std::thread&gt; threads;\n\n          size_t threadsComplete = 0;\n\n\n\n\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            if (maxThreads == 0 || threads.size() &lt; maxThreads) {\n              threads.emplace_back(&amp;GPTrainingLoop::RunArena, this, arena, numberOfTurns);\n\n            } else {\n              // Wait for one of the existing threads to finish\n              threads[0].join();\n              threads.erase(threads.begin());\n              threadsComplete++;\n              threads.emplace_back(&amp;GPTrainingLoop::RunArena, this, arena, numberOfTurns);\n            }\n\n\n            size_t barWidth = 64;\n            float progress = (float) (arena+1) / environments.size();\n            size_t pos = barWidth * progress;\n            std::cout &lt;&lt; \"[\";\n            for (size_t i = 0; i &lt; barWidth; ++i) {\n              if (i &lt; pos) std::cout &lt;&lt; \"=\";\n              else if (i == pos) std::cout &lt;&lt; \"&gt;\";\n              else std::cout &lt;&lt; \" \";\n            }\n            std::cout &lt;&lt; \"] \" &lt;&lt; int(progress * 100.0) &lt;&lt; \" % - \" &lt;&lt; threadsComplete &lt;&lt; \" threads done\\r\";\n            std::cout.flush();\n          }\n\n          // Wait for all threads to finish\n          for (auto &amp;thread: threads) {\n            if (thread.joinable()) {\n              thread.join();\n              threadsComplete+=maxThreads;\n            }\n          }\n\n          std::cout &lt;&lt; std::endl;\n          std::cout &lt;&lt; \"All threads done\" &lt;&lt; std::endl;\n\n\n        }\n\n\n\n        void Run(size_t numGenerations,\n                 size_t numberOfTurns = 100,\n                 size_t maxThreads = 0, bool saveData = false) {\n\n          auto startTime = std::chrono::high_resolution_clock::now();\n\n          global_max_threads = maxThreads;\n\n\n          SaveDataParams saveDataParams(0);\n          saveDataParams.save = saveData;\n          saveDataParams.saveMetaData = true;\n          saveDataParams.saveAllAgentData = true;\n//\n//          saveDataParams.saveTopAgents = true;\n//          saveDataParams.saveLastGenerations = true;\n\n\n\n//          check to see if meta data exists\n          std::filesystem::path normalizedAbsolutePath = getSystemPath();\n          std::string metaDataFilename = \"metaData.xml\";\n//          check to see if the file exists\n          std::filesystem::path metaDataFullPath = normalizedAbsolutePath / metaDataFilename;\n\n\n          size_t generation = 0; // &lt;- the generation to start at\n\n          if (std::filesystem::exists(metaDataFullPath) &amp;&amp; ScavengerQueuing) {\n            std::cout &lt;&lt; \"MetaData file exists\" &lt;&lt; std::endl;\n            metaData.LoadFile(metaDataFullPath.string().c_str());\n            rootMetaData = metaData.FirstChildElement(\"GPLoopMetaData\");\n            auto *generationTag = rootMetaData-&gt;FirstChildElement();\n            generation = generationTag-&gt;UnsignedAttribute(\"generation\") + 1;\n            rollingRandomSeed = generationTag-&gt;UnsignedAttribute(\"randSeed\");\n            std::cout &lt;&lt; \"Starting at generation \" &lt;&lt; generation &lt;&lt; std::endl;\n\n          } else {\n            if (ScavengerQueuing)\n            {\n              std::cout &lt;&lt; \"MetaData file does not exist Starting a new Scavenger Queue\" &lt;&lt; std::endl;\n            }\n            rollingRandomSeed = TRAINING_SEED;\n            rootMetaData = metaData.NewElement(\"GPLoopMetaData\");\n            metaData.InsertFirstChild(rootMetaData);\n          }\n\n          for (; generation &lt; numGenerations; ++generation) {\n            srand(rollingRandomSeed);\n            rollingRandomSeed = rand();\n\n            auto generationStartTime = std::chrono::high_resolution_clock::now();\n            saveDataParams.updateGeneration(generation);\n\n            InitTEMPAgentFitness();\n            ThreadTrainLoop(maxThreads, numberOfTurns);\n\n            std::cout &lt;&lt; std::endl;\n\n            sortedAgents.clear();\n            SortThemAgents();\n\n            int countMaxAgents = AgentsAnalysisComputationsAndPrint(generation);\n\n            saveDataParams.countMaxAgents = countMaxAgents;\n            SaveDataCheckPoint(saveDataParams);\n\n\n            GpLoopMutateHelper();\n            resetEnvironments();\n\n            auto generationEndTime = std::chrono::high_resolution_clock::now();\n            auto generationDuration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(\n                    generationEndTime - generationStartTime);\n            std::cout &lt;&lt; \"Generation \" &lt;&lt; generation &lt;&lt; \" took \" &lt;&lt; generationDuration.count() / 1000000.0 &lt;&lt; \" seconds\"\n                      &lt;&lt; std::endl;\n          analyzer.saveToFile();\n\n          }\n\n          auto endTime = std::chrono::high_resolution_clock::now();\n          auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(endTime - startTime);\n          std::cout &lt;&lt; \"Time taken by run: \" &lt;&lt; duration.count() / 1000000.0 &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n          if (saveData) {\n\n          }\n\n          MemGOBYE();\n        }\n\n        struct SaveDataParams {\n            size_t generation;\n            bool save = false;\n            bool saveAllAgentData = false;\n            bool saveMetaData = true;\n            bool saveTopAgents = false;\n            bool saveLastGenerations = false;\n\n            size_t countMaxAgents = 0;\n\n            std::string dateTimeStr = getDateStr();\n            std::filesystem::path normalizedAbsolutePath = getSystemPath();\n\n            size_t checkPointEvery = 5;\n\n            SaveDataParams(size_t gen) : generation(gen) {}\n\n            void updateGeneration(size_t gen) { generation = gen; }\n        };\n\n\n        void SaveDataCheckPoint(const SaveDataParams &amp;params) {\n          if (!params.save) {\n            return;\n          }\n\n          allOfLastGeneration.Clear();\n          rootAllOfLastGeneration = allOfLastGeneration.NewElement(\"GPLoopAllOfLastGeneration\");\n          allOfLastGeneration.InsertFirstChild(rootAllOfLastGeneration);\n\n          size_t totalNumberOfAgents = agents.size() * agents[0].size();\n\n          SerializeAgents(params.generation, rootAllOfLastGeneration, allOfLastGeneration, totalNumberOfAgents);\n\n          if (params.saveTopAgents) {\n            SerializeAgents(params.generation, rootTopAllGenerations, topAgentsDoc);\n          }\n\n          if (params.saveLastGenerations){\n            SerializeAgents(params.generation, rootTopLastGenerations, lastGenerationsTopAgentsDoc, 5);\n          }\n\n          std::string dateTimeStr = params.dateTimeStr;\n          std::filesystem::path normalizedAbsolutePath = params.normalizedAbsolutePath;\n\n\n          if (params.generation % params.checkPointEvery != 0) {\n            return;\n          }\n\n\n          if (params.saveMetaData) {\n            const std::string metaDataFilename = \"metaData_\" + dateTimeStr + \".xml\";\n            auto metaDataFullPath = normalizedAbsolutePath / metaDataFilename;\n            saveXMLDoc(metaData, metaDataFullPath.string());\n          }\n\n          if (params.saveAllAgentData) {\n            const std::string allAgentDataFilename = \"allAgentData_\" + dateTimeStr + \".xml\";\n            auto allAgentDataFullPath = normalizedAbsolutePath / allAgentDataFilename;\n            saveXMLDoc(allOfLastGeneration, allAgentDataFullPath.string());\n          }\n\n\n\n          if (params.saveTopAgents) {\n            const std::string filename = \"AgentData_\" + dateTimeStr + \".xml\";\n            auto fullPath = normalizedAbsolutePath / filename;\n\n            saveXMLDoc(topAgentsDoc, fullPath.string());\n          }\n\n          if (params.saveLastGenerations) {\n            const std::string lastGenerationsFilename = \"lastGenerations_\" + dateTimeStr + \".xml\";\n            auto lastGenerationsFullPath = normalizedAbsolutePath / lastGenerationsFilename;\n            saveXMLDoc(lastGenerationsTopAgentsDoc, lastGenerationsFullPath.string());\n          }\n\n\n          std::cout &lt;&lt; \"@@@@@@@@@@@@@@@@@@@@@@  \" &lt;&lt; \"DataSaved\" &lt;&lt; \"  @@@@@@@@@@@@@@@@@@@@@@\" &lt;&lt; std::endl;\n\n//            analyzer.saveToFile(getSystemPath() / \"fitness.csv\");\n          lastGenerationsTopAgentsDoc.Clear();\n          ResetMainTagLastGenerations();\n        }\n\n\n        std::string FormatPosition(const cse491::GridPosition &amp; pos, int precision = 0) {\n          std::stringstream ss;\n          ss &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision) &lt;&lt; \"[\" &lt;&lt; pos.GetX() &lt;&lt; \",\" &lt;&lt; pos.GetY() &lt;&lt; \"]\";\n          return ss.str();\n        }\n\n        size_t Get_A_StarDistance(const cse491::GridPosition &amp; startpos, const cse491::GridPosition &amp; endpos, int arenaIDX, int agentIDX) {\n          auto&amp; agent = agents[arenaIDX][agentIDX];\n          auto&amp; world = environments[arenaIDX];\n\n\n          auto distance = walle::GetShortestPath(startpos, endpos, *world, *agent).size() - 1;\n          assert(distance &gt;= 0);\n          return distance;\n        }\n\n\n        int AgentsAnalysisComputationsAndPrint(int generation, double deltaForMaxFitness = 0.1) {\n          // print average fitness\n          double averageFitness = 0;\n          double maxFitness = -10000;\n\n\n          std::pair&lt;int, int&gt; bestAgent = std::make_pair(-1, -1);\n\n          int countMaxAgents = 0;\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n              averageFitness += TEMPAgentFitness[arena][a];\n\n\n              if (abs(TEMPAgentFitness[arena][a] - maxFitness) &gt; deltaForMaxFitness &amp;&amp;\n                  TEMPAgentFitness[arena][a] &gt; maxFitness) {\n                maxFitness = TEMPAgentFitness[arena][a];\n                bestAgent = std::make_pair(arena, a);\n                countMaxAgents = 1;\n              }\n\n              if (abs(TEMPAgentFitness[arena][a] - maxFitness) &lt; deltaForMaxFitness) {\n                countMaxAgents++;\n              }\n            }\n          }\n\n          averageFitness /= (environments.size() * agents[0].size());\n\n\n          std::cout &lt;&lt; \"Generation \" &lt;&lt; generation &lt;&lt; \" complete\" &lt;&lt; std::endl;\n          std::cout &lt;&lt; \"Average fitness: \" &lt;&lt; averageFitness &lt;&lt; \" \";\n          analyzer.addAverageFitness(averageFitness);\n\n          std::cout &lt;&lt; \"Max fitness: \" &lt;&lt; maxFitness &lt;&lt; std::endl;\n          analyzer.addMaxFitness(maxFitness);\n\n\n\n          std::string tagName = \"generation_\" + std::to_string(generation);\n          auto *generationTag = metaData.NewElement(tagName.c_str());\n          generationTag-&gt;SetAttribute(\"generation\", generation);\n\n          generationTag-&gt;SetAttribute(\"averageFitness\", averageFitness);\n          generationTag-&gt;SetAttribute(\"maxFitness\", maxFitness);\n          generationTag-&gt;SetAttribute(\"bestAgentIDX\", bestAgent.second);\n\n          generationTag-&gt;SetAttribute(\"Rand\", rollingRandomSeed);\n\n          rootMetaData-&gt;InsertFirstChild(generationTag);\n\n\n\n\n          std::cout &lt;&lt; \"Best agent: AGENT[\" &lt;&lt; bestAgent.first &lt;&lt; \",\" &lt;&lt; bestAgent.second &lt;&lt; \"] \" &lt;&lt; std::endl;\n\n          std::cout &lt;&lt; \"Best Agent Final Positions\" &lt;&lt; std::endl;\n\n          Printgrid(endPositions[bestAgent.first][bestAgent.second], 'A');\n\n          // auto&amp; agent = agents[bestAgent.first][bestAgent.second];\n          auto&amp; startPosition = STARTPOSITIONS;\n          auto&amp; endPosition = endPositions[bestAgent.first][bestAgent.second];\n\n          // auto&amp; world = environments[bestAgent.first];\n\n\n          auto calculateDistance = [](const cse491::GridPosition&amp; startPosition, const cse491::GridPosition &amp; currentPosition) {\n              return std::sqrt(std::pow(currentPosition.GetX() - startPosition.GetX(), 2) +\n                               std::pow(currentPosition.GetY() - startPosition.GetY(), 2));\n          };\n\n          int columnWidth = 10; // Adjust as needed\n\n          std::cout &lt;&lt; std::left &lt;&lt; std::setw(columnWidth) &lt;&lt; \"Start\"\n                    &lt;&lt; std::setw(columnWidth) &lt;&lt; \"Final\"\n                  &lt;&lt; std::setw(columnWidth) &lt;&lt; \"Distance\"\n                  &lt;&lt; \"A* Distance\\n\";\n          for (size_t i = 0; i &lt; STARTPOSITIONS.size(); ++i) {\n            std::cout &lt;&lt; std::setw(columnWidth) &lt;&lt; FormatPosition(STARTPOSITIONS[i])\n                      &lt;&lt; std::setw(columnWidth) &lt;&lt; FormatPosition(endPositions[bestAgent.first][bestAgent.second][i]);\n\n\n            // Calculate and print Euclidean distance\n            double distance = calculateDistance(STARTPOSITIONS[i], endPositions[bestAgent.first][bestAgent.second][i]);\n            std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; std::setw(12) &lt;&lt; distance;\n\n\n            // Calculate and print A* distance\n            size_t astarDistance = Get_A_StarDistance(startPosition[i], endPosition[i], bestAgent.first, bestAgent.second);\n            std::cout &lt;&lt; std::setw(12) &lt;&lt; astarDistance;\n\n\n            std::cout &lt;&lt; std::endl;\n          }\n\n          std::cout &lt;&lt; \"with best agent weighted score of \" &lt;&lt; TEMPAgentFitness[bestAgent.first][bestAgent.second] &lt;&lt; std::endl;\n          std::cout &lt;&lt; std::endl;\n          analyzer.addAverageScore(TEMPAgentFitness[bestAgent.first][bestAgent.second]);\n\n          std::cout &lt;&lt; \"Number of agents with max fitness: \" &lt;&lt; countMaxAgents &lt;&lt; std::endl;\n          std::cout &lt;&lt; \"------------------------------------------------------------------\" &lt;&lt; std::endl;\n          analyzer.addNumAgentsWithMaxFitness(countMaxAgents);\n          return countMaxAgents;\n        }\n\n        void SortThemAgents() {\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n              sortedAgents.push_back(std::make_pair(arena, a));\n            }\n          }\n\n          std::sort(sortedAgents.begin(), sortedAgents.end(),\n                    [&amp;](const std::pair&lt;int, int&gt; &amp;a, const std::pair&lt;int, int&gt; &amp;b) {\n                        return TEMPAgentFitness[a.first][a.second] &gt; TEMPAgentFitness[b.first][b.second];\n                    });\n        }\n\n\n        void saveXMLDoc(tinyxml2::XMLDocument &amp;paramdoc, std::string fullPath) {\n          if (paramdoc.SaveFile(fullPath.c_str()) == tinyxml2::XML_SUCCESS) {\n            // std::filesystem::path fullPath = std::filesystem::absolute(\"example.xml\");\n            std::cout &lt;&lt; \"XML file saved successfully to: \" &lt;&lt; fullPath &lt;&lt; std::endl;\n          } else {\n            std::cout &lt;&lt; \"Error saving XML file.\" &lt;&lt; std::endl;\n//            std::cout &lt;&lt; \"Error ID: \" &lt;&lt; paramdoc.ErrorID() &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Error for path\" &lt;&lt; fullPath &lt;&lt; std::endl;\n          }\n        }\n\n\n        void SerializeAgents(int generation, tinyxml2::XMLElement *rootElement, tinyxml2::XMLDocument &amp;paramDocument,\n                             size_t topN = 5) {\n\n          std::string tagName = \"generation_\" + std::to_string(generation);\n          auto *generationTag = paramDocument.NewElement(tagName.c_str());\n\n\n          rootElement-&gt;InsertFirstChild(generationTag);\n\n          for (size_t i = 0; i &lt; std::min(sortedAgents.size(), topN); ++i) {\n            auto [arenaIDX, agentIDX] = sortedAgents[i];\n            agents[arenaIDX][agentIDX]-&gt;SerializeGP(paramDocument, generationTag, TEMPAgentFitness[arenaIDX][agentIDX]);\n          }\n\n\n        }\n\n        void InitTEMPAgentFitness() {\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            TEMPAgentFitness.push_back(std::vector&lt;double&gt;(agents[arena].size(), 0));\n          }\n        }\n\n\n        void MutateAgents(int start, int end, const std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;sortedAgents,\n                          std::vector&lt;std::vector&lt;cowboys::GPAgentBase *&gt;&gt; &amp;agents, double mutationRate) {\n          for (int i = start; i &lt; end; i++) {\n            auto [arenaIDX, agentIDX] = sortedAgents[i];\n            agents[arenaIDX][agentIDX]-&gt;MutateAgent(mutationRate);\n\n            if (i % (sortedAgents.size() / 10) == 0) {\n              std::cout &lt;&lt; \" --- mutation complete \" &lt;&lt; (i * 1.0 / sortedAgents.size()) &lt;&lt; std::endl;\n            }\n          }\n        }\n\n        void MutateAndCopyAgents(int start, int end, const std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;sortedAgents,\n                                 std::vector&lt;std::vector&lt;cowboys::GPAgentBase *&gt;&gt; &amp;agents, int elitePopulationSize) {\n          for (int i = start; i &lt; end; i++) {\n            auto [arenaIDX, agentIDX] = sortedAgents[i];\n            auto eliteINDEX = rand() % elitePopulationSize;\n            auto [eliteArenaIDX, eliteAgentIDX] = sortedAgents[eliteINDEX];\n\n            agents[arenaIDX][agentIDX]-&gt;Copy(*agents[eliteArenaIDX][eliteAgentIDX]);\n            agents[arenaIDX][agentIDX]-&gt;MutateAgent(0.01);\n\n            if (i % (sortedAgents.size() / 10) == 0) {\n              std::cout &lt;&lt; \" --- mutation complete \" &lt;&lt; (i * 1.0 / sortedAgents.size()) &lt;&lt; std::endl;\n            }\n          }\n        }\n\n        void GpLoopMutateHelper() {\n\n//          constexpr double ELITE_POPULATION_PERCENT = 0.1;\n//          constexpr double UNFIT_POPULATION_PERCENT = 0.2;\n\n\n          const int ELITE_POPULATION_SIZE = int(ELITE_POPULATION_PERCENT * sortedAgents.size());\n\n\n          double averageEliteFitness = 0;\n          for (int i = 0; i &lt; ELITE_POPULATION_SIZE; i++) {\n            auto [arenaIDX, agentIDX] = sortedAgents[i];\n            averageEliteFitness += TEMPAgentFitness[arenaIDX][agentIDX];\n          }\n          averageEliteFitness /= ELITE_POPULATION_SIZE;\n\n          std::cout &lt;&lt; \" --- average elite score \" &lt;&lt; averageEliteFitness &lt;&lt; \"------ \" &lt;&lt; std::endl;\n          analyzer.addEliteScore(averageEliteFitness);\n\n          const int MIDDLE_MUTATE_ENDBOUND = int(sortedAgents.size() * (1 - UNFIT_POPULATION_PERCENT));\n          const int MIDDLE_MUTATE_STARTBOUND = int(ELITE_POPULATION_PERCENT * sortedAgents.size());\n\n          // Determine the number of threads to use\n          const int num_threads = global_max_threads;\n//          const int num_threads = std::min(static_cast&lt;int&gt;(std::thread::hardware_concurrency()), global_max_threads);\n\n          std::vector&lt;std::thread&gt; threads;\n\n          // Calculate the number of agents per thread\n          int agents_per_thread = (MIDDLE_MUTATE_ENDBOUND - MIDDLE_MUTATE_STARTBOUND) / num_threads;\n\n          // Launch threads for the first loop\n          for (int i = 0; i &lt; num_threads; ++i) {\n            int start = MIDDLE_MUTATE_STARTBOUND + i * agents_per_thread;\n            int end = (i == num_threads - 1) ? MIDDLE_MUTATE_ENDBOUND : start + agents_per_thread;\n            threads.push_back(std::thread([this, start, end] {\n                this-&gt;MutateAgents(start, end, sortedAgents, agents, 0.05);\n            }));\n          }\n\n          // Join the threads\n          for (auto &amp;t: threads) {\n            t.join();\n          }\n\n          threads.clear();\n\n          // Second loop - copy and mutate agents\n          // int unfitAgents = int(sortedAgents.size() * UNFIT_POPULATION_PERCENT);\n          agents_per_thread = (sortedAgents.size() - MIDDLE_MUTATE_ENDBOUND) / num_threads;\n          for (int i = 0; i &lt; num_threads; ++i) {\n            int start = MIDDLE_MUTATE_ENDBOUND + i * agents_per_thread;\n            int end = (i == num_threads - 1) ? sortedAgents.size() : start + agents_per_thread;\n\n            threads.push_back(std::thread([this, start, end, ELITE_POPULATION_SIZE] {\n                this-&gt;MutateAndCopyAgents(start, end, sortedAgents, agents, ELITE_POPULATION_SIZE);\n            }));\n          }\n\n          for (auto &amp;t: threads) {\n            t.join();\n          }\n\n\n        }\n\n        void Printgrid(const std::vector&lt;cse491::GridPosition&gt; &amp;positions, char symbol = 'S') {\n\n          if (environments.empty()) {\n            std::cout &lt;&lt; \"No environments to print\" &lt;&lt; std::endl;\n            return;\n          }\n\n          size_t arena = 0;\n          auto &amp;grid = environments[arena]-&gt;GetGrid();\n          std::vector&lt;std::string&gt; symbol_grid(grid.GetHeight());\n\n\n          const auto &amp;type_options = environments[arena]-&gt;GetCellTypes();\n          // Load the world into the symbol_grid;\n          for (size_t y = 0; y &lt; grid.GetHeight(); ++y) {\n            symbol_grid[y].resize(grid.GetWidth());\n            for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n              symbol_grid[y][x] = type_options[grid.At(x, y)].symbol;\n            }\n          }\n\n\n\n          for (size_t pos_idx = 0; pos_idx &lt; positions.size(); ++pos_idx) {\n\n            assert(positions[pos_idx].CellY() &lt; symbol_grid.size());\n            assert(positions[pos_idx].CellX() &lt; symbol_grid[positions[pos_idx].CellY()].size());\n            symbol_grid[positions[pos_idx].CellY()][positions[pos_idx].CellX()] = symbol;\n          }\n\n\n//          const auto &amp;agent_set = agents[arena];\n//          for (const auto &amp;agent_ptr: agent_set) {\n//            cse491::GridPosition pos = agent_ptr-&gt;GetPosition();\n//            char c = '*';\n//            if (agent_ptr-&gt;HasProperty(\"symbol\")) {\n//              c = agent_ptr-&gt;template GetProperty&lt;char&gt;(\"symbol\");\n//            }\n//            symbol_grid[pos.CellY()][pos.CellX()] = c;\n//          }\n\n          std::cout &lt;&lt; \"    \";\n          for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n            if (x % 10 == 0 &amp;&amp; x != 0) {\n              std::cout &lt;&lt; x / 10; // Print the ten's place of the column number\n            } else {\n              std::cout &lt;&lt; \" \"; // Space for non-marker columns\n            }\n          }\n          std::cout &lt;&lt; \"\\n\";\n\n          // Print column numbers\n          std::cout &lt;&lt; \"    \"; // Space for row numbers\n          for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n            std::cout &lt;&lt; x % 10; // Print only the last digit of the column number\n          }\n          std::cout &lt;&lt; \"\\n\";\n\n          // Print out the symbol_grid with a box around it.\n          std::cout &lt;&lt; \"   +\" &lt;&lt; std::string(grid.GetWidth(), '-') &lt;&lt; \"+\\n\";\n          for (size_t y = 0; y &lt; grid.GetHeight(); ++y) {\n\n            if (y % 10 == 0 &amp;&amp; y != 0) {\n              std::cout &lt;&lt; y / 10 &lt;&lt; \" \"; // Print the ten's place of the row number\n            } else {\n              std::cout &lt;&lt; \"  \"; // Space for non-marker rows\n            }\n\n            // Print row number\n            std::cout &lt;&lt; y % 10 &lt;&lt; \"|\"; // Print only the last digit of the row number\n            for (char cell: symbol_grid[y]) {\n              std::cout &lt;&lt; cell;\n            }\n            std::cout &lt;&lt; \"|\\n\";\n          }\n\n          std::cout &lt;&lt; \"   +\" &lt;&lt; std::string(grid.GetWidth(), '-') &lt;&lt; \"+\\n\";\n          std::cout &lt;&lt; std::endl;\n        }\n\n\n\n        void resetEnvironments() {\n\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n              agents[arena][a]-&gt;Reset();\n            }\n          }\n\n          TEMPAgentFitness.clear();\n        }\n\n        void RunArena(size_t arena, size_t numberOfTurns) {\n          for (size_t startPos_idx = 0; startPos_idx &lt; STARTPOSITIONS.size(); ++startPos_idx) {\n            for(size_t a = 0; a &lt; agents[arena].size(); ++a) {\n              // Reset the agent before each run\n              agents[arena][a]-&gt;Reset();\n              // Set the starting position\n              agents[arena][a]-&gt;SetPosition(STARTPOSITIONS[startPos_idx]);\n            }\n\n            for (size_t turn = 0; turn &lt; numberOfTurns; turn++) {\n              environments[arena]-&gt;RunAgents();\n              environments[arena]-&gt;UpdateWorld();\n            }\n            for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n//              double tempscore = SimpleFitnessFunction(*agents[arena][a], STARTPOSITIONS[startPos_idx]);\n              double tempscore = AStarFitnessFunction(STARTPOSITIONS[startPos_idx], agents[arena][a]-&gt;GetPosition(), arena, a);\n              auto tempEndPosition = agents[arena][a]-&gt;GetPosition();\n              endPositions[arena][a][startPos_idx] = tempEndPosition;\n              independentAgentFitness[arena][a][startPos_idx] = tempscore;\n              TEMPAgentFitness[arena][a] += tempscore;\n\n            }\n\n          }\n\n          for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n            std::vector&lt;double&gt; scores = independentAgentFitness[arena][a];\n            // auto computeMedian = [&amp;scores]() -&gt; double {\n            //     std::vector&lt;double&gt; temp(scores);  // Copy the data\n            //     std::sort(temp.begin(), temp.end());\n\n            //     size_t n = temp.size();\n            //     return n % 2 ? temp[n / 2] : (temp[n / 2 - 1] + temp[n / 2]) / 2.0;\n            // };\n\n\n//            TEMPAgentFitness[arena][a] /= STARTPOSITIONS.size();\n//            TEMPAgentFitness[arena][a] += computeMedian();\n//            double min = *std::min_element(scores.begin(), scores.end());\n            [[maybe_unused]] double avg = TEMPAgentFitness[arena][a] / STARTPOSITIONS.size();\n            //  TEMPAgentFitness[arena][a] = 0.7 * min + 0.3 * avg;\n              // TEMPAgentFitness[arena][a] = min;\n              TEMPAgentFitness[arena][a] = avg;\n          }\n\n        }\n\n        void MemGOBYE() {\n\n          TEMPAgentFitness.clear();\n          environments.clear();\n          agents.clear();\n          sortedAgents.clear();\n\n        }\n\n        ~GPTrainingLoop() = default;\n    };\n}\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_8hpp/","title":"File Graph.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; Graph.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"../AgentLibary.hpp\"</code></li> <li><code>#include \"GraphNode.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_8hpp/#classes","title":"Classes","text":"Type Name class Graph A graph of nodes that can be used to make decisions. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/Graph.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_8hpp_source/","title":"File Graph.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; Graph.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"../../core/AgentBase.hpp\"\n#include \"../AgentLibary.hpp\"\n#include \"GraphNode.hpp\"\n\nnamespace cowboys {\n  using GraphLayer = std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt;;\n\n  class Graph {\n  protected:\n    std::vector&lt;GraphLayer&gt; layers;\n\n  public:\n    Graph() = default;\n    ~Graph() = default;\n\n    size_t GetNodeCount() const {\n      return std::accumulate(layers.cbegin(), layers.cend(), 0,\n                             [](size_t sum, const auto &amp;layer) { return sum + layer.size(); });\n    }\n\n    size_t GetLayerCount() const { return layers.size(); }\n\n    size_t MakeDecision(const std::vector&lt;double&gt; &amp;inputs, const std::vector&lt;size_t&gt; &amp;actions) {\n      if (layers.size() == 0)\n        return actions.at(0);\n\n      // Set inputs of input layer\n      size_t i = 0;\n      for (auto &amp;node : layers[0]) {\n        double input = 0;\n        if (i &lt; inputs.size())\n          input = inputs.at(i);\n        node-&gt;SetDefaultOutput(input);\n        ++i;\n      }\n\n      // Get output of last layer\n      std::vector&lt;double&gt; outputs;\n      for (auto &amp;node : layers.back()) {\n        outputs.push_back(node-&gt;GetOutput());\n      }\n\n      // Choose the action with the highest output\n      auto max_output = std::max_element(outputs.cbegin(), outputs.cend());\n      size_t index = std::distance(outputs.cbegin(), max_output);\n\n      // If index is out of bounds, return the last action\n      size_t action = 0;\n      if (index &gt;= actions.size())\n        action = actions.back();\n      else // Otherwise, return the action at the index\n        action = actions.at(index);\n      return action;\n    }\n\n    void AddLayer(const GraphLayer &amp;layer) { layers.push_back(layer); }\n\n    std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; GetFunctionalNodes() const {\n      std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; functional_nodes;\n      for (size_t i = 1; i &lt; layers.size(); ++i) {\n        functional_nodes.insert(functional_nodes.cend(), layers.at(i).cbegin(), layers.at(i).cend());\n      }\n      return functional_nodes;\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; GetNodes() const {\n      std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; all_nodes;\n      for (auto &amp;layer : layers) {\n        all_nodes.insert(all_nodes.cend(), layer.cbegin(), layer.cend());\n      }\n      return all_nodes;\n    }\n  };\n\n  std::vector&lt;size_t&gt; EncodeActions(const std::unordered_map&lt;std::string, size_t&gt; &amp;action_map) {\n    std::vector&lt;size_t&gt; actions;\n    for (const auto &amp;[action_name, action_id] : action_map) {\n      actions.push_back(action_id);\n    }\n    // Sort the actions so that they are in a consistent order.\n    std::sort(actions.begin(), actions.end());\n    return actions;\n  }\n\n  std::vector&lt;double&gt; EncodeState(const cse491::WorldGrid &amp;grid, const cse491::type_options_t &amp; /*type_options*/,\n                                  const cse491::item_map_t &amp; /*item_set*/, const cse491::agent_map_t &amp; /*agent_set*/,\n                                  const cse491::AgentBase *agent,\n                                  const std::unordered_map&lt;std::string, double&gt; &amp;extra_agent_state) {\n    std::vector&lt;double&gt; inputs;\n\n    auto current_position = agent-&gt;GetPosition();\n\n    double current_state = grid.At(current_position);\n    double above_state = grid.IsValid(current_position.Above()) ? grid.At(current_position.Above()) : 0.;\n    double below_state = grid.IsValid(current_position.Below()) ? grid.At(current_position.Below()) : 0.;\n    double left_state = grid.IsValid(current_position.ToLeft()) ? grid.At(current_position.ToLeft()) : 0.;\n    double right_state = grid.IsValid(current_position.ToRight()) ? grid.At(current_position.ToRight()) : 0.;\n\n    double prev_action = extra_agent_state.at(\"previous_action\");\n    double starting_x = extra_agent_state.at(\"starting_x\");\n    double starting_y = extra_agent_state.at(\"starting_y\");\n    auto starting_pos = cse491::GridPosition(starting_x, starting_y);\n    auto path = walle::GetShortestPath(agent-&gt;GetPosition(), starting_pos, agent-&gt;GetWorld(), *agent);\n    double distance_from_start = path.size();\n\n    inputs.insert(inputs.end(), {prev_action, starting_x, starting_y, distance_from_start, current_state, above_state, below_state, left_state, right_state});\n\n    return inputs;\n  }\n\n} // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_builder_8hpp/","title":"File GraphBuilder.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GraphBuilder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CGPGenotype.hpp\"</code></li> <li><code>#include \"Graph.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_builder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_builder_8hpp/#classes","title":"Classes","text":"Type Name class GraphBuilder A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphBuilder.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_builder_8hpp_source/","title":"File GraphBuilder.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GraphBuilder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include \"CGPGenotype.hpp\"\n#include \"Graph.hpp\"\n\nnamespace cowboys {\n\n  class GraphBuilder {\n  public:\n    GraphBuilder() = default;\n    ~GraphBuilder() = default;\n\n    std::unique_ptr&lt;Graph&gt; CartesianGraph(const CGPGenotype &amp;genotype, const std::vector&lt;InnerFunction&gt; &amp;function_set,\n                                          const cse491::AgentBase *agent = nullptr) {\n      auto decision_graph = std::make_unique&lt;Graph&gt;();\n\n      //\n      // Add all the nodes\n      //\n      // Input layer\n      GraphLayer input_layer;\n      for (size_t i = 0; i &lt; genotype.GetNumInputs(); ++i) {\n        input_layer.emplace_back(std::make_shared&lt;GraphNode&gt;(0));\n      }\n      decision_graph-&gt;AddLayer(input_layer);\n\n      // Middle Layers\n      for (size_t i = 0; i &lt; genotype.GetNumLayers(); ++i) {\n        GraphLayer layer;\n        for (size_t j = 0; j &lt; genotype.GetNumNodesPerLayer(); ++j) {\n          layer.emplace_back(std::make_shared&lt;GraphNode&gt;(0));\n        }\n        decision_graph-&gt;AddLayer(layer);\n      }\n\n      // Action layer\n      GraphLayer output_layer;\n      for (size_t i = 0; i &lt; genotype.GetNumOutputs(); ++i) {\n        output_layer.emplace_back(std::make_shared&lt;GraphNode&gt;(0));\n      }\n      decision_graph-&gt;AddLayer(output_layer);\n\n      //\n      // Configure graph based on genotype\n      //\n\n      auto functional_nodes = decision_graph-&gt;GetFunctionalNodes();\n      auto all_nodes = decision_graph-&gt;GetNodes();\n      auto nodes_it = functional_nodes.cbegin();\n      auto genes_it = genotype.cbegin();\n      // Iterator distances should be the same\n      assert(std::distance(functional_nodes.cend(), functional_nodes.cbegin()) ==\n             std::distance(genotype.cend(), genotype.cbegin()));\n      // Get the iterator of all nodes and move it to the start of the first functional node\n      auto all_nodes_it = all_nodes.cbegin() + genotype.GetNumInputs();\n      for (; nodes_it != functional_nodes.end() &amp;&amp; genes_it != genotype.cend(); ++nodes_it, ++genes_it) {\n        // Advance the all nodes iterator if we are at the start of a new layer\n        auto dist = std::distance(functional_nodes.cbegin(), nodes_it);\n        if (dist != 0 &amp;&amp; dist % genotype.GetNumNodesPerLayer() == 0) {\n          std::advance(all_nodes_it, genotype.GetNumNodesPerLayer());\n        }\n\n        auto &amp;[connections, function_idx, output] = *genes_it;\n        (*nodes_it)-&gt;SetFunctionPointer(NodeFunction{function_set.at(function_idx), agent});\n        (*nodes_it)-&gt;SetDefaultOutput(output);\n\n        // Copy the all nodes iterator and move it backwards by the number of connections\n        auto nodes_it_copy = all_nodes_it;\n        std::advance(nodes_it_copy, -connections.size());\n        // Add the inputs to the node\n        for (auto &amp;connection : connections) {\n          if (connection != '0') {\n            (*nodes_it)-&gt;AddInput(*nodes_it_copy);\n          }\n          ++nodes_it_copy;\n        }\n      }\n\n      return decision_graph;\n    }\n\n    std::unique_ptr&lt;Graph&gt; VerticalPacer() {\n      auto decision_graph = std::make_unique&lt;Graph&gt;();\n\n      GraphLayer input_layer;\n      std::shared_ptr&lt;GraphNode&gt; prev_action = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; current_state = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; above_state = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; below_state = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; left_state = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; right_state = std::make_shared&lt;GraphNode&gt;(0);\n      input_layer.insert(input_layer.end(),\n                         {prev_action, current_state, above_state, below_state, left_state, right_state});\n      decision_graph-&gt;AddLayer(input_layer);\n\n      // state == 1 =&gt; floor which is walkable\n      GraphLayer obstruction_layer;\n      std::shared_ptr&lt;GraphNode&gt; up_not_blocked = std::make_shared&lt;GraphNode&gt;(AnyEq);\n      up_not_blocked-&gt;AddInputs(GraphLayer{above_state, std::make_shared&lt;GraphNode&gt;(1)});\n      std::shared_ptr&lt;GraphNode&gt; down_not_blocked = std::make_shared&lt;GraphNode&gt;(AnyEq);\n      down_not_blocked-&gt;AddInputs(GraphLayer{below_state, std::make_shared&lt;GraphNode&gt;(1)});\n      obstruction_layer.insert(obstruction_layer.end(), {up_not_blocked, down_not_blocked});\n      decision_graph-&gt;AddLayer(obstruction_layer);\n\n      // Separate previous action into up and down nodes\n      GraphLayer prev_action_layer;\n      std::shared_ptr&lt;GraphNode&gt; up_prev_action = std::make_shared&lt;GraphNode&gt;(AnyEq);\n      up_prev_action-&gt;AddInputs(GraphLayer{prev_action, std::make_shared&lt;GraphNode&gt;(1)});\n      std::shared_ptr&lt;GraphNode&gt; down_prev_action = std::make_shared&lt;GraphNode&gt;(AnyEq);\n      down_prev_action-&gt;AddInputs(GraphLayer{prev_action, std::make_shared&lt;GraphNode&gt;(2)});\n      prev_action_layer.insert(prev_action_layer.end(), {up_prev_action, down_prev_action});\n      decision_graph-&gt;AddLayer(prev_action_layer);\n\n      GraphLayer moving_layer;\n      // If up_not_blocked and up_prev_action ? return 1 : return 0\n      // If down_not_blocked and down_prev_action ? return 1 : return 0\n      std::shared_ptr&lt;GraphNode&gt; keep_up = std::make_shared&lt;GraphNode&gt;(And);\n      keep_up-&gt;AddInputs(GraphLayer{up_not_blocked, up_prev_action});\n      std::shared_ptr&lt;GraphNode&gt; keep_down = std::make_shared&lt;GraphNode&gt;(And);\n      keep_down-&gt;AddInputs(GraphLayer{down_not_blocked, down_prev_action});\n      moving_layer.insert(moving_layer.end(), {keep_up, keep_down});\n      decision_graph-&gt;AddLayer(moving_layer);\n\n      // If down_blocked, turn_up\n      // If up_blocked, turn_down\n      GraphLayer turn_layer;\n      std::shared_ptr&lt;GraphNode&gt; turn_up = std::make_shared&lt;GraphNode&gt;(Not);\n      turn_up-&gt;AddInputs(GraphLayer{down_not_blocked});\n      std::shared_ptr&lt;GraphNode&gt; turn_down = std::make_shared&lt;GraphNode&gt;(Not);\n      turn_down-&gt;AddInputs(GraphLayer{up_not_blocked});\n      turn_layer.insert(turn_layer.end(), {turn_up, turn_down});\n      decision_graph-&gt;AddLayer(turn_layer);\n\n      // Output layer, up, down, left, right\n      GraphLayer action_layer;\n      // move up = keep_up + turn_up,\n      // move down = keep_down + turn_down,\n      std::shared_ptr&lt;GraphNode&gt; up = std::make_shared&lt;GraphNode&gt;(Sum);\n      up-&gt;AddInputs(GraphLayer{keep_up, turn_up});\n      std::shared_ptr&lt;GraphNode&gt; down = std::make_shared&lt;GraphNode&gt;(Sum);\n      down-&gt;AddInputs(GraphLayer{keep_down, turn_down});\n      std::shared_ptr&lt;GraphNode&gt; left = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; right = std::make_shared&lt;GraphNode&gt;(0);\n      action_layer.insert(action_layer.end(), {up, down, left, right});\n      decision_graph-&gt;AddLayer(action_layer);\n\n      return decision_graph;\n    }\n  };\n} // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/","title":"File GraphNode.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GraphNode.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;execution&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"../../core/WorldBase.hpp\"</code></li> <li><code>#include \"../AgentLibary.hpp\"</code></li> <li><code>#include \"GPAgentSensors.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#classes","title":"Classes","text":"Type Name class GraphNode A node in a decision graph. struct NodeFunction A function pointer wrapper that holds extra arguments for the function pointer."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#macros","title":"Macros","text":"Type Name define PAR"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#define-par","title":"define PAR","text":"<pre><code>#define PAR \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphNode.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp_source/","title":"File GraphNode.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GraphNode.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n// Macro for parallel execution, add -DPARALLEL flag to CMAKE_CXX_FLAGS when building to enable\n#if PARALLEL\n#include &lt;execution&gt;\n#define PAR std::execution::par,\n#else\n#define PAR\n#endif\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;cmath&gt;\n#include &lt;execution&gt;\n#include &lt;functional&gt;\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;numeric&gt;\n#include &lt;optional&gt;\n#include &lt;ranges&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"../../core/AgentBase.hpp\"\n#include \"../../core/WorldBase.hpp\"\n#include \"../AgentLibary.hpp\"\n#include \"GPAgentSensors.hpp\"\n\nnamespace cowboys {\n  class GraphNode; \n  using InnerFunction = double (*)(const GraphNode &amp;, const cse491::AgentBase &amp;);\n  struct NodeFunction {\n    InnerFunction function{nullptr};\n    const cse491::AgentBase *agent{nullptr};\n    double operator()(const GraphNode &amp;node) const { return function(node, *agent); }\n    bool IsNull() const { return function == nullptr; }\n  };\n\n  class GraphNode : public std::enable_shared_from_this&lt;GraphNode&gt; {\n  protected:\n    std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; inputs;\n\n    NodeFunction function_pointer;\n\n    double default_output{0};\n\n    std::vector&lt;GraphNode *&gt; outputs;\n\n    mutable double cached_output{0};\n\n    mutable bool cached_output_valid{false};\n\n    void AddOutput(GraphNode *node) { outputs.push_back(node); }\n\n    void RecursiveInvalidateCache() const {\n      cached_output_valid = false;\n      for (auto &amp;output : outputs) {\n        output-&gt;RecursiveInvalidateCache();\n      }\n    }\n\n  public:\n    GraphNode() = default;\n    ~GraphNode() = default;\n\n    GraphNode(double default_value) : default_output{default_value} {}\n    GraphNode(NodeFunction function) : function_pointer{function} {}\n    GraphNode(InnerFunction function) : function_pointer{function} {}\n\n    double GetOutput() const {\n      if (cached_output_valid)\n        return cached_output;\n\n      double result = default_output;\n      // Invoke function pointer if it exists\n      if (!function_pointer.IsNull()) {\n        result = function_pointer(*this);\n      }\n\n      // Cache the output\n      cached_output = result;\n      cached_output_valid = true;\n\n      return result;\n    }\n\n    std::vector&lt;double&gt; GetInputValues() const {\n      std::vector&lt;double&gt; values;\n      values.reserve(inputs.size());\n      std::transform(inputs.cbegin(), inputs.cend(), std::back_inserter(values),\n                     [](const auto &amp;node) { return node-&gt;GetOutput(); });\n      return values;\n    }\n\n    template &lt;size_t N&gt; std::optional&lt;std::vector&lt;double&gt;&gt; GetInputValues(const std::array&lt;size_t, N&gt; &amp;indices) const {\n      size_t max_index = *std::max_element(indices.cbegin(), indices.cend());\n      if (max_index &gt;= inputs.size())\n        return std::nullopt;\n      std::vector&lt;double&gt; values;\n      values.reserve(N);\n      std::transform(indices.cbegin(), indices.cend(), std::back_inserter(values),\n                     [this](const auto &amp;index) { return inputs.at(index)-&gt;GetOutput(); });\n      return values;\n    }\n\n    void SetFunctionPointer(NodeFunction function) {\n      function_pointer = function;\n      RecursiveInvalidateCache();\n    }\n\n    void SetFunctionPointer(InnerFunction inner_function) {\n      function_pointer = NodeFunction{inner_function};\n      RecursiveInvalidateCache();\n    }\n\n    void AddInput(std::shared_ptr&lt;GraphNode&gt; node) {\n      inputs.push_back(node);\n      // Add a weak pointer to this node to the input node's outputs\n      node-&gt;AddOutput(this);\n      RecursiveInvalidateCache();\n    }\n\n    void AddInputs(const std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; &amp;nodes) {\n      inputs.insert(inputs.cend(), nodes.cbegin(), nodes.cend());\n      RecursiveInvalidateCache();\n    }\n\n    void SetInputs(std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; nodes) {\n      inputs = nodes;\n      RecursiveInvalidateCache();\n    }\n\n    void SetDefaultOutput(double value) {\n      if (default_output != value) {\n        default_output = value;\n        RecursiveInvalidateCache();\n      }\n    }\n\n    double GetDefaultOutput() const { return default_output; }\n\n    bool IsCacheValid() const { return cached_output_valid; }\n  };\n\n  double Sum(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues();\n    return std::reduce(PAR vals.cbegin(), vals.cend(), 0.);\n  }\n\n  double And(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues();\n    return std::any_of(vals.cbegin(), vals.cend(), [](const double val) { return val == 0.; }) ? 0. : 1.;\n  }\n\n  double AnyEq(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    if (vals.size() == 0)\n      return node.GetDefaultOutput();\n    for (size_t i = 1; i &lt; vals.size(); ++i) {\n      if (vals.at(0) == vals.at(i))\n        return 1.;\n    }\n    return 0.;\n  }\n\n  double Not(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues&lt;1&gt;(std::array&lt;size_t, 1&gt;{0});\n    if (!vals.has_value())\n      return node.GetDefaultOutput();\n    return (*vals)[0] == 0. ? 1. : 0.;\n  }\n\n  double Gate(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues&lt;2&gt;(std::array&lt;size_t, 2&gt;{0, 1});\n    if (!vals.has_value())\n      return node.GetDefaultOutput();\n    return (*vals)[1] != 0. ? (*vals)[0] : 0.;\n  }\n\n  double Sin(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::sin(val); });\n  }\n\n  double Cos(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::cos(val); });\n  }\n\n  double Product(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues();\n    return std::reduce(PAR vals.cbegin(), vals.cend(), 1., std::multiplies{});\n  }\n\n  double Reciprocal(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return 1. / (val + std::numeric_limits&lt;double&gt;::epsilon()); });\n  }\n\n  double Exp(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::exp(val); });\n  }\n\n  double LessThan(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::is_sorted(vals.begin(), vals.end(), std::less{});\n  }\n\n  double GreaterThan(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::is_sorted(vals.begin(), vals.end(), std::greater{});\n  }\n\n  double Max(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    if (vals.empty())\n      return node.GetDefaultOutput();\n    return *std::max_element(vals.cbegin(), vals.cend());\n  }\n\n  double Min(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    if (vals.empty())\n      return node.GetDefaultOutput();\n    return *std::min_element(vals.cbegin(), vals.cend());\n  }\n\n  double NegSum(const GraphNode &amp;node, const cse491::AgentBase &amp;agent) { return -Sum(node, agent); }\n\n  double Square(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return val * val; });\n  }\n\n  double PosClamp(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::max(0., val); });\n  }\n\n  double NegClamp(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::min(0., val); });\n  }\n\n  double Sqrt(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::sqrt(std::max(0., val)); });\n  }\n\n  double WallDistanceUp(const GraphNode &amp;, const cse491::AgentBase &amp;agent) {\n    return Sensors::wallDistance(agent.GetWorld().GetGrid(), agent, SensorDirection::ABOVE);\n  }\n\n  double WallDistanceDown(const GraphNode &amp;, const cse491::AgentBase &amp;agent) {\n    return Sensors::wallDistance(agent.GetWorld().GetGrid(), agent, SensorDirection::BELOW);\n  }\n\n  double WallDistanceLeft(const GraphNode &amp;, const cse491::AgentBase &amp;agent) {\n    return Sensors::wallDistance(agent.GetWorld().GetGrid(), agent, SensorDirection::LEFT);\n  }\n\n  double WallDistanceRight(const GraphNode &amp;, const cse491::AgentBase &amp;agent) {\n    return Sensors::wallDistance(agent.GetWorld().GetGrid(), agent, SensorDirection::RIGHT);\n  }\n\n  double AStarDistance(const GraphNode &amp;node, const cse491::AgentBase &amp;agent) {\n    //\n    // The outputs of the first two connections are the x and y coordinates of the goal position. It'd probably be rare\n    // for agents to randomly use it in a useful way. Most of the time when it IS used, there is no input connections\n    // and thus the default output is used, so it isn't REALLY being used. Other times when it does have input\n    // connections, the agent has a lower fitness, so it probably wasn't making good use of it.\n    //\n    // Decided to make an easier way A* can be used by agents by giving the A* distance from the agent's start position\n    // as an input. This can still be used in the off chance it is useful.\n    auto vals = node.GetInputValues&lt;2&gt;(std::array&lt;size_t, 2&gt;{0, 1});\n    if (!vals.has_value())\n      return node.GetDefaultOutput();\n    auto vals2 = *vals;\n    auto goal_position = cse491::GridPosition(vals2[0], vals2[1]);\n    auto path = walle::GetShortestPath(agent.GetPosition(), goal_position, agent.GetWorld(), agent);\n    return path.size();\n  }\n\n  static const std::vector&lt;InnerFunction&gt; NODE_FUNCTION_SET{\n      nullptr,  Sum,         And, AnyEq, Not,    Gate,   Sin,      Cos,      Product, Exp,\n      LessThan, GreaterThan, Max, Min,   NegSum, Square, PosClamp, NegClamp, Sqrt};\n  static const std::vector&lt;InnerFunction&gt; SENSOR_FUNCTION_SET{WallDistanceUp, WallDistanceDown, WallDistanceLeft,\n                                                              WallDistanceRight, AStarDistance};\n\n  static const std::vector&lt;InnerFunction&gt; FUNCTION_SET = []() {\n    std::vector&lt;InnerFunction&gt; functions;\n    functions.reserve(NODE_FUNCTION_SET.size() + SENSOR_FUNCTION_SET.size());\n    functions.insert(functions.cend(), NODE_FUNCTION_SET.cbegin(), NODE_FUNCTION_SET.cend());\n    functions.insert(functions.cend(), SENSOR_FUNCTION_SET.cbegin(), SENSOR_FUNCTION_SET.cend());\n    return functions;\n  }();\n} // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_l_g_p_agent_8hpp/","title":"File LGPAgent.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; LGPAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"GPAgentSensors.hpp\"</code></li> <li><code>#include \"./GPAgentBase.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_l_g_p_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_l_g_p_agent_8hpp/#classes","title":"Classes","text":"Type Name class LGPAgent <p>The documentation for this class was generated from the following file <code>source/Agents/GP/LGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_l_g_p_agent_8hpp_source/","title":"File LGPAgent.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; LGPAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n#include \"../../core/AgentBase.hpp\"\n#include \"GPAgentSensors.hpp\"\n\n#include \"./GPAgentBase.hpp\"\n\nnamespace cowboys\n{\n    const int LISTSIZE = 100;\n\n    class LGPAgent : public GPAgentBase\n    {\n    protected:\n        // A dictionary of actions and a dictionary of sensors\n        // A sensor is a function that takes in a grid and returns a value (e.g. distance to left wall)\n\n        std::vector&lt;std::string&gt; possibleInstructionsList = {};\n        std::vector&lt;std::string&gt; actionsList = {};\n        std::vector&lt;std::string&gt; operationsList = {\"lessthan\", \"greaterthan\", \"equals\"};\n        std::vector&lt;std::string&gt; sensorsNamesList = {\"getLeft\", \"getRight\", \"getUp\", \"getDown\"};\n\n        // A list that stores the results of executed instructions\n        std::vector&lt;int&gt; resultsList;\n\n        std::vector&lt;std::tuple&lt;std::string, int, int&gt;&gt; instructionsList = {};\n        size_t currentInstructionIndex = 0;\n\n        std::random_device rd;\n        std::mt19937 gen;\n\n    public:\n        LGPAgent(size_t id, const std::string &amp;name) : GPAgentBase(id, name)\n        {\n            gen = std::mt19937(rd());\n\n            for (auto i = 0; i &lt; LISTSIZE; i++)\n            {\n                resultsList.push_back(0);\n            }\n        }\n\n        bool Initialize() override\n        {\n            possibleInstructionsList = EncodeActions(action_map, sensorsNamesList, operationsList, actionsList);\n            GenerateRandomActionList();\n            return true;\n        }\n\n        void GenerateRandomActionList()\n        {\n            std::uniform_int_distribution&lt;size_t&gt; dist(0, possibleInstructionsList.size() - 1);\n            std::uniform_int_distribution&lt;size_t&gt; dist2(0, LISTSIZE - 1);\n            for (int i = 0; i &lt; LISTSIZE; i++)\n            {\n                instructionsList.push_back(std::make_tuple(possibleInstructionsList[dist(gen)], dist2(gen), dist2(gen)));\n            }\n\n        }\n\n        static std::vector&lt;std::string&gt; EncodeActions(const std::unordered_map&lt;std::string, size_t&gt; &amp;action_map, const std::vector&lt;std::string&gt; &amp;sensorsNamesList, \n                                                        const std::vector&lt;std::string&gt; &amp;operationsList, std::vector&lt;std::string&gt; &amp;actionsList)\n        {\n            std::vector&lt;std::string&gt; instructions;\n            for (const auto &amp;[action_name, action_id] : action_map)\n            {\n                instructions.push_back(action_name);\n                actionsList.push_back(action_name);\n            }\n            for (const auto &amp;sensor : operationsList)\n            {\n                instructions.push_back(sensor);\n            }\n\n            for (const auto &amp;sensor : sensorsNamesList)\n            {\n                instructions.push_back(sensor);\n            }\n\n            return instructions;\n        }\n\n        void MutateAgent(double mutation_rate = 0.01) override\n        {\n            std::uniform_int_distribution&lt;size_t&gt; rnd_mutate(1, 100);\n            std::uniform_int_distribution&lt;size_t&gt; dist(0, possibleInstructionsList.size() - 1);\n            std::uniform_int_distribution&lt;size_t&gt; dist2(0, LISTSIZE - 1);\n\n            for (auto i = 0; i &lt; LISTSIZE; i++)\n            {\n                if (rnd_mutate(gen) / 100.0 &lt;= mutation_rate)\n                {\n                    instructionsList[i] = std::make_tuple(possibleInstructionsList[dist(gen)], dist2(gen), dist2(gen));\n                }\n            }\n\n            resultsList.clear();\n            resultsList.resize(LISTSIZE);\n            currentInstructionIndex = 0;\n        }\n\n        const std::vector&lt;std::tuple&lt;std::string, int, int&gt;&gt; &amp;GetInstructionsList(){ return instructionsList; }\n\n        void Configure(const LGPAgent &amp;other) {\n            instructionsList = other.instructionsList;\n            possibleInstructionsList = other.possibleInstructionsList;\n            actionsList = other.actionsList;\n            operationsList = other.operationsList;\n            sensorsNamesList = other.sensorsNamesList;\n            resultsList = other.resultsList;\n            currentInstructionIndex = other.currentInstructionIndex;\n        }\n\n        void Copy(const GPAgentBase &amp;other) override\n        {\n            assert(dynamic_cast&lt;const LGPAgent *&gt;(&amp;other) != nullptr);\n            Configure(dynamic_cast&lt;const LGPAgent &amp;&gt;(other));\n        }\n\n\n        size_t GetAction([[maybe_unused]] const cse491::WorldGrid &amp;grid,\n                            [[maybe_unused]] const cse491::type_options_t &amp;type_options,\n                            [[maybe_unused]] const cse491::item_map_t &amp;item_set,\n                            [[maybe_unused]] const cse491::agent_map_t &amp;agent_set) override\n        {\n            std::string action;\n            std::string sensor;\n            std::string operation;\n            auto instruction = instructionsList[currentInstructionIndex];\n            int i = 0;\n\n            if (currentInstructionIndex != 0)\n            {\n                resultsList[currentInstructionIndex - 1] = action_result;\n            }\n            else\n            {\n                resultsList[LISTSIZE - 1] = action_result;\n            }\n\n            while (i &lt; LISTSIZE * 2 &amp;&amp; action.empty())\n            {\n                if (std::find(actionsList.begin(), actionsList.end(), std::get&lt;0&gt;(instruction)) != actionsList.end())\n                {\n                    // the instruction is in the action list (provided by the world)\n                    action = std::get&lt;0&gt;(instruction);\n                }\n                else if (std::find(sensorsNamesList.begin(), sensorsNamesList.end(), std::get&lt;0&gt;(instruction)) != sensorsNamesList.end())\n                {\n                    // the instruction is in the sensor list (getLeft, getRight, getUp, getDown)\n                    sensor = std::get&lt;0&gt;(instruction);\n\n                    SensorDirection direction = Sensors::getSensorDirectionEnum(sensor);\n                    int distance = Sensors::wallDistance(grid, *this, direction);\n\n\n                    resultsList[currentInstructionIndex] = distance;\n\n\n                }\n                else\n                {\n                    // the instruction is an operation (lessthan, greaterthan, equals)\n                    operation = std::get&lt;0&gt;(instruction);\n                    if (operation == \"lessthan\")\n                    {\n                        if (std::get&lt;1&gt;(instruction) &lt; std::get&lt;2&gt;(instruction))\n                        {\n                            resultsList[currentInstructionIndex] = 1;\n                        }\n                        else\n                        {\n                            resultsList[currentInstructionIndex] = 0;\n                            ++currentInstructionIndex;\n                        }\n                    }\n                    else if (operation == \"greaterthan\")\n                    {\n                        if (std::get&lt;1&gt;(instruction) &gt; std::get&lt;2&gt;(instruction))\n                        {\n                            resultsList[currentInstructionIndex] = 1;\n                        }\n                        else\n                        {\n                            resultsList[currentInstructionIndex] = 0;\n                            ++currentInstructionIndex;\n                        }\n                    }\n                    else if (operation == \"equals\")\n                    {\n                        if (std::get&lt;1&gt;(instruction) == std::get&lt;2&gt;(instruction))\n                        {\n                            resultsList[currentInstructionIndex] = 1;\n                        }\n                        else\n                        {\n                            resultsList[currentInstructionIndex] = 0;\n                            ++currentInstructionIndex;\n                        }\n                    }\n                }\n\n                ++currentInstructionIndex;\n                if (currentInstructionIndex &gt;= LISTSIZE)\n                {\n                    currentInstructionIndex = 0;\n                }\n                ++i;\n                instruction = instructionsList[currentInstructionIndex];\n            }\n            if (!action.empty())\n            {\n                return action_map[action];\n            }\n\n            return 0;\n        }\n\n\n        std::string Export() override {\n            std::string encodedLists = \"\";\n\n            for (auto instruction : instructionsList)\n            {\n                encodedLists += std::get&lt;0&gt;(instruction);\n                encodedLists += \".\";\n                encodedLists += std::to_string(std::get&lt;1&gt;(instruction));\n                encodedLists += \".\";\n                encodedLists += std::to_string(std::get&lt;2&gt;(instruction));\n                encodedLists += \",\";\n            }\n\n            encodedLists += \";\";\n\n            for (auto possInstruction : possibleInstructionsList)\n            {\n                encodedLists += possInstruction;\n                encodedLists += \".\";\n            }\n\n            encodedLists += \";\";\n\n            for (auto action : actionsList)\n            {\n                encodedLists += action;\n                encodedLists += \".\";\n            }\n\n            return encodedLists;\n        }\n\n        void SerializeGP(tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement* parentElem, double fitness = -1) override\n        {\n            auto agentElem = doc.NewElement(\"LGPAgent\");\n            parentElem-&gt;InsertEndChild(agentElem);\n\n            auto listElem = doc.NewElement(\"instruction list\");\n            listElem-&gt;SetText(Export().c_str());\n            if (fitness != -1)\n                listElem-&gt;SetAttribute(\"fitness\", fitness);\n            agentElem-&gt;InsertEndChild(listElem);\n        }\n\n        void Import(const std::string &amp; encodedLists) override {\n            std::vector&lt;std::tuple&lt;std::string, int, int&gt;&gt; decodedInstructionsList = {};\n            std::string decodedInstruction;\n            size_t start_pos = 0;\n            size_t first_period_pos;\n            size_t second_period_pos;\n            size_t comma_pos = encodedLists.find(\",\");\n\n            // Load the instruction list\n            while (comma_pos != std::string::npos) {\n                decodedInstruction = encodedLists.substr(start_pos, comma_pos - start_pos);\n                first_period_pos = decodedInstruction.find(\".\");\n                second_period_pos = decodedInstruction.find(\".\", first_period_pos + 1);\n                decodedInstructionsList.push_back(std::make_tuple(decodedInstruction.substr(0, first_period_pos),\n                        std::stoi(decodedInstruction.substr(first_period_pos+1, second_period_pos-first_period_pos+1)), std::stoi(decodedInstruction.substr(second_period_pos+1))));\n\n                start_pos = comma_pos + 1;\n                comma_pos = encodedLists.find(\",\", start_pos);\n            }\n\n            std::vector&lt;std::string&gt; decodedPossInstructionsList = {};\n            std::vector&lt;std::string&gt; decodedActionsList = {};\n            size_t first_semicolon_pos = encodedLists.find(\";\");\n            size_t second_semicolon_pos = encodedLists.find(\";\", first_semicolon_pos+1);\n            std::string unseparated_instruction_list = encodedLists.substr(first_semicolon_pos+1, second_semicolon_pos-first_semicolon_pos+1);\n            std::string unseparated_action_list = encodedLists.substr(second_semicolon_pos+1);\n\n            // Load the list of possible instructions\n            size_t period_pos = unseparated_instruction_list.find(\".\");\n            start_pos = 0;\n            while (period_pos != std::string::npos) {\n                decodedPossInstructionsList.push_back(unseparated_instruction_list.substr(start_pos, period_pos));\n\n                start_pos = period_pos + 1;\n                period_pos = encodedLists.find(\".\", start_pos);\n            }\n\n            // Load the list of actions\n            period_pos = unseparated_action_list.find(\".\");\n            start_pos = 0;\n            while (period_pos != std::string::npos) {\n                decodedActionsList.push_back(unseparated_action_list.substr(start_pos, period_pos));\n\n                start_pos = period_pos + 1;\n                period_pos = encodedLists.find(\".\", start_pos);\n            }\n\n            instructionsList = decodedInstructionsList;\n            possibleInstructionsList = decodedPossInstructionsList;\n            actionsList = decodedActionsList;\n            resultsList.clear();\n            resultsList.resize(LISTSIZE);\n            currentInstructionIndex = 0;\n        }\n\n        void PrintAgent() override {\n            for (auto i = 0; i &lt; LISTSIZE; i++)\n            {\n                std::cout &lt;&lt; std::get&lt;0&gt;(instructionsList[i]) &lt;&lt; \" \";\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n    };\n}\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cowboys An Agent based on genetic programming. <ul> <li>namespace base64 A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x)). </li> </ul> </li> <li>namespace cse491 </li> <li>namespace std </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/","title":"Class Index","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#c","title":"c","text":"<ul> <li>CGPAgent (cowboys)</li> <li>CGPGenotype (cowboys)</li> <li>CGPNodeGene (cowboys)</li> <li>CGPParameters (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#g","title":"g","text":"<ul> <li>GPAgent (cowboys)</li> <li>GPAgentAnalyzer (cowboys)</li> <li>GPAgentBase (cowboys)</li> <li>GPAgentRegisters (cowboys)</li> <li>GPTrainingLoop (cowboys)</li> <li>Graph (cowboys)</li> <li>GraphBuilder (cowboys)</li> <li>GraphNode (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#i","title":"i","text":"<ul> <li>iterator (cowboys::GPAgentRegisters)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#l","title":"l","text":"<ul> <li>LGPAgent (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#n","title":"n","text":"<ul> <li>NodeFunction (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#s","title":"s","text":"<ul> <li>SaveDataParams (cowboys::GPTrainingLoop)</li> <li>Sensors (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class cowboys::CGPGenotype Holds all the information that uniquely defines a cartesian graph. </li> <li>class cowboys::GPAgentAnalyzer </li> <li>class cowboys::GPAgentRegisters Class to hold the registers of the agent. </li> <li>class cowboys::GPAgentRegisters::iterator Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator.</li> <li>class cowboys::GPTrainingLoop </li> <li>class cowboys::Graph A graph of nodes that can be used to make decisions. </li> <li>class cowboys::GraphBuilder A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs.</li> <li>class cowboys::Sensors </li> <li>struct cowboys::CGPNodeGene Holds the representation of a cartesian graph node. </li> <li>struct cowboys::CGPParameters Holds the parameters that define the structure of a cartesian graph. </li> <li>struct cowboys::GPTrainingLoop::SaveDataParams </li> <li>struct cowboys::NodeFunction A function pointer wrapper that holds extra arguments for the function pointer. </li> <li>class AgentBase <ul> <li>class cowboys::GPAgentBase <ul> <li>class cowboys::CGPAgent An agent based on cartesian genetic programming. </li> <li>class cowboys::LGPAgent </li> </ul> </li> <li>class cowboys::GPAgent </li> <li>class cowboys::GPAgentBase <ul> <li>class cowboys::CGPAgent An agent based on cartesian genetic programming. </li> <li>class cowboys::LGPAgent </li> </ul> </li> <li>class cowboys::GPAgentBase <ul> <li>class cowboys::CGPAgent An agent based on cartesian genetic programming. </li> <li>class cowboys::LGPAgent </li> </ul> </li> </ul> </li> <li>class std::enable_shared_from_this&lt; GraphNode &gt; <ul> <li>class cowboys::GraphNode A node in a decision graph. </li> </ul> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/","title":"Class Members","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#a","title":"a","text":"<ul> <li>addAverageFitness (cowboys::GPAgentAnalyzer)</li> <li>addAverageScore (cowboys::GPAgentAnalyzer)</li> <li>addEliteScore (cowboys::GPAgentAnalyzer)</li> <li>addMaxFitness (cowboys::GPAgentAnalyzer)</li> <li>addNumAgentsWithMaxFitness (cowboys::GPAgentAnalyzer)</li> <li>average_fitness (cowboys::GPAgentAnalyzer)</li> <li>average_score (cowboys::GPAgentAnalyzer)</li> <li>AStarFitnessFunction (cowboys::GPTrainingLoop)</li> <li>AgentsAnalysisComputationsAndPrint (cowboys::GPTrainingLoop)</li> <li>agents (cowboys::GPTrainingLoop)</li> <li>allOfLastGeneration (cowboys::GPTrainingLoop)</li> <li>analyzer (cowboys::GPTrainingLoop)</li> <li>AddLayer (cowboys::Graph)</li> <li>AddInput (cowboys::GraphNode)</li> <li>AddInputs (cowboys::GraphNode)</li> <li>AddOutput (cowboys::GraphNode)</li> <li>actionsList (cowboys::LGPAgent)</li> <li>agent (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#b","title":"b","text":"<ul> <li>begin (cowboys::CGPGenotype, cowboys::GPAgentRegisters)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#c","title":"c","text":"<ul> <li>CGPAgent (cowboys::CGPAgent)</li> <li>Configure (cowboys::CGPAgent, cowboys::CGPGenotype, cowboys::LGPAgent)</li> <li>Copy (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>CGPGenotype (cowboys::CGPGenotype)</li> <li>cbegin (cowboys::CGPGenotype)</li> <li>cend (cowboys::CGPGenotype)</li> <li>CGPParameters (cowboys::CGPParameters)</li> <li>checkPointEvery (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>countMaxAgents (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>CartesianGraph (cowboys::GraphBuilder)</li> <li>cached_output (cowboys::GraphNode)</li> <li>cached_output_valid (cowboys::GraphNode)</li> <li>currentInstructionIndex (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#d","title":"d","text":"<ul> <li>decision_graph (cowboys::CGPAgent)</li> <li>DecodeGenotype (cowboys::CGPGenotype)</li> <li>DecodeHeader (cowboys::CGPGenotype)</li> <li>default_output (cowboys::CGPNodeGene, cowboys::GraphNode)</li> <li>dateTimeStr (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>debugPosition (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#e","title":"e","text":"<ul> <li>Export (cowboys::CGPAgent, cowboys::CGPGenotype, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>EncodeGenotype (cowboys::CGPGenotype)</li> <li>EncodeGenotypeRaw (cowboys::CGPGenotype)</li> <li>EncodeHeader (cowboys::CGPGenotype)</li> <li>ExportRaw (cowboys::CGPGenotype)</li> <li>end (cowboys::CGPGenotype, cowboys::GPAgentRegisters)</li> <li>elite_score (cowboys::GPAgentAnalyzer)</li> <li>extra_state (cowboys::GPAgentBase)</li> <li>ELITE_POPULATION_PERCENT (cowboys::GPTrainingLoop)</li> <li>endPositions (cowboys::GPTrainingLoop)</li> <li>environments (cowboys::GPTrainingLoop)</li> <li>EncodeActions (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#f","title":"f","text":"<ul> <li>function_idx (cowboys::CGPNodeGene)</li> <li>FormatPosition (cowboys::GPTrainingLoop)</li> <li>FullLoadGrabLatestGeneration (cowboys::GPTrainingLoop)</li> <li>function_pointer (cowboys::GraphNode)</li> <li>function (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#g","title":"g","text":"<ul> <li>GetAction (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>GetComplexity (cowboys::CGPAgent)</li> <li>GetGenotype (cowboys::CGPAgent)</li> <li>genotype (cowboys::CGPAgent)</li> <li>GetLayersBack (cowboys::CGPGenotype)</li> <li>GetNumConnections (cowboys::CGPGenotype)</li> <li>GetNumFunctionalNodes (cowboys::CGPGenotype)</li> <li>GetNumInputs (cowboys::CGPGenotype)</li> <li>GetNumLayers (cowboys::CGPGenotype)</li> <li>GetNumNodesPerLayer (cowboys::CGPGenotype)</li> <li>GetNumOutputs (cowboys::CGPGenotype)</li> <li>GetNumPossibleConnections (cowboys::CGPGenotype)</li> <li>GetFunctionalNodeCount (cowboys::CGPParameters)</li> <li>GPAgent (cowboys::GPAgent)</li> <li>GPAgentAnalyzer (cowboys::GPAgentAnalyzer)</li> <li>GPAgentBase (cowboys::GPAgentBase)</li> <li>GetExtraState (cowboys::GPAgentBase)</li> <li>GetRandom (cowboys::GPAgentBase)</li> <li>GetRandomNormal (cowboys::GPAgentBase)</li> <li>GetRandomULL (cowboys::GPAgentBase)</li> <li>GetSeed (cowboys::GPAgentBase)</li> <li>GPAgentRegisters (cowboys::GPAgentRegisters)</li> <li>getNumRegisters (cowboys::GPAgentRegisters)</li> <li>getRegister (cowboys::GPAgentRegisters)</li> <li>GPTrainingLoop (cowboys::GPTrainingLoop)</li> <li>Get_A_StarDistance (cowboys::GPTrainingLoop)</li> <li>GpLoopMutateHelper (cowboys::GPTrainingLoop)</li> <li>generation (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>getDateStr (cowboys::GPTrainingLoop)</li> <li>getSystemPath (cowboys::GPTrainingLoop)</li> <li>global_max_threads (cowboys::GPTrainingLoop)</li> <li>GetFunctionalNodes (cowboys::Graph)</li> <li>GetLayerCount (cowboys::Graph)</li> <li>GetNodeCount (cowboys::Graph)</li> <li>GetNodes (cowboys::Graph)</li> <li>Graph (cowboys::Graph)</li> <li>GraphBuilder (cowboys::GraphBuilder)</li> <li>GetDefaultOutput (cowboys::GraphNode)</li> <li>GetInputValues (cowboys::GraphNode)</li> <li>GetOutput (cowboys::GraphNode)</li> <li>GraphNode (cowboys::GraphNode)</li> <li>GenerateRandomActionList (cowboys::LGPAgent)</li> <li>GetInstructionsList (cowboys::LGPAgent)</li> <li>gen (cowboys::LGPAgent)</li> <li>getSensorDirectionEnum (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#h","title":"h","text":"<ul> <li>HasInputConnections (cowboys::CGPGenotype)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#i","title":"i","text":"<ul> <li>Import (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Initialize (cowboys::CGPAgent, cowboys::GPAgent, cowboys::GPAgentBase, cowboys::GPTrainingLoop, cowboys::LGPAgent)</li> <li>InitGenotype (cowboys::CGPGenotype)</li> <li>input_connections (cowboys::CGPNodeGene)</li> <li>index (cowboys::GPAgentRegisters::iterator)</li> <li>iterator (cowboys::GPAgentRegisters::iterator)</li> <li>InitTEMPAgentFitness (cowboys::GPTrainingLoop)</li> <li>independentAgentFitness (cowboys::GPTrainingLoop)</li> <li>IsCacheValid (cowboys::GraphNode)</li> <li>inputs (cowboys::GraphNode)</li> <li>instructionsList (cowboys::LGPAgent)</li> <li>IsNull (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#l","title":"l","text":"<ul> <li>layers_back (cowboys::CGPParameters)</li> <li>lastGenerationsTopAgentsDoc (cowboys::GPTrainingLoop)</li> <li>loadLastGeneration (cowboys::GPTrainingLoop)</li> <li>layers (cowboys::Graph)</li> <li>LGPAgent (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#m","title":"m","text":"<ul> <li>MutateAgent (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Mutate (cowboys::CGPGenotype)</li> <li>MutateConnections (cowboys::CGPGenotype)</li> <li>MutateDefault (cowboys::CGPGenotype)</li> <li>MutateFunctions (cowboys::CGPGenotype)</li> <li>MutateHeader (cowboys::CGPGenotype)</li> <li>MutateOutputs (cowboys::CGPGenotype)</li> <li>movementIndex (cowboys::GPAgent)</li> <li>max_agents (cowboys::GPAgentAnalyzer)</li> <li>max_fitness (cowboys::GPAgentAnalyzer)</li> <li>MemGOBYE (cowboys::GPTrainingLoop)</li> <li>MutateAgents (cowboys::GPTrainingLoop)</li> <li>MutateAndCopyAgents (cowboys::GPTrainingLoop)</li> <li>metaData (cowboys::GPTrainingLoop)</li> <li>MakeDecision (cowboys::Graph)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#n","title":"n","text":"<ul> <li>nodes (cowboys::CGPGenotype)</li> <li>num_inputs (cowboys::CGPParameters)</li> <li>num_layers (cowboys::CGPParameters)</li> <li>num_nodes_per_layer (cowboys::CGPParameters)</li> <li>num_outputs (cowboys::CGPParameters)</li> <li>norm_dist (cowboys::GPAgentBase)</li> <li>normalizedAbsolutePath (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#o","title":"o","text":"<ul> <li>operator= (cowboys::CGPGenotype)</li> <li>operator== (cowboys::CGPGenotype, cowboys::CGPNodeGene, cowboys::CGPParameters, cowboys::GPAgentRegisters::iterator)</li> <li>operator!= (cowboys::GPAgentRegisters::iterator)</li> <li>operator* (cowboys::GPAgentRegisters::iterator)</li> <li>operator++ (cowboys::GPAgentRegisters::iterator)</li> <li>outputs (cowboys::GraphNode)</li> <li>operationsList (cowboys::LGPAgent)</li> <li>operator() (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#p","title":"p","text":"<ul> <li>PrintAgent (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>params (cowboys::CGPGenotype)</li> <li>predefinedMovement (cowboys::GPAgent)</li> <li>Printgrid (cowboys::GPTrainingLoop)</li> <li>possibleInstructionsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#r","title":"r","text":"<ul> <li>Reset (cowboys::GPAgentBase)</li> <li>rng (cowboys::GPAgentBase)</li> <li>registers (cowboys::GPAgentRegisters::iterator, cowboys::GPAgentRegisters)</li> <li>ResetMainTagLastGenerations (cowboys::GPTrainingLoop)</li> <li>Run (cowboys::GPTrainingLoop)</li> <li>RunArena (cowboys::GPTrainingLoop)</li> <li>resetEnvironments (cowboys::GPTrainingLoop)</li> <li>rollingRandomSeed (cowboys::GPTrainingLoop)</li> <li>rootAllOfLastGeneration (cowboys::GPTrainingLoop)</li> <li>rootMetaData (cowboys::GPTrainingLoop)</li> <li>rootTopAllGenerations (cowboys::GPTrainingLoop)</li> <li>rootTopLastGenerations (cowboys::GPTrainingLoop)</li> <li>RecursiveInvalidateCache (cowboys::GraphNode)</li> <li>rd (cowboys::LGPAgent)</li> <li>resultsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#s","title":"s","text":"<ul> <li>SerializeGP (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>SetParameters (cowboys::CGPGenotype)</li> <li>SelectAction (cowboys::GPAgent, cowboys::GPAgentBase)</li> <li>saveToFile (cowboys::GPAgentAnalyzer)</li> <li>SetSeed (cowboys::GPAgentBase)</li> <li>seed (cowboys::GPAgentBase)</li> <li>setRegister (cowboys::GPAgentRegisters)</li> <li>size (cowboys::GPAgentRegisters)</li> <li>STARTPOSITIONS (cowboys::GPTrainingLoop)</li> <li>SaveDataCheckPoint (cowboys::GPTrainingLoop)</li> <li>ScavengerQueuing (cowboys::GPTrainingLoop)</li> <li>SerializeAgents (cowboys::GPTrainingLoop)</li> <li>SimpleFitnessFunction (cowboys::GPTrainingLoop)</li> <li>SortThemAgents (cowboys::GPTrainingLoop)</li> <li>SaveDataParams (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>save (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveAllAgentData (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveLastGenerations (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveMetaData (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveTopAgents (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveXMLDoc (cowboys::GPTrainingLoop)</li> <li>sortedAgents (cowboys::GPTrainingLoop)</li> <li>SetDefaultOutput (cowboys::GraphNode)</li> <li>SetFunctionPointer (cowboys::GraphNode)</li> <li>SetInputs (cowboys::GraphNode)</li> <li>sensorsNamesList (cowboys::LGPAgent)</li> <li>Sensors (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#t","title":"t","text":"<ul> <li>TEMPAgentFitness (cowboys::GPTrainingLoop)</li> <li>ThreadTrainLoop (cowboys::GPTrainingLoop)</li> <li>topAgentsDoc (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#u","title":"u","text":"<ul> <li>uni_dist (cowboys::GPAgentBase)</li> <li>UNFIT_POPULATION_PERCENT (cowboys::GPTrainingLoop)</li> <li>updateGeneration (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#v","title":"v","text":"<ul> <li>VerticalPacer (cowboys::GraphBuilder)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#w","title":"w","text":"<ul> <li>wallDistance (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#_1","title":"~","text":"<ul> <li>~CGPGenotype (cowboys::CGPGenotype)</li> <li>~GPAgent (cowboys::GPAgent)</li> <li>~GPAgentAnalyzer (cowboys::GPAgentAnalyzer)</li> <li>~GPAgentBase (cowboys::GPAgentBase)</li> <li>~GPAgentRegisters (cowboys::GPAgentRegisters)</li> <li>~GPTrainingLoop (cowboys::GPTrainingLoop)</li> <li>~Graph (cowboys::Graph)</li> <li>~GraphBuilder (cowboys::GraphBuilder)</li> <li>~GraphNode (cowboys::GraphNode)</li> <li>~Sensors (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#a","title":"a","text":"<ul> <li>addAverageFitness (cowboys::GPAgentAnalyzer)</li> <li>addAverageScore (cowboys::GPAgentAnalyzer)</li> <li>addEliteScore (cowboys::GPAgentAnalyzer)</li> <li>addMaxFitness (cowboys::GPAgentAnalyzer)</li> <li>addNumAgentsWithMaxFitness (cowboys::GPAgentAnalyzer)</li> <li>AStarFitnessFunction (cowboys::GPTrainingLoop)</li> <li>AgentsAnalysisComputationsAndPrint (cowboys::GPTrainingLoop)</li> <li>AddLayer (cowboys::Graph)</li> <li>AddInput (cowboys::GraphNode)</li> <li>AddInputs (cowboys::GraphNode)</li> <li>AddOutput (cowboys::GraphNode)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#b","title":"b","text":"<ul> <li>begin (cowboys::CGPGenotype, cowboys::GPAgentRegisters)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#c","title":"c","text":"<ul> <li>CGPAgent (cowboys::CGPAgent)</li> <li>Configure (cowboys::CGPAgent, cowboys::CGPGenotype, cowboys::LGPAgent)</li> <li>Copy (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>CGPGenotype (cowboys::CGPGenotype)</li> <li>cbegin (cowboys::CGPGenotype)</li> <li>cend (cowboys::CGPGenotype)</li> <li>CGPParameters (cowboys::CGPParameters)</li> <li>CartesianGraph (cowboys::GraphBuilder)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#d","title":"d","text":"<ul> <li>DecodeGenotype (cowboys::CGPGenotype)</li> <li>DecodeHeader (cowboys::CGPGenotype)</li> <li>debugPosition (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#e","title":"e","text":"<ul> <li>Export (cowboys::CGPAgent, cowboys::CGPGenotype, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>EncodeGenotype (cowboys::CGPGenotype)</li> <li>EncodeGenotypeRaw (cowboys::CGPGenotype)</li> <li>EncodeHeader (cowboys::CGPGenotype)</li> <li>ExportRaw (cowboys::CGPGenotype)</li> <li>end (cowboys::CGPGenotype, cowboys::GPAgentRegisters)</li> <li>EncodeActions (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#f","title":"f","text":"<ul> <li>FormatPosition (cowboys::GPTrainingLoop)</li> <li>FullLoadGrabLatestGeneration (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#g","title":"g","text":"<ul> <li>GetAction (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>GetComplexity (cowboys::CGPAgent)</li> <li>GetGenotype (cowboys::CGPAgent)</li> <li>GetLayersBack (cowboys::CGPGenotype)</li> <li>GetNumConnections (cowboys::CGPGenotype)</li> <li>GetNumFunctionalNodes (cowboys::CGPGenotype)</li> <li>GetNumInputs (cowboys::CGPGenotype)</li> <li>GetNumLayers (cowboys::CGPGenotype)</li> <li>GetNumNodesPerLayer (cowboys::CGPGenotype)</li> <li>GetNumOutputs (cowboys::CGPGenotype)</li> <li>GetNumPossibleConnections (cowboys::CGPGenotype)</li> <li>GetFunctionalNodeCount (cowboys::CGPParameters)</li> <li>GPAgent (cowboys::GPAgent)</li> <li>GPAgentAnalyzer (cowboys::GPAgentAnalyzer)</li> <li>GPAgentBase (cowboys::GPAgentBase)</li> <li>GetExtraState (cowboys::GPAgentBase)</li> <li>GetRandom (cowboys::GPAgentBase)</li> <li>GetRandomNormal (cowboys::GPAgentBase)</li> <li>GetRandomULL (cowboys::GPAgentBase)</li> <li>GetSeed (cowboys::GPAgentBase)</li> <li>GPAgentRegisters (cowboys::GPAgentRegisters)</li> <li>getNumRegisters (cowboys::GPAgentRegisters)</li> <li>getRegister (cowboys::GPAgentRegisters)</li> <li>GPTrainingLoop (cowboys::GPTrainingLoop)</li> <li>Get_A_StarDistance (cowboys::GPTrainingLoop)</li> <li>GpLoopMutateHelper (cowboys::GPTrainingLoop)</li> <li>getDateStr (cowboys::GPTrainingLoop)</li> <li>getSystemPath (cowboys::GPTrainingLoop)</li> <li>GetFunctionalNodes (cowboys::Graph)</li> <li>GetLayerCount (cowboys::Graph)</li> <li>GetNodeCount (cowboys::Graph)</li> <li>GetNodes (cowboys::Graph)</li> <li>Graph (cowboys::Graph)</li> <li>GraphBuilder (cowboys::GraphBuilder)</li> <li>GetDefaultOutput (cowboys::GraphNode)</li> <li>GetInputValues (cowboys::GraphNode)</li> <li>GetOutput (cowboys::GraphNode)</li> <li>GraphNode (cowboys::GraphNode)</li> <li>GenerateRandomActionList (cowboys::LGPAgent)</li> <li>GetInstructionsList (cowboys::LGPAgent)</li> <li>getSensorDirectionEnum (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#h","title":"h","text":"<ul> <li>HasInputConnections (cowboys::CGPGenotype)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#i","title":"i","text":"<ul> <li>Import (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Initialize (cowboys::CGPAgent, cowboys::GPAgent, cowboys::GPAgentBase, cowboys::GPTrainingLoop, cowboys::LGPAgent)</li> <li>InitGenotype (cowboys::CGPGenotype)</li> <li>iterator (cowboys::GPAgentRegisters::iterator)</li> <li>InitTEMPAgentFitness (cowboys::GPTrainingLoop)</li> <li>IsCacheValid (cowboys::GraphNode)</li> <li>IsNull (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#l","title":"l","text":"<ul> <li>loadLastGeneration (cowboys::GPTrainingLoop)</li> <li>LGPAgent (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#m","title":"m","text":"<ul> <li>MutateAgent (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Mutate (cowboys::CGPGenotype)</li> <li>MutateConnections (cowboys::CGPGenotype)</li> <li>MutateDefault (cowboys::CGPGenotype)</li> <li>MutateFunctions (cowboys::CGPGenotype)</li> <li>MutateHeader (cowboys::CGPGenotype)</li> <li>MutateOutputs (cowboys::CGPGenotype)</li> <li>MemGOBYE (cowboys::GPTrainingLoop)</li> <li>MutateAgents (cowboys::GPTrainingLoop)</li> <li>MutateAndCopyAgents (cowboys::GPTrainingLoop)</li> <li>MakeDecision (cowboys::Graph)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (cowboys::CGPGenotype)</li> <li>operator== (cowboys::CGPGenotype, cowboys::CGPNodeGene, cowboys::CGPParameters, cowboys::GPAgentRegisters::iterator)</li> <li>operator!= (cowboys::GPAgentRegisters::iterator)</li> <li>operator* (cowboys::GPAgentRegisters::iterator)</li> <li>operator++ (cowboys::GPAgentRegisters::iterator)</li> <li>operator() (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#p","title":"p","text":"<ul> <li>PrintAgent (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Printgrid (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#r","title":"r","text":"<ul> <li>Reset (cowboys::GPAgentBase)</li> <li>ResetMainTagLastGenerations (cowboys::GPTrainingLoop)</li> <li>Run (cowboys::GPTrainingLoop)</li> <li>RunArena (cowboys::GPTrainingLoop)</li> <li>resetEnvironments (cowboys::GPTrainingLoop)</li> <li>RecursiveInvalidateCache (cowboys::GraphNode)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#s","title":"s","text":"<ul> <li>SerializeGP (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>SetParameters (cowboys::CGPGenotype)</li> <li>SelectAction (cowboys::GPAgent, cowboys::GPAgentBase)</li> <li>saveToFile (cowboys::GPAgentAnalyzer)</li> <li>SetSeed (cowboys::GPAgentBase)</li> <li>setRegister (cowboys::GPAgentRegisters)</li> <li>size (cowboys::GPAgentRegisters)</li> <li>SaveDataCheckPoint (cowboys::GPTrainingLoop)</li> <li>SerializeAgents (cowboys::GPTrainingLoop)</li> <li>SimpleFitnessFunction (cowboys::GPTrainingLoop)</li> <li>SortThemAgents (cowboys::GPTrainingLoop)</li> <li>SaveDataParams (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveXMLDoc (cowboys::GPTrainingLoop)</li> <li>SetDefaultOutput (cowboys::GraphNode)</li> <li>SetFunctionPointer (cowboys::GraphNode)</li> <li>SetInputs (cowboys::GraphNode)</li> <li>Sensors (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#t","title":"t","text":"<ul> <li>ThreadTrainLoop (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#u","title":"u","text":"<ul> <li>updateGeneration (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#v","title":"v","text":"<ul> <li>VerticalPacer (cowboys::GraphBuilder)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#w","title":"w","text":"<ul> <li>wallDistance (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~CGPGenotype (cowboys::CGPGenotype)</li> <li>~GPAgent (cowboys::GPAgent)</li> <li>~GPAgentAnalyzer (cowboys::GPAgentAnalyzer)</li> <li>~GPAgentBase (cowboys::GPAgentBase)</li> <li>~GPAgentRegisters (cowboys::GPAgentRegisters)</li> <li>~GPTrainingLoop (cowboys::GPTrainingLoop)</li> <li>~Graph (cowboys::Graph)</li> <li>~GraphBuilder (cowboys::GraphBuilder)</li> <li>~GraphNode (cowboys::GraphNode)</li> <li>~Sensors (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#a","title":"a","text":"<ul> <li>average_fitness (cowboys::GPAgentAnalyzer)</li> <li>average_score (cowboys::GPAgentAnalyzer)</li> <li>agents (cowboys::GPTrainingLoop)</li> <li>allOfLastGeneration (cowboys::GPTrainingLoop)</li> <li>analyzer (cowboys::GPTrainingLoop)</li> <li>actionsList (cowboys::LGPAgent)</li> <li>agent (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#c","title":"c","text":"<ul> <li>checkPointEvery (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>countMaxAgents (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>cached_output (cowboys::GraphNode)</li> <li>cached_output_valid (cowboys::GraphNode)</li> <li>currentInstructionIndex (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#d","title":"d","text":"<ul> <li>decision_graph (cowboys::CGPAgent)</li> <li>default_output (cowboys::CGPNodeGene, cowboys::GraphNode)</li> <li>dateTimeStr (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#e","title":"e","text":"<ul> <li>elite_score (cowboys::GPAgentAnalyzer)</li> <li>extra_state (cowboys::GPAgentBase)</li> <li>ELITE_POPULATION_PERCENT (cowboys::GPTrainingLoop)</li> <li>endPositions (cowboys::GPTrainingLoop)</li> <li>environments (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#f","title":"f","text":"<ul> <li>function_idx (cowboys::CGPNodeGene)</li> <li>function_pointer (cowboys::GraphNode)</li> <li>function (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#g","title":"g","text":"<ul> <li>genotype (cowboys::CGPAgent)</li> <li>generation (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>global_max_threads (cowboys::GPTrainingLoop)</li> <li>gen (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#i","title":"i","text":"<ul> <li>input_connections (cowboys::CGPNodeGene)</li> <li>index (cowboys::GPAgentRegisters::iterator)</li> <li>independentAgentFitness (cowboys::GPTrainingLoop)</li> <li>inputs (cowboys::GraphNode)</li> <li>instructionsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#l","title":"l","text":"<ul> <li>layers_back (cowboys::CGPParameters)</li> <li>lastGenerationsTopAgentsDoc (cowboys::GPTrainingLoop)</li> <li>layers (cowboys::Graph)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#m","title":"m","text":"<ul> <li>movementIndex (cowboys::GPAgent)</li> <li>max_agents (cowboys::GPAgentAnalyzer)</li> <li>max_fitness (cowboys::GPAgentAnalyzer)</li> <li>metaData (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#n","title":"n","text":"<ul> <li>nodes (cowboys::CGPGenotype)</li> <li>num_inputs (cowboys::CGPParameters)</li> <li>num_layers (cowboys::CGPParameters)</li> <li>num_nodes_per_layer (cowboys::CGPParameters)</li> <li>num_outputs (cowboys::CGPParameters)</li> <li>norm_dist (cowboys::GPAgentBase)</li> <li>normalizedAbsolutePath (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#o","title":"o","text":"<ul> <li>outputs (cowboys::GraphNode)</li> <li>operationsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#p","title":"p","text":"<ul> <li>params (cowboys::CGPGenotype)</li> <li>predefinedMovement (cowboys::GPAgent)</li> <li>possibleInstructionsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#r","title":"r","text":"<ul> <li>rng (cowboys::GPAgentBase)</li> <li>registers (cowboys::GPAgentRegisters::iterator, cowboys::GPAgentRegisters)</li> <li>rollingRandomSeed (cowboys::GPTrainingLoop)</li> <li>rootAllOfLastGeneration (cowboys::GPTrainingLoop)</li> <li>rootMetaData (cowboys::GPTrainingLoop)</li> <li>rootTopAllGenerations (cowboys::GPTrainingLoop)</li> <li>rootTopLastGenerations (cowboys::GPTrainingLoop)</li> <li>rd (cowboys::LGPAgent)</li> <li>resultsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#s","title":"s","text":"<ul> <li>seed (cowboys::GPAgentBase)</li> <li>STARTPOSITIONS (cowboys::GPTrainingLoop)</li> <li>ScavengerQueuing (cowboys::GPTrainingLoop)</li> <li>save (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveAllAgentData (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveLastGenerations (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveMetaData (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveTopAgents (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>sortedAgents (cowboys::GPTrainingLoop)</li> <li>sensorsNamesList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#t","title":"t","text":"<ul> <li>TEMPAgentFitness (cowboys::GPTrainingLoop)</li> <li>topAgentsDoc (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#u","title":"u","text":"<ul> <li>uni_dist (cowboys::GPAgentBase)</li> <li>UNFIT_POPULATION_PERCENT (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/","title":"Namespace Members","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#a","title":"a","text":"<ul> <li>AStarDistance (cowboys)</li> <li>And (cowboys)</li> <li>AnyEq (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#b","title":"b","text":"<ul> <li>B2ToB64 (cowboys::base64)</li> <li>B64ToB2 (cowboys::base64)</li> <li>B64ToDouble (cowboys::base64)</li> <li>B64ToULL (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#c","title":"c","text":"<ul> <li>Cos (cowboys)</li> <li>CHARS (cowboys::base64)</li> <li>CHAR_TO_IDX (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#d","title":"d","text":"<ul> <li>DoubleToB64 (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#e","title":"e","text":"<ul> <li>EncodeActions (cowboys)</li> <li>EncodeState (cowboys)</li> <li>Exp (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#f","title":"f","text":"<ul> <li>FUNCTION_SET (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#g","title":"g","text":"<ul> <li>Gate (cowboys)</li> <li>GraphLayer (cowboys)</li> <li>GreaterThan (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#h","title":"h","text":"<ul> <li>HEADER_END (cowboys)</li> <li>HEADER_SEP (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#i","title":"i","text":"<ul> <li>INPUT_SIZE (cowboys)</li> <li>InnerFunction (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#l","title":"l","text":"<ul> <li>LAYERS_BACK (cowboys)</li> <li>LISTSIZE (cowboys)</li> <li>LessThan (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#m","title":"m","text":"<ul> <li>Max (cowboys)</li> <li>Min (cowboys)</li> <li>MAX_CHAR (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#n","title":"n","text":"<ul> <li>NODE_FUNCTION_SET (cowboys)</li> <li>NODE_GENE_SEP (cowboys)</li> <li>NODE_SEP (cowboys)</li> <li>NUM_LAYERS (cowboys)</li> <li>NUM_NODES_PER_LAYER (cowboys)</li> <li>NegClamp (cowboys)</li> <li>NegSum (cowboys)</li> <li>Not (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#p","title":"p","text":"<ul> <li>PosClamp (cowboys)</li> <li>Product (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#r","title":"r","text":"<ul> <li>Reciprocal (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#s","title":"s","text":"<ul> <li>SENSOR_FUNCTION_SET (cowboys)</li> <li>SensorDirection (cowboys)</li> <li>Sin (cowboys)</li> <li>Sqrt (cowboys)</li> <li>Square (cowboys)</li> <li>Sum (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#t","title":"t","text":"<ul> <li>TRAINING_SEED (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#u","title":"u","text":"<ul> <li>ULLToB64 (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#w","title":"w","text":"<ul> <li>WALL (cowboys)</li> <li>WallDistanceDown (cowboys)</li> <li>WallDistanceLeft (cowboys)</li> <li>WallDistanceRight (cowboys)</li> <li>WallDistanceUp (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#a","title":"a","text":"<ul> <li>AStarDistance (cowboys)</li> <li>And (cowboys)</li> <li>AnyEq (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#b","title":"b","text":"<ul> <li>B2ToB64 (cowboys::base64)</li> <li>B64ToB2 (cowboys::base64)</li> <li>B64ToDouble (cowboys::base64)</li> <li>B64ToULL (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#c","title":"c","text":"<ul> <li>Cos (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#d","title":"d","text":"<ul> <li>DoubleToB64 (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#e","title":"e","text":"<ul> <li>EncodeActions (cowboys)</li> <li>EncodeState (cowboys)</li> <li>Exp (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#g","title":"g","text":"<ul> <li>Gate (cowboys)</li> <li>GreaterThan (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#l","title":"l","text":"<ul> <li>LessThan (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#m","title":"m","text":"<ul> <li>Max (cowboys)</li> <li>Min (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#n","title":"n","text":"<ul> <li>NegClamp (cowboys)</li> <li>NegSum (cowboys)</li> <li>Not (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#p","title":"p","text":"<ul> <li>PosClamp (cowboys)</li> <li>Product (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#r","title":"r","text":"<ul> <li>Reciprocal (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#s","title":"s","text":"<ul> <li>Sin (cowboys)</li> <li>Sqrt (cowboys)</li> <li>Square (cowboys)</li> <li>Sum (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#u","title":"u","text":"<ul> <li>ULLToB64 (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#w","title":"w","text":"<ul> <li>WallDistanceDown (cowboys)</li> <li>WallDistanceLeft (cowboys)</li> <li>WallDistanceRight (cowboys)</li> <li>WallDistanceUp (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#c","title":"c","text":"<ul> <li>CHARS (cowboys::base64)</li> <li>CHAR_TO_IDX (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#f","title":"f","text":"<ul> <li>FUNCTION_SET (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#h","title":"h","text":"<ul> <li>HEADER_END (cowboys)</li> <li>HEADER_SEP (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#i","title":"i","text":"<ul> <li>INPUT_SIZE (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#l","title":"l","text":"<ul> <li>LAYERS_BACK (cowboys)</li> <li>LISTSIZE (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_CHAR (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#n","title":"n","text":"<ul> <li>NODE_FUNCTION_SET (cowboys)</li> <li>NODE_GENE_SEP (cowboys)</li> <li>NODE_SEP (cowboys)</li> <li>NUM_LAYERS (cowboys)</li> <li>NUM_NODES_PER_LAYER (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#s","title":"s","text":"<ul> <li>SENSOR_FUNCTION_SET (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#t","title":"t","text":"<ul> <li>TRAINING_SEED (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#w","title":"w","text":"<ul> <li>WALL (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_typedefs/#g","title":"g","text":"<ul> <li>GraphLayer (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>InnerFunction (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_enums/#s","title":"s","text":"<ul> <li>SensorDirection (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/macros/","title":"Macros","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/macros/#p","title":"p","text":"<ul> <li>PAR (GraphNode.hpp)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cse491 A World that consists only of walls and open cells. <ul> <li>class MazeWorld </li> </ul> </li> <li>namespace cse491_team8 A World that consists of trees, water, and grass cells. <ul> <li>class ManualWorld </li> </ul> </li> <li>namespace group4 <ul> <li>class SecondWorld </li> </ul> </li> <li>namespace group6 A World that consists only of walls and open cells. <ul> <li>class BiomeGenerator </li> <li>class GenerativeWorld </li> </ul> </li> <li>namespace siv <ul> <li>class BasicPerlinNoise </li> <li>namespace perlin_detail </li> </ul> </li> <li>namespace std </li> <li>namespace tao <ul> <li>namespace pegtl </li> </ul> </li> <li>namespace worldlang Namespace for scripting language stuff. <ul> <li>class ProgramExecutor Class that manages program execution. <ul> <li>struct Identifier </li> </ul> </li> <li>struct Unit </li> <li>struct add </li> <li>struct add_a </li> <li>struct assignment </li> <li>struct code_block </li> <li>struct comment </li> <li>struct comp </li> <li>struct comp_a </li> <li>struct element </li> <li>struct expression </li> <li>struct expression_list </li> <li>struct function </li> <li>struct identifier </li> <li>struct identifier_list </li> <li>struct mul </li> <li>struct mul_a </li> <li>struct number </li> <li>struct op_prio_add </li> <li>struct op_prio_comp </li> <li>struct op_prio_mul </li> <li>struct program </li> <li>struct statement </li> <li>struct statement_list </li> <li>struct string </li> </ul> </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Worlds <ul> <li>file BiomeGenerator.cpp </li> <li>file BiomeGenerator.hpp </li> <li>file GenerativeWorld.hpp </li> <li>file Language.hpp </li> <li>file ManualWorld.hpp </li> <li>file MazeWorld.hpp </li> <li>file PerlinNoise.hpp </li> <li>file ProgramExecutor.hpp </li> <li>file SecondWorld.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>A World that consists only of walls and open cells. More...</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491/#classes","title":"Classes","text":"Type Name class MazeWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/MazeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/","title":"Class cse491::MazeWorld","text":"<p>ClassList &gt; cse491 &gt; MazeWorld</p> <p>Inherits the following classes: WorldBase</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#public-functions","title":"Public Functions","text":"Type Name void ConfigAgent (AgentBase &amp; agent) override const void ConfigAgent (AgentBase &amp; agent) override int DoAction (AgentBase &amp; agent, size_t action_id) overrideAllow the agents to move around the maze. bool IsTraversable (const AgentBase &amp;, cse491::GridPosition pos) override const MazeWorld (unsigned int seed=0)  ~MazeWorld () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#protected-types","title":"Protected Types","text":"Type Name enum ActionType"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t floor_id Easy access to floor CellType ID. size_t wall_id Easy access to wall CellType ID."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-configagent-12","title":"function ConfigAgent [1/2]","text":"<pre><code>inline void cse491::MazeWorld::ConfigAgent (\n    AgentBase &amp; agent\n) override const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-configagent-22","title":"function ConfigAgent [2/2]","text":"<pre><code>inline void cse491::MazeWorld::ConfigAgent (\n    AgentBase &amp; agent\n) override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-doaction","title":"function DoAction","text":"<pre><code>inline int cse491::MazeWorld::DoAction (\n    AgentBase &amp; agent,\n    size_t action_id\n) override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-istraversable","title":"function IsTraversable","text":"<pre><code>inline bool cse491::MazeWorld::IsTraversable (\n    const AgentBase &amp;,\n    cse491::GridPosition pos\n) override const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-mazeworld","title":"function MazeWorld","text":"<pre><code>inline cse491::MazeWorld::MazeWorld (\n    unsigned int seed=0\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-mazeworld_1","title":"function ~MazeWorld","text":"<pre><code>cse491::MazeWorld::~MazeWorld () = default\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#enum-actiontype","title":"enum ActionType","text":"<pre><code>enum cse491::MazeWorld::ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    MOVE_ARBITRARY\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#variable-floor_id","title":"variable floor_id","text":"<pre><code>size_t floor_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#variable-wall_id","title":"variable wall_id","text":"<pre><code>size_t wall_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/MazeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491__team8/","title":"Namespace cse491_team8","text":"<p>Namespace List &gt; cse491_team8</p> <p>A World that consists of trees, water, and grass cells. More...</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491__team8/#classes","title":"Classes","text":"Type Name class ManualWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491__team8/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>Evan Orvis </p> <p>Author:</p> <p>Grant Carr </p> <p>Author:</p> <p>Lauren Garvey </p> <p>Author:</p> <p>Nate Gu REVIEW UPDATES * Many functions that used to take item or agent pointers now take references! </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/ManualWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/","title":"Class cse491_team8::ManualWorld","text":"<p>ClassList &gt; cse491_team8 &gt; ManualWorld</p> <p>Inherits the following classes: WorldBase</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#public-functions","title":"Public Functions","text":"Type Name void AddMove (cse491::AgentBase &amp; agent, std::string &amp; move, char stat, double modification) adds a move to the move set for an agent int DoAction (cse491::AgentBase &amp; agent, size_t action_id) overrideCentral function for an agent to take any action. void DoActionAttemptItemPickup (cse491::AgentBase &amp; agent, const cse491::GridPosition &amp; new_position) Attempt to pick up an item for the agent. cse491::GridPosition DoActionFindNewPosition (cse491::AgentBase &amp; agent, size_t action_id) Updates agent's position and direction. void DoActionTestNewPositionTree (cse491::AgentBase &amp; agent, const cse491::GridPosition &amp; new_position) Attempt to interact with a tree If the agent can interact with the tree, prompts the user if they want to use one of their chops. bool DoActionTestNewPositionWater (cse491::AgentBase &amp; agent) Attempt to float on a water tile If the agent has a boat, prompts the user if they want to use the boat once. void DoBattle (cse491::AgentBase &amp; other_agent, cse491::AgentBase &amp; agent, char attack_type) Checks the strength between two agents. void DropItems (cse491::AgentBase &amp; agent, cse491::AgentBase &amp; other_agent) Removes all items from other agent. size_t FindItem (cse491::AgentBase &amp; agent, const std::string &amp; item_name) Check if an agent owns an item. void GenerateMoveSets () Generates move sets for all the agents Sets the move sets as a property for each agent. void HealAction (cse491::AgentBase &amp; agent) Heals an Agent. bool IsTraversable (const cse491::AgentBase &amp;, cse491::GridPosition pos) override constDetermine if this tile can be walked on, defaults to every tile is walkable. cse491::GridPosition LookAhead (cse491::AgentBase &amp; agent) looks one tile ahead of the agent based on facing direction ManualWorld ()  void MoveSetAction (cse491::AgentBase &amp; agent) Displays the moveset for the agent. int OtherAction (cse491::AgentBase &amp; other_agent, cse491::AgentBase &amp; agent) Determines the damage of the other agent. bool RemoveMove (cse491::AgentBase &amp; agent, std::string &amp; move) removes a move from the move set for an agent void Run () overrideRuns agents, updates the world. void RunAgents () overrideStep through each agent giving them a chance to take an action. void StatsAction (cse491::AgentBase &amp; agent) Displays the items and properties that the player has. void UpdateWorld () overrideLooks for adjacencies. ~ManualWorld () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-types","title":"Protected Types","text":"Type Name enum ActionType enum FacingDirection"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t bridge_id Easy access to bridge CellType ID. size_t grass_id Easy access to floor CellType ID. size_t portal_id_a Easy access to first portal CellType ID. size_t portal_id_b Easy access to second portal CellType ID. size_t portal_id_c Easy access to third portal CellType ID. size_t portal_id_d Easy access to fourth portal CellType ID. size_t rock_id Easy access to rock CellType ID. size_t tree_id Easy access to tree CellType ID. size_t water_id Easy access to water CellType ID."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-functions","title":"Protected Functions","text":"Type Name void ConfigAgent (cse491::AgentBase &amp; agent) overrideProvide the agent with movement actions."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-addmove","title":"function AddMove","text":"<p>adds a move to the move set for an agent </p> <pre><code>inline void cse491_team8::ManualWorld::AddMove (\n    cse491::AgentBase &amp; agent,\n    std::string &amp; move,\n    char stat,\n    double modification\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> the agent to add the move to </li> <li><code>move</code> the name of the move to add </li> <li><code>stat</code> the stat that the move affects </li> <li><code>modification</code> the modification percent of the move to that stat Adds a move to the move set map </li> </ul> <p>Returns:</p> <p>None </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doaction","title":"function DoAction","text":"<p>Central function for an agent to take any action. </p> <pre><code>inline int cse491_team8::ManualWorld::DoAction (\n    cse491::AgentBase &amp; agent,\n    size_t action_id\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The specific agent taking the action </li> <li><code>action</code> The id of the action to take </li> </ul> <p>Returns:</p> <p>The result of this action (usually 0/1 to indicate success) </p> <p>Note:</p> <p>Thus function must be overridden in any derived world. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doactionattemptitempickup","title":"function DoActionAttemptItemPickup","text":"<p>Attempt to pick up an item for the agent. </p> <pre><code>inline void cse491_team8::ManualWorld::DoActionAttemptItemPickup (\n    cse491::AgentBase &amp; agent,\n    const cse491::GridPosition &amp; new_position\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that is picking up the item. </li> <li><code>new_position</code> New position of the agent to check if an item is there. </li> </ul> <p>Returns:</p> <p>Nothing </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doactionfindnewposition","title":"function DoActionFindNewPosition","text":"<p>Updates agent's position and direction. </p> <pre><code>inline cse491::GridPosition cse491_team8::ManualWorld::DoActionFindNewPosition (\n    cse491::AgentBase &amp; agent,\n    size_t action_id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that is moving its position </li> <li><code>action_id</code> A size_t representing the direction the agent moved </li> </ul> <p>Returns:</p> <p>The agent's new position </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doactiontestnewpositiontree","title":"function DoActionTestNewPositionTree","text":"<p>Attempt to interact with a tree If the agent can interact with the tree, prompts the user if they want to use one of their chops. </p> <pre><code>inline void cse491_team8::ManualWorld::DoActionTestNewPositionTree (\n    cse491::AgentBase &amp; agent,\n    const cse491::GridPosition &amp; new_position\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent trying to interact </li> <li><code>new_position</code> The position being interacted with </li> </ul> <p>Returns:</p> <p>Nothing, the tree gets chopped if possible but the agent doesn't move </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doactiontestnewpositionwater","title":"function DoActionTestNewPositionWater","text":"<p>Attempt to float on a water tile If the agent has a boat, prompts the user if they want to use the boat once. </p> <pre><code>inline bool cse491_team8::ManualWorld::DoActionTestNewPositionWater (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent trying to interact </li> </ul> <p>Returns:</p> <p>True if the agent is able to (and chooses) to move to the new spot, else false </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-dobattle","title":"function DoBattle","text":"<p>Checks the strength between two agents. </p> <pre><code>inline void cse491_team8::ManualWorld::DoBattle (\n    cse491::AgentBase &amp; other_agent,\n    cse491::AgentBase &amp; agent,\n    char attack_type\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other_agent</code> The autonomous agent to compare </li> <li><code>agent</code> The interface (player) agent to compare </li> <li><code>attack_type</code> The attack that is being used by the player Prints the stronger agent and removes the weaker </li> </ul> <p>See also: RemoveAgent </p> <p>Returns:</p> <p>None </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-dropitems","title":"function DropItems","text":"<p>Removes all items from other agent. </p> <pre><code>inline void cse491_team8::ManualWorld::DropItems (\n    cse491::AgentBase &amp; agent,\n    cse491::AgentBase &amp; other_agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> Agent that won the battle </li> <li><code>other_agent</code> Agent that is dropping items </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-finditem","title":"function FindItem","text":"<p>Check if an agent owns an item. </p> <pre><code>inline size_t cse491_team8::ManualWorld::FindItem (\n    cse491::AgentBase &amp; agent,\n    const std::string &amp; item_name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent to see if is an owner </li> <li><code>item_name</code> Name of the item </li> </ul> <p>Returns:</p> <p>item_id </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-generatemovesets","title":"function GenerateMoveSets","text":"<p>Generates move sets for all the agents Sets the move sets as a property for each agent. </p> <pre><code>inline void cse491_team8::ManualWorld::GenerateMoveSets () \n</code></pre> <p>Returns:</p> <p>None </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-healaction","title":"function HealAction","text":"<p>Heals an Agent. </p> <pre><code>inline void cse491_team8::ManualWorld::HealAction (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The Agent getting healed Calculates the healing of the agent </li> </ul> <p>Returns:</p> <p>None </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-istraversable","title":"function IsTraversable","text":"<p>Determine if this tile can be walked on, defaults to every tile is walkable. </p> <pre><code>inline bool cse491_team8::ManualWorld::IsTraversable (\n    const cse491::AgentBase &amp;,\n    cse491::GridPosition pos\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position we are checking </li> </ul> <p>Returns:</p> <p>If an agent should be allowed on this square </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-lookahead","title":"function LookAhead","text":"<p>looks one tile ahead of the agent based on facing direction </p> <pre><code>inline cse491::GridPosition cse491_team8::ManualWorld::LookAhead (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> Agent that is looking ahead </li> </ul> <p>Returns:</p> <p>the grid position </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-manualworld","title":"function ManualWorld","text":"<pre><code>inline cse491_team8::ManualWorld::ManualWorld () \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-movesetaction","title":"function MoveSetAction","text":"<p>Displays the moveset for the agent. </p> <pre><code>inline void cse491_team8::ManualWorld::MoveSetAction (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> Agent moveset being displayed. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-otheraction","title":"function OtherAction","text":"<p>Determines the damage of the other agent. </p> <pre><code>inline int cse491_team8::ManualWorld::OtherAction (\n    cse491::AgentBase &amp; other_agent,\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other_agent</code> The NPC agent </li> <li><code>agent</code> The player agent Gets the damage of the NPC agent </li> </ul> <p>Returns:</p> <p>The damage of the NPC </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-removemove","title":"function RemoveMove","text":"<p>removes a move from the move set for an agent </p> <pre><code>inline bool cse491_team8::ManualWorld::RemoveMove (\n    cse491::AgentBase &amp; agent,\n    std::string &amp; move\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> the agent to remove a move from </li> <li><code>move</code> the name of the move to remove Removes a move from the move set map </li> </ul> <p>Returns:</p> <p>true for success, false for failure </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-run","title":"function Run","text":"<pre><code>inline void cse491_team8::ManualWorld::Run () override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-runagents","title":"function RunAgents","text":"<pre><code>inline void cse491_team8::ManualWorld::RunAgents () override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-statsaction","title":"function StatsAction","text":"<p>Displays the items and properties that the player has. </p> <pre><code>inline void cse491_team8::ManualWorld::StatsAction (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> Agent stats being showed. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-updateworld","title":"function UpdateWorld","text":"<pre><code>inline void cse491_team8::ManualWorld::UpdateWorld () override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-manualworld_1","title":"function ~ManualWorld","text":"<pre><code>cse491_team8::ManualWorld::~ManualWorld () = default\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#enum-actiontype","title":"enum ActionType","text":"<pre><code>enum cse491_team8::ManualWorld::ActionType {\n    REMAIN_STILL =0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    USE_AXE,\n    USE_BOAT,\n    STATS,\n    HEAL,\n    RUN,\n    ATTACK,\n    SPECIAL,\n    BUFF,\n    HELP\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#enum-facingdirection","title":"enum FacingDirection","text":"<pre><code>enum cse491_team8::ManualWorld::FacingDirection {\n    UP =0,\n    RIGHT,\n    DOWN,\n    LEFT\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-bridge_id","title":"variable bridge_id","text":"<pre><code>size_t bridge_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-grass_id","title":"variable grass_id","text":"<pre><code>size_t grass_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-portal_id_a","title":"variable portal_id_a","text":"<pre><code>size_t portal_id_a;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-portal_id_b","title":"variable portal_id_b","text":"<pre><code>size_t portal_id_b;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-portal_id_c","title":"variable portal_id_c","text":"<pre><code>size_t portal_id_c;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-portal_id_d","title":"variable portal_id_d","text":"<pre><code>size_t portal_id_d;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-rock_id","title":"variable rock_id","text":"<pre><code>size_t rock_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-tree_id","title":"variable tree_id","text":"<pre><code>size_t tree_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-water_id","title":"variable water_id","text":"<pre><code>size_t water_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-configagent","title":"function ConfigAgent","text":"<pre><code>inline void cse491_team8::ManualWorld::ConfigAgent (\n    cse491::AgentBase &amp; agent\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/ManualWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/","title":"Namespace group4","text":"<p>Namespace List &gt; group4</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#classes","title":"Classes","text":"Type Name class SecondWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#public-attributes","title":"Public Attributes","text":"Type Name const std::string COMBAT_SCRIPT   = = \"../assets/scripts/g4_agent_attack.ws\"Filename for agent combat script. const std::string FINAL_FLOOR_FILENAME   = = \"../assets/grids/third_floor.grid\"Filename for the last floor grid file. const std::string FIRST_FLOOR_FILENAME   = = \"../assets/grids/group4_maze.grid\"Filename for the first floor grid file. const std::string ITEM_PICKUP_SCRIPT   = = \"../assets/scripts/g4_item_pickup.ws\"Filename for item pickup script. const size_t MAX_INVENTORY_SIZE   = = 30Maximum inventory size for an agent. const cse491::GridPosition OffGrid   = = {-1, -1}Off the grid position. const std::string SECOND_FLOOR_FILENAME   = = \"../assets/grids/second_floor.grid\"Filename for the second floor grid file. const std::string WORLD_LOAD_SCRIPT   = = \"../assets/scripts/g4_world_load.ws\"Filename for world initialization script. const std::string WORLD_LOAD_SCRIPT_2   = = \"../assets/scripts/g4_world_2_load.ws\"Filename for second floor initialization script. const std::string WORLD_LOAD_SCRIPT_3   = = \"../assets/scripts/g4_world_3_load.ws\"Filename for final floor initialization script."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-combat_script","title":"variable COMBAT_SCRIPT","text":"<p>Filename for agent combat script. </p> <pre><code>const std::string COMBAT_SCRIPT;\n</code></pre> <p>When an agent attempts to move into another agent, this attack script runs. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-final_floor_filename","title":"variable FINAL_FLOOR_FILENAME","text":"<pre><code>const std::string FINAL_FLOOR_FILENAME;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-first_floor_filename","title":"variable FIRST_FLOOR_FILENAME","text":"<pre><code>const std::string FIRST_FLOOR_FILENAME;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-item_pickup_script","title":"variable ITEM_PICKUP_SCRIPT","text":"<p>Filename for item pickup script. </p> <pre><code>const std::string ITEM_PICKUP_SCRIPT;\n</code></pre> <p>This script modifies properties of the agent collecting the item. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-max_inventory_size","title":"variable MAX_INVENTORY_SIZE","text":"<pre><code>const size_t MAX_INVENTORY_SIZE;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-offgrid","title":"variable OffGrid","text":"<pre><code>const cse491::GridPosition OffGrid;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-second_floor_filename","title":"variable SECOND_FLOOR_FILENAME","text":"<pre><code>const std::string SECOND_FLOOR_FILENAME;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-world_load_script","title":"variable WORLD_LOAD_SCRIPT","text":"<pre><code>const std::string WORLD_LOAD_SCRIPT;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-world_load_script_2","title":"variable WORLD_LOAD_SCRIPT_2","text":"<pre><code>const std::string WORLD_LOAD_SCRIPT_2;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-world_load_script_3","title":"variable WORLD_LOAD_SCRIPT_3","text":"<pre><code>const std::string WORLD_LOAD_SCRIPT_3;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/SecondWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/","title":"Class group4::SecondWorld","text":"<p>ClassList &gt; group4 &gt; SecondWorld</p> <p>More...</p> <ul> <li><code>#include &lt;SecondWorld.hpp&gt;</code></li> </ul> <p>Inherits the following classes: WorldBase</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#public-functions","title":"Public Functions","text":"Type Name bool CheckPosition (cse491::AgentBase &amp; agent, cse491::GridPosition &amp; pos)  int DoAction (cse491::AgentBase &amp; agent, size_t action_id) override void DropItem (cse491::AgentBase &amp; agent, cse491::GridPosition &amp; pos)  bool IsTraversable (const AgentBase &amp; agent, cse491::GridPosition pos) override const void LoadFromFile (const std::string &amp; input_filename)  void PrintEntities ()  virtual void Run () override void SaveToFile ()  SecondWorld ()  SecondWorld (std::string grid_filename, std::string agent_filename)  ~SecondWorld () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-types","title":"Protected Types","text":"Type Name enum ActionType"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-attributes","title":"Protected Attributes","text":"Type Name std::map&lt; size_t, std::unique_ptr&lt; cse491::ItemBase &gt; &gt; inventory Vector of the items in this world. worldlang::ProgramExecutor pe Script executor object."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-functions","title":"Protected Functions","text":"Type Name void ConfigAgent (cse491::AgentBase &amp; agent) overrideProvide the agent with movement actions."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#detailed-description","title":"Detailed Description","text":"<p>Creates a world with agents and a win flag </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-checkposition","title":"function CheckPosition","text":"<pre><code>inline bool group4::SecondWorld::CheckPosition (\n    cse491::AgentBase &amp; agent,\n    cse491::GridPosition &amp; pos\n) \n</code></pre> <p>Checks to see if there is a flag or item at the agent's current position </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent </li> <li><code>pos</code> The position </li> </ul> <p>Returns:</p> <p>true if agent should update position on return </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-doaction","title":"function DoAction","text":"<pre><code>inline int group4::SecondWorld::DoAction (\n    cse491::AgentBase &amp; agent,\n    size_t action_id\n) override\n</code></pre> <p>Allows agents to perform an action and sets each agent's new position </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent performing the action </li> <li><code>action_id</code> The id that represents the move </li> </ul> <p>Returns:</p> <p>An int that declares if the move is legal or illegal (true / false) </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-dropitem","title":"function DropItem","text":"<pre><code>inline void group4::SecondWorld::DropItem (\n    cse491::AgentBase &amp; agent,\n    cse491::GridPosition &amp; pos\n) \n</code></pre> <p>Drops the item in the agent's inventory </p> <p>Parameters:</p> <ul> <li><code>agent</code> This agent's item we're dropping </li> <li><code>pos</code> The position where the item will be dropped </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-istraversable","title":"function IsTraversable","text":"<pre><code>inline bool group4::SecondWorld::IsTraversable (\n    const AgentBase &amp; agent,\n    cse491::GridPosition pos\n) override const\n</code></pre> <p>Can walk on all tiles except for walls and water (unless agent has property set) </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-loadfromfile","title":"function LoadFromFile","text":"<pre><code>inline void group4::SecondWorld::LoadFromFile (\n    const std::string &amp; input_filename\n) \n</code></pre> <p>Loads data from a JSON file and adds agents with specified properties into the world. </p> <p>Parameters:</p> <ul> <li><code>input_filename</code> Relative path to input.json file </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-printentities","title":"function PrintEntities","text":"<pre><code>inline void group4::SecondWorld::PrintEntities () \n</code></pre> <p>Prints the entities in item_set (testing) </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-run","title":"function Run","text":"<pre><code>inline virtual void group4::SecondWorld::Run () override\n</code></pre> <p>This function gives us an output.json file </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-savetofile","title":"function SaveToFile","text":"<pre><code>inline void group4::SecondWorld::SaveToFile () \n</code></pre> <p>This function gives us an output.json file using nlohmann::json library </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-secondworld-12","title":"function SecondWorld [1/2]","text":"<pre><code>inline group4::SecondWorld::SecondWorld () \n</code></pre> <p>Constructor with no arguments </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-secondworld-22","title":"function SecondWorld [2/2]","text":"<pre><code>inline group4::SecondWorld::SecondWorld (\n    std::string grid_filename,\n    std::string agent_filename\n) \n</code></pre> <p>Constructor with grid and agent file names </p> <p>Parameters:</p> <ul> <li><code>grid_filename</code> Relative path to grid file </li> <li><code>agent_filename</code> Relative path to agent input.json file </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-secondworld","title":"function ~SecondWorld","text":"<pre><code>group4::SecondWorld::~SecondWorld () = default\n</code></pre> <p>Destructor </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#enum-actiontype","title":"enum ActionType","text":"<pre><code>enum group4::SecondWorld::ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    DROP_ITEM\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#variable-inventory","title":"variable inventory","text":"<pre><code>std::map&lt;size_t, std::unique_ptr&lt;cse491::ItemBase&gt; &gt; inventory;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#variable-pe","title":"variable pe","text":"<pre><code>worldlang::ProgramExecutor pe;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-configagent","title":"function ConfigAgent","text":"<pre><code>inline void group4::SecondWorld::ConfigAgent (\n    cse491::AgentBase &amp; agent\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/SecondWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/","title":"Namespace group6","text":"<p>Namespace List &gt; group6</p> <p>A World that consists only of walls and open cells. More...</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#classes","title":"Classes","text":"Type Name class BiomeGenerator class GenerativeWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#public-types","title":"Public Types","text":"Type Name enum BiomeType"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#enum-biometype","title":"enum BiomeType","text":"<pre><code>enum group6::BiomeType {\n    Maze,\n    Grasslands,\n    Ocean\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/BiomeGenerator.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/","title":"Class group6::BiomeGenerator","text":"<p>ClassList &gt; group6 &gt; BiomeGenerator</p> <p>More...</p> <ul> <li><code>#include &lt;BiomeGenerator.hpp&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#public-functions","title":"Public Functions","text":"Type Name BiomeGenerator (BiomeType biome, unsigned int width, unsigned int height, unsigned int seed)  void applyPathToGrid (const std::vector&lt; GridPosition &gt; &amp; path)  std::vector&lt; GridPosition &gt; clearPath () const void generate ()  BiomeType getBiome () const unsigned int getSeed () const void oceanHandler ()  void placeDoorTile (const size_t &amp; doorTile)  void placeSpecialTiles (const size_t &amp; genericTile, const size_t &amp; specialTile, double percentage)  void placeTileRandom (const size_t &amp; tile, const size_t &amp; spawnTile)  void placeTrees ()  void saveToFile (const std::string &amp; filename) const void setTiles (const size_t &amp; firstTile, const size_t &amp; secondTile)  void setWorld (WorldBase * world)  ~BiomeGenerator () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#detailed-description","title":"Detailed Description","text":"<p>Generates a new grid based on a specified biome </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-biomegenerator","title":"function BiomeGenerator","text":"<pre><code>group6::BiomeGenerator::BiomeGenerator (\n    BiomeType biome,\n    unsigned int width,\n    unsigned int height,\n    unsigned int seed\n) \n</code></pre> <p>Creates a generator with a grid of the given size and using the given seed </p> <p>Parameters:</p> <ul> <li><code>biome</code> The biome of the grid </li> <li><code>width</code> The width of the grid </li> <li><code>height</code> The height of the grid </li> <li><code>seed</code> The seed used for random number generation </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-applypathtogrid","title":"function applyPathToGrid","text":"<pre><code>void group6::BiomeGenerator::applyPathToGrid (\n    const std::vector&lt; GridPosition &gt; &amp; path\n) \n</code></pre> <p>Clears the walls out of the grid, guaranteeing a path from the left of the grid, to any point on the rightmost side of the map </p> <p>Parameters:</p> <ul> <li><code>path</code> A vector of GridPositions necessary for this path </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-clearpath","title":"function clearPath","text":"<pre><code>std::vector&lt; GridPosition &gt; group6::BiomeGenerator::clearPath () const\n</code></pre> <p>Clears a randomized path from the top left of the grid, to any point on the rightmost side of the map </p> <p>Returns:</p> <p>A vector of GridPositions necessary for this path </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-generate","title":"function generate","text":"<pre><code>void group6::BiomeGenerator::generate () \n</code></pre> <p>Generates the grid with two types of tiles </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-getbiome","title":"function getBiome","text":"<pre><code>inline BiomeType group6::BiomeGenerator::getBiome () const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-getseed","title":"function getSeed","text":"<pre><code>inline unsigned int group6::BiomeGenerator::getSeed () const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-oceanhandler","title":"function oceanHandler","text":"<pre><code>void group6::BiomeGenerator::oceanHandler () \n</code></pre> <p>Handles logic for Ocean biome </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-placedoortile","title":"function placeDoorTile","text":"<pre><code>void group6::BiomeGenerator::placeDoorTile (\n    const size_t &amp; doorTile\n) \n</code></pre> <p>Generates door tile on grid at [1][1] </p> <p>Parameters:</p> <ul> <li><code>doorTile</code> Door Tile </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-placespecialtiles","title":"function placeSpecialTiles","text":"<pre><code>void group6::BiomeGenerator::placeSpecialTiles (\n    const size_t &amp; genericTile,\n    const size_t &amp; specialTile,\n    double percentage\n) \n</code></pre> <p>Generates special tiles on the grid </p> <p>Parameters:</p> <ul> <li><code>genericTile</code> The tile that the special tile can spawn on </li> <li><code>specialTile</code> The special tile to generate </li> <li><code>percentage</code> Chance of special tile generating on the generic tile </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-placetilerandom","title":"function placeTileRandom","text":"<pre><code>void group6::BiomeGenerator::placeTileRandom (\n    const size_t &amp; tile,\n    const size_t &amp; spawnTile\n) \n</code></pre> <p>Generates random coordinates to place the given tile</p> <p>Parameters:</p> <ul> <li><code>tile</code> The tile being placed </li> <li><code>spawnTile</code> The type of tile allowed to be replaced </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-placetrees","title":"function placeTrees","text":"<pre><code>void group6::BiomeGenerator::placeTrees () \n</code></pre> <p>Places trees on the grid </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-savetofile","title":"function saveToFile","text":"<pre><code>void group6::BiomeGenerator::saveToFile (\n    const std::string &amp; filename\n) const\n</code></pre> <p>Saves the grid to the given filepath </p> <p>Parameters:</p> <ul> <li><code>filename</code> The filename the grid will be saved to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-settiles","title":"function setTiles","text":"<pre><code>void group6::BiomeGenerator::setTiles (\n    const size_t &amp; firstTile,\n    const size_t &amp; secondTile\n) \n</code></pre> <p>Sets the tile vector for the biome </p> <p>Parameters:</p> <ul> <li><code>firstTile</code> Tile #1 for the biome </li> <li><code>secondTile</code> Tile #2 for the biome </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-setworld","title":"function setWorld","text":"<pre><code>void group6::BiomeGenerator::setWorld (\n    WorldBase * world\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-biomegenerator_1","title":"function ~BiomeGenerator","text":"<pre><code>group6::BiomeGenerator::~BiomeGenerator () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/BiomeGenerator.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/","title":"Class group6::GenerativeWorld","text":"<p>ClassList &gt; group6 &gt; GenerativeWorld</p> <p>Inherits the following classes: WorldBase</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#public-functions","title":"Public Functions","text":"Type Name void AStarAgentHelper (AgentBase &amp; agent)  void AddArmory ()  void AddTeleporters ()  void AgentCollisionHelper (AgentBase &amp; agent)  void ArmoryTileHelper (AgentBase &amp; agent)  int DoAction (AgentBase &amp; agent, size_t action_id) override void DoorTileHelper (AgentBase &amp; agent)  void EndGame (bool win)  GenerativeWorld (BiomeType biome, unsigned int width, unsigned int height, unsigned int seed)  void HoleTileHelper (AgentBase &amp; agent, GridPosition &amp; new_position)  bool IsTraversable (const AgentBase &amp;, cse491::GridPosition pos) override const void ItemHelper (AgentBase &amp; agent, GridPosition &amp; new_position)  void KeyTileHelper (AgentBase &amp; agent, GridPosition &amp; new_position)  void SpikeTileHelper (AgentBase &amp; agent)  void TarTileHelper (AgentBase &amp; agent)  void TeleporterHelper (GridPosition &amp; new_position)  ~GenerativeWorld () override"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#public-static-functions","title":"Public Static Functions","text":"Type Name vector&lt; GridPosition &gt; FindTiles (WorldGrid grid, size_t tile_id)"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-types","title":"Protected Types","text":"Type Name enum ActionType"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t armory_id Easy access to armory CellTypeID. size_t dirt_id Easy access to dirt CellTypeID. size_t door_id Easy access to door CellTypeID. size_t floor_id Easy access to floor CellType ID. size_t grass_id Easy access to grass CellTypeID. size_t hole_id Easy access to hole CellTypeID. size_t key_id Easy access to key CellTypeID. size_t sand_id Easy access to sand CellTypeID. size_t spike_id Easy access to spike CellType ID. size_t tar_id Easy access to tar CellTypeID. size_t teleporter_id Easy access to teleporter CellTypeId. size_t tree_id Easy access to tree CellTypeID. size_t wall_id Easy access to wall CellType ID. size_t water_id Easy access to water CellTypeID. unsigned int world_height unsigned int world_width"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-functions","title":"Protected Functions","text":"Type Name void ConfigAgent (AgentBase &amp; agent) override void CreateGrid (BiomeType biome, unsigned int width, unsigned int height, unsigned int seed, const string &amp; file)  void DamageAgent (AgentBase &amp; agent)"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-astaragenthelper","title":"function AStarAgentHelper","text":"<pre><code>inline void group6::GenerativeWorld::AStarAgentHelper (\n    AgentBase &amp; agent\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-addarmory","title":"function AddArmory","text":"<pre><code>inline void group6::GenerativeWorld::AddArmory () \n</code></pre> <p>Adds armory tiles to grid </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-addteleporters","title":"function AddTeleporters","text":"<pre><code>inline void group6::GenerativeWorld::AddTeleporters () \n</code></pre> <p>Adds teleporters to map </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-agentcollisionhelper","title":"function AgentCollisionHelper","text":"<pre><code>inline void group6::GenerativeWorld::AgentCollisionHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Collision testing functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-armorytilehelper","title":"function ArmoryTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::ArmoryTileHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Helper function for armory functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-doaction","title":"function DoAction","text":"<pre><code>inline int group6::GenerativeWorld::DoAction (\n    AgentBase &amp; agent,\n    size_t action_id\n) override\n</code></pre> <p>Handles logic for agent movement </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent attempting to do an action </li> <li><code>action_id</code> The action being performed </li> </ul> <p>Returns:</p> <p>1 if the action was successful. 0 if it was not </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-doortilehelper","title":"function DoorTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::DoorTileHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Helper function for door tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-endgame","title":"function EndGame","text":"<pre><code>inline void group6::GenerativeWorld::EndGame (\n    bool win\n) \n</code></pre> <p>Ends the game </p> <p>Parameters:</p> <ul> <li><code>win</code> True if the game is ending in a win. False if it is a loss </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-generativeworld","title":"function GenerativeWorld","text":"<pre><code>inline explicit group6::GenerativeWorld::GenerativeWorld (\n    BiomeType biome,\n    unsigned int width,\n    unsigned int height,\n    unsigned int seed\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-holetilehelper","title":"function HoleTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::HoleTileHelper (\n    AgentBase &amp; agent,\n    GridPosition &amp; new_position\n) \n</code></pre> <p>Helper function for hole tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>new_position</code> new position agent is moving to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-istraversable","title":"function IsTraversable","text":"<pre><code>inline bool group6::GenerativeWorld::IsTraversable (\n    const AgentBase &amp;,\n    cse491::GridPosition pos\n) override const\n</code></pre> <p>Boolean function for traversable tiles in maze </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>pos</code> position of tile </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-itemhelper","title":"function ItemHelper","text":"<pre><code>inline void group6::GenerativeWorld::ItemHelper (\n    AgentBase &amp; agent,\n    GridPosition &amp; new_position\n) \n</code></pre> <p>Helper function for item pickup functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>new_position</code> new position agent is moving to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-keytilehelper","title":"function KeyTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::KeyTileHelper (\n    AgentBase &amp; agent,\n    GridPosition &amp; new_position\n) \n</code></pre> <p>Helper function for key tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>new_position</code> new position agent is moving to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-spiketilehelper","title":"function SpikeTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::SpikeTileHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Helper function for spike tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-tartilehelper","title":"function TarTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::TarTileHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Helper function for tar tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-teleporterhelper","title":"function TeleporterHelper","text":"<pre><code>inline void group6::GenerativeWorld::TeleporterHelper (\n    GridPosition &amp; new_position\n) \n</code></pre> <p>Helper function for armory functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>new_position</code> new position agent is moving to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-generativeworld_1","title":"function ~GenerativeWorld","text":"<pre><code>group6::GenerativeWorld::~GenerativeWorld () override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-findtiles","title":"function FindTiles","text":"<pre><code>static inline vector&lt; GridPosition &gt; group6::GenerativeWorld::FindTiles (\n    WorldGrid grid,\n    size_t tile_id\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#enum-actiontype","title":"enum ActionType","text":"<pre><code>enum group6::GenerativeWorld::ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-armory_id","title":"variable armory_id","text":"<pre><code>size_t armory_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-dirt_id","title":"variable dirt_id","text":"<pre><code>size_t dirt_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-door_id","title":"variable door_id","text":"<pre><code>size_t door_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-floor_id","title":"variable floor_id","text":"<pre><code>size_t floor_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-grass_id","title":"variable grass_id","text":"<pre><code>size_t grass_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-hole_id","title":"variable hole_id","text":"<pre><code>size_t hole_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-key_id","title":"variable key_id","text":"<pre><code>size_t key_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-sand_id","title":"variable sand_id","text":"<pre><code>size_t sand_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-spike_id","title":"variable spike_id","text":"<pre><code>size_t spike_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-tar_id","title":"variable tar_id","text":"<pre><code>size_t tar_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-teleporter_id","title":"variable teleporter_id","text":"<pre><code>size_t teleporter_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-tree_id","title":"variable tree_id","text":"<pre><code>size_t tree_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-wall_id","title":"variable wall_id","text":"<pre><code>size_t wall_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-water_id","title":"variable water_id","text":"<pre><code>size_t water_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-world_height","title":"variable world_height","text":"<pre><code>unsigned int world_height;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-world_width","title":"variable world_width","text":"<pre><code>unsigned int world_width;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-configagent","title":"function ConfigAgent","text":"<pre><code>inline void group6::GenerativeWorld::ConfigAgent (\n    AgentBase &amp; agent\n) override\n</code></pre> <p>Provide the agent with movement actions. </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent being configured </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-creategrid","title":"function CreateGrid","text":"<pre><code>inline void group6::GenerativeWorld::CreateGrid (\n    BiomeType biome,\n    unsigned int width,\n    unsigned int height,\n    unsigned int seed,\n    const string &amp; file\n) \n</code></pre> <p>Creates a new grid with the given parameters</p> <p>Parameters:</p> <ul> <li><code>biome</code> The BiomeType being used </li> <li><code>width</code> The width of the grid </li> <li><code>height</code> The height of the grid </li> <li><code>seed</code> The seed used for random generation </li> <li><code>file</code> The file to save the grid to. Full path is \"../assets/grids/generated_[file].grid\" </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-damageagent","title":"function DamageAgent","text":"<pre><code>inline void group6::GenerativeWorld::DamageAgent (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Ends game if agent is the player </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent being damaged </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Worlds/GenerativeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/","title":"Namespace siv","text":"<p>Namespace List &gt; siv</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#namespaces","title":"Namespaces","text":"Type Name namespace perlin_detail"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#classes","title":"Classes","text":"Type Name class BasicPerlinNoise &lt;class Float&gt;"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#public-types","title":"Public Types","text":"Type Name typedef BasicPerlinNoise&lt; double &gt; PerlinNoise"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#typedef-perlinnoise","title":"typedef PerlinNoise","text":"<pre><code>using PerlinNoise =  BasicPerlinNoise&lt;double&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/PerlinNoise.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/","title":"Class siv::BasicPerlinNoise","text":"<p>template &lt;class Float class Float&gt;</p> <p>ClassList &gt; siv &gt; BasicPerlinNoise</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#public-types","title":"Public Types","text":"Type Name typedef std::mt19937 default_random_engine typedef typename default_random_engine::result_type seed_type typedef std::array&lt; std::uint8_t, 256 &gt; state_type typedef Float value_type"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#public-functions","title":"Public Functions","text":"Type Name SIVPERLIN_NODISCARD_CXX20 constexpr BasicPerlinNoise () noexcept SIVPERLIN_NODISCARD_CXX20 BasicPerlinNoise (seed_type seed)  SIVPERLIN_CONCEPT_URBG SIVPERLIN_NODISCARD_CXX20 BasicPerlinNoise (URBG &amp;&amp; urbg)  constexpr void deserialize (const state_type &amp; state) noexcept value_type noise1D (value_type x) noexcept const value_type noise1D_01 (value_type x) noexcept const value_type noise2D (value_type x, value_type y) noexcept const value_type noise2D_01 (value_type x, value_type y) noexcept const value_type noise3D (value_type x, value_type y, value_type z) noexcept const value_type noise3D_01 (value_type x, value_type y, value_type z) noexcept const value_type normalizedOctave1D (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave1D_01 (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave2D (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave2D_01 (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave3D (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave3D_01 (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave1D (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave1D_01 (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave1D_11 (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave2D (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave2D_01 (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave2D_11 (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave3D (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave3D_01 (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave3D_11 (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const void reseed (seed_type seed)  SIVPERLIN_CONCEPT_URBG void reseed (URBG &amp;&amp; urbg)  constexpr const state_type &amp; serialize () noexcept const"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#typedef-default_random_engine","title":"typedef default_random_engine","text":"<pre><code>using default_random_engine =  std::mt19937;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#typedef-seed_type","title":"typedef seed_type","text":"<pre><code>using seed_type =  typename default_random_engine::result_type;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#typedef-state_type","title":"typedef state_type","text":"<pre><code>using state_type =  std::array&lt;std::uint8_t, 256&gt;;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using value_type =  Float;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-basicperlinnoise-13","title":"function BasicPerlinNoise [1/3]","text":"<pre><code>inline SIVPERLIN_NODISCARD_CXX20 constexpr siv::BasicPerlinNoise::BasicPerlinNoise () noexcept\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-basicperlinnoise-23","title":"function BasicPerlinNoise [2/3]","text":"<pre><code>inline explicit SIVPERLIN_NODISCARD_CXX20 siv::BasicPerlinNoise::BasicPerlinNoise (\n    seed_type seed\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-basicperlinnoise-33","title":"function BasicPerlinNoise [3/3]","text":"<pre><code>inline explicit SIVPERLIN_CONCEPT_URBG SIVPERLIN_NODISCARD_CXX20 siv::BasicPerlinNoise::BasicPerlinNoise (\n    URBG &amp;&amp; urbg\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-deserialize","title":"function deserialize","text":"<pre><code>inline constexpr void siv::BasicPerlinNoise::deserialize (\n    const state_type &amp; state\n) noexcept\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise1d","title":"function noise1D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise1D (\n    value_type x\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise1d_01","title":"function noise1D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise1D_01 (\n    value_type x\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise2d","title":"function noise2D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise2D (\n    value_type x,\n    value_type y\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise2d_01","title":"function noise2D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise2D_01 (\n    value_type x,\n    value_type y\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise3d","title":"function noise3D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise3D (\n    value_type x,\n    value_type y,\n    value_type z\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise3d_01","title":"function noise3D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise3D_01 (\n    value_type x,\n    value_type y,\n    value_type z\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave1d","title":"function normalizedOctave1D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave1D (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave1d_01","title":"function normalizedOctave1D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave1D_01 (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave2d","title":"function normalizedOctave2D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave2D (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave2d_01","title":"function normalizedOctave2D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave2D_01 (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave3d","title":"function normalizedOctave3D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave3D (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave3d_01","title":"function normalizedOctave3D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave3D_01 (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave1d","title":"function octave1D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave1D (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave1d_01","title":"function octave1D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave1D_01 (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave1d_11","title":"function octave1D_11","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave1D_11 (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave2d","title":"function octave2D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave2D (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave2d_01","title":"function octave2D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave2D_01 (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave2d_11","title":"function octave2D_11","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave2D_11 (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave3d","title":"function octave3D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave3D (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave3d_01","title":"function octave3D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave3D_01 (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave3d_11","title":"function octave3D_11","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave3D_11 (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-reseed-12","title":"function reseed [1/2]","text":"<pre><code>inline void siv::BasicPerlinNoise::reseed (\n    seed_type seed\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-reseed-22","title":"function reseed [2/2]","text":"<pre><code>inline SIVPERLIN_CONCEPT_URBG void siv::BasicPerlinNoise::reseed (\n    URBG &amp;&amp; urbg\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-serialize","title":"function serialize","text":"<pre><code>inline constexpr const state_type &amp; siv::BasicPerlinNoise::serialize () noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/PerlinNoise.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv_1_1perlin__detail/","title":"Namespace siv::perlin_detail","text":"<p>Namespace List &gt; siv &gt; perlin_detail</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/PerlinNoise.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacetao/","title":"Namespace tao","text":"<p>Namespace List &gt; tao</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacetao/#namespaces","title":"Namespaces","text":"Type Name namespace pegtl <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacetao_1_1pegtl/","title":"Namespace tao::pegtl","text":"<p>Namespace List &gt; tao &gt; pegtl</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/","title":"Namespace worldlang","text":"<p>Namespace List &gt; worldlang</p> <p>Namespace for scripting language stuff. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#classes","title":"Classes","text":"Type Name class ProgramExecutor Class that manages program execution. struct Unit struct add struct add_a struct assignment struct code_block struct comment struct comp struct comp_a struct element struct expression struct expression_list struct function struct identifier struct identifier_list struct mul struct mul_a struct number struct op_prio_add struct op_prio_comp struct op_prio_mul struct program struct statement struct statement_list struct string"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#public-types","title":"Public Types","text":"Type Name typedef tao::pegtl::parse_tree::selector&lt; Rule, tao::pegtl::parse_tree::store_content::on&lt; number, string, function, identifier, identifier_list, expression, expression_list, statement, statement_list, code_block, program, assignment, op_prio_add, op_prio_mul, op_prio_comp &gt;, tao::pegtl::parse_tree::fold_one::on&lt; add_a, mul_a &gt; &gt; selector"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; Unit &gt; parse_to_code (std::string program)  std::string stripWhitespace (const std::string &amp; input)"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#typedef-selector","title":"typedef selector","text":"<pre><code>using selector =  tao::pegtl::parse_tree::selector&lt; Rule, tao::pegtl::parse_tree::store_content::on&lt; number, string, function, identifier, identifier_list, expression, expression_list, statement, statement_list, code_block, program, assignment, op_prio_add, op_prio_mul, op_prio_comp &gt;, tao::pegtl::parse_tree::fold_one::on&lt; add_a, mul_a &gt; &gt;;\n</code></pre> <p>Selector for tree generation This is used by PEGTL's parse_tree function to determine which nodes are kept, which are folded into their parent when possible, and which are ignored (these are not listed here). </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#function-parse_to_code","title":"function parse_to_code","text":"<pre><code>std::vector&lt; Unit &gt; worldlang::parse_to_code (\n    std::string program\n) \n</code></pre> <p>Converts a program string into code units using PEGTL </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#function-stripwhitespace","title":"function stripWhitespace","text":"<pre><code>std::string worldlang::stripWhitespace (\n    const std::string &amp; input\n) \n</code></pre> <p>function to strip whitespace </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/","title":"Class worldlang::ProgramExecutor","text":"<p>ClassList &gt; worldlang &gt; ProgramExecutor</p> <p>Class that manages program execution. More...</p> <ul> <li><code>#include &lt;ProgramExecutor.hpp&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#classes","title":"Classes","text":"Type Name struct Identifier"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; void(ProgramExecutor &amp;)&gt; Callable typedef std::variant&lt; size_t, double, std::string, Callable, Identifier &gt; Value Variant type containing all possible values types for variables."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#public-functions","title":"Public Functions","text":"Type Name ProgramExecutor () Constructor. ProgramExecutor (cse491::WorldBase &amp; world) Constructor with function registration. T as (const Value &amp; a) Get a value of type T from provided Value. void error (const std::string &amp; error) Sets the error message and end interpreter execution. std::string getErrorMessage () Gets the error message stored. bool has (const Value &amp; a) Check whether or not this Value contains the expected type. std::vector&lt; Value &gt; popArgs () Returns all arguments passed to an interpreter function. Value popStack () Retrieves a single value from the interpreter value stack. void pushStack (Value value) Pushes a single Value onto the interpreter value stack. void registerFunction (std::string name, Callable callable) Registers a function on this ProgramExecutor object. bool run (const std::string &amp; program) Executes a program from a string. bool run ()  bool runFile (const std::string &amp; filename) Executes a program from a file. void setVariable (const std::string &amp; name, Value value)  void skipBlock (int nest=0)  T var (const std::string &amp; name) Gets the value of a variable as type T. virtual ~ProgramExecutor () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#detailed-description","title":"Detailed Description","text":"<p>Handles run-time state of program and contains the interpreter function.</p> <p>Native C++ functions can be registered on this object to extend the functionality. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#typedef-callable","title":"typedef Callable","text":"<pre><code>using Callable =  std::function&lt;void(ProgramExecutor&amp;)&gt;;\n</code></pre> <p>This is the signature interpreter functions should have.</p> <p>To read the arguments passed to the function, use ProgramExecutor::popArgs(). To return values from a function, use ProgramExecutor::pushStack(). </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#typedef-value","title":"typedef Value","text":"<pre><code>using Value =  std::variant &lt; size_t, double, std::string, Callable, Identifier &gt;;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-programexecutor-12","title":"function ProgramExecutor [1/2]","text":"<pre><code>inline worldlang::ProgramExecutor::ProgramExecutor () \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-programexecutor-22","title":"function ProgramExecutor [2/2]","text":"<pre><code>inline worldlang::ProgramExecutor::ProgramExecutor (\n    cse491::WorldBase &amp; world\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-as","title":"function as","text":"<p>Get a value of type T from provided Value. </p> <pre><code>template&lt;typename T typename T&gt;\ninline T worldlang::ProgramExecutor::as (\n    const Value &amp; a\n) \n</code></pre> <p>Gets the value of type T from given Value whether it contains a value or an identifier storing that value.</p> <p>If the value cannot be accessed, sets the error message and returns a default-constructed value.</p> <p>For example, if your program consists of <code>a=5</code> and <code>b=a</code> then as&lt;double&gt; will handle both 5 and a correctly as arguments std::get&lt;double&gt; is longer and only handles 5.</p> <p>Parameters:</p> <ul> <li><code>a</code> Value to retrieve value from </li> </ul> <p>Returns:</p> <p>Value of type T </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-error","title":"function error","text":"<p>Sets the error message and end interpreter execution. </p> <pre><code>inline void worldlang::ProgramExecutor::error (\n    const std::string &amp; error\n) \n</code></pre> <p>Sets the stored error message for the interpreter. Only the first error set is saved.</p> <p>Parameters:</p> <ul> <li><code>error</code> Message to store </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-geterrormessage","title":"function getErrorMessage","text":"<p>Gets the error message stored. </p> <pre><code>inline std::string worldlang::ProgramExecutor::getErrorMessage () \n</code></pre> <p>Gets the error message from the interpreter. If no error was set, this will be the empty string.</p> <p>Returns:</p> <p>Error message </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-has","title":"function has","text":"<p>Check whether or not this Value contains the expected type. </p> <pre><code>template&lt;typename T typename T&gt;\ninline bool worldlang::ProgramExecutor::has (\n    const Value &amp; a\n) \n</code></pre> <p>Checks the type of the given Value. If the type does not match and cannot be obtained, sets the interpreter error message and returns false. Otherwise, returns true.</p> <p>Parameters:</p> <ul> <li><code>a</code> Value to validate type of. </li> </ul> <p>Returns:</p> <p>true if type is usable </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-popargs","title":"function popArgs","text":"<p>Returns all arguments passed to an interpreter function. </p> <pre><code>inline std::vector&lt; Value &gt; worldlang::ProgramExecutor::popArgs () \n</code></pre> <p>This function retrieves the arguments of the function in the same order as in the source code. The end of the argument list is determined by an internal special Identifier</p> <p>This function should be called once for any Callable to get the arguments passed.</p> <p>Returns:</p> <p>Vector of Values provided to an interpreter function. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-popstack","title":"function popStack","text":"<p>Retrieves a single value from the interpreter value stack. </p> <pre><code>inline Value worldlang::ProgramExecutor::popStack () \n</code></pre> <p>Returns:</p> <p>Value object from stack. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-pushstack","title":"function pushStack","text":"<p>Pushes a single Value onto the interpreter value stack. </p> <pre><code>inline void worldlang::ProgramExecutor::pushStack (\n    Value value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> Value to push to interpreter stack </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-registerfunction","title":"function registerFunction","text":"<p>Registers a function on this ProgramExecutor object.</p> <pre><code>inline void worldlang::ProgramExecutor::registerFunction (\n    std::string name,\n    Callable callable\n) \n</code></pre> <p>This allows the given function to be called from the interpreter via a function called <code>name</code>.</p> <p>Note:</p> <p>Names can be overridden by the user's program if they overwrite <code>name</code>.</p> <p>Parameters:</p> <ul> <li><code>name</code> Function name </li> <li><code>callable</code> Function accepting a ProgramExecutor&amp; with no return. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-run-12","title":"function run [1/2]","text":"<p>Executes a program from a string. </p> <pre><code>inline bool worldlang::ProgramExecutor::run (\n    const std::string &amp; program\n) \n</code></pre> <p>Executes a program from a string. This is the main interpreter function. See Language.hpp for most interesting syntax and parsing details.</p> <p>Parameters:</p> <ul> <li><code>program</code> Program to run. </li> </ul> <p>Returns:</p> <p>true if program ran successfully, false if an error occured </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-run-22","title":"function run [2/2]","text":"<pre><code>inline bool worldlang::ProgramExecutor::run () \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-runfile","title":"function runFile","text":"<p>Executes a program from a file. </p> <pre><code>inline bool worldlang::ProgramExecutor::runFile (\n    const std::string &amp; filename\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> File to load </li> </ul> <p>Returns:</p> <p>true if program ran successfully, false if an error occured </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-setvariable","title":"function setVariable","text":"<pre><code>inline void worldlang::ProgramExecutor::setVariable (\n    const std::string &amp; name,\n    Value value\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-skipblock","title":"function skipBlock","text":"<pre><code>inline void worldlang::ProgramExecutor::skipBlock (\n    int nest=0\n) \n</code></pre> <p>Moves the interpreter's program counter to the end of the current block.</p> <p>Parameters:</p> <ul> <li><code>nest</code> Optional starting nest value (defaults to zero) Begins as if it was nested within this many <code>start_block</code> operations. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-var","title":"function var","text":"<p>Gets the value of a variable as type T. </p> <pre><code>template&lt;typename T typename T&gt;\ninline T worldlang::ProgramExecutor::var (\n    const std::string &amp; name\n) \n</code></pre> <p>Exception:</p> <ul> <li><code>std::out_of_range</code> if it is not defined </li> <li><code>std::bad_variant_access</code> if variable is wrong type </li> </ul> <p>Parameters:</p> <ul> <li><code>name</code> Variable name to check </li> </ul> <p>Returns:</p> <p>Value of variable as type T </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-programexecutor","title":"function ~ProgramExecutor","text":"<pre><code>virtual worldlang::ProgramExecutor::~ProgramExecutor () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/ProgramExecutor.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_program_executor_1_1_identifier/","title":"Struct worldlang::ProgramExecutor::Identifier","text":"<p>ClassList &gt; worldlang &gt; ProgramExecutor &gt; Identifier</p> <p>Inherits the following classes: string</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/ProgramExecutor.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/","title":"Struct worldlang::Unit","text":"<p>ClassList &gt; worldlang &gt; Unit</p> <p>More...</p> <ul> <li><code>#include &lt;Language.hpp&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#public-types","title":"Public Types","text":"Type Name enum Type"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#public-attributes","title":"Public Attributes","text":"Type Name Type type std::string value The value of this code unit. What it means depends on the type."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#detailed-description","title":"Detailed Description","text":"<p>A singular code unit. Will have some specific meaning within the interpreter itself. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#enum-type","title":"enum Type","text":"<pre><code>enum worldlang::Unit::Type {\n    number,\n    string,\n    identifier,\n    function,\n    operation,\n    function_decl\n};\n</code></pre> <p>Various types of code Units. </p> <p>Note:</p> <p>that most internal interpreter functions all fall under <code>operation</code>. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#variable-type","title":"variable type","text":"<pre><code>Type type;\n</code></pre> <p>This determines how this unit is used within the interpreter. The type of this code unit. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#variable-value","title":"variable value","text":"<pre><code>std::string value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1add/","title":"Struct worldlang::add","text":"<p>ClassList &gt; worldlang &gt; add</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; add_a, op_prio_add, add &gt;, add_a &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1add__a/","title":"Struct worldlang::add_a","text":"<p>ClassList &gt; worldlang &gt; add_a</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; mul, op_prio_add, mul &gt;, mul &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1assignment/","title":"Struct worldlang::assignment","text":"<p>ClassList &gt; worldlang &gt; assignment</p> <p>Inherits the following classes: tao::pegtl::seq&lt; identifier_list, pegtl::one&lt; '=' &gt;, expression_list &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1code__block/","title":"Struct worldlang::code_block","text":"<p>ClassList &gt; worldlang &gt; code_block</p> <p>Inherits the following classes: tao::pegtl::seq&lt; pegtl::one&lt; '{' &gt;, pegtl::eol, statement_list, pegtl::one&lt; '}' &gt;, pegtl::eol &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1comment/","title":"Struct worldlang::comment","text":"<p>ClassList &gt; worldlang &gt; comment</p> <p>Inherits the following classes: tao::pegtl::seq&lt; pegtl::one&lt; '#' &gt;, pegtl::until&lt; pegtl::eol &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1comp/","title":"Struct worldlang::comp","text":"<p>ClassList &gt; worldlang &gt; comp</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; comp_a, op_prio_comp, comp &gt;, comp_a &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1comp__a/","title":"Struct worldlang::comp_a","text":"<p>ClassList &gt; worldlang &gt; comp_a</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; add, op_prio_comp, add &gt;, add &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1element/","title":"Struct worldlang::element","text":"<p>ClassList &gt; worldlang &gt; element</p> <p>Inherits the following classes: tao::pegtl::sor&lt; function, identifier, number, string, pegtl::seq&lt; pegtl::one&lt; '(' &gt;, expression, pegtl::one&lt; ')' &gt; &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1expression/","title":"Struct worldlang::expression","text":"<p>ClassList &gt; worldlang &gt; expression</p> <p>Inherits the following classes: tao::pegtl::sor&lt; comp &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1expression__list/","title":"Struct worldlang::expression_list","text":"<p>ClassList &gt; worldlang &gt; expression_list</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; expression, pegtl::one&lt; ',' &gt;, expression_list &gt;, expression &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1function/","title":"Struct worldlang::function","text":"<p>ClassList &gt; worldlang &gt; function</p> <p>Inherits the following classes: tao::pegtl::seq&lt; identifier, pegtl::one&lt; '(' &gt;, pegtl::opt&lt; expression_list &gt;, pegtl::one&lt; ')' &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1identifier/","title":"Struct worldlang::identifier","text":"<p>ClassList &gt; worldlang &gt; identifier</p> <p>Inherits the following classes: identifier</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1identifier__list/","title":"Struct worldlang::identifier_list","text":"<p>ClassList &gt; worldlang &gt; identifier_list</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; identifier, pegtl::one&lt; ',' &gt;, identifier_list &gt;, identifier &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1mul/","title":"Struct worldlang::mul","text":"<p>ClassList &gt; worldlang &gt; mul</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; mul_a, op_prio_mul, mul &gt;, mul_a &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1mul__a/","title":"Struct worldlang::mul_a","text":"<p>ClassList &gt; worldlang &gt; mul_a</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; element, op_prio_mul, element &gt;, element &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1number/","title":"Struct worldlang::number","text":"<p>ClassList &gt; worldlang &gt; number</p> <p>Inherits the following classes: tao::pegtl::seq&lt; pegtl::opt&lt; pegtl::one&lt; '-' &gt; &gt;, pegtl::plus&lt; pegtl::digit &gt;, pegtl::opt&lt; pegtl::one&lt; '.' &gt;, pegtl::plus&lt; pegtl::digit &gt; &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1op__prio__add/","title":"Struct worldlang::op_prio_add","text":"<p>ClassList &gt; worldlang &gt; op_prio_add</p> <p>Inherits the following classes: tao::pegtl::one&lt; '+', '-' &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1op__prio__comp/","title":"Struct worldlang::op_prio_comp","text":"<p>ClassList &gt; worldlang &gt; op_prio_comp</p> <p>Inherits the following classes: tao::pegtl::sor&lt; TAO_PEGTL_STRING(\"==\"), TAO_PEGTL_STRING(\"!=\"), TAO_PEGTL_STRING(\"&lt;=\"), TAO_PEGTL_STRING(\"&gt;=\"), pegtl::one&lt; '&lt;' &gt;, pegtl::one&lt; '&gt;' &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1op__prio__mul/","title":"Struct worldlang::op_prio_mul","text":"<p>ClassList &gt; worldlang &gt; op_prio_mul</p> <p>Inherits the following classes: tao::pegtl::one&lt; ' *', '/' &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1program/","title":"Struct worldlang::program","text":"<p>ClassList &gt; worldlang &gt; program</p> <p>Inherits the following classes: tao::pegtl::seq&lt; statement_list, pegtl::eolf &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1statement/","title":"Struct worldlang::statement","text":"<p>ClassList &gt; worldlang &gt; statement</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; function, pegtl::opt&lt; code_block &gt;, pegtl::opt&lt; pegtl::eol &gt; &gt;, pegtl::seq&lt; assignment, pegtl::opt&lt; pegtl::eol &gt; &gt;, comment, pegtl::eol &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1statement__list/","title":"Struct worldlang::statement_list","text":"<p>ClassList &gt; worldlang &gt; statement_list</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; statement, statement_list &gt;, statement &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1string/","title":"Struct worldlang::string","text":"<p>ClassList &gt; worldlang &gt; string</p> <p>Inherits the following classes: tao::pegtl::seq&lt; pegtl::one&lt; '\"' &gt;, pegtl::star&lt; pegtl::not_one&lt;'\"'&gt; &gt;, pegtl::one&lt; '\"' &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Worlds <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/dir_9813a27ecb6dbdc5ed22cda8cf865019/","title":"Dir source/Worlds","text":"<p>FileList &gt; source &gt; Worlds</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/dir_9813a27ecb6dbdc5ed22cda8cf865019/#files","title":"Files","text":"Type Name file BiomeGenerator.cpp file BiomeGenerator.hpp file GenerativeWorld.hpp file Language.hpp file ManualWorld.hpp file MazeWorld.hpp file PerlinNoise.hpp file ProgramExecutor.hpp file SecondWorld.hpp <p>The documentation for this class was generated from the following file <code>source/Worlds/</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8cpp/","title":"File BiomeGenerator.cpp","text":"<p>FileList &gt; source &gt; Worlds &gt; BiomeGenerator.cpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"BiomeGenerator.hpp\"</code></li> <li><code>#include \"Agents/AgentLibary.hpp\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Author:</p> <p>Paul Schulte, Milan Mihailovic (some code assisted with ChatGPT) </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/BiomeGenerator.cpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8cpp_source/","title":"File BiomeGenerator.cpp","text":"<p>File List &gt; source &gt; Worlds &gt; BiomeGenerator.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"BiomeGenerator.hpp\"\n#include \"Agents/AgentLibary.hpp\"\n\n#include &lt;cmath&gt;\n#include &lt;tuple&gt;\n#include &lt;queue&gt;\n\nusing namespace group6;\nusing namespace cse491;\n\nusing std::vector;\n\nBiomeGenerator::BiomeGenerator(BiomeType biome, unsigned int width, unsigned int height, unsigned int seed) : biome(biome), width(width), height(height), seed(seed) {\n    if (biome == BiomeType::Maze) {\n        setTiles(floor_id, wall_id);\n    } else if (biome == BiomeType::Grasslands) {\n        setTiles(grass_id, dirt_id);\n    }\n    else if (biome == BiomeType::Ocean) {\n        setTiles(water_id, sand_id);\n    }\n\n    perlinNoise = PerlinNoise(seed);\n    grid.Resize(width, height);\n}\n\nvoid BiomeGenerator::setWorld(WorldBase *world) {\n    worldPtr = world;\n}\n\nvoid BiomeGenerator::generate() {\n    size_t tile1 = tiles[0];\n    size_t tile2 = tiles[1];\n\n    for (unsigned int y = 0; y &lt; height; y++) {\n        for (unsigned int x = 0; x &lt; width; x++) {\n            // Give 5x5 clear space in top left corner\n            // TODO: Replace with putting player in valid room instead of 0,0\n            if (x &gt; 4 || y &gt; 4) {\n                const double val = perlinNoise.noise2D(x * frequency / width, y * frequency / height);\n                grid.At(x, y) = val &lt; 0 ? tile1 : tile2;\n            }\n        }\n    }\n\n\n    if (biome == BiomeType::Maze) {\n        placeSpecialTiles(tile1, spike_id, 0.05); // Placing spike tiles\n        placeSpecialTiles(tile1, tar_id, 0.08); // Placing tar tiles\n        placeTileRandom(key_id, floor_id); // placing key tile\n\n        vector&lt;GridPosition&gt; path = clearPath();\n        applyPathToGrid(path);\n        placeDoorTile(door_id); // placing door tile\n        grid.At(keyLocation) = key_id;\n\n    }\n\n    if (biome == BiomeType::Grasslands) {\n        placeTileRandom(hole_id, grass_id); // placing hole tile\n    }\n\n    if (biome == BiomeType::Ocean) {\n        oceanHandler();\n        placeTileRandom(hole_id, sand_id);\n    }\n\n}\n\nvoid BiomeGenerator::placeTileRandom(const size_t &amp;tile, const size_t &amp;spawnTile) {\n    bool counter = false;\n    while (!counter) {\n        int random_x = (int)worldPtr-&gt;GetRandom(width / 2.0, width - 1);\n        int random_y = (int)worldPtr-&gt;GetRandom(height / 2.0, height - 1);\n\n        if (grid.At(random_x, random_y) == spawnTile) {\n            grid.At(random_x, random_y) = tile;\n\n            if (tile == key_id) {\n                keyLocation = GridPosition(random_x, random_y);\n            }\n\n            counter = true;\n        }\n    }\n}\n\nvoid BiomeGenerator::placeDoorTile(const size_t &amp;doorTile) {\n    grid.At(2, 2) = doorTile;\n}\n\nvoid BiomeGenerator::placeSpecialTiles(const size_t &amp;genericTile, const size_t &amp;specialTile, double percentage) {\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; floorPositions;\n    for (unsigned int x = 0; x &lt; width; ++x) {\n        for (unsigned int y = 0; y &lt; height; ++y) {\n            if (grid.At(x, y) == genericTile) {\n                floorPositions.emplace_back(x, y);\n            }\n        }\n    }\n\n    int numSpikes = (int)round((int)floorPositions.size() * percentage);\n\n    // Convert some generic floor tiles to special tiles\n    for (int i = 0; i &lt; numSpikes; ++i) {\n        int pos = (int)round(worldPtr-&gt;GetRandom((int)floorPositions.size() - 1));\n        grid.At(floorPositions [pos].first, floorPositions[pos].second) = specialTile;\n\n        floorPositions.erase(floorPositions.begin() + pos);\n    }\n}\n\nvector&lt;GridPosition&gt; BiomeGenerator::clearPath() const {\n    vector&lt;GridPosition&gt; path;\n\n    GridPosition current(0, 0); // Starting point\n    path.push_back(current);\n\n    // Continue until we reach the KeyLocation\n    while (current != keyLocation) {\n        std::vector&lt;GridPosition&gt; possibleMoves;\n\n        // Always add right movement if not aligned horizontally\n        if (current.GetX() &lt; keyLocation.GetX()) {\n            possibleMoves.push_back(current.ToRight());\n        }\n\n        // Add down movement if above the target and within grid bounds\n        if (current.GetY() &lt; keyLocation.GetY() &amp;&amp; current.GetY() &lt; height - 1) {\n            possibleMoves.push_back(current.Below());\n        }\n\n        // Add up movement if below the target and within grid bounds\n        if (current.GetY() &gt; keyLocation.GetY() &amp;&amp; current.GetY() &gt; 0) {\n            possibleMoves.push_back(current.Above());\n        }\n\n        // Randomly choose one of the possible moves\n        if (!possibleMoves.empty()) {\n            GridPosition next = possibleMoves[int(worldPtr-&gt;GetRandom(0, 2)) % possibleMoves.size()];\n\n            // Check if we have made a valid move, if so, update the path and current position\n            if (next != current) {\n                path.push_back(next);\n                current = next;\n            }\n        }\n    }\n\n    return path;\n}\n\n\n\nvoid BiomeGenerator::applyPathToGrid(const vector&lt;GridPosition&gt; &amp;path) {\n    for (const GridPosition &amp;p: path) {\n        grid.At(p) = floor_id;\n    }\n}\n\nvoid BiomeGenerator::saveToFile(const std::string &amp;filename) const {\n    type_options_t types = type_options_t();\n\n    types.push_back(CellType{\"floor\", \"Floor that you can easily walk over.\", ' '});\n    types.push_back(CellType{\"wall\", \"Impenetrable wall that you must find a way around.\", '#'});\n    types.push_back(CellType{\"spike\", \"Dangerous spike that resets the game.\", 'X'});\n    types.push_back(CellType{\"tar\", \"Slow tile that makes you take two steps to get through it\", 'O'});\n    types.push_back(CellType{\"key\", \"item that can be picked up to unlock door and escape maze\", 'K'});\n    types.push_back(CellType{\"door\", \"Door that can be walked through only with possession of key to leave maze\", 'D'});\n    types.push_back(CellType{\"grass\", \"Grass you can walk on.\", 'M'});\n    types.push_back(CellType{\"dirt\", \"Dirt you can walk on.\", '~'});\n    types.push_back(CellType{\"tree\", \"A tree that blocks the way.\", 't'});\n    types.push_back(CellType{\"hole\", \"A hole that you can fall into the maze from.\", '8'});\n\n    types.push_back(CellType{\"water\",\"Water that you may be able to swim on.\", 'W'});\n    types.push_back(CellType{\"sand\", \"Sand you can walk on.\", '-'});\n\n\n    grid.Write(filename, types);\n\n}\n\nvoid BiomeGenerator::setTiles(const size_t &amp;firstTile, const size_t &amp;secondTile) {\n    tiles.clear();\n    tiles.push_back(firstTile);\n    tiles.push_back(secondTile);\n}\n\nvoid BiomeGenerator::placeTrees() {\n    // Iterates through each tile in the grid with a margin of 1 tile to prevent out of bounds access\n    for (unsigned int y = 1; y &lt; height - 1; ++y) {\n        for (unsigned int x = 1; x &lt; width - 1; ++x) {\n            // Only place trees on grass tiles and ensure we have space for a 3x3 tree\n            if (grid.At(x, y) == grass_id &amp;&amp;\n                    grid.At(x-1, y) == grass_id &amp;&amp; grid.At(x+1, y) == grass_id &amp;&amp;\n                    grid.At(x, y-1) == grass_id &amp;&amp; grid.At(x, y+1) == grass_id &amp;&amp;\n                    grid.At(x-1, y-1) == grass_id &amp;&amp; grid.At(x+1, y-1) == grass_id &amp;&amp;\n                    grid.At(x-1, y+1) == grass_id &amp;&amp; grid.At(x+1, y+1) == grass_id) {\n                // Use a random chance to place a tree\n                if (worldPtr-&gt;GetRandom( 100) &lt; 10) { // 10% chance to place a tree\n                    // Place a 3x3 block of tree tile characters for the tree\n                    for (int i = -1; i &lt;= 1; ++i) {\n                        for (int j = -1; j &lt;= 1; ++j) {\n                            grid.At(x + i, y + j) = tree_id;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid BiomeGenerator::oceanHandler(){\n    for (unsigned int y = 1; y &lt; height - 1; ++y) {\n        for (unsigned int x = 1; x &lt; width - 1; ++x) {\n            if (grid.At(x, y) == water_id) {\n                if (worldPtr-&gt;GetRandom(100) &lt; 15) {\n                    for (int i = -1; i &lt;= 1; ++i) {\n                        for (int j = -1; j &lt;= 1; ++j) {\n                            if (x + i &gt; 0 &amp;&amp; x + i &lt; width - 1 &amp;&amp; y + j &gt; 0 &amp;&amp; y + j &lt; height - 1) {\n                                grid.At(x + i, y + j) = sand_id;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp/","title":"File BiomeGenerator.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; BiomeGenerator.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"PerlinNoise.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> <li><code>#include \"../core/WorldGrid.hpp\"</code></li> <li><code>#include \"../core/Data.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace group6 A World that consists only of walls and open cells."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp/#classes","title":"Classes","text":"Type Name class BiomeGenerator"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Paul Schulte, Milan Mihailovic, ChatGPT</p> <p>Uses perlin noise to create dirt and grass on a grid </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/BiomeGenerator.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp_source/","title":"File BiomeGenerator.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; BiomeGenerator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;queue&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n\n#include \"PerlinNoise.hpp\"\n#include \"../core/WorldBase.hpp\"\n#include \"../core/WorldGrid.hpp\"\n#include \"../core/Data.hpp\"\n\nnamespace group6 {\n    using siv::PerlinNoise;\n    using cse491::WorldGrid, cse491::WorldBase, cse491::GridPosition;\n\n    enum class BiomeType {\n        Maze,\n        Grasslands,\n        Ocean\n    };\n\n    class BiomeGenerator {\n    private:\n        const double frequency = 8.0;         \n        // const int octaves = 8;                ///&lt; [1, 16]\n\n        PerlinNoise perlinNoise;              \n\n        BiomeType biome;                      \n\n        unsigned int width;                   \n        unsigned int height;                  \n        WorldGrid grid;                       \n\n        WorldBase *worldPtr = nullptr;        \n\n        unsigned int seed;                    \n\n        GridPosition keyLocation;\n\n        std::vector&lt;size_t&gt; tiles;            \n\n        size_t floor_id = 0;\n        size_t wall_id = 1;\n\n        size_t spike_id = 2;\n        size_t tar_id = 3;\n        size_t key_id = 4;\n        size_t door_id = 5;\n\n        size_t grass_id = 6;\n        size_t dirt_id = 7;\n\n        size_t tree_id = 8;\n\n        size_t sand_id = 11;\n        size_t water_id = 10;\n\n        size_t hole_id = 9;\n\n    public:\n        BiomeGenerator(BiomeType biome, unsigned int width, unsigned int height, unsigned int seed);\n        ~BiomeGenerator() = default;\n\n        void setWorld(WorldBase *world);\n\n        void generate();\n        void saveToFile(const std::string &amp;filename) const;\n        void placeSpecialTiles(const size_t &amp;genericTile, const size_t &amp;specialTile, double percentage);\n\n        [[nodiscard]] unsigned int getSeed() const { return  seed; }\n\n        void setTiles(const size_t &amp;firstTile, const size_t &amp;secondTile);\n        [[nodiscard]] BiomeType getBiome() const { return biome; }\n\n        void placeDoorTile(const size_t &amp;doorTile);\n        void placeTileRandom(const size_t&amp; tile, const size_t&amp; spawnTile);\n\n        [[nodiscard]] std::vector&lt;GridPosition&gt; clearPath() const;\n        void applyPathToGrid(const std::vector&lt;GridPosition&gt;&amp; path);\n\n        void placeTrees();\n\n        void oceanHandler();\n    };\n}\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_generative_world_8hpp/","title":"File GenerativeWorld.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; GenerativeWorld.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"BiomeGenerator.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> <li><code>#include \"../Agents/AStarAgent.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_generative_world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace group6 A World that consists only of walls and open cells."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_generative_world_8hpp/#classes","title":"Classes","text":"Type Name class GenerativeWorld <p>The documentation for this class was generated from the following file <code>source/Worlds/GenerativeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_generative_world_8hpp_source/","title":"File GenerativeWorld.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; GenerativeWorld.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"BiomeGenerator.hpp\"\n#include \"../core/WorldBase.hpp\"\n#include \"../Agents/AStarAgent.hpp\"\n\nnamespace group6 {\n    using namespace cse491;\n    using std::vector, std::string;\n\n    class GenerativeWorld : public WorldBase {\n    protected:\n        enum ActionType {\n            REMAIN_STILL = 0, MOVE_UP, MOVE_DOWN, MOVE_LEFT, MOVE_RIGHT\n        };\n\n        size_t floor_id; \n        size_t wall_id;  \n\n        size_t spike_id;      \n        size_t tar_id;        \n        size_t key_id;        \n        size_t door_id;       \n        size_t teleporter_id; \n        size_t armory_id;     \n\n        size_t tree_id;       \n        size_t grass_id;      \n        size_t dirt_id;       \n        size_t hole_id;       \n\n        size_t water_id;      \n        size_t sand_id;       \n\n        unsigned int world_width;\n        unsigned int world_height;\n\n        void ConfigAgent(AgentBase &amp;agent) override {\n            agent.AddAction(\"up\", MOVE_UP);\n            agent.AddAction(\"down\", MOVE_DOWN);\n            agent.AddAction(\"left\", MOVE_LEFT);\n            agent.AddAction(\"right\", MOVE_RIGHT);\n            agent.SetProperty(\"key_property\",0.0); \n            agent.SetProperty(\"tar_property\",5.0); \n        }\n\n        void DamageAgent(AgentBase &amp;agent) {\n            if (agent.IsInterface()) {\n                EndGame(false);\n            }\n        }\n\n        void CreateGrid(BiomeType biome, unsigned int width, unsigned int height, unsigned int seed, const string &amp;file) {\n            BiomeGenerator biomeGenerator(biome, width, height, seed);\n            biomeGenerator.setWorld(this);\n            biomeGenerator.generate();\n\n            string filePath = \"../assets/grids/generated_\" + file + \".grid\";\n\n            biomeGenerator.saveToFile(filePath);\n\n            main_grid.Read(filePath, type_options);\n        }\n\n    public:\n        explicit GenerativeWorld(BiomeType biome, unsigned int width, unsigned int height, unsigned int seed)\n                : WorldBase(seed) {\n            floor_id = AddCellType(\"floor\", \"Floor that you can easily walk over.\", ' ');\n            wall_id = AddCellType(\"wall\", \"Impenetrable wall that you must find a way around.\", '#');\n\n            spike_id = AddCellType(\"spike\", \"Dangerous spike that resets the game.\", 'X');\n\n            tar_id = AddCellType(\"tar\", \"Slow tile that makes you take two steps to get through it\", 'O');\n            key_id = AddCellType(\"key\", \"item that can be picked up to unlock door and escape maze\", 'K');\n            door_id = AddCellType(\"door\", \"Door that can be walked through only with possession of key to leave maze\",'D');\n            teleporter_id = AddCellType(\"teleporter\", \"Teleports agent to other teleporter\", 'T');\n\n            armory_id = AddCellType(\"armory\", \"Armory tile that repairs damaged inventory items\", 'A');\n            tree_id = AddCellType(\"tree\", \"A tree that blocks the way.\", 't');\n            grass_id = AddCellType(\"grass\", \"Grass you can walk on.\", 'M');\n            dirt_id = AddCellType(\"dirt\", \"Dirt you can walk on.\", '~');\n            hole_id = AddCellType(\"hole\", \"A hole that you can fall into the maze from.\", '8');\n\n            water_id = AddCellType(\"water\", \"Water that you may be able to swim on.\", 'W');\n            sand_id = AddCellType(\"sand\", \"Sand you can walk on.\", '-');\n\n            world_width = width;\n            world_height = height;\n\n            CreateGrid(biome, width, height, seed, \"maze\");\n        }\n\n        ~GenerativeWorld() override = default;\n\n        void AddTeleporters() {\n            main_grid.At(53, 6) = teleporter_id;\n            main_grid.At(18, 18) = teleporter_id;\n        }\n\n        [[noreturn]] void EndGame(bool win) {\n            run_over = true;\n\n            if (win) {\n                std::cout &lt;&lt; \"You successfully exited maze!\" &lt;&lt; std::endl;\n            } else {\n                std::cout &lt;&lt; \"Game over, try again!\" &lt;&lt; std::endl;\n            }\n            std::exit(0);\n        }\n\n        void AddArmory() {\n            bool counter = false;\n            while (!counter) {\n                //generate random location in bottom left quarter of map\n                int random_y = (int)GetRandom((double)main_grid.GetHeight() / 2, (double)main_grid.GetHeight() - 1);\n                int random_x = (int)GetRandom(0, (double)main_grid.GetWidth() / 2);\n\n                if (main_grid.At(random_x, random_y) == floor_id) {\n                    main_grid.At(random_x, random_y) = armory_id;\n                    counter = true;\n                }\n            }\n\n            counter = false;\n            while (!counter) {\n                //generate random location in top right quarter of map\n                int random_y = (int)GetRandom(0, (double)main_grid.GetHeight() / 2);\n                int random_x = (int)GetRandom((double)main_grid.GetWidth() / 2, (double)main_grid.GetWidth() - 1);\n\n                if (main_grid.At(random_x, random_y) == floor_id) {\n                    main_grid.At(random_x, random_y) = armory_id;\n                    counter = true;\n                }\n            }\n        }\n\n        [[nodiscard]] static vector&lt;GridPosition&gt; FindTiles(WorldGrid grid, size_t tile_id) {\n            vector&lt;GridPosition&gt; result;\n\n            for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n                for (size_t y = 0; y &lt; grid.GetHeight(); ++y) {\n                    if (grid.At(x, y) == tile_id) {\n                        result.emplace_back(x, y);\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        int DoAction(AgentBase &amp;agent, size_t action_id) override {\n            AgentCollisionHelper(agent);\n\n            // Skip turn if stuck on tar\n            if (agent.GetProperty(\"tar_property\") == 6.0) {\n                agent.SetProperty(\"tar_property\", 5.0);\n                return true;\n            }\n\n            // Determine where the agent is trying to move.\n            GridPosition new_position;\n            switch (action_id) {\n                case REMAIN_STILL:\n                    new_position = agent.GetPosition();\n                    break;\n                case MOVE_UP:\n                    new_position = agent.GetPosition().Above();\n                    break;\n                case MOVE_DOWN:\n                    new_position = agent.GetPosition().Below();\n                    break;\n                case MOVE_LEFT:\n                    new_position = agent.GetPosition().ToLeft();\n                    break;\n                case MOVE_RIGHT:\n                    new_position = agent.GetPosition().ToRight();\n                    break;\n            }\n\n            // Don't let the agent move off the world or into a wall.\n            if (!main_grid.IsValid(new_position)) { return false; }\n            if (main_grid.At(new_position) == wall_id) { return false; }\n\n            //check to see if player is going onto armory tile\n            if (main_grid.At(new_position) == armory_id) {\n                ArmoryTileHelper(agent);\n            }\n            // check to see if player is moving onto spike tile\n            if (main_grid.At(new_position) == spike_id) {\n                SpikeTileHelper(agent);\n            }\n            // check to see if player is moving onto a tar tile\n            else if (main_grid.At(new_position) == tar_id) {\n                TarTileHelper(agent);\n            }\n            // check to see if player is moving onto teleporter\n            else if (main_grid.At(new_position) == teleporter_id) {\n                TeleporterHelper(new_position);\n            }\n            // check to see if player is moving onto key tile\n            else if (main_grid.At(new_position) == key_id) {\n                KeyTileHelper(agent, new_position);\n            }\n            // check to see if the player is moving onto door tile\n            else if (main_grid.At(new_position) == door_id) {\n                DoorTileHelper(agent);\n            }\n            // check to see if player is moving onto a hole tile\n            else if (main_grid.At(new_position) == hole_id) {\n                HoleTileHelper(agent, new_position);\n            }\n\n            //recalculate AStarAgent's path when player moves\n            AStarAgentHelper(agent);\n\n            //check to see if agent is walking on an item\n            ItemHelper(agent, new_position);\n\n            // Set the agent to its new position.\n            agent.SetPosition(new_position);\n\n            return true;\n        }\n\n        void ArmoryTileHelper(AgentBase &amp;agent) {\n            for (const auto &amp;pair: item_map) {\n                //if agent has the item in its inventory, heal it back to full health\n                if (agent.HasItem(pair.first)) {\n                    pair.second-&gt;SetProperty(\"Health\", 4.0);\n                }\n            }\n        }\n\n        void SpikeTileHelper(AgentBase &amp;agent) {\n            bool spike_immune = false;\n\n            //check to see if player has shield on\n            for (const auto &amp;pair: item_map) {\n                if (agent.HasItem(pair.first) &amp;&amp; pair.second-&gt;GetName() == \"Shield\") {\n                    //agent's shield has enough health and will protect player from spike tile\n                    if (pair.second-&gt;GetProperty(\"Health\") &gt; 0) {\n                        pair.second-&gt;SetProperty(\"Health\", pair.second-&gt;GetProperty(\"Health\") - 1);\n                        spike_immune = true;\n\n                        break;\n                    }\n                }\n            }\n\n            // Damage agent if not immune to spike\n            if (!spike_immune) {\n                DamageAgent(agent);\n            }\n        }\n\n        void TarTileHelper(AgentBase &amp;agent) {\n            bool tar_immune = false;\n\n            //check to see if player has boots on\n            for (const auto &amp;pair: item_map) {\n                if (agent.HasItem(pair.first) &amp;&amp; pair.second-&gt;GetName() == \"Boots\") {\n                    //agent's boots have enough health and will protect player from tar\n                    if (pair.second-&gt;GetProperty(\"Health\") &gt; 0) {\n                        pair.second-&gt;SetProperty(\"Health\", pair.second-&gt;GetProperty(\"Health\") - 1);\n                        tar_immune = true;\n\n                        break;\n                    }\n                }\n            }\n\n            // Slow agent if not immune to tar\n            if (!tar_immune) {\n                agent.SetProperty(\"tar_property\", 6.0);\n            }\n        }\n\n        void TeleporterHelper(GridPosition &amp;new_position) {\n            vector&lt;GridPosition&gt; teleporters = FindTiles(main_grid, teleporter_id);\n\n            for (GridPosition teleporter: teleporters) {\n                if (new_position != teleporter) {\n                    new_position = teleporter;\n\n                    break;\n                }\n            }\n        }\n\n        void KeyTileHelper(AgentBase &amp;agent, GridPosition &amp;new_position) {\n            // Only player can pick up keys\n            if (agent.IsInterface()) {\n                agent.SetProperty(\"key_property\", 1.0);\n                main_grid.At(new_position) = floor_id;\n            }\n        }\n\n        void DoorTileHelper(AgentBase &amp;agent) {\n            // Only player with key can win game\n            if (agent.IsInterface() &amp;&amp; agent.GetProperty(\"key_property\") == 1.0) {\n                EndGame(true);\n            }\n        }\n\n        void HoleTileHelper(AgentBase &amp;agent, GridPosition &amp;new_position) {\n            if (agent.IsInterface()) {\n                CreateGrid(BiomeType::Maze, world_width, world_height, ++seed, \"maze2\");\n                new_position.Set(0, 0);\n            }\n        }\n\n        void ItemHelper(AgentBase &amp;agent, GridPosition &amp;new_position) {\n            for (const auto &amp;pair: item_map) {\n                //check to see if items position is same as the position the player is moving to\n                if (pair.second-&gt;GetPosition() == new_position) {\n                    //Add item to inventory\n                    agent.AddItem(pair.first);\n                    break;\n                }\n            }\n        }\n\n        void AgentCollisionHelper(AgentBase &amp;agent) {\n            //if player is on same position as agent, game ends\n            for (const auto &amp;temp_agent: agent_map) {\n                //check to see if the two agents positions being compared are equal,\n                //as well as if one agent is a player and one agent is an enemy\n                if (temp_agent.second-&gt;GetPosition() == agent.GetPosition() &amp;&amp;\n                    ((agent.GetName() == \"Player\" &amp;&amp; temp_agent.second-&gt;GetName() != \"Player\") ||\n                     (agent.GetName() != \"Player\" &amp;&amp; temp_agent.second-&gt;GetName() == \"Player\")))\n                    EndGame(false);\n            }\n        }\n\n\n        bool IsTraversable(const AgentBase &amp; /*agent*/, cse491::GridPosition pos) const override {\n            size_t tileType = main_grid.At(pos);\n            return !(tileType == wall_id || tileType == spike_id || tileType == tar_id || tileType == armory_id || tileType == teleporter_id);\n        }\n\n        void AStarAgentHelper(AgentBase &amp;agent)\n        {\n            if( agent.GetName() == \"AStar1\" )\n            {\n                for( const auto &amp;temp_agent : agent_map )\n                {\n                    //updating AStarAgent's path to the players current location\n                    if( temp_agent.second-&gt;GetName() == \"Player\" )\n                    {\n                        auto &amp;astar_agent = dynamic_cast&lt;walle::AStarAgent&amp;&gt;(agent);\n                        astar_agent.SetGoalPosition(temp_agent.second-&gt;GetPosition());\n                        astar_agent.RecalculatePath();\n                        astar_agent.SetActionResult(1);\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n} // End of namespace group6\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_language_8hpp/","title":"File Language.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; Language.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;tao/pegtl.hpp&gt;</code></li> <li><code>#include &lt;tao/pegtl/contrib/parse_tree.hpp&gt;</code></li> <li><code>#include \"core/EasyLogging.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_language_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace worldlang Namespace for scripting language stuff."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_language_8hpp/#classes","title":"Classes","text":"Type Name struct Unit struct add struct add_a struct assignment struct code_block struct comment struct comp struct comp_a struct element struct expression struct expression_list struct function struct identifier struct identifier_list struct mul struct mul_a struct number struct op_prio_add struct op_prio_comp struct op_prio_mul struct program struct statement struct statement_list struct string <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_language_8hpp_source/","title":"File Language.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; Language.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n// Debug\n#include &lt;iostream&gt;\n\n#include &lt;functional&gt;\n\n#include &lt;tao/pegtl.hpp&gt;\n#include &lt;tao/pegtl/contrib/parse_tree.hpp&gt;\n\n#include \"core/EasyLogging.hpp\"\n\nusing clogged::Logger;\nusing clogged::Team;\nusing clogged::LogLevel;\n\nnamespace pegtl = tao::pegtl;\n\nnamespace worldlang{\n    std::string stripWhitespace(const std::string&amp; input) {\n        std::string result;\n        bool insideString = false;\n\n        for (char c : input) {\n            if (c == '\\\"') {\n                insideString = !insideString;\n            }\n            // https://en.cppreference.com/w/cpp/string/byte/isspace\n            if (!insideString &amp;&amp; std::isspace(c) &amp;&amp; c != '\\n') {\n                // Skip whitespace outside of strings, excluding newlines\n                continue;\n            }\n            result += c;\n        }\n        return result;\n    }\n\n    // Equivalent regex\n    // \\-?[0-9]+(.[0-9]+)?\n    struct number : pegtl::seq &lt; \n        pegtl::opt&lt;\n            pegtl::one&lt; '-' &gt;\n        &gt;,\n        pegtl::plus&lt; pegtl::digit &gt;,\n        pegtl::opt&lt;\n            pegtl::one&lt; '.' &gt;,\n            pegtl::plus&lt; pegtl::digit &gt;\n        &gt;\n    &gt;\n    {};\n\n    struct string : pegtl::seq&lt;\n        pegtl::one&lt; '\"' &gt;,\n        pegtl::star&lt;\n            pegtl::not_one&lt;'\"'&gt;\n        &gt;,\n        pegtl::one&lt; '\"' &gt;\n    &gt;\n    {};\n\n    //[_a-zA-Z][_a-zA-Z0-9]*\n    // (C-style identifier, case sensitive)\n    struct identifier : pegtl::identifier\n    {};\n\n    // identifier list\n    // Contains one or more identifiers.\n    // This matches expressions such as\n    // \"name\" or \"a,b,c\".\n    struct identifier_list; \n    struct identifier_list : pegtl::sor&lt;\n        pegtl::seq&lt;\n            identifier,\n            pegtl::one&lt; ',' &gt;,\n            identifier_list\n        &gt;,\n        identifier\n    &gt;\n    {};\n\n    // Match operators of same priority as addition\n    struct op_prio_add : pegtl::one&lt; '+', '-' &gt;\n    {};\n\n    // Match operators of same priority as multiplication\n    struct op_prio_mul : pegtl::one&lt; '*', '/' &gt;\n    {};\n\n    // Match operators of same priority as comparison ops\n    struct op_prio_comp : pegtl::sor&lt; \n        TAO_PEGTL_STRING(\"==\"),\n        TAO_PEGTL_STRING(\"!=\"),\n        TAO_PEGTL_STRING(\"&lt;=\"),\n        TAO_PEGTL_STRING(\"&gt;=\"),\n        pegtl::one&lt; '&lt;' &gt;,\n        pegtl::one&lt; '&gt;' &gt;\n    &gt;\n    {};\n\n    // Must forward-declare for recursion\n    struct expression;\n    struct expression_list; \n\n    // Function call\n    // Matches expressions of form\n    // \"id(arg1,arg2,...)\" or \"id()\"\n    struct function : pegtl::seq&lt;\n        identifier,\n        pegtl::one&lt; '(' &gt;,\n        pegtl::opt&lt;expression_list&gt;,\n        pegtl::one&lt; ')' &gt;\n    &gt;\n    {};\n\n    // Match an expression or element representing a single value\n    // examples: 5,(-38),myvar1,myfunc1(7)\n    // Note that functions can technically return multiple values or none,\n    // so this isn't perfect.\n    // Expressions within parentheses is also counted as an element to allow\n    // for recursion, so \"(3+5+8)\" is a valid element\n    struct element : pegtl::sor&lt;\n        function,\n        identifier,\n        number,\n        string,\n        pegtl::seq&lt;\n            pegtl::one&lt; '(' &gt;,\n            expression,\n            pegtl::one&lt; ')' &gt;\n        &gt;\n    &gt;\n    {};\n\n    // Matches one multiplication expression or a single element\n    // \"a*b\" or \"c\"\n    struct mul_a : pegtl::sor&lt;\n        pegtl::seq&lt;\n            element,\n            op_prio_mul,\n            element\n        &gt;,\n        element\n    &gt;\n    {};\n\n    struct mul;\n    // Recursively matches multiplication operations\n    // Ex. \"1*4\", \"a*b*c\"\n    struct mul : pegtl::sor&lt;\n        pegtl::seq&lt;\n            mul_a,\n            op_prio_mul,\n            mul\n        &gt;,\n        mul_a\n    &gt;\n    {};\n\n    // Matches one addition expression or a multiplication subexpression\n    // \"a+b\" or \"a+b*c\", with \"b*c\" as the subexpression\n    struct add_a : pegtl::sor&lt;\n        pegtl::seq&lt;\n            mul,\n            op_prio_add,\n            mul\n        &gt;,\n        mul\n    &gt;\n    {}; \n\n    // Matches entire addition expression\n    struct add;\n    struct add : pegtl::sor&lt;\n        pegtl::seq&lt;\n            add_a,\n            op_prio_add,\n            add\n        &gt;,\n        add_a\n    &gt;\n    {};\n\n    struct comp_a : pegtl::sor&lt;\n        pegtl::seq&lt;\n            add,\n            op_prio_comp,\n            add\n        &gt;,\n        add\n    &gt;\n    {}; \n\n    // Matches entire comparison expression\n    struct comp;\n    struct comp : pegtl::sor&lt;\n        pegtl::seq&lt;\n            comp_a,\n            op_prio_comp,\n            comp\n        &gt;,\n        comp_a\n    &gt;\n    {};\n\n    // Match an expression intended to evaluate to a single value.\n    struct expression : pegtl::sor&lt;\n        comp\n    &gt;\n    {};\n\n    struct expression_list;\n    // A list of expressions. Can contain one or more expressions (not zero!)\n    // \"123,345+456,func(3)+6*8\"\n    struct expression_list : pegtl::sor&lt;\n        pegtl::seq&lt;\n            expression,\n            pegtl::one&lt; ',' &gt;,\n            expression_list\n        &gt;,\n        expression\n    &gt;\n    {};\n\n    // Assignment expression\n    // \"var=value\", or \"var,vars=val1,val2\", etc.\n    struct assignment : pegtl::seq&lt;\n        identifier_list,\n        pegtl::one&lt; '=' &gt;,\n        expression_list\n    &gt;\n    {};\n\n    // Comment\n    // # Comment text goes here\n    struct comment : pegtl::seq&lt;\n        pegtl::one&lt; '#' &gt;,\n        pegtl::until&lt;\n            pegtl::eol\n        &gt;\n    &gt;\n    {};\n\n    struct statement_list;\n\n    // Matches a block of code\n    // ex. { /*code*/ }\n    struct code_block : pegtl::seq&lt;\n        pegtl::one&lt; '{' &gt;,\n        pegtl::eol,\n        statement_list,\n        pegtl::one&lt; '}' &gt;,\n        pegtl::eol\n    &gt;\n    {};\n\n    struct statement : pegtl::sor&lt;\n        pegtl::seq&lt;\n            function,\n            pegtl::opt&lt;code_block&gt;,\n            pegtl::opt&lt;pegtl::eol&gt;\n        &gt;,\n        pegtl::seq&lt;\n            assignment,\n            pegtl::opt&lt;pegtl::eol&gt;\n        &gt;,\n        comment,\n        pegtl::eol\n    &gt;\n    {};\n\n    struct statement_list;  \n    // function()\\nfunction()...\n    struct statement_list : pegtl::sor&lt;\n        pegtl::seq&lt;\n            statement,\n            statement_list\n        &gt;,\n        statement\n    &gt;\n    {};\n\n    struct program : pegtl::seq&lt;\n        statement_list,\n        pegtl::eolf\n    &gt;\n    {};\n\n    template&lt; typename Rule &gt;\n    using selector = tao::pegtl::parse_tree::selector&lt; Rule,\n        tao::pegtl::parse_tree::store_content::on&lt;\n            number,\n            string,\n            function,\n            identifier,\n            identifier_list,\n            expression,\n            expression_list,\n            statement,\n            statement_list,\n            code_block,\n            program,\n            assignment,\n            op_prio_add,\n            op_prio_mul,\n            op_prio_comp\n        &gt;,\n        tao::pegtl::parse_tree::fold_one::on&lt;\n            add_a,\n            mul_a\n        &gt;\n    &gt;;\n\n    struct Unit {\n        enum class Type {\n            number,\n            string,\n            identifier,\n            function,\n            operation,\n            function_decl,\n        };\n        Type type;\n\n        std::string value;\n    };\n\n\n    std::vector&lt;Unit&gt; parse_to_code(std::string program){\n        program = stripWhitespace(program);\n        pegtl::string_input in(program, \"program\");\n        std::vector&lt;Unit&gt; out{};\n\n        auto log = Logger::Log() &lt;&lt; Team::TEAM_4 &lt;&lt; LogLevel::DEBUG;\n        log &lt;&lt; \"Entering parser\" &lt;&lt; std::endl;\n\n        std::function&lt;void(const std::unique_ptr&lt;pegtl::parse_tree::node&gt;&amp;)&gt; traverse =\n        [&amp;out, &amp;traverse, &amp;log](const std::unique_ptr&lt;pegtl::parse_tree::node&gt;&amp; node) -&gt; void{\n            const std::string_view&amp; type = node-&gt;type;\n            // visit:\n            if (type == \"worldlang::number\"){\n                out.push_back(Unit{Unit::Type::number, node-&gt;string()});\n            } else if (type == \"worldlang::identifier\"){\n                out.push_back(Unit{Unit::Type::identifier, node-&gt;string()});\n            } else if (type == \"worldlang::string\"){\n                // trim quotes off\n                out.push_back(Unit{Unit::Type::string, node-&gt;string().substr(1,node-&gt;string().size()-2)});\n            } else if (type == \"worldlang::function\"){\n                // (operator_endargs) arg arg arg function_name\n                out.push_back(Unit{Unit::Type::operation, \"endargs\"});\n                if (node-&gt;children.size() &gt; 1)\n                    traverse(node-&gt;children[1]);\n\n//              out.push_back(Unit{Unit::Type::number, std::to_string(argcount)});\n                out.push_back(Unit{Unit::Type::function, node-&gt;children.at(0)-&gt;string()});\n            } else if (type == \"worldlang::assignment\"){\n                // identifier_list\n//              auto identifier_count = count(node-&gt;children.at(0));\n                out.push_back(Unit{Unit::Type::operation, \"endargs\"});\n                traverse(node-&gt;children.at(0));\n                // value\n                // Can't check expression count here: must be done at runtime\n                // since functions may have multiple returns\n                out.push_back(Unit{Unit::Type::operation, \"endargs\"});\n                traverse(node-&gt;children.at(1));\n                // expression\n//              out.push_back(Unit{Unit::Type::number, std::to_string(identifier_count)});\n                out.push_back(Unit{Unit::Type::operation, \"=\"});\n            } else if (type == \"worldlang::mul_a\"\n                    || type == \"worldlang::add_a\"\n                    || type == \"worldlang::expression\"){\n                traverse(node-&gt;children.at(0));\n                if (node-&gt;children.size() &gt; 1){\n                    traverse(node-&gt;children.at(2));\n                    out.push_back(Unit{Unit::Type::operation, node-&gt;children.at(1)-&gt;string()});\n                }\n            } else if (type == \"worldlang::expression_list\"\n                    || type == \"worldlang::identifier_list\"){\n                log &lt;&lt; \"Traversing \" &lt;&lt; type &lt;&lt; \"\\n\";\n                if (node-&gt;children.size()){\n                    for (const auto&amp; c : node-&gt;children){\n                        traverse(c);\n                    }\n                }\n            } else if (type == \"worldlang::code_block\"){\n                log &lt;&lt; \"Traversing \" &lt;&lt; type &lt;&lt; \"\\n\";\n                out.push_back(Unit{Unit::Type::operation, \"start_block\"});\n                traverse(node-&gt;children.at(0));\n                out.push_back(Unit{Unit::Type::operation, \"end_block\"});\n            } else if (type == \"worldlang::statement\"){\n                if (node-&gt;children.size()){\n//                  auto value = node-&gt;children.at(0)-&gt;string();\n                    auto&amp; first = node-&gt;children.at(0);\n                    if (first-&gt;type == \"worldlang::function\" \n                        &amp;&amp; first-&gt;children.at(0)-&gt;string() != \"if\"\n                        &amp;&amp; first-&gt;children.at(0)-&gt;string() != \"for\"\n                        &amp;&amp; node-&gt;children.size() &gt; 1\n                        &amp;&amp; node-&gt;children.at(1)-&gt;type == \"worldlang::code_block\"){\n                        // encode differently here to use for definitions\n                        // &lt;values&gt; . a b c d e funcname(decl)\n                        // funcname assigns variables, then jumps to code\n                        traverse(node-&gt;children.at(0)); // function\n                        out.back().type = Unit::Type::function_decl;\n                        traverse(node-&gt;children.at(1)); // function code\n                    } else {\n                        for (const auto&amp; child : node-&gt;children){\n                            traverse(child);\n                        }\n                    }\n                }\n                out.push_back(Unit{Unit::Type::operation, \"endline\"});\n            } else {\n                log &lt;&lt; \"Type: \" &lt;&lt; type;\n                if (node-&gt;has_content())\n                    log &lt;&lt; \" Content: \" &lt;&lt; node-&gt;string();\n                log &lt;&lt; std::endl;\n                // visit all children\n                for (const auto&amp; child : node-&gt;children){\n                    traverse(child);\n                }\n            }\n        };\n\n        auto root = pegtl::parse_tree::parse &lt; worldlang::program, worldlang::selector &gt; (in);\n\n        if (root){\n            traverse(root-&gt;children[0]);\n            return out;\n        } else {\n            // parse error lol\n            log &lt;&lt; LogLevel::WARNING &lt;&lt; \"Parse error!!\" &lt;&lt; std::endl;\n            return {};\n        }\n    }\n\n} //worldlang\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_manual_world_8hpp/","title":"File ManualWorld.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; ManualWorld.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_manual_world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491_team8 A World that consists of trees, water, and grass cells."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_manual_world_8hpp/#classes","title":"Classes","text":"Type Name class ManualWorld <p>The documentation for this class was generated from the following file <code>source/Worlds/ManualWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_manual_world_8hpp_source/","title":"File ManualWorld.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; ManualWorld.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;map&gt;\n#include &lt;tuple&gt;\n\n#include \"../core/WorldBase.hpp\"\n#include \"../core/AgentBase.hpp\"\n\nnamespace cse491_team8 {\n\n  class ManualWorld : public cse491::WorldBase {\n  protected:\n    enum ActionType { REMAIN_STILL=0, MOVE_UP, MOVE_DOWN, MOVE_LEFT, MOVE_RIGHT, USE_AXE, USE_BOAT, STATS, HEAL, RUN,\n            ATTACK, SPECIAL, BUFF, HELP };\n    enum FacingDirection { UP=0, RIGHT, DOWN, LEFT};\n\n    size_t grass_id;  \n    size_t tree_id;   \n    size_t water_id;  \n    size_t bridge_id; \n    size_t rock_id;   \n    size_t portal_id_a; \n    size_t portal_id_b; \n    size_t portal_id_c; \n    size_t portal_id_d; \n\n    void ConfigAgent(cse491::AgentBase &amp; agent) override {\n      agent.AddAction(\"up\", MOVE_UP);\n      agent.AddAction(\"down\", MOVE_DOWN);\n      agent.AddAction(\"left\", MOVE_LEFT);\n      agent.AddAction(\"right\", MOVE_RIGHT);\n      agent.AddAction(\"use_axe\", USE_AXE);\n      agent.AddAction(\"use_boat\", USE_BOAT);\n      agent.AddAction(\"stats\", STATS);\n      agent.AddAction(\"heal\", HEAL);\n      agent.AddAction(\"run\", RUN);\n      agent.AddAction(\"attack\", ATTACK);\n      agent.AddAction(\"special\", SPECIAL);\n      agent.AddAction(\"buff\", BUFF);\n      agent.AddAction(\"help\", HELP);\n      agent.SetProperties(\"Strength\", 10, \"Health\", 100, \"Max_Health\", 150, \"Direction\", 0, \"Battling\", false);\n    }\n\n  public:\n    ManualWorld() {\n      grass_id = AddCellType(\"grass\", \"Grass that you can easily walk over.\", ' ');\n      tree_id = AddCellType(\"tree\", \"Tree that you cannot pass without an axe.\", '^');\n      water_id = AddCellType(\"water\", \"Water that cannot be crossed without a boat.\", '~');\n      bridge_id = AddCellType(\"bridge\", \"Bridge that allows the playerto cross water.\", '#');\n      rock_id = AddCellType(\"rock\", \"Rock that the player cannot cross\", '$');\n      portal_id_a = AddCellType(\"portal_a\", \"Portal that teleports player to another a-portal spot.\", '}');\n      portal_id_b = AddCellType(\"portal_b\", \"Portal that teleports player to another b-portal spot.\", '{');\n      portal_id_c = AddCellType(\"portal_c\", \"Portal that teleports player to another c-portal spot.\", '(');\n      portal_id_d = AddCellType(\"portal_d\", \"Portal that teleports player to another d-portal spot.\", ')');\n      main_grid.Read(\"../assets/grids/team8_grid_v2.grid\", type_options);\n    }\n    ~ManualWorld() = default;\n\n    void GenerateMoveSets()\n    {\n        for (auto &amp; [id, agent_ptr] : agent_map)\n        {\n          auto agent_strength = agent_ptr-&gt;GetProperty&lt;int&gt;(\"Strength\");\n          if (agent_ptr-&gt;GetName() == \"Interface\")\n          {\n            std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = {\n                {\"Attack\", std::make_tuple('d', 1.0)},\n                {\"Special\", std::make_tuple('d', 1.5)}, {\"Run\", std::make_tuple('d', 0.0)},\n                {\"Heal\", std::make_tuple('h', 0.25)}};\n            // agent_ptr-&gt;SetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\", move_set);\n            agent_ptr-&gt;SetProperty(\"MoveSet\", move_set);\n            continue;\n          }\n          std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = {{\"Attack\", std::make_tuple('d', 1.0)}};\n          if (agent_strength &gt;= 10)\n          {\n            move_set[\"Special\"] = std::make_tuple('d', 1.5);\n          }\n          if (agent_strength &gt;= 15)\n          {\n            move_set[\"Heal\"] = std::make_tuple('h', 0);\n          }\n          if (agent_strength &gt;= 20)\n          {\n            move_set[\"Buff\"] = std::make_tuple('s', 0.5);\n          }\n          agent_ptr-&gt;SetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\", move_set);\n        }\n    }\n\n    void AddMove(cse491::AgentBase&amp; agent, std::string&amp; move, char stat, double modification)\n    {\n      if (!agent.HasProperty(\"MoveSet\")) {\n        agent.Notify(\"Error: Agent does not have a Move Set\\n\");\n        return;\n      }\n      else\n      {\n        std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = agent.GetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\");\n        move_set[move] = std::make_tuple(stat, modification);\n        agent.SetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\", move_set);\n      }\n    }\n    bool RemoveMove(cse491::AgentBase&amp; agent, std::string&amp; move)\n    {\n      if (!agent.HasProperty(\"MoveSet\")) {\n        agent.Notify(\"Error: Agent does not have a Move Set\\n\");\n        return false;\n      }\n      else\n      {\n        std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = agent.GetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\");\n        move_set.erase(move);\n        agent.SetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\", move_set);\n        return true;\n      }\n    }\n\n    void HealAction(cse491::AgentBase &amp; agent)\n    {\n      size_t can_heal = FindItem(agent, \"Health Potion\");\n      if (can_heal != SIZE_MAX) {\n        int healing_req = agent.GetProperty&lt;int&gt;(\"Max_Health\") - agent.GetProperty&lt;int&gt;(\"Health\");\n        int healing = item_map[can_heal]-&gt;GetProperty&lt;int&gt;(\"Healing\");\n        if (healing_req &gt;= healing) {\n          agent.Notify(\"You healed \" + std::to_string(healing) + \" health!\\n\");\n          agent.SetProperty(\"Health\", agent.GetProperty&lt;int&gt;(\"Health\") + healing);\n          agent.RemoveItem(can_heal);\n          RemoveItem(can_heal);\n        }\n        else if (healing_req == 0) {\n          agent.Notify(\"You already have max health\");\n        } else {\n          agent.Notify(\"You healed \" + std::to_string(healing_req) + \" health!\\n\");\n          agent.SetProperty(\"Health\", agent.GetProperty&lt;int&gt;(\"Health\") + healing_req);\n          item_map[can_heal]-&gt;SetProperty(\"Healing\", healing - healing_req);\n        }\n      } else {\n        agent.Notify(\"You do not have any health potions!\\n\");\n      }\n\n    }\n\n    void StatsAction(cse491::AgentBase &amp; agent)\n    {\n        std::string output = \"\";\n        output += \"Items owned by the player:\\n\";\n        for (const auto &amp; [item_id, item] : item_map)\n        {\n            if (item-&gt;IsOwnedBy(agent.GetID()))\n            {\n                for (const auto &amp; [name, entity] : item-&gt;GetPropertyMap())\n                {\n                    if (name == \"Uses\" || name == \"Strength\" || name == \"Healing\")\n                    {\n                        size_t value = item-&gt;GetProperty&lt;int&gt;(name);\n                        output += item-&gt;GetName() + \": \" + name + \": \" + std::to_string(value) + \"\\n\";\n                    }\n                }\n            }\n        }\n        output += \"\\nProperties of the player:\\n\";\n        for (const auto &amp; [name, entity] : agent.GetPropertyMap())\n        {\n            if (name == \"Strength\" || name == \"Health\" || name == \"Max_Health\")\n            {\n                size_t value = agent.GetProperty&lt;int&gt;(name);\n                output += name + \": \" + std::to_string(value) + \"\\n\";\n            }\n        }\n        agent.Notify(output);\n    }\n\n    void MoveSetAction(cse491::AgentBase &amp; agent)\n    {\n        agent.Notify(\"Your Moveset is:\\nMove Up: W\\nMove Down: S\\nMove Left: A\\nMove Right: D\\nUse Axe: C\\nUse Boat: V\\nDisplay Stats: T\\nHeal: H\\nAttack: F\\nSpecial: G\\nRun: R\\nBuff: B\\nDisplay Moveset: Y\");\n    }\n\n    cse491::GridPosition LookAhead(cse491::AgentBase &amp; agent)\n    {\n        size_t direction = agent.GetProperty&lt;int&gt;(\"Direction\");\n        cse491::GridPosition look_position;\n\n        switch (direction)\n        {\n        case (0):\n          look_position = agent.GetPosition().Above();\n          break;\n        case (1):\n          look_position = agent.GetPosition().ToRight();\n          break;\n        case (2):\n          look_position = agent.GetPosition().Below();\n          break;\n        case (3):\n          look_position = agent.GetPosition().ToLeft();\n          break;\n\n        default:\n          agent.Notify(\"Invalid Position: Returning Current Position\");\n          look_position = agent.GetPosition();\n          break;\n        }\n\n        return look_position;\n    }\n\n    void DropItems(cse491::AgentBase &amp; agent, cse491::AgentBase &amp; other_agent)\n    {\n        for (const auto&amp; [id, item] : item_map)\n        {\n            if (item-&gt;IsOwnedBy(other_agent.GetID()))\n            {\n                if (item-&gt;HasProperty(\"Strength\") &amp;&amp; other_agent.HasProperty(\"Strength\"))\n                {\n                    auto agent_health = other_agent.GetProperty&lt;int&gt;(\"Strength\");\n                    auto item_strength = item-&gt;GetProperty&lt;int&gt;(\"Strength\");\n                    other_agent.SetProperty&lt;int&gt;(\"Strength\", (int)(agent_health - item_strength));\n                }\n                other_agent.RemoveItem(item-&gt;GetID());\n                item-&gt;SetPosition(other_agent.GetPosition());\n                agent.Notify(other_agent.GetName() + \" dropped their \" + item-&gt;GetName() + \"!\");\n            }\n        }\n    }\n\n    int OtherAction(cse491::AgentBase &amp; other_agent, cse491::AgentBase &amp; agent)\n    {\n        int other_damage = 0;\n        std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = other_agent.GetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\");\n        auto iterator = move_set.begin();\n        int random = GetRandom(move_set.size());\n        std::advance(iterator, random);\n        std::string random_key = iterator-&gt;first;\n        agent.Notify(\"\\nThe enemy has used: \" + random_key);\n        std::tuple&lt;char, double&gt; move_info = iterator-&gt;second;\n        char stat_char = std::get&lt;0&gt;(move_info);\n        double stat_modification = std::get&lt;1&gt;(move_info);\n        if (stat_char == 'd') {\n            other_damage = static_cast&lt;int&gt;(other_agent.GetProperty&lt;int&gt;(\"Strength\") * stat_modification);\n        }\n        if (stat_char == 'h') {\n            HealAction(other_agent);\n        }\n        if (stat_char == 's') {\n          if (stat_modification &lt; 0) {\n            int agent_strength = agent.GetProperty&lt;int&gt;(\"Strength\");\n            int new_strength = static_cast&lt;int&gt;(agent_strength - abs(stat_modification) * agent_strength);\n            agent.SetProperty&lt;int&gt;(\"Strength\", new_strength);\n          }\n          else {\n            int other_agent_strength = other_agent.GetProperty&lt;int&gt;(\"Strength\");\n            int new_strength_other = static_cast&lt;int&gt;(other_agent_strength + abs(stat_modification) * other_agent_strength);\n            other_agent.SetProperty&lt;int&gt;(\"Strength\", new_strength_other);\n          }\n        }\n        return other_damage;\n    }\n\n    void DoBattle(cse491::AgentBase &amp; other_agent, cse491::AgentBase &amp; agent, char attack_type) {\n        // User Input for Player Decision\n        bool won = false;\n        bool run = false;\n        int damage = 0;\n        switch (attack_type) {\n        case 'a': case 'A': damage = agent.GetProperty&lt;int&gt;(\"Strength\");    break;\n        case 's': case 'S': damage = static_cast&lt;int&gt;(agent.GetProperty&lt;int&gt;(\"Strength\") * 1.5);  break;\n        case 'r': case 'R': won = false; run = true; break;\n        case 'b': case 'B': agent.SetProperty&lt;int&gt;(\"Strength\", static_cast&lt;int&gt;(1.5 * agent.GetProperty&lt;int&gt;(\"Strength\"))); break;\n        case 'h': case 'H': HealAction(agent); break;\n        default: break;\n        }\n\n        // Other Agent Move Choice, will modify strength of player agent or NPC agent based on the move selected\n        int other_damage = OtherAction(other_agent, agent);\n\n        // Process the Player's Move and the Agent's Move\n        if (run)\n        {\n            agent.SetProperty&lt;int&gt;(\"Health\", agent.GetProperty&lt;int&gt;(\"Health\") - other_damage);\n        }\n        else\n        {\n            other_agent.SetProperty&lt;int&gt;(\"Health\", other_agent.GetProperty&lt;int&gt;(\"Health\") - damage);\n            if (other_agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 0)\n            {\n                won = true;\n                other_damage = 0;\n            }\n            agent.SetProperty&lt;int&gt;(\"Health\", agent.GetProperty&lt;int&gt;(\"Health\") - other_damage);\n            if (agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 0)\n            {\n                won = false;\n                // run_over = true;\n            }\n        }\n\n        agent.Notify(\"Player Health: \" + std::to_string(agent.GetProperty&lt;int&gt;(\"Health\"))+\"\\n\"+\n                \"Player Strength: \" + std::to_string(agent.GetProperty&lt;int&gt;(\"Strength\"))+\"\\n\"+\n                \"Enemy Health: \" + std::to_string(other_agent.GetProperty&lt;int&gt;(\"Health\"))+\"\\n\"+\n                \"Enemy Strength: \" + std::to_string(other_agent.GetProperty&lt;int&gt;(\"Strength\")));\n\n        std::string other_agent_name = other_agent.GetName();\n        DataCollection::DataManager::GetInstance().GetAgentInteractionCollector().RecordInteraction(other_agent_name);\n\n        if (!won) {\n          if (run)\n          {\n            agent.Notify(\"You ran away, this means you don't gain health or strength and any battle damage stays!\\n\");\n          }\n          std::cout &lt;&lt; agent.GetName()  &lt;&lt; \": \" &lt;&lt;  agent.GetProperty&lt;int&gt;(\"Health\") &lt;&lt; std::endl;\n          if (agent.IsInterface() &amp;&amp; agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 0)\n          {\n            agent.Notify(other_agent_name + \" has beat \" + agent.GetName() + \"\\nYou Lost...\\n\");\n\n            DropItems(agent, agent);\n\n            agent.SetProperty&lt;int&gt;(\"Health\", 100);\n            agent.SetProperty&lt;int&gt;(\"Direction\", 0);\n\n            agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n            other_agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n\n            agent.SetPosition(80, 63);\n            agent.Notify(\"You Have died and dropped all your items\");\n          }\n        }\n        else\n        {\n          agent.Notify(agent.GetName() + \" has beat \" + other_agent.GetName());\n          agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n          other_agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n          DropItems(agent, other_agent);\n          other_agent.SetProperty&lt;bool&gt;(\"deleted\", true);\n        }\n    }\n\n    void UpdateWorld() override\n    {\n\n    }\n\n    void Run() override\n    {\n      run_over = false;\n      while (!run_over) {\n        RunAgents();\n        CollectData();\n        UpdateWorld();\n      }\n    }\n\n    void RunAgents() override {\n      for (auto &amp; [id, agent_ptr] : agent_map) {\n        if (agent_ptr-&gt;HasProperty(\"deleted\")) {\n          continue;\n        }\n        size_t action_id = agent_ptr-&gt;SelectAction(main_grid, type_options, item_map, agent_map);\n        agent_ptr-&gt;storeActionMap(agent_ptr-&gt;GetName());\n        int result = DoAction(*agent_ptr, action_id);\n        agent_ptr-&gt;SetActionResult(result);\n      }\n    }\n\n    void DoActionAttemptItemPickup(cse491::AgentBase &amp; agent, const cse491::GridPosition &amp; new_position) {\n      for (const auto &amp; [id, item_ptr] : item_map) {\n        if (item_ptr-&gt;GetPosition() == new_position &amp;&amp; item_ptr-&gt;GetOwnerID() == 0)\n        {\n          std::string uses_property = \"\";\n          if (item_ptr-&gt;GetName() == \"Stick\" || item_ptr-&gt;GetName() == \"Sword\") { uses_property = \"Strength\"; }\n          if (item_ptr-&gt;GetName() == \"Boat\" || item_ptr-&gt;GetName() == \"Axe\")  { uses_property = \"Uses\"; }\n          if (item_ptr-&gt;GetName() == \"Health Potion\") { uses_property = \"Healing\"; }\n\n          if (uses_property == \"Strength\")\n          {\n            if (agent.HasProperty(uses_property))\n            {\n              agent.SetProperty(uses_property, item_ptr-&gt;GetProperty&lt;int&gt;(uses_property) + agent.GetProperty&lt;int&gt;(uses_property));\n            }\n            else\n            {\n              agent.SetProperty(uses_property, item_ptr-&gt;GetProperty&lt;int&gt;(uses_property));\n            }\n          }\n\n          DataCollection::DataManager::GetInstance().GetItemUseCollector().IncrementItemUsage(item_ptr-&gt;GetName());\n          agent.Notify(\"Picked up the \" + item_ptr-&gt;GetName() + \"!\\nYou gained \" +\n                        std::to_string(item_ptr-&gt;GetProperty&lt;int&gt;(uses_property)) + \" \" +\n                        uses_property + \"!\\n\");\n\n          // remove it from the board\n          agent.AddItem(item_ptr-&gt;GetID());\n          break;\n        }\n      }\n    }\n\n\n    cse491::GridPosition DoActionFindNewPosition(cse491::AgentBase&amp; agent, size_t action_id) {\n        // Determine where the agent is trying to move.\n        cse491::GridPosition new_position, look_position;\n        char move = ' ';\n\n        bool battling = agent.GetProperty&lt;bool&gt;(\"Battling\");\n        // Update Direction property and get new position.\n        switch (action_id) {\n        case REMAIN_STILL:\n        {\n            new_position = agent.GetPosition();\n            break;\n        }\n        case MOVE_UP:\n        {\n            if (battling)\n            {\n                new_position = agent.GetPosition();\n            }\n            else\n            {\n                agent.SetProperty&lt;int&gt;(\"Direction\", UP);\n                new_position = agent.GetPosition().Above();\n            }\n            break;\n        }\n        case MOVE_DOWN:\n        {\n            if (battling)\n            {\n                new_position = agent.GetPosition();\n            }\n            else\n            {\n                agent.SetProperty&lt;int&gt;(\"Direction\", DOWN);\n                new_position = agent.GetPosition().Below();\n            }\n            break;\n        }\n        case MOVE_LEFT:\n        {\n            if (battling)\n            {\n                new_position = agent.GetPosition();\n            }\n            else\n            {\n                agent.SetProperty&lt;int&gt;(\"Direction\", LEFT);\n                new_position = agent.GetPosition().ToLeft();\n            }\n            break;\n        }\n        case MOVE_RIGHT:\n        {\n            if (battling)\n            {\n                new_position = agent.GetPosition();\n            }\n            else\n            {\n                agent.SetProperty&lt;int&gt;(\"Direction\", RIGHT);\n                new_position = agent.GetPosition().ToRight();\n            }\n            break;\n        }\n        case USE_AXE:\n        {\n            new_position = agent.GetPosition();\n            look_position = LookAhead(agent);\n            if (main_grid.IsValid(look_position) &amp;&amp; main_grid.At(look_position) == tree_id)\n            {\n                DoActionTestNewPositionTree(agent, look_position);\n            } else {\n                agent.Notify(\"You can not use an Axe here!\");\n            }\n            break;\n        }\n        case USE_BOAT:\n        {\n            new_position = agent.GetPosition();\n            if (main_grid.At(new_position) == water_id)\n            {\n              agent.Notify(\"Already on Water\");\n              break;\n            }\n            look_position = LookAhead(agent);\n            if (main_grid.IsValid(look_position) &amp;&amp; main_grid.At(look_position) == water_id)\n            {\n                if (DoActionTestNewPositionWater(agent))\n                {\n                    new_position = look_position;\n                }\n            } else {\n                agent.Notify(\"You can not use a Boat here!\");\n            }\n            break;\n        }\n        case STATS:\n        {\n            new_position = agent.GetPosition();\n            StatsAction(agent);\n            break;\n        }\n        case HEAL:\n        {\n            new_position = agent.GetPosition();\n            if (battling)\n            {\n                move = 'h';\n            }\n            else\n            {\n                HealAction(agent);\n            }\n            break;\n        }\n        case RUN:\n        {\n            if (!battling)\n            {\n                new_position = agent.GetPosition();\n                break;\n            }\n            new_position = agent.GetPosition();\n            agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n\n            auto agents = FindAgentsNear(agent.GetPosition(), 1);\n            for (auto agent_id : agents)\n            {\n                if (!agent_map[agent_id]-&gt;IsInterface() &amp;&amp; !agent_map[agent_id]-&gt;HasProperty(\"deleted\"))\n                {\n                    agent.Notify(\"You are running away\");\n                    agent_map[agent_id]-&gt;SetProperty&lt;bool&gt;(\"Battling\", false);\n                    DoBattle(*agent_map[agent_id], agent, 'r');\n                }\n            }\n            break;\n        }\n        case ATTACK:\n        {\n            move = 'a';\n            break;\n        }\n        case SPECIAL:\n        {\n            move = 's';\n            break;\n        }\n        case BUFF:\n        {\n            move = 'b';\n            break;\n        }\n        case HELP:\n        {\n            new_position = agent.GetPosition();\n            MoveSetAction(agent);\n            break;\n        }\n      }\n\n      if (move != ' ')\n      {\n          if (agent.GetProperty&lt;bool&gt;(\"Battling\") == false)\n          {\n              agent.Notify(\"You are in a battle! Use Y and choose battling moves!\");\n          }\n          auto agents = FindAgentsNear(agent.GetPosition(), 1);\n          for (auto agent_id : agents)\n          {\n              // Battle other agent near the player\n              if (!agent_map[agent_id]-&gt;IsInterface() &amp;&amp; !agent_map[agent_id]-&gt;HasProperty(\"deleted\"))\n              {\n                  agent.SetProperty&lt;bool&gt;(\"Battling\", true);\n                  agent_map[agent_id]-&gt;SetProperty&lt;bool&gt;(\"Battling\", true);\n                  DoBattle(*agent_map[agent_id], agent, move);\n                  break;\n              }\n          }\n          new_position = agent.GetPosition();\n      }\n\n      // assume new position is valid\n      return new_position;\n\n    }\n\n    size_t FindItem(cse491::AgentBase &amp; agent, const std::string &amp; item_name) {\n      size_t item_id = SIZE_MAX;\n      for (auto &amp; item : item_map)\n      {\n        if (item.second-&gt;GetName() == item_name &amp;&amp; item.second-&gt;IsOwnedBy(agent.GetID()))\n        {\n          item_id = item.second-&gt;GetID();\n          break;\n        }\n      }\n      return item_id;\n    }\n\n    void DoActionTestNewPositionTree(cse491::AgentBase &amp; agent, const cse491::GridPosition &amp; new_position) {\n        size_t item_id = FindItem(agent, \"Axe\");\n        if (item_id != SIZE_MAX)\n        {\n          agent.Notify(\"You have used your Axe to chop down this tree. You have \" +\n                        std::to_string(item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") - 1) + \" uses remaining\");\n\n          // decrement uses by 1, change the tree to grass\n          item_map[item_id]-&gt;SetProperty(\"Uses\", item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") - 1);\n          if (item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") == 0)\n          {\n            agent.RemoveItem(item_id);\n            RemoveItem(item_id);\n          }\n          main_grid[new_position] = grass_id;\n        }\n    }\n\n\n    bool DoActionTestNewPositionWater(cse491::AgentBase&amp; agent) {\n        size_t item_id = FindItem(agent, \"Boat\");\n        if (item_id != SIZE_MAX)\n        {\n            agent.Notify(\"You have used your Boat to float on the water. You have \" +\n                          std::to_string(item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") - 1) + \" uses remaining\");\n\n            // decrement uses by 1\n            item_map[item_id]-&gt;SetProperty(\"Uses\", item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") - 1);\n            if (item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") == 0)\n            {\n                agent.RemoveItem(item_id);\n                RemoveItem(item_id);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    int DoAction(cse491::AgentBase &amp; agent, size_t action_id) override {\n\n      cse491::GridPosition new_position = DoActionFindNewPosition(agent, action_id);\n\n      // Don't let the agent move off the world or into a wall.\n      if (!main_grid.IsValid(new_position)) { return false; }\n\n      DoActionAttemptItemPickup(agent, new_position);\n\n      if (main_grid.At(new_position) == tree_id)\n      {\n          return false;\n      }\n\n      if (main_grid.At(new_position) == water_id)\n      {\n          if (agent.HasProperty(\"OnlyWater\"))\n          {\n              agent.SetPosition(new_position);\n              return true;\n          }\n          if (action_id != USE_BOAT &amp;&amp; main_grid.At(agent.GetPosition()) != water_id) { return false; }\n      }\n\n      if (main_grid.At(new_position) == grass_id)\n      {\n        if (agent.HasProperty(\"OnlyWater\")) { return false; }\n      }\n\n      if (main_grid.At(new_position) == rock_id)\n      {\n        return false;\n      }\n\n      if (main_grid.At(new_position) == portal_id_a)\n      {\n          // which portal should we go to - for medium grid\n          if (new_position.GetX() == 33)\n              new_position = cse491::GridPosition(3, 1);\n          else if (new_position.GetX() == 3)\n              new_position = cse491::GridPosition(33, 0);\n\n          // for large grid, big right sand patch (x=137) to circle lake island (x=41)\n          else if (new_position.GetX() == 137)\n              new_position = cse491::GridPosition(41, 98);\n          else if (new_position.GetX() == 41)\n              new_position = cse491::GridPosition(137, 40);\n      }\n\n      if (main_grid.At(new_position) == portal_id_b)\n      {\n          // for medium grid\n          if (new_position.GetX() == 44)\n              new_position = cse491::GridPosition(2, 10);\n          else if (new_position.GetX() == 2)\n              new_position = cse491::GridPosition(44, 17);\n\n          // for large grid, tree-locked upper left sand patch(x=32) to lower right along water (x=114)\n          else if (new_position.GetX() == 32)\n              new_position = cse491::GridPosition(114, 132);\n          else if (new_position.GetX() == 114)\n              new_position = cse491::GridPosition(32, 36);\n\n      }\n\n      if (main_grid.At(new_position) == portal_id_c)\n      {\n          // above top right lake (x=120) to left of circle lake (x=16)\n          if (new_position.GetX() == 120)\n              new_position = cse491::GridPosition(16, 140);\n          else if (new_position.GetX() == 16)\n              new_position = cse491::GridPosition(120, 25);\n      }\n\n      if (main_grid.At(new_position) == portal_id_d)\n      {\n          // from circle lake island (x=36) to very bottom right corner (x=146)\n          if (new_position.GetX() == 36)\n              new_position = cse491::GridPosition(146, 147);\n          else if (new_position.GetX() == 146)\n              new_position = cse491::GridPosition(36, 94);\n      }\n\n      // Set the agent to its new postion.\n      agent.SetPosition(new_position);\n\n      return true;\n    }\n\n    [[nodiscard]] bool IsTraversable(const cse491::AgentBase &amp; /*agent*/, cse491::GridPosition pos) const override {\n      return main_grid.At(pos) == grass_id;\n    }\n\n  };\n\n} // End of namespace cse491_team8\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_maze_world_8hpp/","title":"File MazeWorld.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; MazeWorld.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"../Agents/PathAgent.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_maze_world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A World that consists only of walls and open cells."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_maze_world_8hpp/#classes","title":"Classes","text":"Type Name class MazeWorld <p>The documentation for this class was generated from the following file <code>source/Worlds/MazeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_maze_world_8hpp_source/","title":"File MazeWorld.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; MazeWorld.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"../Agents/PathAgent.hpp\"\n#include \"../core/WorldBase.hpp\"\n\nnamespace cse491 {\n\nclass MazeWorld : public WorldBase {\n protected:\n  enum ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    MOVE_ARBITRARY\n  };\n\n  size_t floor_id; \n  size_t wall_id;  \n\n public:\n  MazeWorld(unsigned int seed = 0) : WorldBase(seed) {\n    // Create cell types\n\n    floor_id =\n        AddCellType(\"floor\", \"Floor that you can easily walk over.\", ' ');\n    wall_id = AddCellType(\n        \"wall\", \"Impenetrable wall that you must find a way around.\", '#');\n    // Set cell type properties\n    type_options.at(floor_id).SetProperty(CellType::CELL_WALL);\n    // Load map\n    main_grid.Read(\"../assets/grids/default_maze.grid\", type_options);\n  }\n  ~MazeWorld() = default;\n\n  using WorldBase::ConfigAgent;\n  void ConfigAgent(AgentBase &amp;agent) const override {\n    agent.AddAction(\"up\", MOVE_UP);\n    agent.AddAction(\"down\", MOVE_DOWN);\n    agent.AddAction(\"left\", MOVE_LEFT);\n    agent.AddAction(\"right\", MOVE_RIGHT);\n    agent.AddAction(\"move_arbitrary\", MOVE_ARBITRARY);\n  }\n\n  void ConfigAgent(AgentBase &amp;agent) override {\n    agent.AddAction(\"up\", MOVE_UP);\n    agent.AddAction(\"down\", MOVE_DOWN);\n    agent.AddAction(\"left\", MOVE_LEFT);\n    agent.AddAction(\"right\", MOVE_RIGHT);\n    agent.AddAction(\"move_arbitrary\", MOVE_ARBITRARY);\n  }\n\n  int DoAction(AgentBase &amp;agent, size_t action_id) override {\n      // Determine where the agent is trying to move.\n      GridPosition new_position;\n      switch (action_id) {\n          case REMAIN_STILL:new_position = agent.GetPosition();\n              break;\n          case MOVE_UP:new_position = agent.GetPosition().Above();\n              break;\n          case MOVE_DOWN:new_position = agent.GetPosition().Below();\n              break;\n          case MOVE_LEFT:new_position = agent.GetPosition().ToLeft();\n              break;\n          case MOVE_RIGHT:new_position = agent.GetPosition().ToRight();\n              break;\n          case MOVE_ARBITRARY:new_position = agent.GetNextPosition();\n              break;\n      }\n\n    // Don't let the agent move off the world or into a wall.\n    if (!main_grid.IsValid(new_position)) { return false; }\n    if (!IsTraversable(agent, new_position)) { return false; }\n\n      // Set the agent to its new position.\n      agent.SetPosition(new_position);\n      return true;\n  }\n\n\n  [[nodiscard]] bool IsTraversable(const AgentBase &amp; /*agent*/, cse491::GridPosition pos) const override {\n    //return !GetCellTypes().at(main_grid.At(pos)).HasProperty(CellType::CELL_WALL);\n    // ^ This doesn't work because we're not assigning any properties to the cell types, so a band-aid solution is to use name\n    return !(GetCellTypes().at(main_grid.At(pos)).name == CellType::CELL_WALL);\n  }\n};\n\n} // End of namespace cse491\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/","title":"File PerlinNoise.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; PerlinNoise.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace siv namespace perlin_detail"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#classes","title":"Classes","text":"Type Name class BasicPerlinNoise &lt;class Float&gt;"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#macros","title":"Macros","text":"Type Name define SIVPERLIN_CONCEPT_URBG  template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;* = nullptr&gt; define SIVPERLIN_CONCEPT_URBG_  template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;*&gt; define SIVPERLIN_DEFAULT_Y  (0.12345) define SIVPERLIN_DEFAULT_Z  (0.34567) define SIVPERLIN_NODISCARD_CXX20 define SIVPERLIN_VERSION  ((SIVPERLIN_VERSION_MAJOR * 100 * 100) + (SIVPERLIN_VERSION_MINOR * 100) + (SIVPERLIN_VERSION_REVISION)) define SIVPERLIN_VERSION_MAJOR  3 define SIVPERLIN_VERSION_MINOR  0 define SIVPERLIN_VERSION_REVISION  0"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_concept_urbg","title":"define SIVPERLIN_CONCEPT_URBG","text":"<pre><code>#define SIVPERLIN_CONCEPT_URBG template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;* = nullptr&gt;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_concept_urbg_","title":"define SIVPERLIN_CONCEPT_URBG_","text":"<pre><code>#define SIVPERLIN_CONCEPT_URBG_ template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;*&gt;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_default_y","title":"define SIVPERLIN_DEFAULT_Y","text":"<pre><code>#define SIVPERLIN_DEFAULT_Y (0.12345)\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_default_z","title":"define SIVPERLIN_DEFAULT_Z","text":"<pre><code>#define SIVPERLIN_DEFAULT_Z (0.34567)\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_nodiscard_cxx20","title":"define SIVPERLIN_NODISCARD_CXX20","text":"<pre><code>#define SIVPERLIN_NODISCARD_CXX20 \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_version","title":"define SIVPERLIN_VERSION","text":"<pre><code>#define SIVPERLIN_VERSION ((SIVPERLIN_VERSION_MAJOR * 100 * 100) + (SIVPERLIN_VERSION_MINOR * 100) + (SIVPERLIN_VERSION_REVISION))\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_version_major","title":"define SIVPERLIN_VERSION_MAJOR","text":"<pre><code>#define SIVPERLIN_VERSION_MAJOR 3\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_version_minor","title":"define SIVPERLIN_VERSION_MINOR","text":"<pre><code>#define SIVPERLIN_VERSION_MINOR 0\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_version_revision","title":"define SIVPERLIN_VERSION_REVISION","text":"<pre><code>#define SIVPERLIN_VERSION_REVISION 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/PerlinNoise.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp_source/","title":"File PerlinNoise.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; PerlinNoise.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n//----------------------------------------------------------------------------------------\n//\n//  siv::PerlinNoise\n//  Perlin noise library for modern C++\n//\n//  Copyright (C) 2013-2021 Ryo Suzuki &lt;reputeless@gmail.com&gt;\n//\n//  Permission is hereby granted, free of charge, to any person obtaining a copy\n//  of this software and associated documentation files(the \"Software\"), to deal\n//  in the Software without restriction, including without limitation the rights\n//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n//  copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions :\n//\n//  The above copyright notice and this permission notice shall be included in\n//  all copies or substantial portions of the Software.\n//\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//  THE SOFTWARE.\n//\n//----------------------------------------------------------------------------------------\n\n# pragma once\n# include &lt;cstdint&gt;\n# include &lt;algorithm&gt;\n# include &lt;array&gt;\n# include &lt;iterator&gt;\n# include &lt;numeric&gt;\n# include &lt;random&gt;\n# include &lt;type_traits&gt;\n\n# if __has_include(&lt;concepts&gt;) &amp;&amp; defined(__cpp_concepts)\n#   include &lt;concepts&gt;\n# endif\n\n\n// Library major version\n# define SIVPERLIN_VERSION_MAJOR            3\n\n// Library minor version\n# define SIVPERLIN_VERSION_MINOR            0\n\n// Library revision version\n# define SIVPERLIN_VERSION_REVISION         0\n\n// Library version\n# define SIVPERLIN_VERSION          ((SIVPERLIN_VERSION_MAJOR * 100 * 100) + (SIVPERLIN_VERSION_MINOR * 100) + (SIVPERLIN_VERSION_REVISION))\n\n\n// [[nodiscard]] for constructors\n# if (201907L &lt;= __has_cpp_attribute(nodiscard))\n#   define SIVPERLIN_NODISCARD_CXX20 [[nodiscard]]\n# else\n#   define SIVPERLIN_NODISCARD_CXX20\n# endif\n\n\n// std::uniform_random_bit_generator concept\n# if __cpp_lib_concepts\n#   define SIVPERLIN_CONCEPT_URBG  template &lt;std::uniform_random_bit_generator URBG&gt;\n#   define SIVPERLIN_CONCEPT_URBG_ template &lt;std::uniform_random_bit_generator URBG&gt;\n# else\n#   define SIVPERLIN_CONCEPT_URBG  template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;* = nullptr&gt;\n#   define SIVPERLIN_CONCEPT_URBG_ template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;*&gt;\n# endif\n\n\n// arbitrary value for increasing entropy\n# ifndef SIVPERLIN_DEFAULT_Y\n#   define SIVPERLIN_DEFAULT_Y (0.12345)\n# endif\n\n// arbitrary value for increasing entropy\n# ifndef SIVPERLIN_DEFAULT_Z\n#   define SIVPERLIN_DEFAULT_Z (0.34567)\n# endif\n\n\nnamespace siv\n{\n    template &lt;class Float&gt;\n    class BasicPerlinNoise\n    {\n    public:\n\n        static_assert(std::is_floating_point_v&lt;Float&gt;);\n\n        //\n        //  Typedefs\n        //\n\n        using state_type = std::array&lt;std::uint8_t, 256&gt;;\n\n        using value_type = Float;\n\n        using default_random_engine = std::mt19937;\n\n        using seed_type = typename default_random_engine::result_type;\n\n        //\n        //  Constructors\n        //\n\n        SIVPERLIN_NODISCARD_CXX20\n        constexpr BasicPerlinNoise() noexcept;\n\n        SIVPERLIN_NODISCARD_CXX20\n        explicit BasicPerlinNoise(seed_type seed);\n\n        SIVPERLIN_CONCEPT_URBG\n        SIVPERLIN_NODISCARD_CXX20\n        explicit BasicPerlinNoise(URBG&amp;&amp; urbg);\n\n        //\n        //  Reseed\n        //\n\n        void reseed(seed_type seed);\n\n        SIVPERLIN_CONCEPT_URBG\n        void reseed(URBG&amp;&amp; urbg);\n\n        //\n        //  Serialization\n        //\n\n        [[nodiscard]]\n        constexpr const state_type&amp; serialize() const noexcept;\n\n        constexpr void deserialize(const state_type&amp; state) noexcept;\n\n        //\n        //  Noise (The result is in the range [-1, 1])\n        //\n\n        [[nodiscard]]\n        value_type noise1D(value_type x) const noexcept;\n\n        [[nodiscard]]\n        value_type noise2D(value_type x, value_type y) const noexcept;\n\n        [[nodiscard]]\n        value_type noise3D(value_type x, value_type y, value_type z) const noexcept;\n\n        //\n        //  Noise (The result is remapped to the range [0, 1])\n        //\n\n        [[nodiscard]]\n        value_type noise1D_01(value_type x) const noexcept;\n\n        [[nodiscard]]\n        value_type noise2D_01(value_type x, value_type y) const noexcept;\n\n        [[nodiscard]]\n        value_type noise3D_01(value_type x, value_type y, value_type z) const noexcept;\n\n        //\n        //  Octave noise (The result can be out of the range [-1, 1])\n        //\n\n        [[nodiscard]]\n        value_type octave1D(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave2D(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave3D(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        //\n        //  Octave noise (The result is clamped to the range [-1, 1])\n        //\n\n        [[nodiscard]]\n        value_type octave1D_11(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave2D_11(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave3D_11(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        //\n        //  Octave noise (The result is clamped and remapped to the range [0, 1])\n        //\n\n        [[nodiscard]]\n        value_type octave1D_01(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave2D_01(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave3D_01(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        //\n        //  Octave noise (The result is normalized to the range [-1, 1])\n        //\n\n        [[nodiscard]]\n        value_type normalizedOctave1D(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type normalizedOctave2D(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type normalizedOctave3D(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        //\n        //  Octave noise (The result is normalized and remapped to the range [0, 1])\n        //\n\n        [[nodiscard]]\n        value_type normalizedOctave1D_01(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type normalizedOctave2D_01(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type normalizedOctave3D_01(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n    private:\n\n        state_type m_permutation;\n    };\n\n    using PerlinNoise = BasicPerlinNoise&lt;double&gt;;\n\n    namespace perlin_detail\n    {\n        //\n        //  These functions are provided for consistency.\n        //  You may get different results from std::shuffle() with different standard library implementations.\n        //\n        SIVPERLIN_CONCEPT_URBG\n        [[nodiscard]]\n        inline std::uint64_t Random(const std::uint64_t max, URBG&amp;&amp; urbg)\n        {\n            return (urbg() % (max + 1));\n        }\n\n        template &lt;class RandomIt, class URBG&gt;\n        inline void Shuffle(RandomIt first, RandomIt last, URBG&amp;&amp; urbg)\n        {\n            if (first == last)\n            {\n                return;\n            }\n\n            using difference_type = typename std::iterator_traits&lt;RandomIt&gt;::difference_type;\n\n            for (RandomIt it = first + 1; it &lt; last; ++it)\n            {\n                const std::uint64_t n = static_cast&lt;std::uint64_t&gt;(it - first);\n                std::iter_swap(it, first + static_cast&lt;difference_type&gt;(Random(n, std::forward&lt;URBG&gt;(urbg))));\n            }\n        }\n        //\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Fade(const Float t) noexcept\n        {\n            return t * t * t * (t * (t * 6 - 15) + 10);\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Lerp(const Float a, const Float b, const Float t) noexcept\n        {\n            return (a + (b - a) * t);\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Grad(const std::uint8_t hash, const Float x, const Float y, const Float z) noexcept\n        {\n            const std::uint8_t h = hash &amp; 15;\n            const Float u = h &lt; 8 ? x : y;\n            const Float v = h &lt; 4 ? y : h == 12 || h == 14 ? x : z;\n            return ((h &amp; 1) == 0 ? u : -u) + ((h &amp; 2) == 0 ? v : -v);\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Remap_01(const Float x) noexcept\n        {\n            return (x * Float(0.5) + Float(0.5));\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Clamp_11(const Float x) noexcept\n        {\n            return std::clamp(x, Float(-1.0), Float(1.0));\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float RemapClamp_01(const Float x) noexcept\n        {\n            if (x &lt;= Float(-1.0))\n            {\n                return Float(0.0);\n            }\n            else if (Float(1.0) &lt;= x)\n            {\n                return Float(1.0);\n            }\n\n            return (x * Float(0.5) + Float(0.5));\n        }\n\n        template &lt;class Noise, class Float&gt;\n        [[nodiscard]]\n        inline auto Octave1D(const Noise&amp; noise, Float x, const std::int32_t octaves, const Float persistence) noexcept\n        {\n            using value_type = Float;\n            value_type result = 0;\n            value_type amplitude = 1;\n\n            for (std::int32_t i = 0; i &lt; octaves; ++i)\n            {\n                result += (noise.noise1D(x) * amplitude);\n                x *= 2;\n                amplitude *= persistence;\n            }\n\n            return result;\n        }\n\n        template &lt;class Noise, class Float&gt;\n        [[nodiscard]]\n        inline auto Octave2D(const Noise&amp; noise, Float x, Float y, const std::int32_t octaves, const Float persistence) noexcept\n        {\n            using value_type = Float;\n            value_type result = 0;\n            value_type amplitude = 1;\n\n            for (std::int32_t i = 0; i &lt; octaves; ++i)\n            {\n                result += (noise.noise2D(x, y) * amplitude);\n                x *= 2;\n                y *= 2;\n                amplitude *= persistence;\n            }\n\n            return result;\n        }\n\n        template &lt;class Noise, class Float&gt;\n        [[nodiscard]]\n        inline auto Octave3D(const Noise&amp; noise, Float x, Float y, Float z, const std::int32_t octaves, const Float persistence) noexcept\n        {\n            using value_type = Float;\n            value_type result = 0;\n            value_type amplitude = 1;\n\n            for (std::int32_t i = 0; i &lt; octaves; ++i)\n            {\n                result += (noise.noise3D(x, y, z) * amplitude);\n                x *= 2;\n                y *= 2;\n                z *= 2;\n                amplitude *= persistence;\n            }\n\n            return result;\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float MaxAmplitude(const std::int32_t octaves, const Float persistence) noexcept\n        {\n            using value_type = Float;\n            value_type result = 0;\n            value_type amplitude = 1;\n\n            for (std::int32_t i = 0; i &lt; octaves; ++i)\n            {\n                result += amplitude;\n                amplitude *= persistence;\n            }\n\n            return result;\n        }\n    }\n\n\n    template &lt;class Float&gt;\n    inline constexpr BasicPerlinNoise&lt;Float&gt;::BasicPerlinNoise() noexcept\n            : m_permutation{ 151,160,137,91,90,15,\n                             131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n                             190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n                             88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n                             77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n                             102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n                             135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n                             5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n                             223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n                             129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n                             251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n                             49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n                             138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 } {}\n\n    template &lt;class Float&gt;\n    inline BasicPerlinNoise&lt;Float&gt;::BasicPerlinNoise(const seed_type seed)\n    {\n        reseed(seed);\n    }\n\n    template &lt;class Float&gt;\n    SIVPERLIN_CONCEPT_URBG_\n    inline BasicPerlinNoise&lt;Float&gt;::BasicPerlinNoise(URBG&amp;&amp; urbg)\n    {\n        reseed(std::forward&lt;URBG&gt;(urbg));\n    }\n\n\n    template &lt;class Float&gt;\n    inline void BasicPerlinNoise&lt;Float&gt;::reseed(const seed_type seed)\n    {\n        reseed(default_random_engine{ seed });\n    }\n\n    template &lt;class Float&gt;\n    SIVPERLIN_CONCEPT_URBG_\n    inline void BasicPerlinNoise&lt;Float&gt;::reseed(URBG&amp;&amp; urbg)\n    {\n        std::iota(m_permutation.begin(), m_permutation.end(), uint8_t{ 0 });\n\n        perlin_detail::Shuffle(m_permutation.begin(), m_permutation.end(), std::forward&lt;URBG&gt;(urbg));\n    }\n\n\n    template &lt;class Float&gt;\n    inline constexpr const typename BasicPerlinNoise&lt;Float&gt;::state_type&amp; BasicPerlinNoise&lt;Float&gt;::serialize() const noexcept\n    {\n        return m_permutation;\n    }\n\n    template &lt;class Float&gt;\n    inline constexpr void BasicPerlinNoise&lt;Float&gt;::deserialize(const state_type&amp; state) noexcept\n    {\n        m_permutation = state;\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise1D(const value_type x) const noexcept\n    {\n        return noise3D(x,\n                       static_cast&lt;value_type&gt;(SIVPERLIN_DEFAULT_Y),\n                       static_cast&lt;value_type&gt;(SIVPERLIN_DEFAULT_Z));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise2D(const value_type x, const value_type y) const noexcept\n    {\n        return noise3D(x,\n                       y,\n                       static_cast&lt;value_type&gt;(SIVPERLIN_DEFAULT_Z));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise3D(const value_type x, const value_type y, const value_type z) const noexcept\n    {\n        const value_type _x = std::floor(x);\n        const value_type _y = std::floor(y);\n        const value_type _z = std::floor(z);\n\n        const std::int32_t ix = static_cast&lt;std::int32_t&gt;(_x) &amp; 255;\n        const std::int32_t iy = static_cast&lt;std::int32_t&gt;(_y) &amp; 255;\n        const std::int32_t iz = static_cast&lt;std::int32_t&gt;(_z) &amp; 255;\n\n        const value_type fx = (x - _x);\n        const value_type fy = (y - _y);\n        const value_type fz = (z - _z);\n\n        const value_type u = perlin_detail::Fade(fx);\n        const value_type v = perlin_detail::Fade(fy);\n        const value_type w = perlin_detail::Fade(fz);\n\n        const std::uint8_t A = (m_permutation[ix &amp; 255] + iy) &amp; 255;\n        const std::uint8_t B = (m_permutation[(ix + 1) &amp; 255] + iy) &amp; 255;\n\n        const std::uint8_t AA = (m_permutation[A] + iz) &amp; 255;\n        const std::uint8_t AB = (m_permutation[(A + 1) &amp; 255] + iz) &amp; 255;\n\n        const std::uint8_t BA = (m_permutation[B] + iz) &amp; 255;\n        const std::uint8_t BB = (m_permutation[(B + 1) &amp; 255] + iz) &amp; 255;\n\n        const value_type p0 = perlin_detail::Grad(m_permutation[AA], fx, fy, fz);\n        const value_type p1 = perlin_detail::Grad(m_permutation[BA], fx - 1, fy, fz);\n        const value_type p2 = perlin_detail::Grad(m_permutation[AB], fx, fy - 1, fz);\n        const value_type p3 = perlin_detail::Grad(m_permutation[BB], fx - 1, fy - 1, fz);\n        const value_type p4 = perlin_detail::Grad(m_permutation[(AA + 1) &amp; 255], fx, fy, fz - 1);\n        const value_type p5 = perlin_detail::Grad(m_permutation[(BA + 1) &amp; 255], fx - 1, fy, fz - 1);\n        const value_type p6 = perlin_detail::Grad(m_permutation[(AB + 1) &amp; 255], fx, fy - 1, fz - 1);\n        const value_type p7 = perlin_detail::Grad(m_permutation[(BB + 1) &amp; 255], fx - 1, fy - 1, fz - 1);\n\n        const value_type q0 = perlin_detail::Lerp(p0, p1, u);\n        const value_type q1 = perlin_detail::Lerp(p2, p3, u);\n        const value_type q2 = perlin_detail::Lerp(p4, p5, u);\n        const value_type q3 = perlin_detail::Lerp(p6, p7, u);\n\n        const value_type r0 = perlin_detail::Lerp(q0, q1, v);\n        const value_type r1 = perlin_detail::Lerp(q2, q3, v);\n\n        return perlin_detail::Lerp(r0, r1, w);\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise1D_01(const value_type x) const noexcept\n    {\n        return perlin_detail::Remap_01(noise1D(x));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise2D_01(const value_type x, const value_type y) const noexcept\n    {\n        return perlin_detail::Remap_01(noise2D(x, y));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise3D_01(const value_type x, const value_type y, const value_type z) const noexcept\n    {\n        return perlin_detail::Remap_01(noise3D(x, y, z));\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave1D(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Octave1D(*this, x, octaves, persistence);\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave2D(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Octave2D(*this, x, y, octaves, persistence);\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave3D(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Octave3D(*this, x, y, z, octaves, persistence);\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave1D_11(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Clamp_11(octave1D(x, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave2D_11(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Clamp_11(octave2D(x, y, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave3D_11(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Clamp_11(octave3D(x, y, z, octaves, persistence));\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave1D_01(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::RemapClamp_01(octave1D(x, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave2D_01(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::RemapClamp_01(octave2D(x, y, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave3D_01(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::RemapClamp_01(octave3D(x, y, z, octaves, persistence));\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave1D(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return (octave1D(x, octaves, persistence) / perlin_detail::MaxAmplitude(octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave2D(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return (octave2D(x, y, octaves, persistence) / perlin_detail::MaxAmplitude(octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave3D(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return (octave3D(x, y, z, octaves, persistence) / perlin_detail::MaxAmplitude(octaves, persistence));\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave1D_01(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Remap_01(normalizedOctave1D(x, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave2D_01(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Remap_01(normalizedOctave2D(x, y, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave3D_01(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Remap_01(normalizedOctave3D(x, y, z, octaves, persistence));\n    }\n}\n\n# undef SIVPERLIN_NODISCARD_CXX20\n# undef SIVPERLIN_CONCEPT_URBG\n# undef SIVPERLIN_CONCEPT_URBG_\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_program_executor_8hpp/","title":"File ProgramExecutor.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; ProgramExecutor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Language.hpp\"</code></li> <li><code>#include \"core/WorldBase.hpp\"</code></li> <li><code>#include \"core/EasyLogging.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;stack&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include \"core/AgentBase.hpp\"</code></li> <li><code>#include \"Interfaces/TrashInterface.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_program_executor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace worldlang Namespace for scripting language stuff."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_program_executor_8hpp/#classes","title":"Classes","text":"Type Name class ProgramExecutor Class that manages program execution. struct Identifier <p>The documentation for this class was generated from the following file <code>source/Worlds/ProgramExecutor.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_program_executor_8hpp_source/","title":"File ProgramExecutor.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; ProgramExecutor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include \"Language.hpp\"\n\n#include \"core/WorldBase.hpp\"\n#include \"core/EasyLogging.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;stack&gt;\n#include &lt;variant&gt;\n\n#include \"core/AgentBase.hpp\"\n#include \"Interfaces/TrashInterface.hpp\"\n\n#ifdef USE_SFML_INTERFACE\n#include \"Interfaces/MainInterface.hpp\"\n#endif\n\nusing cse491::AgentBase;\nusing cse491::Entity;\nusing cse491::CellType;\nusing clogged::Logger;\nusing clogged::Team;\nusing clogged::LogLevel;\n\nnamespace worldlang {\n\n    class ProgramExecutor {\n    // Internal types\n    public:\n        using Callable = std::function&lt;void(ProgramExecutor&amp;)&gt;;\n\n        struct Identifier : std::string {};\n\n        using Value = std::variant &lt; size_t, double, std::string, Callable, Identifier &gt;;\n\n    // Execution state\n    private:\n        std::map&lt;std::string, std::vector&lt;Unit&gt;&gt; scripts;\n\n        std::vector&lt;Unit&gt;* code = nullptr;\n\n        size_t index = 0;\n\n        std::map &lt; std::string, Value &gt; variables{};\n\n        std::stack &lt; Value &gt; stack{};\n\n        std::stack &lt; std::vector&lt; Value &gt; &gt; call_stack{};\n\n        std::string error_message{};\n\n    // Public methods\n    public:\n        ProgramExecutor(){\n            // if function\n            // skips a block if value is false\n            registerFunction(\"if\", [this](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 1) { error(\"Wrong number of arguments!\"); return; }\n                // jump to end of block if false\n\n                if (pe.as&lt;double&gt;(args.at(0)) == 0){\n                    skipBlock();\n                } else {\n                    // advance to start of block automatically\n                }\n                // mark type of block entered\n                call_stack.push({\"__IF_BLOCK\"});\n            });\n            // for function\n            registerFunction(\"for\", [this](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 3 &amp;&amp; args.size() != 4) { error(\"Wrong number of arguments!\"); return; }\n                auto var = pe.as&lt;Identifier&gt;(args.at(0));\n                auto start = pe.as&lt;double&gt;(args.at(1));\n                auto end = pe.as&lt;double&gt;(args.at(2));\n                auto step = args.size() == 4 ? pe.as&lt;double&gt;(args.at(3)) : 1.0;\n\n                variables.insert_or_assign(static_cast&lt;std::string&gt;(var), start);\n\n                auto value = pe.as&lt;double&gt;(args.at(0));\n                if ((start &lt; end &amp;&amp; step &gt; 0 &amp;&amp; value &lt;= end)\n                    || (start &gt;= end &amp;&amp; step &lt; 0 &amp;&amp; value &gt;= end)){\n                    // enter the loop if conditions are met\n                    call_stack.push({\"__FOR_BLOCK\", var, start, end, step, static_cast&lt;double&gt;(index)});\n                    index++; // skip start_block which checks condition + increments\n                } else {\n                    // skip loop entirely\n                    skipBlock();\n                    index++; // skip end_block or else it tries to jump to beginning\n                }\n            });\n            // Log some values\n            registerFunction(\"print\", [](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                for (auto a : args){\n                    if (pe.has&lt;double&gt;(a)){\n                        std::cout &lt;&lt; pe.as&lt;double&gt;(a);\n                    } else if (pe.has&lt;size_t&gt;(a)){\n                        std::cout &lt;&lt; pe.as&lt;size_t&gt;(a);\n                    } else if (pe.has&lt;std::string&gt;(a)){\n                        std::cout &lt;&lt; pe.as&lt;std::string&gt;(a);\n                    } else if (pe.has&lt;Callable&gt;(a)){\n                        std::cout &lt;&lt; \"&lt;Callable&gt;\";\n                    }\n                }\n                std::cout &lt;&lt; std::endl;\n            });\n        }\n\n        ProgramExecutor(cse491::WorldBase&amp; world) : ProgramExecutor(){\n            // Load world grid from file\n            registerFunction(\"loadWorld\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 1) { error(\"Wrong number of arguments!\"); return; }\n                world.GetGrid().Read(as&lt;std::string&gt;(args.at(0)), world.GetCellTypes());\n            });\n            // Get the size of the world\n            registerFunction(\"getWorldSize\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 0) { error(\"Wrong number of arguments!\"); return; }\n                pe.pushStack(static_cast&lt;double&gt;(world.GetGrid().GetWidth()));\n                pe.pushStack(static_cast&lt;double&gt;(world.GetGrid().GetHeight()));\n            });\n            // Create an agent\n            registerFunction(\"addAgent\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() &lt; 5) { error(\"Wrong number of arguments!\"); return; }\n                // type, name, symbol, x, y\n                auto type = pe.as&lt;std::string&gt;(args[0]);\n                auto name = pe.as&lt;std::string&gt;(args[1]);\n                auto symbol = pe.as&lt;std::string&gt;(args[2]);\n                auto x = pe.as&lt;double&gt;(args[3]);\n                auto y = pe.as&lt;double&gt;(args[4]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n                if (!symbol.size()) { error(\"Symbol cannot be empty!\"); return; }\n\n                //TODO:Use the agent Factory class here, see if that works better.\n                AgentBase* agent;\n                if (type == \"Player\"){\n                    agent = &amp;world.AddAgent&lt;cse491::TrashInterface&gt;(name, \"symbol\", symbol[0]);\n                    agent-&gt;SetPosition(x, y);\n                } \n#ifdef USE_SFML_INTERFACE\n        else if (type == \"Player2D\") {\n                    agent = &amp;world.AddAgent&lt;i_2D::MainInterface&gt;(name, \"symbol\", symbol[0]);\n                    agent-&gt;SetPosition(x, y);\n        } \n#endif \n        else {\n                    error(\"Unknown agent type!\"); return;\n                }\n\n                pe.pushStack(agent-&gt;GetID());\n            });\n            // Set agent property\n            registerFunction(\"setProperty\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 3) { error(\"Wrong number of arguments!\"); return; }\n                auto id = pe.as&lt;size_t&gt;(args[0]);\n                auto prop = pe.as&lt;std::string&gt;(args[1]);\n                auto value = args[2];\n\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                Entity&amp; agent = world.HasAgent(id) ? static_cast&lt;Entity&amp;&gt;(world.GetAgent(id)) : world.GetItem(id);\n                if (pe.has&lt;double&gt;(value)){\n                    agent.SetProperty(prop, as&lt;double&gt;(value));\n                } else if (pe.has&lt;std::string&gt;(value)){\n                    auto s = as&lt;std::string&gt;(value);\n                    // silly hack\n                    if (s.size() == 1){\n                        agent.SetProperty(prop, s[0]);\n                    } else {\n                        agent.SetProperty(prop, s);\n                    }\n                } else {\n                    error(\"Unsupported property type!\");\n                }\n            });\n            // Get agent property\n            registerFunction(\"getProperty\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto id = pe.as&lt;size_t&gt;(args[0]);\n                auto prop = pe.as&lt;std::string&gt;(args[1]);\n\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                Entity&amp; agent = world.HasAgent(id) ? static_cast&lt;Entity&amp;&gt;(world.GetAgent(id)) : world.GetItem(id);\n                if(agent.HasProperty(prop)){\n                    // property exists but type is unknown\n                    // assume double, as there is no way to determine the type currently\n                    // TODO: Fix this if types are ever stored\n                    pushStack(agent.GetProperty&lt;double&gt;(prop));\n                } else {\n                    error(\"Undefined property:\" + prop);\n                }\n            });\n            // Check if property exists\n            registerFunction(\"hasProperty\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto id = pe.as&lt;size_t&gt;(args[0]);\n                auto prop = pe.as&lt;std::string&gt;(args[1]);\n\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                Entity&amp; agent = world.HasAgent(id) ? static_cast&lt;Entity&amp;&gt;(world.GetAgent(id)) : world.GetItem(id);\n                if(agent.HasProperty(prop)){\n                    pushStack(1.0);\n                } else {\n                    pushStack(0.0);\n                }\n            });\n            // Get agent position\n            registerFunction(\"getAgentPosition\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 1) { error(\"Wrong number of arguments!\"); return; }\n                auto id = pe.as&lt;size_t&gt;(args[0]);\n\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                AgentBase&amp; agent = world.GetAgent(id);\n                auto x = agent.GetPosition().GetX();\n                auto y = agent.GetPosition().GetY();\n                pushStack(x);\n                pushStack(y);\n            });\n            // Set agent position\n            registerFunction(\"setAgentPosition\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 3) { error(\"Wrong number of arguments!\"); return; }\n                auto agent_id = pe.as&lt;size_t&gt;(args[0]);\n                auto x = pe.as&lt;double&gt;(args[1]);\n                auto y = pe.as&lt;double&gt;(args[2]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                AgentBase&amp; agent = world.GetAgent(agent_id);\n                agent.SetPosition(x, y);\n            });\n            // Get agent at this position\n            registerFunction(\"findAgentAt\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto x = pe.as&lt;double&gt;(args[0]);\n                auto y = pe.as&lt;double&gt;(args[1]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                auto res = world.FindAgentsAt({x, y});\n                if (res.size()){\n                    pe.pushStack(res[0]);\n                } else {\n                    pe.pushStack(0u);\n                }\n            });\n            // Get item at this position\n            registerFunction(\"findItemAt\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto x = pe.as&lt;double&gt;(args[0]);\n                auto y = pe.as&lt;double&gt;(args[1]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                auto res = world.FindItemsAt({x, y});\n                if (res.size()){\n                    pe.pushStack(res[0]);\n                } else {\n                    pe.pushStack(0u);\n                }\n            });\n            // Get size of the agent's inventory\n            registerFunction(\"getInventorySize\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 1) { error(\"Wrong number of arguments!\"); return; }\n                auto agent_id = pe.as&lt;size_t&gt;(args[0]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                AgentBase&amp; agent = world.GetAgent(agent_id);\n                pe.pushStack(static_cast&lt;double&gt;(agent.GetInventory().size()));\n            });\n            // Gets an item from the inventory\n            registerFunction(\"getInventoryItem\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto agent_id = pe.as&lt;size_t&gt;(args[0]);\n                auto item_index = pe.as&lt;double&gt;(args[1]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                AgentBase&amp; agent = world.GetAgent(agent_id);\n                if (item_index &gt;= agent.GetInventory().size()) {\n                    error(\"Item index out of range!\"); return;\n                }\n\n                pe.pushStack(agent.GetInventory()[item_index]);\n            });\n            // Add an item to the world\n            registerFunction(\"addItem\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                // name,symbol,x,y,prop1,val1,prop2,val2...\n                if (args.size() &lt; 4) { error(\"Wrong number of arguments!\"); return; }\n                auto name = pe.as&lt;std::string&gt;(args[0]);\n                auto symbol = pe.as&lt;std::string&gt;(args[1]);\n                auto x = pe.as&lt;double&gt;(args[2]);\n                auto y = pe.as&lt;double&gt;(args[3]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n                if (symbol.empty()) { error(\"Symbol can't be empty!\"); return; }\n\n                auto item = std::make_unique&lt;cse491::ItemBase&gt;(world.NextEntityID(), name);\n                item-&gt;SetProperties(\"symbol\",symbol.at(0));\n                item-&gt;SetPosition(x,y);\n                item-&gt;SetGrid();\n                for (size_t i = 4; i &lt; args.size(); i += 2){\n                    item-&gt;SetProperty(pe.as&lt;std::string&gt;(args[i]), pe.as&lt;double&gt;(args[i+1]));\n                }\n                pe.pushStack(item-&gt;GetID());\n\n                world.AddItem(std::move(item));\n            });\n            // Gets an item from the inventory\n            registerFunction(\"addInventoryItem\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto owner_id = pe.as&lt;size_t&gt;(args[0]);\n                auto item_id = pe.as&lt;size_t&gt;(args[1]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                world.GetItem(item_id).SetPosition(-1,-1);\n                Entity&amp; entity = world.HasAgent(owner_id) ? static_cast&lt;Entity&amp;&gt;(world.GetAgent(owner_id)) : world.GetItem(owner_id);\n                entity.AddItem(item_id);\n            });\n            // Create a new cell type\n            registerFunction(\"addCellType\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() &lt; 3) { error(\"Wrong number of arguments!\"); return; }\n                // name, desc, symbol, props (ignored: TODO later)\n                auto name = pe.as&lt;std::string&gt;(args[0]);\n                auto desc = pe.as&lt;std::string&gt;(args[1]);\n                auto symbol = pe.as&lt;std::string&gt;(args[2]);\n                std::cout &lt;&lt; desc &lt;&lt; \",\" &lt;&lt; name &lt;&lt; \",\" &lt;&lt; symbol &lt;&lt; \",\";\n                if (!symbol.size()) { error(\"Symbol cannot be empty!\"); return; }\n                std::cout &lt;&lt; (int)symbol[0] &lt;&lt; \"\\n\";\n\n                auto id = world.AddCellType(name, desc, symbol[0]);\n                for (size_t i = 3; i &lt; args.size(); ++i){\n                    world.type_options[id].SetProperty(pe.as&lt;std::string&gt;(args[i]));\n                }\n\n                pe.pushStack(id);\n            });\n            // Get a random number\n            registerFunction(\"rand\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() &gt; 2) { error(\"Wrong number of arguments!\"); return; }\n                if (args.size() == 0){\n                    // random double in [0,1]\n                    pushStack(world.GetRandom());\n                } else if (args.size() == 1){\n                    // random int in [0,max]\n                    auto max = pe.as&lt;double&gt;(args[0]) + 1;\n                    pushStack((double)(int)world.GetRandom(max)); // casts for rounding\n                } else if (args.size() == 2){\n                    // random int in [min,max]\n                    auto min = pe.as&lt;double&gt;(args[0]);\n                    auto max = pe.as&lt;double&gt;(args[1]) + 1;\n                    pushStack((double)(int)world.GetRandom(min,max)); // casts for rounding\n                }\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n            });\n            // Set constants\n            setVariable(\"ID_NONE\",0u);\n            setVariable(\"CELL_WALL\", CellType::CELL_WALL);\n            setVariable(\"CELL_WATER\", CellType::CELL_WATER);\n        }\n\n        virtual ~ProgramExecutor() = default;\n\n        void skipBlock(int nest = 0){\n            do {\n                auto&amp; unit = code-&gt;at(++index);\n                if (unit.type == Unit::Type::operation &amp;&amp; unit.value == \"start_block\") nest++;\n                if (unit.type == Unit::Type::operation &amp;&amp; unit.value == \"end_block\") nest--;\n            } while(nest);\n            // points to one past end_block\n            index--;\n            // points to end_block\n        }\n\n        void registerFunction(std::string name, Callable callable){\n            variables.insert_or_assign(name, callable);\n        }\n\n        Value popStack(){\n            auto v = stack.top();\n            stack.pop();\n            return v;\n        }\n\n        std::vector&lt;Value&gt; popArgs(){\n            std::vector&lt; Value &gt; values;\n            do {\n                values.push_back(popStack());\n            } while (!(has&lt;Identifier&gt;(values.back()) \n                    &amp;&amp; static_cast&lt;std::string&gt;(as&lt;Identifier&gt;(values.back())) == \"__INTERNAL_ENDARGS\"));\n            values.pop_back(); // don't keep that one\n            std::reverse(values.begin(), values.end());\n            return values;\n        }\n\n        void pushStack(Value value){\n            stack.push(value);\n        }\n\n        template &lt;typename T&gt;\n        bool has(const Value&amp; a){\n            if (std::holds_alternative&lt;T&gt;(a)){\n                return true;\n            } else if (std::holds_alternative&lt;Identifier&gt;(a)){\n                try {\n                    auto val = variables.at(static_cast&lt;std::string&gt;(std::get&lt;Identifier&gt;(a)));\n                    return std::holds_alternative&lt;T&gt;(val);\n                } catch(const std::out_of_range&amp; e) {\n                    error(\"Variable does not exist!\");\n                }\n            }\n            return false;\n        }\n\n        template &lt;typename T&gt;\n        T as(const Value&amp; a){\n            if (std::holds_alternative&lt;T&gt;(a)){\n                return std::get&lt;T&gt;(a);\n            } else if (std::holds_alternative&lt;Identifier&gt;(a)){\n                auto val = variables.at(static_cast&lt;std::string&gt;(std::get&lt;Identifier&gt;(a)));\n                if (std::holds_alternative&lt;T&gt;(val)){\n                    return std::get&lt;T&gt;(val);\n                }\n            }\n            // error if conversion fails\n            error(std::string{\"Type error in as()! Expected \"}+typeid(T).name());\n            return T{};\n        }\n\n        template &lt;typename T&gt;\n        T var(const std::string&amp; name){\n            auto val = variables.at(name);\n            return std::get&lt;T&gt;(val);\n        }\n\n        void setVariable(const std::string&amp; name, Value value){\n            variables.insert_or_assign(name, value);\n        }\n\n        void error(const std::string&amp; error){\n            if (error_message.empty()){\n                error_message = error;\n            }\n        }\n\n        std::string getErrorMessage(){\n            return error_message;\n        }\n\n        bool runFile(const std::string&amp; filename){\n            //TODO: program preprocessing (add newline to end, remove spaces)\n            if (!scripts.count(filename)){\n                std::ifstream in{filename};\n                std::string s;\n                std::string filedata;\n                while (getline(in, s))\n                    filedata += s + '\\n';\n\n                scripts[filename] = parse_to_code(filedata);\n                if (scripts[filename].empty()){\n                    // implies a parse error\n                    error(\"Error parsing program from file\");\n                    return false;\n                }\n            }\n            code = &amp;scripts[filename];\n            return run();\n        }\n\n        bool run(const std::string&amp; program){\n            scripts[\"__STRING_PROGRAM\"] = parse_to_code(program);\n            code = &amp;scripts[\"__STRING_PROGRAM\"];\n            if (code-&gt;empty()){\n                error(\"Error parsing program from string\");\n                return false;\n            }\n            return run();\n        }\n\n        bool run(){\n            auto log = Logger::Log();\n            log &lt;&lt; Team::TEAM_4 &lt;&lt; LogLevel::INFO &lt;&lt; \"Entering program execution\" &lt;&lt; std::endl;\n\n            error_message = \"\";\n\n            log &lt;&lt; LogLevel::DEBUG;\n\n            index = 0;\n            while (error_message.empty() &amp;&amp; index &lt; code-&gt;size()){\n                auto&amp; unit = code-&gt;at(index);\n                switch (unit.type){\n                    case Unit::Type::number:\n                        log &lt;&lt; \"Push number \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        try {\n                            pushStack(std::stod(unit.value));\n                        } catch (const std::invalid_argument&amp; e) {\n                            error(\"Failed to convert number!\");\n                        } catch (const std::out_of_range&amp; e){\n                            error(\"Number too big!\");\n                        }\n                        break;\n\n                    case Unit::Type::string:\n                        log &lt;&lt; \"Push string \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        pushStack(unit.value);\n                        break;\n\n                    case Unit::Type::identifier:\n                        log &lt;&lt; \"Push identifier \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        pushStack(Identifier{unit.value});\n                        break;\n\n                    case Unit::Type::operation:\n                        // perform operation!\n                        log &lt;&lt; \"Perform operation \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        if (unit.value == \"=\"){\n                            // values to assign\n                            std::vector&lt; Value &gt; values = popArgs();\n                            // identifiers to assign to\n                            auto identifier_values = popArgs();\n                            if (values.size() &gt; identifier_values.size()){\n                                error(\"Too many values!\");\n                                break;\n                            } else if (values.size() &lt; identifier_values.size()){\n                                error(\"Not enough values!\");\n                                break;\n                            }\n                            // Convert to identifiers specifically\n                            std::vector&lt; Identifier &gt; identifiers;\n                            std::transform(\n                identifier_values.begin(), identifier_values.end(),\n                std::back_inserter(identifiers),\n                [this](const Value&amp; v){ return as&lt;Identifier&gt;(v); }\n              );\n                            //ex. a,b,c=1,2,3 becomes the following units\n                            // . a b c . 1 2 3 =\n                            // v: 3 2 1\n                            // i: c b a\n                            if (!getErrorMessage().empty()){\n                                // transform failed in some way \n                                break;\n                            }\n\n                            // upon reaching this point, values and identifiers\n                            // are the same length and contain valid items.\n                            for (size_t i = 0; i &lt; identifiers.size(); ++i){\n                                auto a = identifiers[i];\n                                auto b = values[i];\n\n                                if (!std::holds_alternative&lt;Identifier&gt;(b)){\n                                    setVariable(static_cast&lt;std::string&gt;(a), b);\n                                } else {\n                                    // exception if variable b does not exist\n                                    try {\n                                        auto&amp; b_var = variables.at(static_cast&lt;std::string&gt;(as&lt;Identifier&gt;(b)));\n                                        setVariable(static_cast&lt;std::string&gt;(a), b_var);\n                                    } catch (const std::out_of_range&amp; e){\n                                        error(\"Variable did not exist!\");\n                                    }\n                                }\n                            }\n                        } else if (std::string{\"+ - * / == != &lt;= &gt;= &lt; &gt;\"}.find(unit.value) != std::string::npos){\n                            // binary expressions\n                            auto b = popStack();\n                            auto a = popStack();\n                            if (unit.value == \"+\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(as&lt;double&gt;(a) + as&lt;double&gt;(b));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(as&lt;std::string&gt;(a) + as&lt;std::string&gt;(b));\n                                } else {\n                                    error(\"Runtime type error (plus)\");\n                                }\n                            } else if (unit.value == \"-\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(as&lt;double&gt;(a) - as&lt;double&gt;(b));\n                                } else {\n                                    error(\"Runtime type error (minus)\");\n                                }\n                            } else if (unit.value == \"*\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(as&lt;double&gt;(a) * as&lt;double&gt;(b));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    std::string n;\n                                    double c = as&lt;double&gt;(b);\n                                    for (int i = 0; i &lt; c; ++i){\n                                        n += as&lt;std::string&gt;(a);\n                                    }\n                                    pushStack(n);\n                                } else {\n                                    error(\"Runtime type error (times)\");\n                                }\n                            } else if (unit.value == \"/\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(as&lt;double&gt;(a) / as&lt;double&gt;(b));\n                                } else {\n                                    error(\"Runtime type error (divide)\");\n                                }\n                            } else if (unit.value == \"==\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) == as&lt;double&gt;(b)));\n                                } else if (has&lt;size_t&gt;(a) &amp;&amp; has&lt;size_t&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;size_t&gt;(a) == as&lt;size_t&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) == as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (==)\");\n                                }\n                            } else if (unit.value == \"!=\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) != as&lt;double&gt;(b)));\n                                } else if (has&lt;size_t&gt;(a) &amp;&amp; has&lt;size_t&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;size_t&gt;(a) != as&lt;size_t&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) != as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (!=)\");\n                                }\n                            } else if (unit.value == \"&lt;\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) &lt; as&lt;double&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) &lt; as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (&lt;)\");\n                                }\n                            } else if (unit.value == \"&gt;\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) &gt; as&lt;double&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) &gt; as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (&gt;)\");\n                                }\n                            } else if (unit.value == \"&lt;=\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) &lt;= as&lt;double&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) &lt;= as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (&lt;=)\");\n                                }\n                            } else if (unit.value == \"&gt;=\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) &gt;= as&lt;double&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) &gt;= as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (&gt;=)\");\n                                }\n                            }\n                        } else if (unit.value == \"endline\"){\n                            // clear stack on end of line\n                            while (stack.size())\n                                popStack();\n                        } else if (unit.value == \"endargs\"){\n                            // this could absolutely be broken but that's OK\n                            pushStack(Identifier{\"__INTERNAL_ENDARGS\"});\n                        } else if (unit.value == \"start_block\"){\n                            auto type = as&lt;std::string&gt;(call_stack.top().at(0));\n                            if (type == \"__FOR_BLOCK\"){\n                                auto info = call_stack.top();\n\n                                double value = as&lt;double&gt;(info.at(1));\n                                double start = as&lt;double&gt;(info.at(2));\n                                double end = as&lt;double&gt;(info.at(3));\n                                double step = as&lt;double&gt;(info.at(4));\n\n                                if ((start &lt; end &amp;&amp; step &gt; 0 &amp;&amp; value + step &lt;= end)\n                                    || (start &gt;= end &amp;&amp; step &lt; 0 &amp;&amp; value + step &gt;= end)){\n                                    // continue\n                                    variables.insert_or_assign(static_cast&lt;std::string&gt;(as&lt;Identifier&gt;(info.at(1))), value + step);\n                                    // jump back to the beginning to check the condiiton\n//                                  index = static_cast&lt;int&gt;(as&lt;double&gt;(call_stack.top().at(5)));\n                                } else {\n                                    // end loop\n                                    call_stack.pop();\n                                    skipBlock(1);\n                                    index++; // skip end_block or else it tries to jump to beginning\n                                    break;\n                                }\n                            }\n                        } else if (unit.value == \"end_block\"){\n                            // check for for loop if needed \n                            auto type = as&lt;std::string&gt;(call_stack.top().at(0));\n                            if (type == \"__FOR_BLOCK\"){\n                                // jump back to the beginning to check the condiiton\n                                index = static_cast&lt;int&gt;(as&lt;double&gt;(call_stack.top().at(5)));\n                            } else if (type == \"__IF_BLOCK\"){\n                                // this only runs once, don't really need to save this\n                                call_stack.pop();\n                            } else if (type == \"__FUNCTION_BLOCK\"){\n                                // return from function\n                                index = static_cast&lt;int&gt;(as&lt;double&gt;(call_stack.top().at(1)));\n                                call_stack.pop();\n                            }\n                        } else {\n                            error(\"Unknown operation '\" + unit.value + \"'\");\n                        }\n                        break;\n\n                    case Unit::Type::function:\n                        log &lt;&lt; \"Perform function \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        if (variables.count(unit.value)){\n                            auto&amp; func = variables.at(unit.value);\n                            if (std::holds_alternative&lt;Callable&gt;(func)){\n                                std::get&lt;Callable&gt;(func)(*this);\n                            } else {\n                                error(unit.value + \" is not a callable object!\");\n                            }\n                            break;\n                        } else {\n                            error(\"Function \" + unit.value + \" does not exist!\");\n                        }\n                        break;\n\n                    case Unit::Type::function_decl:\n                        {\n                        log &lt;&lt; \"Create function \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        auto vars = popArgs(); // should consist of variable names only\n                        for (auto&amp; v : vars){\n                            if (!std::holds_alternative&lt;Identifier&gt;(v)){\n                                error(\"Function definition only accepts identifiers!\");\n                            }\n                        }\n\n                        if (!getErrorMessage().empty()) break;\n                        // args are all vars\n                        auto func_body_index = index;\n                        auto func = [this, vars, func_body_index](ProgramExecutor&amp; pe){\n                            // first: assign to all vars the values on the stack\n                            auto values = pe.popArgs();\n                            if (values.size() != vars.size()){\n                                error(\"Invalid number of arguments (to user-defined function)!\");\n                                return;\n                            }\n\n                            for (size_t i = 0; i &lt; vars.size(); ++i){\n                                auto a = static_cast&lt;std::string&gt;(std::get&lt;Identifier&gt;(vars[i]));\n                                auto b = values[i];\n\n                                if (!std::holds_alternative&lt;Identifier&gt;(b)){\n                                    setVariable(a, b);\n                                } else {\n                                    // exception if variable b does not exist\n                                    try {\n                                        auto&amp; b_var = variables.at(static_cast&lt;std::string&gt;(as&lt;Identifier&gt;(b)));\n                                        setVariable(a, b_var);\n                                    } catch (const std::out_of_range&amp; e){\n                                        error(\"Variable did not exist!\");\n                                    }\n                                }\n                            }\n                            // Assigned stack values to vars (as best as possible)\n                            // Store return index\n                            call_stack.push({\"__FUNCTION_BLOCK\", static_cast&lt;double&gt;(this-&gt;index)});\n                            // Assign PC to start of code block\n                            this-&gt;index = func_body_index;\n                        };\n\n                        // Assign this created function to this name\n                        setVariable(unit.value, func);\n                        skipBlock(); // skip past the function definition\n                        ++index;\n                        }\n                        break;\n\n                    default:\n                        error(\"Unknown code unit '\" + unit.value +\"'!\");\n                }\n                index++;\n            }\n\n            log &lt;&lt; \"Program execution ends\" &lt;&lt; std::endl;\n            if (!error_message.empty()){\n                log &lt;&lt; LogLevel::WARNING &lt;&lt; \"With error: \" &lt;&lt; error_message &lt;&lt; std::endl;\n            }\n\n            return error_message.empty();\n        }\n    };\n} //worldlang\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp/","title":"File SecondWorld.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; SecondWorld.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include \"../Agents/PacingAgent.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> <li><code>#include \"ProgramExecutor.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace group4"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp/#classes","title":"Classes","text":"Type Name class SecondWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Jayson Van Dam </p> <p>Author:</p> <p>Kurt LaBlanc </p> <p>Author:</p> <p>Satvik Ravipati </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/SecondWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp_source/","title":"File SecondWorld.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; SecondWorld.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n#include &lt;algorithm&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n#include \"../Agents/PacingAgent.hpp\"\n#include \"../core/WorldBase.hpp\"\n#include \"ProgramExecutor.hpp\"  //&lt; for attack, item scripts\n\nusing cse491::CellType;\n\nnamespace group4 {\nconst std::string FIRST_FLOOR_FILENAME = \"../assets/grids/group4_maze.grid\";\n\nconst std::string SECOND_FLOOR_FILENAME = \"../assets/grids/second_floor.grid\";\n\nconst std::string FINAL_FLOOR_FILENAME = \"../assets/grids/third_floor.grid\";\n\nconst std::string ITEM_PICKUP_SCRIPT = \"../assets/scripts/g4_item_pickup.ws\";\n\nconst std::string COMBAT_SCRIPT = \"../assets/scripts/g4_agent_attack.ws\";\n\nconst std::string WORLD_LOAD_SCRIPT = \"../assets/scripts/g4_world_load.ws\";\n\nconst std::string WORLD_LOAD_SCRIPT_2 = \"../assets/scripts/g4_world_2_load.ws\";\n\nconst std::string WORLD_LOAD_SCRIPT_3 = \"../assets/scripts/g4_world_3_load.ws\";\n\nconst size_t MAX_INVENTORY_SIZE = 30;\n\nconst cse491::GridPosition OffGrid = {-1, -1};\n\nclass SecondWorld : public cse491::WorldBase {\n private:\n  std::string world_filename = \"\";\n\n  std::string agents_filename = \"\";\n\n\n  void LoadWorldScript(std::string source){\n    // Clear items on the current grid, unless held by a player\n    for (auto it = item_map.begin(); it != item_map.end();) {\n      auto&amp; item = it-&gt;second;\n      if (item-&gt;IsOnGrid()) {\n        // clear this item\n        it = item_map.erase(it);\n      } else if (item-&gt;IsOwnedByItem()) {\n        // it's owned by a chest: this is currently the only item containing\n        // items\n        it = item_map.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    // Clear agents, unless they are the player (an interface)\n    std::vector&lt;size_t&gt; agents_to_remove = {};\n    for (auto&amp; [agent_id, agent_ptr] : agent_map) {\n      if (!agent_ptr-&gt;IsInterface()) {\n        agents_to_remove.push_back(agent_id);\n      }\n    }\n\n    for (auto agent_id : agents_to_remove) {\n      RemoveAgent(agent_id);\n    }\n\n    // Initialize level\n    pe.runFile(source);\n  }\n\n\n  void SwitchGrid(cse491::AgentBase&amp; agent) {\n\n    // This value initialized by each world load script to point to the next level\n    auto next_world_script = pe.var&lt;std::string&gt;(\"next_world\");\n\n    agent.Notify(\"Going to \" + world_filename, \"world_switched\");\n    if (next_world_script == \"GAME_END\") {\n      agent.Notify(\"Congrats, you won the game!\", \"congrats_msg\");\n      run_over = true;\n      return;\n    }\n\n    LoadWorldScript(next_world_script);\n  }\n\n protected:\n  enum ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    DROP_ITEM,\n//    WARP_TO_FLOOR_3  // New action for hidden warp tile\n  };\n\n  worldlang::ProgramExecutor pe;\n\n  std::map&lt;size_t, std::unique_ptr&lt;cse491::ItemBase&gt;&gt; inventory;\n\n  void ConfigAgent(cse491::AgentBase&amp; agent) override {\n    agent.AddAction(\"up\", MOVE_UP);\n    agent.AddAction(\"down\", MOVE_DOWN);\n    agent.AddAction(\"left\", MOVE_LEFT);\n    agent.AddAction(\"right\", MOVE_RIGHT);\n    agent.AddAction(\"drop\", DROP_ITEM);\n//    agent.AddAction(\"warp\", WARP_TO_FLOOR_3);\n  }\n\n public:\n  SecondWorld() : world_filename(FIRST_FLOOR_FILENAME), pe{*this} {\n    pe.registerFunction(\"loadAgents\", [this](worldlang::ProgramExecutor&amp; pe){\n      auto args = pe.popArgs();\n      if (args.size() != 1) { pe.error(\"Wrong number of arguments!\"); return; }\n      auto path = pe.as&lt;std::string&gt;(args[0]);\n\n      this-&gt;LoadFromFile(path);\n    });\n\n    LoadWorldScript(WORLD_LOAD_SCRIPT);\n  }\n\n  SecondWorld(std::string grid_filename, std::string agent_filename)\n      : world_filename(grid_filename),\n        agents_filename(agent_filename),\n        pe{*this} {\n    AddCellType(\"floor\", \"Floor that you can easily walk over.\", ' ');\n    AddCellType(\"flag\", \"Goal flag for a game end state\", 'g');\n    AddCellType(\"wall\", \"Impenetrable wall that you must find a way around.\", '#');\n    AddCellType(\"hidden_warp\", \"Hidden warp tile that warps to floor 3.\", 'u');\n    AddCellType(\"water\", \"Water that distinguishes fire.\", 'w');\n\n    main_grid.Read(grid_filename, type_options);\n    LoadFromFile(agent_filename);\n  }\n\n  ~SecondWorld() = default;\n\n  void LoadFromFile(const std::string&amp; input_filename) {\n    std::ifstream input_file(input_filename);\n\n    if (!input_file.is_open()) {\n      std::cerr &lt;&lt; \"Error: could not open file \" &lt;&lt; input_filename &lt;&lt; std::endl;\n      return;\n    }\n\n    nlohmann::json data;\n    try {\n      input_file &gt;&gt; data;\n    } catch (const nlohmann::json::parse_error&amp; err) {\n      std::cerr &lt;&lt; \"JSON parsing error: \" &lt;&lt; err.what() &lt;&lt; std::endl;\n      return;\n    }\n\n//    const int BASE_MAX_HEALTH = 100;\n    for (const auto&amp; agent : data) {\n      // May get a json.exception.type_error here if you assign to the wrong C++\n      // type, so make sure to nail down what types things are in JSON first! My\n      // intuition is that each agent object will have: name: string (C++\n      // std::string) x: number (C++ int) y: number (C++ int) entities:\n      // array&lt;string&gt; (C++ std::vector&lt;std::string&gt;)\n      std::string agent_name = agent.at(\"name\");\n      int x_pos = agent.at(\"x\");\n      int y_pos = agent.at(\"y\");\n\n//      int additional_max_health = 0;\n//      std::vector&lt;std::string&gt; entities = agent.at(\"entities\");\n\n\n//      for (const auto&amp; entity : entities) {\n        // TODO: How should we set the entity properties here?\n        // Just adding to MaxHealth now, but this doesn't seem very scalable.\n/*        if (entity == \"chocolate_bar\") {\n          additional_max_health = 10;\n        }*/\n//      }\n\n      auto&amp; a = AddAgent&lt;cse491::PacingAgent&gt;(agent_name)\n          .SetPosition(x_pos, y_pos);\n//          .SetProperty(\"MaxHealth\", BASE_MAX_HEALTH + additional_max_health);\n\n      auto properties = agent.at(\"properties\");\n      for (const auto&amp; p : properties.items()){\n        std::cout &lt;&lt; p.value().is_number() &lt;&lt; std::endl;\n        a.SetProperty(p.key(), p.value().get&lt;double&gt;());\n      }\n\n    }\n  }\n\n  virtual void Run() override {\n    while (!run_over) {\n      RunAgents();\n    }\n\n    SaveToFile();\n  }\n\n  void SaveToFile() {\n    nlohmann::json output_data;  // json to store the data being outputted\n\n    for (const auto&amp; [agent_id, agent_ptr] : agent_map) {\n      auto new_position = agent_ptr-&gt;GetPosition();\n      std::string agent_name = agent_ptr-&gt;GetName();\n      double x_pos = new_position.GetX();\n      double y_pos = new_position.GetY();\n\n      nlohmann::json agent_data;  // json for each agent\n      agent_data[\"name\"] = agent_name;\n      agent_data[\"x\"] = x_pos;\n      agent_data[\"y\"] = y_pos;\n\n      output_data.push_back(agent_data);  // add it to the json array\n    }\n\n    std::ofstream ofs(\"output.json\");  // save it to a file called output.json\n    ofs &lt;&lt; output_data.dump(2);        // indentation\n  }\n\n  void DropItem(cse491::AgentBase&amp; agent, cse491::GridPosition&amp; pos) {\n    // Cannot drop\n    if (agent.GetInventory().empty()) {\n      agent.Notify(\"Cannot drop any items, inventory is empty.\", \"item_alert\");\n      return;\n    }\n\n    auto items_found = FindItemsAt(pos, 0);\n    auto&amp; item_drop = GetItem(agent.GetInventory().at(0));\n\n    // Transfer ownership to chest\n    if (!items_found.empty()) {\n      auto&amp; target_item = GetItem(items_found.at(0));\n      if (target_item.HasProperty(\"Chest\")) {\n        item_drop.SetPosition(OffGrid);\n        target_item.AddItem(item_drop);\n\n        // Set the position and remove item from agent's inventory\n        agent.RemoveItem(item_drop.GetID());\n\n        // Must set the grid back because RemoveItem() doesn't account for that\n        item_drop.SetGrid();\n        agent.Notify(\"Dropping \" + item_drop.GetName() + \" into the chest!\",\n                     \"item_alert\");\n        return;\n\n        // Item already on player's position\n      } else {\n        agent.Notify(\n            \"Cannot drop the item, there is already an item on this cell.\",\n            \"item_alert\");\n        return;\n      }\n    }\n    // Transfer ownership to grid\n    agent.RemoveItem(item_drop.GetID());\n    item_drop.SetGrid();\n    item_drop.SetPosition(pos);\n\n    agent.Notify(\"Dropping \" + item_drop.GetName() + \" onto the ground!\",\n                 \"item_alert\");\n  }\n\n  bool CheckPosition(cse491::AgentBase&amp; agent, cse491::GridPosition&amp; pos) {\n    // First check to see if agent is on win flag\n    if ((type_options[main_grid.At(pos)].HasProperty(\"Goal\")) &amp;&amp;\n        (agent.IsInterface())) {\n      agent.Notify(\"Flag found \", \"item_alert\");\n\n      agent.Notify(\"Leaving \" + world_filename, \"world_switched\");\n\n      SwitchGrid(agent);\n\n      return false;\n\n      // then checks if agent is on any items\n    } else if ((type_options[main_grid.At(pos)].HasProperty(\"Warp\")) &amp;&amp;\n               (agent.IsInterface())) {\n      // Agent used the hidden warp tile action\n      agent.Notify(\"Hidden warp tile activated! Warping to floor 3.\",\n                   \"hidden_warp\");\n\n      agent.Notify(\"Leaving \" + world_filename, \"world_switched\");\n\n      LoadWorldScript(WORLD_LOAD_SCRIPT_3); // skip right to the end\n      return false;\n    } else {\n      auto items_found = FindItemsAt(pos, 0);\n      // If there are items at this position\n      if (!items_found.empty() &amp;&amp; agent.IsInterface()) {\n        auto&amp; item_found = GetItem(items_found.at(0));\n\n        // Item is a chest\n        if (item_found.HasProperty(\"Chest\")) {\n          // Check to see if the chest owns any items\n          if (!item_found.GetInventory().empty()) {\n            auto temp_inventory = item_found.GetInventory();\n            agent.Notify(\"This is inside the chest: \", \"item_alert\");\n\n            // Display the items found\n            for (auto x : temp_inventory) {\n              agent.Notify(\"You found the \" + GetItem(x).GetName() +\n                           \" in the \" + item_found.GetName());\n              agent.AddItem(GetItem(x));\n              item_found.RemoveItem(GetItem(x));\n            }\n\n            // Check agent's inventory size\n            if (agent.GetInventory().size() == MAX_INVENTORY_SIZE) {\n              agent.Notify(\n                  \"It looks like your inventory is full, please drop items or \"\n                  \"place them in chests!\",\n                  \"item_alert\");\n            }\n          } else {\n            agent.Notify(\"The chest is empty! You can store items with 't'!\",\n                         \"item_alert\");\n          }\n\n          // Item is not a chest\n        } else {\n          if (agent.GetInventory().size() == MAX_INVENTORY_SIZE) {\n            agent.Notify(\n                \"It looks like your inventory is full, please drop items or \"\n                \"place them in chests!\",\n                \"item_alert\");\n\n          } else {\n            agent.Notify(\"You found \" + item_found.GetName() + \"!\",\n                         \"item_alert\");\n\n            // Set the position off the grid, so it doesn't render\n            // Note: Setting the position with a GridPosition SETS THE OWNER\n            item_found.SetPosition(OffGrid);\n            // Add item to the agent's inventory\n            agent.AddItem(item_found.GetID());\n\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  int DoAction(cse491::AgentBase&amp; agent, size_t action_id) override {\n    if (agent.HasProperty(\"Dead\")){\n      return false; // Can't move when dead!\n    }\n\n    cse491::GridPosition new_position;\n    bool IsDropped = false;\n    switch (action_id) {\n      case REMAIN_STILL:\n        new_position = agent.GetPosition();\n        break;\n      case MOVE_UP:\n        new_position = agent.GetPosition().Above();\n        break;\n      case MOVE_DOWN:\n        new_position = agent.GetPosition().Below();\n        break;\n      case MOVE_LEFT:\n        new_position = agent.GetPosition().ToLeft();\n        break;\n      case MOVE_RIGHT:\n        new_position = agent.GetPosition().ToRight();\n        break;\n      case DROP_ITEM:\n        new_position = agent.GetPosition();\n        DropItem(agent, new_position);\n//        IsDropped = true;\n        return true;\n        break;\n    }\n\n    if (!main_grid.IsValid(new_position)) {\n      return false;\n    }\n    if (!IsTraversable(agent, new_position)) {\n      return false;\n    }\n\n    // At this point, new_position is valid and not going into a wall.\n    // Check if there are any agents on this tile:\n    auto res = this-&gt;FindAgentsAt(new_position);\n    if (res.size() &amp;&amp; res[0] != agent.GetID()) {\n      // At least one agent was found (and isn't the player)\n      // Take the first agent and attack it.\n      pe.setVariable(\"agent\", agent.GetID());\n      pe.setVariable(\"opponent\", res[0]);\n      pe.runFile(COMBAT_SCRIPT);\n\n      auto&amp; opponent = GetAgent(res[0]);\n      if (opponent.HasProperty(\"Dead\") &amp;&amp; opponent.IsInterface()){\n        // game over!\n        opponent.Notify(\"You have died.\", \"game_over\");\n        run_over = true;\n      } else if (opponent.HasProperty(\"Dead\") &amp;&amp; opponent.HasProperty(\"Boss\")){\n        // level up: i.e. you can go on water now\n        agent.Notify(\"You have defeated the boss! You now can walk on water.\", \"message\");\n        agent.SetProperty(\"Swimmer\", true);\n      }\n\n      // The movement was not legal, so we return false.\n      // TODO: Should this return a status indicating that an attack occured,\n      // to distinguish moves that do nothing from attacks?\n      return false;\n    }\n\n    if (!IsDropped) {\n      if (!CheckPosition(agent, new_position))\n        //does not set position if grid changed, but move is considered successful\n        return true; \n    }\n\n    IsDropped = false;\n    agent.SetPosition(new_position);\n    return true;\n  }\n\n  void PrintEntities() {\n    for (const auto&amp; [id, item_ptr] : item_map) {\n      if (!item_ptr) {\n        continue;\n      }\n      std::cout &lt;&lt; item_ptr-&gt;GetName() &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  bool IsTraversable(const AgentBase&amp; agent,\n                     cse491::GridPosition pos) const override {\n    if (GetCellTypes().at(main_grid.At(pos)).HasProperty(CellType::CELL_WALL))\n      return false;\n    else if (GetCellTypes()\n                 .at(main_grid.At(pos))\n                 .HasProperty(CellType::CELL_WATER))\n      return agent.HasProperty(\"Swimmer\");\n    else\n      return true;\n  }\n};\n}  // namespace group4\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cse491 A World that consists only of walls and open cells. </li> <li>namespace cse491_team8 A World that consists of trees, water, and grass cells. </li> <li>namespace group4 </li> <li>namespace group6 A World that consists only of walls and open cells. </li> <li>namespace siv <ul> <li>namespace perlin_detail </li> </ul> </li> <li>namespace std </li> <li>namespace tao <ul> <li>namespace pegtl </li> </ul> </li> <li>namespace worldlang Namespace for scripting language stuff. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/","title":"Class Index","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#a","title":"a","text":"<ul> <li>add (worldlang)</li> <li>add_a (worldlang)</li> <li>assignment (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#b","title":"b","text":"<ul> <li>BasicPerlinNoise (siv)</li> <li>BiomeGenerator (group6)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#c","title":"c","text":"<ul> <li>code_block (worldlang)</li> <li>comment (worldlang)</li> <li>comp (worldlang)</li> <li>comp_a (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#e","title":"e","text":"<ul> <li>element (worldlang)</li> <li>expression (worldlang)</li> <li>expression_list (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#f","title":"f","text":"<ul> <li>function (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#g","title":"g","text":"<ul> <li>GenerativeWorld (group6)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#i","title":"i","text":"<ul> <li>Identifier (worldlang::ProgramExecutor)</li> <li>identifier (worldlang)</li> <li>identifier_list (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#m","title":"m","text":"<ul> <li>ManualWorld (cse491_team8)</li> <li>MazeWorld (cse491)</li> <li>mul (worldlang)</li> <li>mul_a (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#n","title":"n","text":"<ul> <li>number (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#o","title":"o","text":"<ul> <li>op_prio_add (worldlang)</li> <li>op_prio_comp (worldlang)</li> <li>op_prio_mul (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#p","title":"p","text":"<ul> <li>program (worldlang)</li> <li>ProgramExecutor (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#s","title":"s","text":"<ul> <li>SecondWorld (group4)</li> <li>statement (worldlang)</li> <li>statement_list (worldlang)</li> <li>string (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#u","title":"u","text":"<ul> <li>Unit (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class group6::BiomeGenerator </li> <li>class siv::BasicPerlinNoise </li> <li>class worldlang::ProgramExecutor Class that manages program execution. </li> <li>struct worldlang::Unit </li> <li>class WorldBase <ul> <li>class cse491::MazeWorld </li> <li>class cse491_team8::ManualWorld </li> <li>class group4::SecondWorld </li> <li>class group6::GenerativeWorld </li> </ul> </li> <li>class string <ul> <li>struct worldlang::ProgramExecutor::Identifier </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; add_a, op_prio_add, add &gt;, add_a &gt; <ul> <li>struct worldlang::add </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; mul, op_prio_add, mul &gt;, mul &gt; <ul> <li>struct worldlang::add_a </li> </ul> </li> <li>class tao::pegtl::seq&lt; identifier_list, pegtl::one&lt; '=' &gt;, expression_list &gt; <ul> <li>struct worldlang::assignment </li> </ul> </li> <li>class tao::pegtl::seq&lt; pegtl::one&lt; '{' &gt;, pegtl::eol, statement_list, pegtl::one&lt; '}' &gt;, pegtl::eol &gt; <ul> <li>struct worldlang::code_block </li> </ul> </li> <li>class tao::pegtl::seq&lt; pegtl::one&lt; '#' &gt;, pegtl::until&lt; pegtl::eol &gt; &gt; <ul> <li>struct worldlang::comment </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; comp_a, op_prio_comp, comp &gt;, comp_a &gt; <ul> <li>struct worldlang::comp </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; add, op_prio_comp, add &gt;, add &gt; <ul> <li>struct worldlang::comp_a </li> </ul> </li> <li>class tao::pegtl::sor&lt; function, identifier, number, string, pegtl::seq&lt; pegtl::one&lt; '(' &gt;, expression, pegtl::one&lt; ')' &gt; &gt; &gt; <ul> <li>struct worldlang::element </li> </ul> </li> <li>class tao::pegtl::sor&lt; comp &gt; <ul> <li>struct worldlang::expression </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; expression, pegtl::one&lt; ',' &gt;, expression_list &gt;, expression &gt; <ul> <li>struct worldlang::expression_list </li> </ul> </li> <li>class tao::pegtl::seq&lt; identifier, pegtl::one&lt; '(' &gt;, pegtl::opt&lt; expression_list &gt;, pegtl::one&lt; ')' &gt; &gt; <ul> <li>struct worldlang::function </li> </ul> </li> <li>class identifier <ul> <li>struct worldlang::identifier </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; identifier, pegtl::one&lt; ',' &gt;, identifier_list &gt;, identifier &gt; <ul> <li>struct worldlang::identifier_list </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; mul_a, op_prio_mul, mul &gt;, mul_a &gt; <ul> <li>struct worldlang::mul </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; element, op_prio_mul, element &gt;, element &gt; <ul> <li>struct worldlang::mul_a </li> </ul> </li> <li>class tao::pegtl::seq&lt; pegtl::opt&lt; pegtl::one&lt; '-' &gt; &gt;, pegtl::plus&lt; pegtl::digit &gt;, pegtl::opt&lt; pegtl::one&lt; '.' &gt;, pegtl::plus&lt; pegtl::digit &gt; &gt; &gt; <ul> <li>struct worldlang::number </li> </ul> </li> <li>class tao::pegtl::one&lt; '+', '-' &gt; <ul> <li>struct worldlang::op_prio_add </li> </ul> </li> <li>class tao::pegtl::sor&lt; TAO_PEGTL_STRING(\"==\"), TAO_PEGTL_STRING(\"!=\"), TAO_PEGTL_STRING(\"&lt;=\"), TAO_PEGTL_STRING(\"&gt;=\"), pegtl::one&lt; '&lt;' &gt;, pegtl::one&lt; '&gt;' &gt; &gt; <ul> <li>struct worldlang::op_prio_comp </li> </ul> </li> <li>class tao::pegtl::one&lt; ' *', '/' &gt; <ul> <li>struct worldlang::op_prio_mul </li> </ul> </li> <li>class tao::pegtl::seq&lt; statement_list, pegtl::eolf &gt; <ul> <li>struct worldlang::program </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; function, pegtl::opt&lt; code_block &gt;, pegtl::opt&lt; pegtl::eol &gt; &gt;, pegtl::seq&lt; assignment, pegtl::opt&lt; pegtl::eol &gt; &gt;, comment, pegtl::eol &gt; <ul> <li>struct worldlang::statement </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; statement, statement_list &gt;, statement &gt; <ul> <li>struct worldlang::statement_list </li> </ul> </li> <li>class tao::pegtl::seq&lt; pegtl::one&lt; '\"' &gt;, pegtl::star&lt; pegtl::not_one&lt;'\"'&gt; &gt;, pegtl::one&lt; '\"' &gt; &gt; <ul> <li>struct worldlang::string </li> </ul> </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/","title":"Class Members","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#a","title":"a","text":"<ul> <li>ActionType (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>AddMove (cse491_team8::ManualWorld)</li> <li>agents_filename (group4::SecondWorld)</li> <li>applyPathToGrid (group6::BiomeGenerator)</li> <li>AStarAgentHelper (group6::GenerativeWorld)</li> <li>AddArmory (group6::GenerativeWorld)</li> <li>AddTeleporters (group6::GenerativeWorld)</li> <li>AgentCollisionHelper (group6::GenerativeWorld)</li> <li>ArmoryTileHelper (group6::GenerativeWorld)</li> <li>armory_id (group6::GenerativeWorld)</li> <li>as (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#b","title":"b","text":"<ul> <li>bridge_id (cse491_team8::ManualWorld)</li> <li>BiomeGenerator (group6::BiomeGenerator)</li> <li>biome (group6::BiomeGenerator)</li> <li>BasicPerlinNoise (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#c","title":"c","text":"<ul> <li>ConfigAgent (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>CheckPosition (group4::SecondWorld)</li> <li>clearPath (group6::BiomeGenerator)</li> <li>CreateGrid (group6::GenerativeWorld)</li> <li>Callable (worldlang::ProgramExecutor)</li> <li>call_stack (worldlang::ProgramExecutor)</li> <li>code (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#d","title":"d","text":"<ul> <li>DoAction (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>DoActionAttemptItemPickup (cse491_team8::ManualWorld)</li> <li>DoActionFindNewPosition (cse491_team8::ManualWorld)</li> <li>DoActionTestNewPositionTree (cse491_team8::ManualWorld)</li> <li>DoActionTestNewPositionWater (cse491_team8::ManualWorld)</li> <li>DoBattle (cse491_team8::ManualWorld)</li> <li>DropItems (cse491_team8::ManualWorld)</li> <li>DropItem (group4::SecondWorld)</li> <li>dirt_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>door_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>DamageAgent (group6::GenerativeWorld)</li> <li>DoorTileHelper (group6::GenerativeWorld)</li> <li>default_random_engine (siv::BasicPerlinNoise)</li> <li>deserialize (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#e","title":"e","text":"<ul> <li>EndGame (group6::GenerativeWorld)</li> <li>error (worldlang::ProgramExecutor)</li> <li>error_message (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#f","title":"f","text":"<ul> <li>floor_id (cse491::MazeWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>FacingDirection (cse491_team8::ManualWorld)</li> <li>FindItem (cse491_team8::ManualWorld)</li> <li>frequency (group6::BiomeGenerator)</li> <li>FindTiles (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#g","title":"g","text":"<ul> <li>GenerateMoveSets (cse491_team8::ManualWorld)</li> <li>grass_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>generate (group6::BiomeGenerator)</li> <li>getBiome (group6::BiomeGenerator)</li> <li>getSeed (group6::BiomeGenerator)</li> <li>grid (group6::BiomeGenerator)</li> <li>GenerativeWorld (group6::GenerativeWorld)</li> <li>getErrorMessage (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#h","title":"h","text":"<ul> <li>HealAction (cse491_team8::ManualWorld)</li> <li>height (group6::BiomeGenerator)</li> <li>hole_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>HoleTileHelper (group6::GenerativeWorld)</li> <li>has (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#i","title":"i","text":"<ul> <li>IsTraversable (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>inventory (group4::SecondWorld)</li> <li>ItemHelper (group6::GenerativeWorld)</li> <li>index (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#k","title":"k","text":"<ul> <li>keyLocation (group6::BiomeGenerator)</li> <li>key_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>KeyTileHelper (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#l","title":"l","text":"<ul> <li>LookAhead (cse491_team8::ManualWorld)</li> <li>LoadFromFile (group4::SecondWorld)</li> <li>LoadWorldScript (group4::SecondWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#m","title":"m","text":"<ul> <li>MazeWorld (cse491::MazeWorld)</li> <li>ManualWorld (cse491_team8::ManualWorld)</li> <li>MoveSetAction (cse491_team8::ManualWorld)</li> <li>m_permutation (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#n","title":"n","text":"<ul> <li>noise1D (siv::BasicPerlinNoise)</li> <li>noise1D_01 (siv::BasicPerlinNoise)</li> <li>noise2D (siv::BasicPerlinNoise)</li> <li>noise2D_01 (siv::BasicPerlinNoise)</li> <li>noise3D (siv::BasicPerlinNoise)</li> <li>noise3D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave1D (siv::BasicPerlinNoise)</li> <li>normalizedOctave1D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave2D (siv::BasicPerlinNoise)</li> <li>normalizedOctave2D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave3D (siv::BasicPerlinNoise)</li> <li>normalizedOctave3D_01 (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#o","title":"o","text":"<ul> <li>OtherAction (cse491_team8::ManualWorld)</li> <li>oceanHandler (group6::BiomeGenerator)</li> <li>octave1D (siv::BasicPerlinNoise)</li> <li>octave1D_01 (siv::BasicPerlinNoise)</li> <li>octave1D_11 (siv::BasicPerlinNoise)</li> <li>octave2D (siv::BasicPerlinNoise)</li> <li>octave2D_01 (siv::BasicPerlinNoise)</li> <li>octave2D_11 (siv::BasicPerlinNoise)</li> <li>octave3D (siv::BasicPerlinNoise)</li> <li>octave3D_01 (siv::BasicPerlinNoise)</li> <li>octave3D_11 (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#p","title":"p","text":"<ul> <li>portal_id_a (cse491_team8::ManualWorld)</li> <li>portal_id_b (cse491_team8::ManualWorld)</li> <li>portal_id_c (cse491_team8::ManualWorld)</li> <li>portal_id_d (cse491_team8::ManualWorld)</li> <li>PrintEntities (group4::SecondWorld)</li> <li>pe (group4::SecondWorld)</li> <li>perlinNoise (group6::BiomeGenerator)</li> <li>placeDoorTile (group6::BiomeGenerator)</li> <li>placeSpecialTiles (group6::BiomeGenerator)</li> <li>placeTileRandom (group6::BiomeGenerator)</li> <li>placeTrees (group6::BiomeGenerator)</li> <li>ProgramExecutor (worldlang::ProgramExecutor)</li> <li>popArgs (worldlang::ProgramExecutor)</li> <li>popStack (worldlang::ProgramExecutor)</li> <li>pushStack (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#r","title":"r","text":"<ul> <li>RemoveMove (cse491_team8::ManualWorld)</li> <li>Run (cse491_team8::ManualWorld, group4::SecondWorld)</li> <li>RunAgents (cse491_team8::ManualWorld)</li> <li>rock_id (cse491_team8::ManualWorld)</li> <li>reseed (siv::BasicPerlinNoise)</li> <li>registerFunction (worldlang::ProgramExecutor)</li> <li>run (worldlang::ProgramExecutor)</li> <li>runFile (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#s","title":"s","text":"<ul> <li>StatsAction (cse491_team8::ManualWorld)</li> <li>SaveToFile (group4::SecondWorld)</li> <li>SecondWorld (group4::SecondWorld)</li> <li>SwitchGrid (group4::SecondWorld)</li> <li>sand_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>saveToFile (group6::BiomeGenerator)</li> <li>seed (group6::BiomeGenerator)</li> <li>setTiles (group6::BiomeGenerator)</li> <li>setWorld (group6::BiomeGenerator)</li> <li>spike_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>SpikeTileHelper (group6::GenerativeWorld)</li> <li>seed_type (siv::BasicPerlinNoise)</li> <li>serialize (siv::BasicPerlinNoise)</li> <li>state_type (siv::BasicPerlinNoise)</li> <li>scripts (worldlang::ProgramExecutor)</li> <li>setVariable (worldlang::ProgramExecutor)</li> <li>skipBlock (worldlang::ProgramExecutor)</li> <li>stack (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#t","title":"t","text":"<ul> <li>tree_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>tar_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>tiles (group6::BiomeGenerator)</li> <li>TarTileHelper (group6::GenerativeWorld)</li> <li>TeleporterHelper (group6::GenerativeWorld)</li> <li>teleporter_id (group6::GenerativeWorld)</li> <li>Type (worldlang::Unit)</li> <li>type (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#u","title":"u","text":"<ul> <li>UpdateWorld (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#v","title":"v","text":"<ul> <li>value_type (siv::BasicPerlinNoise)</li> <li>Value (worldlang::ProgramExecutor)</li> <li>var (worldlang::ProgramExecutor)</li> <li>variables (worldlang::ProgramExecutor)</li> <li>value (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#w","title":"w","text":"<ul> <li>wall_id (cse491::MazeWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>water_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>world_filename (group4::SecondWorld)</li> <li>width (group6::BiomeGenerator)</li> <li>worldPtr (group6::BiomeGenerator)</li> <li>world_height (group6::GenerativeWorld)</li> <li>world_width (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#_1","title":"~","text":"<ul> <li>~MazeWorld (cse491::MazeWorld)</li> <li>~ManualWorld (cse491_team8::ManualWorld)</li> <li>~SecondWorld (group4::SecondWorld)</li> <li>~BiomeGenerator (group6::BiomeGenerator)</li> <li>~GenerativeWorld (group6::GenerativeWorld)</li> <li>~ProgramExecutor (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#a","title":"a","text":"<ul> <li>AddMove (cse491_team8::ManualWorld)</li> <li>applyPathToGrid (group6::BiomeGenerator)</li> <li>AStarAgentHelper (group6::GenerativeWorld)</li> <li>AddArmory (group6::GenerativeWorld)</li> <li>AddTeleporters (group6::GenerativeWorld)</li> <li>AgentCollisionHelper (group6::GenerativeWorld)</li> <li>ArmoryTileHelper (group6::GenerativeWorld)</li> <li>as (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#b","title":"b","text":"<ul> <li>BiomeGenerator (group6::BiomeGenerator)</li> <li>BasicPerlinNoise (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#c","title":"c","text":"<ul> <li>ConfigAgent (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>CheckPosition (group4::SecondWorld)</li> <li>clearPath (group6::BiomeGenerator)</li> <li>CreateGrid (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#d","title":"d","text":"<ul> <li>DoAction (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>DoActionAttemptItemPickup (cse491_team8::ManualWorld)</li> <li>DoActionFindNewPosition (cse491_team8::ManualWorld)</li> <li>DoActionTestNewPositionTree (cse491_team8::ManualWorld)</li> <li>DoActionTestNewPositionWater (cse491_team8::ManualWorld)</li> <li>DoBattle (cse491_team8::ManualWorld)</li> <li>DropItems (cse491_team8::ManualWorld)</li> <li>DropItem (group4::SecondWorld)</li> <li>DamageAgent (group6::GenerativeWorld)</li> <li>DoorTileHelper (group6::GenerativeWorld)</li> <li>deserialize (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#e","title":"e","text":"<ul> <li>EndGame (group6::GenerativeWorld)</li> <li>error (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#f","title":"f","text":"<ul> <li>FindItem (cse491_team8::ManualWorld)</li> <li>FindTiles (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#g","title":"g","text":"<ul> <li>GenerateMoveSets (cse491_team8::ManualWorld)</li> <li>generate (group6::BiomeGenerator)</li> <li>getBiome (group6::BiomeGenerator)</li> <li>getSeed (group6::BiomeGenerator)</li> <li>GenerativeWorld (group6::GenerativeWorld)</li> <li>getErrorMessage (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#h","title":"h","text":"<ul> <li>HealAction (cse491_team8::ManualWorld)</li> <li>HoleTileHelper (group6::GenerativeWorld)</li> <li>has (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#i","title":"i","text":"<ul> <li>IsTraversable (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>ItemHelper (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#k","title":"k","text":"<ul> <li>KeyTileHelper (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#l","title":"l","text":"<ul> <li>LookAhead (cse491_team8::ManualWorld)</li> <li>LoadFromFile (group4::SecondWorld)</li> <li>LoadWorldScript (group4::SecondWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#m","title":"m","text":"<ul> <li>MazeWorld (cse491::MazeWorld)</li> <li>ManualWorld (cse491_team8::ManualWorld)</li> <li>MoveSetAction (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#n","title":"n","text":"<ul> <li>noise1D (siv::BasicPerlinNoise)</li> <li>noise1D_01 (siv::BasicPerlinNoise)</li> <li>noise2D (siv::BasicPerlinNoise)</li> <li>noise2D_01 (siv::BasicPerlinNoise)</li> <li>noise3D (siv::BasicPerlinNoise)</li> <li>noise3D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave1D (siv::BasicPerlinNoise)</li> <li>normalizedOctave1D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave2D (siv::BasicPerlinNoise)</li> <li>normalizedOctave2D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave3D (siv::BasicPerlinNoise)</li> <li>normalizedOctave3D_01 (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#o","title":"o","text":"<ul> <li>OtherAction (cse491_team8::ManualWorld)</li> <li>oceanHandler (group6::BiomeGenerator)</li> <li>octave1D (siv::BasicPerlinNoise)</li> <li>octave1D_01 (siv::BasicPerlinNoise)</li> <li>octave1D_11 (siv::BasicPerlinNoise)</li> <li>octave2D (siv::BasicPerlinNoise)</li> <li>octave2D_01 (siv::BasicPerlinNoise)</li> <li>octave2D_11 (siv::BasicPerlinNoise)</li> <li>octave3D (siv::BasicPerlinNoise)</li> <li>octave3D_01 (siv::BasicPerlinNoise)</li> <li>octave3D_11 (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#p","title":"p","text":"<ul> <li>PrintEntities (group4::SecondWorld)</li> <li>placeDoorTile (group6::BiomeGenerator)</li> <li>placeSpecialTiles (group6::BiomeGenerator)</li> <li>placeTileRandom (group6::BiomeGenerator)</li> <li>placeTrees (group6::BiomeGenerator)</li> <li>ProgramExecutor (worldlang::ProgramExecutor)</li> <li>popArgs (worldlang::ProgramExecutor)</li> <li>popStack (worldlang::ProgramExecutor)</li> <li>pushStack (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#r","title":"r","text":"<ul> <li>RemoveMove (cse491_team8::ManualWorld)</li> <li>Run (cse491_team8::ManualWorld, group4::SecondWorld)</li> <li>RunAgents (cse491_team8::ManualWorld)</li> <li>reseed (siv::BasicPerlinNoise)</li> <li>registerFunction (worldlang::ProgramExecutor)</li> <li>run (worldlang::ProgramExecutor)</li> <li>runFile (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#s","title":"s","text":"<ul> <li>StatsAction (cse491_team8::ManualWorld)</li> <li>SaveToFile (group4::SecondWorld)</li> <li>SecondWorld (group4::SecondWorld)</li> <li>SwitchGrid (group4::SecondWorld)</li> <li>saveToFile (group6::BiomeGenerator)</li> <li>setTiles (group6::BiomeGenerator)</li> <li>setWorld (group6::BiomeGenerator)</li> <li>SpikeTileHelper (group6::GenerativeWorld)</li> <li>serialize (siv::BasicPerlinNoise)</li> <li>setVariable (worldlang::ProgramExecutor)</li> <li>skipBlock (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#t","title":"t","text":"<ul> <li>TarTileHelper (group6::GenerativeWorld)</li> <li>TeleporterHelper (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#u","title":"u","text":"<ul> <li>UpdateWorld (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#v","title":"v","text":"<ul> <li>var (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~MazeWorld (cse491::MazeWorld)</li> <li>~ManualWorld (cse491_team8::ManualWorld)</li> <li>~SecondWorld (group4::SecondWorld)</li> <li>~BiomeGenerator (group6::BiomeGenerator)</li> <li>~GenerativeWorld (group6::GenerativeWorld)</li> <li>~ProgramExecutor (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#a","title":"a","text":"<ul> <li>agents_filename (group4::SecondWorld)</li> <li>armory_id (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#b","title":"b","text":"<ul> <li>bridge_id (cse491_team8::ManualWorld)</li> <li>biome (group6::BiomeGenerator)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#c","title":"c","text":"<ul> <li>call_stack (worldlang::ProgramExecutor)</li> <li>code (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#d","title":"d","text":"<ul> <li>dirt_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>door_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#e","title":"e","text":"<ul> <li>error_message (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#f","title":"f","text":"<ul> <li>floor_id (cse491::MazeWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>frequency (group6::BiomeGenerator)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#g","title":"g","text":"<ul> <li>grass_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>grid (group6::BiomeGenerator)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#h","title":"h","text":"<ul> <li>height (group6::BiomeGenerator)</li> <li>hole_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#i","title":"i","text":"<ul> <li>inventory (group4::SecondWorld)</li> <li>index (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#k","title":"k","text":"<ul> <li>keyLocation (group6::BiomeGenerator)</li> <li>key_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#m","title":"m","text":"<ul> <li>m_permutation (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#p","title":"p","text":"<ul> <li>portal_id_a (cse491_team8::ManualWorld)</li> <li>portal_id_b (cse491_team8::ManualWorld)</li> <li>portal_id_c (cse491_team8::ManualWorld)</li> <li>portal_id_d (cse491_team8::ManualWorld)</li> <li>pe (group4::SecondWorld)</li> <li>perlinNoise (group6::BiomeGenerator)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#r","title":"r","text":"<ul> <li>rock_id (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#s","title":"s","text":"<ul> <li>sand_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>seed (group6::BiomeGenerator)</li> <li>spike_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>scripts (worldlang::ProgramExecutor)</li> <li>stack (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#t","title":"t","text":"<ul> <li>tree_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>tar_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>tiles (group6::BiomeGenerator)</li> <li>teleporter_id (group6::GenerativeWorld)</li> <li>type (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#v","title":"v","text":"<ul> <li>variables (worldlang::ProgramExecutor)</li> <li>value (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#w","title":"w","text":"<ul> <li>wall_id (cse491::MazeWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>water_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>world_filename (group4::SecondWorld)</li> <li>width (group6::BiomeGenerator)</li> <li>worldPtr (group6::BiomeGenerator)</li> <li>world_height (group6::GenerativeWorld)</li> <li>world_width (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/#c","title":"c","text":"<ul> <li>Callable (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/#d","title":"d","text":"<ul> <li>default_random_engine (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/#s","title":"s","text":"<ul> <li>seed_type (siv::BasicPerlinNoise)</li> <li>state_type (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (siv::BasicPerlinNoise)</li> <li>Value (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_enums/","title":"Class Member Enums","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_enums/#a","title":"a","text":"<ul> <li>ActionType (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_enums/#f","title":"f","text":"<ul> <li>FacingDirection (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_enums/#t","title":"t","text":"<ul> <li>Type (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/","title":"Namespace Members","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#b","title":"b","text":"<ul> <li>BiomeType (group6)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#c","title":"c","text":"<ul> <li>COMBAT_SCRIPT (group4)</li> <li>Clamp_11 (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#f","title":"f","text":"<ul> <li>FINAL_FLOOR_FILENAME (group4)</li> <li>FIRST_FLOOR_FILENAME (group4)</li> <li>Fade (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#g","title":"g","text":"<ul> <li>Grad (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#i","title":"i","text":"<ul> <li>ITEM_PICKUP_SCRIPT (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#l","title":"l","text":"<ul> <li>Lerp (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#m","title":"m","text":"<ul> <li>MAX_INVENTORY_SIZE (group4)</li> <li>MaxAmplitude (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#o","title":"o","text":"<ul> <li>OffGrid (group4)</li> <li>Octave1D (siv::perlin_detail)</li> <li>Octave2D (siv::perlin_detail)</li> <li>Octave3D (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#p","title":"p","text":"<ul> <li>PerlinNoise (siv)</li> <li>parse_to_code (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#r","title":"r","text":"<ul> <li>Random (siv::perlin_detail)</li> <li>RemapClamp_01 (siv::perlin_detail)</li> <li>Remap_01 (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#s","title":"s","text":"<ul> <li>SECOND_FLOOR_FILENAME (group4)</li> <li>Shuffle (siv::perlin_detail)</li> <li>selector (worldlang)</li> <li>stripWhitespace (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#w","title":"w","text":"<ul> <li>WORLD_LOAD_SCRIPT (group4)</li> <li>WORLD_LOAD_SCRIPT_2 (group4)</li> <li>WORLD_LOAD_SCRIPT_3 (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#c","title":"c","text":"<ul> <li>Clamp_11 (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#f","title":"f","text":"<ul> <li>Fade (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#g","title":"g","text":"<ul> <li>Grad (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#l","title":"l","text":"<ul> <li>Lerp (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#m","title":"m","text":"<ul> <li>MaxAmplitude (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#o","title":"o","text":"<ul> <li>Octave1D (siv::perlin_detail)</li> <li>Octave2D (siv::perlin_detail)</li> <li>Octave3D (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#p","title":"p","text":"<ul> <li>parse_to_code (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#r","title":"r","text":"<ul> <li>Random (siv::perlin_detail)</li> <li>RemapClamp_01 (siv::perlin_detail)</li> <li>Remap_01 (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#s","title":"s","text":"<ul> <li>Shuffle (siv::perlin_detail)</li> <li>stripWhitespace (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#c","title":"c","text":"<ul> <li>COMBAT_SCRIPT (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#f","title":"f","text":"<ul> <li>FINAL_FLOOR_FILENAME (group4)</li> <li>FIRST_FLOOR_FILENAME (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#i","title":"i","text":"<ul> <li>ITEM_PICKUP_SCRIPT (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_INVENTORY_SIZE (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#o","title":"o","text":"<ul> <li>OffGrid (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#s","title":"s","text":"<ul> <li>SECOND_FLOOR_FILENAME (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#w","title":"w","text":"<ul> <li>WORLD_LOAD_SCRIPT (group4)</li> <li>WORLD_LOAD_SCRIPT_2 (group4)</li> <li>WORLD_LOAD_SCRIPT_3 (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>PerlinNoise (siv)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>selector (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_enums/#b","title":"b","text":"<ul> <li>BiomeType (group6)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/macros/","title":"Macros","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/macros/#s","title":"s","text":"<ul> <li>SIVPERLIN_CONCEPT_URBG (PerlinNoise.hpp)</li> <li>SIVPERLIN_CONCEPT_URBG_ (PerlinNoise.hpp)</li> <li>SIVPERLIN_DEFAULT_Y (PerlinNoise.hpp)</li> <li>SIVPERLIN_DEFAULT_Z (PerlinNoise.hpp)</li> <li>SIVPERLIN_NODISCARD_CXX20 (PerlinNoise.hpp)</li> <li>SIVPERLIN_VERSION (PerlinNoise.hpp)</li> <li>SIVPERLIN_VERSION_MAJOR (PerlinNoise.hpp)</li> <li>SIVPERLIN_VERSION_MINOR (PerlinNoise.hpp)</li> <li>SIVPERLIN_VERSION_REVISION (PerlinNoise.hpp)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}