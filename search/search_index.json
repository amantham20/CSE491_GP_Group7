{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CSE 491 Capstone Project Fall 2023","text":""},{"location":"DataCollection/","title":"Group 2 Data Collection","text":""},{"location":"DataCollection/#datacollection-namespace","title":"DataCollection Namespace","text":"<p>The DataCollection namespace provides a set of classes and templates for managing and processing data related to agent actions and positions. This library offers flexibility and ease of use for storing, retrieving, and manipulating data within your C++ applications.</p>"},{"location":"DataCollection/#classes","title":"Classes","text":"<ol> <li>AgentData</li> </ol> <p>The <code>AgentData</code> class represents data collected for an agent, including their name, actions, positions, and associated IDs.</p> <p>Methods:    - <code>StorePositions(cse491::GridPosition pos)</code>: Stores a grid position for the agent.    - <code>StoreAction(std::unordered_map&lt;std::string, size_t&gt; action)</code>: Stores an action for the agent.    - <code>StoreAgentId(int id)</code>: Stores an agent ID associated with an action.    - <code>GetActions() -&gt; std::vector&lt;std::unordered_map&lt;std::string, size_t&gt;&gt;&amp;</code>: Retrieves the stored actions.    - <code>SetActions(const std::vector&lt;std::unordered_map&lt;std::string, size_t&gt;&gt;&amp; newActions)</code>: Sets the stored actions to a new set of actions.    - <code>GetPositionSize() const -&gt; int</code>: Gets the size of the stored grid positions.    - <code>GetAgentIds() const -&gt; std::vector&lt;int&gt;</code>: Gets the agent IDs associated with the stored actions.</p> <ol> <li>DataReceiver\\&lt;T&gt;</li> </ol> <p>The <code>DataReceiver</code> class template provides a generic way to store and retrieve data objects of a specified type.</p> <p>Methods:    - <code>StoreData(T obj)</code>: Stores a data object of type T.    - <code>getStorage() -&gt; std::vector&lt;T&gt;&amp;</code>: Retrieves the stored data objects.</p> <ol> <li>AgentReceiver</li> </ol> <p>The <code>AgentReceiver</code> class extends <code>DataReceiver&lt;AgentData&gt;</code> and provides specific functionality for storing <code>AgentData</code> objects along with grid positions and last action IDs.</p> <p>Methods:    - <code>StoreData(cse491::GridPosition pos, int last_action)</code>: Stores a grid position and last action ID associated with an agent.    - <code>GetPositionSize() -&gt; int</code>: Gets the position size of the last stored <code>AgentData</code> object.    - <code>IsEmpty() -&gt; bool</code>: Checks if the storage is empty.</p>"},{"location":"DataCollection/#usage","title":"Usage","text":"<p>To use the DataCollection namespace in your C++ application, include the appropriate header files and create instances of the classes as needed. Make sure to follow the specific methods and their parameters as outlined in the class descriptions above.</p> <pre><code>#include &lt;DataCollection/AgentData.h&gt;\n#include &lt;DataCollection/DataReceiver.h&gt;\n#include &lt;DataCollection/AgentReceiver.h&gt;\n\n// Example Usage\nDataCollection::AgentData agent;\nagent.StorePositions(cse491::GridPosition(1, 2));\nagent.StoreAction({{\"up\", 1}});\nagent.StoreAgentId(101);\n\nDataCollection::AgentReceiver agentReceiver;\nagentReceiver.StoreData(cse491::GridPosition(3, 4), 102);\nint positionSize = agentReceiver.GetPositionSize();\nbool isEmpty = agentReceiver.IsEmpty();\n</code></pre>"},{"location":"DataCollection/#installation","title":"Installation","text":"<p>To use this library, simply include the necessary header files in your project. Ensure that you have C++11 or later enabled in your compiler settings.</p>"},{"location":"DataCollection/#contributing","title":"Contributing","text":"<p>Feel free to contribute by reporting issues, suggesting features, or submitting pull requests. We welcome any contributions that can improve the functionality, performance, or usability of this library.</p>"},{"location":"DataCollection/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE.md file for details.</p>"},{"location":"Group%201%20-%20README/","title":"Group 1: Agent Library Function Descriptions","text":"<p>Below is a set of classes and functions designed to create multiple different Agents with various functionalities.</p> <p>Path Agent </p> <p>Agent that has a user-defined custom movement pattern passed a sequence to be sequentially applied as the agent is updated</p> <ul> <li> <p>Constructor with <code>std::vector</code></p> <ul> <li>param <code>id</code>: unique agent id</li> <li>param <code>name</code>: name of path agent</li> <li>param <code>offsets</code>: collection of offsets to move the agent <code>PathAgent(size_t id, std::string const&amp; name, std::vector&lt;cse491::GridPosition&gt; &amp;&amp; offsets = {}) : cse491::AgentBase(id, name), offsets_(offsets);</code></li> </ul> </li> <li> <p>Constructor with <code>std::string</code></p> <ul> <li>param <code>id</code>: unique agent id</li> <li>param <code>name</code>: name of path agent</li> <li>param <code>commands</code>: sequence of commands to be interpreted as offsets <code>PathAgent::PathAgent(size_t id, std::string const&amp; name, std::string_view commands) : cse491::AgentBase(id, name), offsets_(str_to_offsets(commands))</code></li> </ul> </li> <li> <p>Initializer</p> <ul> <li>Checks that the agent is able to freely change its own grid location.         Verifies that it can currently index into a valid offset</li> <li>return: <code>true</code> if so; <code>false</code> otherwise. <code>bool PathAgent::Initialize();</code></li> </ul> </li> <li> <p>Select Action</p> <ul> <li>Moves the agent by applying the current offset</li> <li>param <code>WorldGrid</code>: reference grid</li> <li>param <code>type_options_t</code>: type options</li> <li>param <code>item_set_t</code>: set of items</li> <li>param <code>agent_set_t</code>: agent set <code>size_t PathAgent::SelectAction(const WorldGrid &amp; /* grid*/, const type_options_t &amp; /* type_options*/, const item_set_t &amp; /* item_set*/, const agent_set_t &amp; /* agent_set*/)</code></li> </ul> </li> <li> <p>Set Properties with <code>std::vector</code></p> <ul> <li>Assigns the offsets_member to a new series of offsets</li> <li>param <code>offsets</code>: collection of grid positions used as the new offsets</li> <li>param <code>start_index = 0</code>: which offset to start indexing into (beginning by default)</li> <li>return: <code>self</code></li> <li>Attention: throws an <code>std::invalid_argument</code> when an invalid start index is provided <code>PathAgent&amp; PathAgent::SetProperties(std::vector&lt;cse491::GridPosition&gt; &amp;&amp; offsets, size_t start_index = 0)</code></li> </ul> </li> <li> <p>Set properties with <code>std::string</code></p> <ul> <li>Assigns the offsets_ member to a new series of offsets, taking a command string</li> <li>param <code>commands</code>: formatted string of commands used as offsets</li> <li>param <code>start_index = 0</code>: which command to begin indexing into (first command by default)</li> <li>return: <code>self</code></li> <li>Attention: throws an <code>std::invalid_argument</code> when mis-formatted commands an invalid index is provided <code>PathAgent&amp; PathAgent::SetProperties(std::string_view commands, size_t start_index = 0)</code></li> </ul> </li> <li> <p>Helper function for a formatted <code>std::string</code> input</p> <ul> <li>Converts a string to a sequence of offsets</li> <li>This convenience method takes a string with a special formatting that allows one to specify a sequence of inputs in linear directions.</li> <li>The format is [steps[*]] where <code>steps</code> is a positive integer and optional (assumed to be 1 by default) <li>star <code>*</code> represents scaling the movement by <code>steps</code>. Optional, but cannot be used if <code>steps</code> is not provided<ul> <li>if the star is not present, then <code>steps</code> individual offsets are created in the direction <code>direction</code></li> </ul> </li> <li>Example: \"n w 3e 10s 5w x\" should create the sequence of offsets<ul> <li><code>{-1, 0}, {0, 1}, {0, -1}, {0, -1}, {0, -1}, {10, 0}, {0, 5}, {0, 0}</code></li> </ul> </li> <li>param <code>commands</code>: string in a format of sequential directions</li> <li>note: throws an <code>std::invalid_argument</code> when input string is poorly formatted</li> <li>note: this includes when a negative integer is passed as <code>steps</code>. If a zero is used, treated as the default (one)</li> <p><code>static std::vector&lt;cse491::GridPosition&gt; str_to_offsets(std::string_view commands)</code></p> <p>More agents to be documented...</p>"},{"location":"Group_7/","title":"Group 7 : Genetic Programming Agents","text":"<p>authors: Aman, Simon, Rajmeet, Jason</p> <p></p> <p>(Img: Rajmeet, Simon, Jason, Aman) </p>"},{"location":"Group_7/#introduction","title":"Introduction","text":""},{"location":"Group_7/#gp-agent-base-class","title":"GP Agent Base Class","text":""},{"location":"Group_7/#lgp-agent","title":"LGP Agent","text":""},{"location":"Group_7/#cgp-agent","title":"CGP Agent","text":""},{"location":"Group_7/#gp-loop","title":"GP Loop","text":""},{"location":"Group_7/#it-runs-on-my-machine","title":"It runs on my machine","text":"<p>we have used cmake to ensure that our code compiles on all platforms. but.... we have tested our code on the following machines/architectures: - Windows 11 - Windows 10 - Ubuntu 20.04 - HPCC Cluster Centos7 - MacOS Sonoma (ARM) - mlcollard/linux-dev (Docker Container)</p> <p>Tested in the following IDEs: - CLion - VSCode</p> <p>Tested on the following compilers: - gcc 9.3.0 - Apple clang 12.0.0 - LLVM clang 11.0.0</p>"},{"location":"Group_7/#profiled-with-and-optimized-with","title":"Profiled with and optimized with:","text":"<ul> <li> <p>clion profiler / </p> </li> <li> <p>Xcode instruments  </p> </li> <li> <p>intel vtune  </p> </li> <li> <p>very sleepy Didnt deserve a screenshot. /s</p> </li> <li> <p>code coverage in clion   </p> </li> </ul>"},{"location":"Group_7/#sanitized-with","title":"Sanitized with:","text":"<ul> <li>clang sanitizer Memory</li> <li>valgrind</li> <li>gcc sanitizer Memory</li> <li>gcc sanitizer address</li> <li>Used to find and fix memory UB in the code.   </li> </ul>"},{"location":"Group_7/#other-contributions","title":"Other Contributions","text":""},{"location":"Group_7/#easylogging","title":"EasyLogging","text":"<p>Created a logging class that is can be used to log debug messages in debug mode. Teams can be specified to log with different levels of verbosity. This is useful for debugging and profiling.</p>"},{"location":"Group_7/#cmake","title":"CMake","text":"<p>Initial cmake setup for the project. This is useful for cross platform compilation and testing.</p>"},{"location":"Group_7/#serializationusingtinyxml2","title":"serializationUsingTinyXML2","text":"<p>Created and tested a serialization class that can be used to serialize and deserialize objects to and from xml files. This is useful for saving and loading the state of the GP agents. Implemented serialization pattern using tinyxml2 library.</p>"},{"location":"Group_7/#mkdocs-documentation","title":"mkdocs documentation","text":"<p>Created and tested a mkdocs documentation for the project. This is useful for creating a website for the project.</p>"},{"location":"HowToAssembleAMain/","title":"How to Assemble a Main","text":"<p>Once you have your Agents, World, and Interface picked out, it's easy to assemble them into an <code>main()</code> function that you can turn into a working executable.</p> <p>Create the appropriate .cpp file, and follow these steps:</p> <ol> <li>Include all of the modules that you will be using.  In the case of <code>simple_main.cpp</code> this looks like:</li> </ol> <pre><code>#include \"Agents/PacingAgent.hpp\"\n#include \"Interfaces/TrashInterface.hpp\"\n#include \"Worlds/MazeWorld.hpp\"\n</code></pre> <ol> <li>Inside your <code>main()</code> function, start by building your world.  It should look something like:</li> </ol> <pre><code>main() {\n  cse491::MazeWorld world;\n</code></pre> <p>Some world types may be able to take arguments to their constructors, but most probably won't.</p> <ol> <li>Add in your agents using the <code>AddAgent</code> member function, specifying the type of agent with a template argument and the agent's name as a regular argument.  <code>AddAgent</code> will return a reference to the new agent, so you can immediately modify it, such as by setting its position.</li> </ol> <pre><code>  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 1\").SetPosition(3,1);\n  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 2\").SetPosition(6,1);\n</code></pre> <p>Furthermore, AddAgent can take additional parameters to set properties BEFORE configuration is run. For example, if you want to set stats for strength and speed, you could do something like:</p> <pre><code>  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 1\", \"strength\", 1.0, \"speed\", 5.5).SetPosition(3,1);\n  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 2\", \"strength\", 8.6, \"speed\", 1.2).SetPosition(6,1);\n</code></pre> <p>This will allow you to change what you do in agent configuration based on the properties provided.</p> <ol> <li>Add in your interface as a type of agent.  For example:</li> </ol> <pre><code>  world.AddAgent&lt;cse491::TrashInterface&gt;(\"Interface\").SetProperty(\"char\", '@');\n</code></pre> <p>This will set up any \"player\" characters.</p> <ol> <li>Launch the run using <code>world.Run();</code>.</li> </ol>"},{"location":"HowToAssembleAMain/#what-if-i-want-to-collect-extra-data-for-analysis","title":"What if I want to collect extra data for analysis?","text":"<p>If you want to track the agents and the world during a run, you will skip step 5 above and instead manually run the agents and update the world, collecting data as you go.</p> <p>For example, in place of <code>world.Run();</code> you could have:</p> <pre><code>  while (!world.GetRunOver()) {\n    world.RunAgents();\n    world.UpdateWorld();\n    // Collect extra data about the world here!\n  }\n</code></pre> <p>You should have access to all of the basic data in the world; we may need to expand the API to provide access if you don't have everything you need.</p>"},{"location":"HowToAssembleAMain/#compiling-a-main","title":"Compiling a main","text":"<p>By default, any <code>.cpp</code> files in <code>/source/</code> (not in subdirectories) should be automatically detected and compiled with CMake (see <code>HowToCompile.md</code>).</p> <p>If your main requires other source files (i.e., other <code>.cpp</code> files), you will also need to make a <code>.cmake</code> file.  For example, <code>example.cpp</code> would need a <code>example.cmake</code> file. </p> <p>This <code>.cmake</code> file will give you fine-grained control over the compilation process of your main file. To add extra source files, simply add new lines like so: </p> <pre><code>add_source_to_target(${EXE_NAME} \"source/Agents/PathAgent.cpp\")\n</code></pre> <p>The <code>${EXE_NAME}</code> argument should NOT change, as it is a variable from the other CMake infrastructure.  You will, however, need to update the other argument, which a string to the other source file you want to compile and link against. You will need one copy of this line for each source file you need to include. </p>"},{"location":"HowToBuildAWorld/","title":"How to Build A World","text":"<p>When building your own world, the first steps are boilerplate:</p> <ol> <li> <p>Include the WorldBase file If you're in the Worlds/ directory, do this with: <code>#include \"../core/WorldBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your world class, making sure to derive it from <code>WorldBase</code>.  Something like <code>class MYWorld : public WorldBase {</code>, but of course use your world name instead of \"MYWorld\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member variables that your world might use.  Additionally, you need to set up some internal functionality.  Specifically:</p> <ol> <li> <p>Create a enumeration where you will list all of the action types available to an agent.  The first action should always be a \"do nothing\" action and explicitly set to zero.  For example: <code>enum ActionType { REMAIN_STILL=0, MOVE_UP, MOVE_DOWN, MOVE_LEFT, MOVE_RIGHT };</code></p> </li> <li> <p>Add a <code>ConfigAgent</code> function that provides a new agent with a list of the actions that it has available.  For example:</p> </li> </ol> <pre><code>    /// Provide the agent with movement actions.\n    void ConfigAgent(AgentBase &amp; agent) override {\n      agent.AddAction(\"up\", MOVE_UP);\n      agent.AddAction(\"down\", MOVE_DOWN);\n      agent.AddAction(\"left\", MOVE_LEFT);\n      agent.AddAction(\"right\", MOVE_RIGHT);\n    }\n</code></pre> <p>In the public section of the class, you need to build a few more functions:</p> <ol> <li>A default constructor (i.e., <code>MYWorld() { ... }</code>).  You should do any normal set up for this world, including the member variables that you created above.  You should also specify the type options and initialize the <code>main_grid</code> for this world.</li> <li>Specify the type options with the <code>AddCellType</code> function, which is defined in the base class.     <code>AddCellType(\"dirt\", \"Regular ground\", ' ');     AddCellType(\"tree\", \"A tall tree\", '^');     AddCellType(\"river\", \"Flowing water\", '~');</code></li> <li> <p>An easy way to initialize the <code>main_grid</code> is to use the <code>Read()</code> member function on <code>WorldGrid</code> to load the grid from a file.  For example: <code>main_grid.Read(\"../assets/grids/MYWorld.grid\", type_options);</code></p> </li> <li> <p>Add a destructor (i.e., <code>~MYWorld() { ... }</code>).  This function only needs to have a body if you need to clean up one of the member variables you added.</p> </li> <li> <p>Build <code>int DoAction(AgentBase &amp; agent, size_t action_id) override { ... }</code> for your new world.  This function will be run automatically whenever an agent takes an action, specifying both the agent and action involved.</p> </li> </ol> <p>Finally you need to build a main file that initializes this world, add any needed agents (either autonomous agents or interfaces), and run.</p>"},{"location":"HowToBuildAWorld/#member-variables-inherited-from-worldbase","title":"Member variables inherited from <code>WorldBase</code>","text":"<p><code>WorldBase</code> has a lot of boilerplate functionality though almost all of it can be replaced in a derived world.</p> <p>There are five member variables maintained in the world: - <code>WorldGrid main_grid</code> - the \"main\" world that is passed to agents by default.  You may maintain additional grids if you choose, and may decide which one of these is seen by an agent. - <code>type_options_t type_options</code> - a vector of <code>CellType</code> information, which specifies the name of each cell, its description, and an (optional) ASCII symbol associated with it.  The position in this vector it he ID of a cell type. - <code>item_set_t item_set</code> - a vector of pointers to all of the \"items\" in this world.  The world can define and use items however it likes, though they should be type <code>cse491::Entity</code>.  Like agents, items can have arbitrary properties. - <code>agent_set_t agent_set</code> - a vector of all agents currently active in the world. - <code>bool run_over</code> - a value that defaults to false, but if you change it to true the run will terminate at the end of the current iteration.</p>"},{"location":"HowToBuildAWorld/#working-with-properties","title":"Working with properties","text":"<p>Agents can have arbitrarily named properties; worlds can add properties to the agents, and modify the (<code>double</code>) value associated with that property at any time.</p> <p>To add a property, simply give it a value, such as <code>agent.SetProperty(\"property_name\", value)</code> where <code>value</code> is a floating point number (it will default to 0.0 if you don't include it.)  This might be a good way to add \"hit points\" or \"size\" to agents.  You can alter what happens to an agent based on these properties; if an agent's hit points reach zero, you might kill it off.</p> <p>You can always set properties to new values later, or use <code>agent.HasProperty(\"property_name\")</code> to test if an agent has a property or <code>agent.GetProperty(\"property_name\")</code> to read its value.</p> <p>If at any point you want to remove a property, you can do so with <code>agent.RemoveProperty(\"property_name\")</code>.  For example, you might have a property called \"invisible\" that you add to an agent when it vanishes, but you remove when it reappears.</p> <p>For properties that you want agents to always possess, it's probably a good idea to set them in the <code>ConfigAgent()</code> function.</p>"},{"location":"HowToBuildAWorld/#providing-limited-data-to-agents","title":"Providing limited data to agents","text":"<p>Some worlds will want to provide agents with limited data, perhaps only showing rooms that the agent is currently in or items/agents nearby. To do this, the world will be responsible for producing or maintaining the alternate data structures and those are the ones that should be passed to agents when they are called.</p> <p>The default version of the function <code>WorldBase::RunAgents()</code> will use the full information provided in the world, but this is a virtual function.  If you override it in your derived class, you simply need to step through all of the agents and run <code>SelectAction</code> on each with the revised arguments.  (Of course, after each action is selected, make sure to also run <code>DoAction</code> and <code>SetActionResult</code> for each, as per the base class.)</p>"},{"location":"HowToBuildAWorld/#managing-non-agent-activities-in-the-world","title":"Managing non-agent activities in the world","text":"<p>In some worlds, you may want events happening in the background, independent of agents.  For example, crops might grow, seasons might change, or weather might occur. To manage these non-agent events, you simply need to override <code>UpdateWorld()</code> in your derived class.  Every time each agent is run (in the <code>Run()</code> function) UpdateWorld() is then called.  If you need a different balance for <code>UpdateWorld()</code> (perhaps you need it to go after every agent) simply override the Run() function in your derived World class.</p>"},{"location":"HowToBuildAnAgent/","title":"How to Build an Autonomous Agent","text":"<p>When building your own agent, the first steps are boilerplate:</p> <ol> <li> <p>Include the AgentBase file If you're in the Agents/ directory, do this with: <code>#include \"../core/AgentBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your agent class, making sure to derive it from <code>AgentBase</code>.  Something like <code>class MYAgent : public AgentBase {</code>, but of course use your agent name instead of \"MYAgent\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member variables that your agent might use.  Remember that you also have the option of using agent properties (see below) instead of private variables if you want the values to be accessible to other modules.</p> <p>In the public section, you should create:</p> <ol> <li> <p>A constructor and destructor, as needed for your implementation (agents are not required to have any specific code here.)</p> </li> <li> <p>An Initialize function that gets run after the agent has been configured by the world.  This will allow an agent to set itself up based on the actions that were provided by the world.  This function has the format <code>bool Initialize() override {...}</code> and should return <code>false</code> if it detected a problem during initialization (such as a required action name is not available).</p> </li> <li> <p>A <code>SelectAction</code> function that identifies the action that the organism will take. The format for <code>SelectionAction</code> is:</p> </li> </ol> <pre><code>    size_t SelectAction(const WorldGrid &amp; grid,\n                        const type_options_t &amp; type_options,\n                        const item_set_t &amp; item_set,\n                        const agent_set_t &amp; agent_set) override\n    {\n      // An agent should use their current state as well as the provided\n      // grid, type_options, item_set, and agent set to decide next action.\n    }\n</code></pre> <p>The arguments passed in to <code>SelectAction</code> will be the full set of possibilities by default (i.e., the full grid, all type options, all items, and all agents), but some worlds may choose to maintain more limited versions of these variables containing only what an organism currently knows about.  In such cases it would be these more limited version that would be passed in to the function.</p> <p>As part of their current state, agents have two relevant member variables inherited from their base class.  (1) A map of strings to action IDs called <code>action_map</code>, that indicates which value to return to take an action by a given name, and (2) an <code>int</code> called <code>action_result</code> that indicates the results of their last action.  Usually <code>action_result</code> will be 1 or 0 to indicate success or failure of that action.</p>"},{"location":"HowToBuildAnAgent/#agent-properties","title":"Agent Properties","text":"<p>While properties are typically added to agents from a World, they are technically allowed to add properties to themselves, typically in their own constructor.  These properties might be ones that affect the behavior of the agents, but should also be accessible from outside of the Agent class itself.</p> <p>For example, you might want to put <code>double facing = 1.0;</code> inside the private section if facing should only ever be used by this class.  Alternatively you can put <code>SetProperty(\"facing\", 1.0);</code> in the constructor if you want it accessible to the world.  Any other class would be able to run <code>agent.HasProperty(\"facing\")</code> to determine if the property exists in <code>agent</code>, or <code>agent.GetProperty(\"facing\")</code> to retrieve its value.</p>"},{"location":"HowToBuildAnInterface/","title":"How to Build an Interface","text":"<p>When building your own interface, the first steps are boilerplate:</p> <ol> <li> <p>Include the InterfaceBase file If you're in the Interfaces/ directory, do this with: <code>#include \"../core/InterfaceBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your Interface class, making sure to derive it from <code>InterfaceBase</code>.  Something like <code>class MYInterface : public InterfaceBase {</code>, but of course use your Interface name instead of \"MYInterface\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member functions or variables that your interface might use.  I recommend a series of helper functions, such as a <code>DrawGrid</code> function to display the current state of the world.</p> <p>In the public section, you should create:</p> <ol> <li> <p>A constructor and destructor, as needed for your implementation.  Interfaces will likely need to do substantial setup in the constructor and teardown in the destructor.</p> </li> <li> <p>Add an Initialize function. This gets run after the interface has been configured by the world, thus you will have access to all of the available actions in order to map them to buttons or other inputs.  This function has the format <code>bool Initialize() override {...}</code> and should return <code>true</code> as long as everything initialized correctly (false otherwise).</p> </li> <li> <p>A <code>SelectAction</code> function that presents to the user the current state of the world and then reports back the next action for the user's agent should take. The format for <code>SelectionAction</code> is:</p> </li> </ol> <pre><code>    size_t SelectAction(const WorldGrid &amp; grid,\n                        const type_options_t &amp; type_options,\n                        const item_set_t &amp; item_set,\n                        const agent_set_t &amp; agent_set) override\n    {\n      // An interface should keep track of the user's actions and report them\n      // back.  If the system is not supposed to wait for the user (i.e., real\n      // time) then return a zero any time the user has not selected an action.\n    }\n</code></pre> <p>The arguments passed in to <code>SelectAction</code> will be the full set of possibilities by default (i.e., the full grid, all type options, all items, and all agents), but some worlds may choose to maintain more limited versions of these variables containing only what an organism currently knows about.  In such cases it would be these more limited version that would be passed in to the function.</p> <p>As part of their current state, agents have two relevant member variables inherited from their base class.  (1) A map of strings to action IDs called <code>action_map</code>, that indicates which value to return to take an action by a given name, and (2) an <code>int</code> called <code>action_result</code> that indicates the results of their last action.  Usually <code>action_result</code> will be 1 or 0 to indicate success or failure of that action.</p>"},{"location":"HowToCompile/","title":"How to Compile","text":"<p>First you'll need to clone the repo with submodules. </p> <p>If you haven't yet cloned the repo, run: </p> <pre><code>git clone https://github.com/MSU-CSE491/cse_491_fall_2023.git --recursive\n</code></pre> <p>If you have already cloned the repo, but you need to download the submodules, run the following inside the repo's directory:</p> <pre><code>git submodule init\ngit submodule update\n</code></pre> <p>Now jump to the section for your operating system.</p>"},{"location":"HowToCompile/#compiling-under-linux","title":"Compiling under Linux","text":"<p>If you're on a Linux machine, you first need to download some dependencies for SFML.  Specifically, you need:  - freetype - x11 - xrandr - udev - opengl - flac - ogg - vorbis - vorbisenc - vorbisfile - openal - pthread</p> <p>If you're on Ubuntu or other similar Debian distro, you can run the following: </p> <pre><code>sudo apt install libX-dev\n</code></pre> <p>For library X. </p> <p>Once you have all dependencies downloaded, navigate to the root of the repo and run the following to build: </p> <pre><code>mkdir cmake-build-release\ncd cmake-build-release\ncmake -DCMAKE_BUILD_TYPE=Release ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory.  Note that <code>Debug</code> can be swapped with <code>Release</code> or <code>Test</code> here.</p>"},{"location":"HowToCompile/#compiling-under-macos","title":"Compiling under MacOS","text":"<p>Mac shouldn't require any additional dependencies, so simply run the following, starting at the root of the repo:</p> <pre><code>mkdir cmake-build-release\ncd cmake-build-release\ncmake -DCMAKE_BUILD_TYPE=Release ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory. </p>"},{"location":"HowToCompile/#compiling-under-windows-with-mingw","title":"Compiling under Windows with MinGW","text":"<p>After you have the repo and submodules downloaded, we need to ensure you have MinGW and CMake. In a command line window, try running <code>g++</code> and <code>cmake</code>, if either give a \"command not found\" message, then we need to install them. </p> <p>MinGW gives us g++, and can be downloaded here: https://winlibs.com/</p> <p>CMake can be downloaded from here: https://cmake.org/download/</p> <p>Note: You'll likely need to add both MinGW's and CMake's <code>bin</code> folder to your path (I think CMake has a <code>bin</code> directory, otherwise add whatever directory contains the executable).  To add a directory to your path, follow these instructions: https://www.architectryan.com/2018/03/17/add-to-the-path-on-windows-10/ Note that you may run into issues if the directories you're adding have spaces in their paths (e.g., \"C:\\Program Files...\" was giving me issues). If you run into this, I'd recommend creating a new directory on your <code>C:\\</code> drive, like <code>C:\\bin\\</code> and then add CMake and MinGW as subdirectories there. </p> <p>Once you have CMake and MinGW working in your terminal (note you'll have to restart cmd/VSCode/whatever to get the path changes to take effect), run the following from the root of your repo:</p> <pre><code>mkdir build-build-release\ncd build-build-release\ncmake -DCMAKE_BUILD_TYPE=Release -G \"MinGW Makefiles\" ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory. </p> <p>Note that if you tried to build using CMake before, it likely tried to use MSVC as a compiler. If so, just wipe the build folder and start fresh. </p>"},{"location":"HowToCompile/#how-to-compile-in-debug-mode","title":"How to compile in debug mode","text":"<p>First, it is recommended you build debug and release modes in separate directories.  To follow CLion's lead, you can create both <code>cmake-build-debug</code> and <code>cmake-build-release</code>. This will prevent you from needing to recompile Catch and SFML when you switch between debug and release!</p> <p>To compile in debug mode, change the build type to debug via <code>-DCMAKE_BUILD_TYPE=Debug</code> in the first cmake command. </p> <p>This would normally look like: </p> <pre><code>cmake -DCMAKE_BUILD_TYPE=Debug ..\n</code></pre> <p>Unless you're on Windows, which would be:</p> <pre><code>cmake -DCMAKE_BUILD_TYPE=Debug -G \"MinGW Makefiles\" ..\n</code></pre> <p>You can then build like normal. </p> <p>Note that you can also replace <code>Debug</code> with <code>Test</code> to run only the unit tests.</p>"},{"location":"HowToOverview/","title":"How-To Guides","text":"<p>Below are a set of guides for how to develop your own modules and joining them together into an executable (potentially with additional analysis and data collection.)</p> <ul> <li> <p>How to compile - Walks through how to compile via CMake.</p> </li> <li> <p>How to Build an Agent - A guide to designing your own type of autonomous agent.</p> </li> <li> <p>How to Build a World - A guide to designing you own world with custom interaction modes among agents and other environmental properties.</p> </li> <li> <p>How to Build an Interface - How to build an interface that allows a human user to control an agent.</p> </li> <li> <p>How to Assemble a <code>main()</code> function - A guide to selecting worlds, agents, and interfaces and turning them into a custom executable (including how to collect data about the resulting system.)</p> </li> <li> <p>How to build, run, and create unit tests - Walks through how to build and run existing unit tests, as well as create new unit test files. </p> </li> </ul>"},{"location":"HowToTest/","title":"How to Test","text":"<p>This guide will demonstrate how to create, build, and run tests.</p> <p>Note: that these instructions should work on Mac and Linux systems. Windows instructions should be similar, but please add any information about working with tests on Windows via a pull request! </p> <p>Note: this guide assumes you have Catch2 downloaded.  If you haven't yet downloaded the repo, simply add a <code>--recursive</code> to the end of your <code>git clone</code>.  If you have downloaded the rest of the repo, simply initialize and update the submodules: </p> <pre><code>git submodule init\ngit submodule update\n</code></pre>"},{"location":"HowToTest/#how-to-compile-tests","title":"How to compile tests","text":"<p>First, create a build directory for tests if you don't already have one, and then enter that directory:</p> <pre><code>mkdir cmake-build-test\ncd cmake-build-test\n</code></pre> <p>Now we need to use CMake to compile. This is a two step process. First we tell CMake where to find the files, relative to our current directory. </p> <pre><code>cmake -DCMAKE_BUILD_TYPE=Test ..\n</code></pre> <p>If that completes without errors, we can now build the files in our current directory. </p> <pre><code>cmake --build .\n</code></pre> <p>That should compile the unit tests.  Note that this process will take a while the first time as it needs to compile Catch2. It should be much faster in subsequent builds. </p>"},{"location":"HowToTest/#compiling-with-extra-source-files","title":"Compiling with extra source files.","text":"<p>Note that if you want to compile code that depends on additional source files (i.e., additional <code>.cpp</code> files), you need to perform one additional step before compiling. Specifically, you need to create an additional <code>.cmake</code> file. </p> <p>The <code>.cmake</code> file should have the same base name as your test's main <code>.cpp</code>, for example, <code>WorldGrid.cpp</code> would have an accompanying <code>WorldGrid.cmake</code>. </p> <p>You have free reign within this CMake file, but to add sources you will need to add lines like this (one per source file you want to add): </p> <pre><code>add_source_to_target(${EXE_NAME} \"source/Agents/PathAgent.cpp\")\n</code></pre> <p>The <code>${EXE_NAME}</code> DOES NOT CHANGE, it is a variable set in the other CMake files. You wimply need to change the string to match the path of your source file (relative to the repo's root). </p> <p>Once this file is created, compilation can proceed as normal. The CMake build system will automatically detect and execute the file you just created. </p>"},{"location":"HowToTest/#running-tests","title":"Running tests","text":"<p>Inside of your test build directory (<code>/cmake-build-test/</code> above), run the following: </p> <pre><code>ctest --output-on-failure\n</code></pre> <p>This should run all the unit tests, providing something like the following: </p> <pre><code>\nTest project /Users/thammina/projectsLocal/CSE491_GP_Group7/build\n    Start 1: tests-unit-core-Data\n1/3 Test #1: tests-unit-core-Data .............   Passed    0.01 sec\n    Start 2: tests-unit-core-WorldGrid\n2/3 Test #2: tests-unit-core-WorldGrid ........   Passed    0.01 sec\n    Start 3: tests-unit-gp_agents-agent\n3/3 Test #3: tests-unit-gp_agents-agent .......   Passed    0.01 sec\n\n100% tests passed, 0 tests failed out of 3\n</code></pre> <p>By specifying the <code>--output-on-failure</code> flag, we should see also see the specifics of which cases failed, if any. </p> <p>If you wish to run a particular test, simply navigate to the <code>executable</code> directory inside the build folder, and then run that particular test (e.g., <code>tests-unit-core-Data</code>). Note that it may end in <code>.exe</code> on  Windows.</p>"},{"location":"HowToTest/#adding-new-tests","title":"Adding new tests","text":"<p>To add tests for a new file, navigate to the corresponding folder in the <code>tests/unit</code> directory (not in <code>cmake-build-test</code> directory).  For example, if we want to add a test for a new file in <code>core</code>, from the root of the repo we would navigate like so: </p> <pre><code>cd tests/unit/core\n</code></pre> <p>Once in the correct directory we need to add the actual source code of the test.  This should be done as a new <code>.cpp</code> file, which will typically have the same name as the header file in source (e.g., <code>WorldGrid.hpp</code> will have a new test file called <code>WorldGrid.cpp</code>). </p> <p>Once you've created that file, you can start with this skeleton code: </p> <pre><code>/**\n * This file is part of the Fall 2023, CSE 491 course project.\n * @brief &lt;TODO&gt;\n **/\n\n// Catch2 \n#define CATCH_CONFIG_MAIN\n#include &lt;catch2/catch_all.hpp&gt;\n\n// Class project\n// Place your includes here\n// e.g., #include \"core/Data.hpp\"\n\nTEST_CASE(\"NAME\", \"[tags]\"){\n}\n\n</code></pre> <p>This should be it! CMake should automatically detect the file and compile (and let Austin know if that doesn't work!)</p>"},{"location":"blogpost/","title":"Index","text":"<p>sdfsdf</p>"},{"location":"blogpost/#blog-post-submissions","title":"Blog Post Submissions","text":"<p>All blog post submissions should go into this direcectory, in a sub-directory consisting of your last name.  For example, my subdirectory would be <code>Ofria/</code>.</p>"},{"location":"blogpost/Budny/final/","title":"Problem setup.","text":"<p>Suppose you have created a program in C++. It works well, it meets all your requirements, it's well tested, stable.  So, you move on to a different project, and that project happens to be in a different language, but then you realize you already solved some of the problems with your new project in your previous C++ program. Wouldn't it be nice if you could reuse that code, somehow?</p> <p>Luckily, it IS often possible to reuse that code, especially if it's something like a library that's naturally suited to reuse. The language barrier is only a minor hurdle you need to clear \u2013 many modern languages have support for calling functions in other languages via something known as a Foreign Function Interface (FFI). </p> <p>Some languages support C++ interoperability directly, but many languages' FFIs are designed to adapt C functions instead. This still allows you to use C++ code, but it requires you to wrap your C++ code with a C interface. Thus, the first step in allowing your C++ code to be used elsewhere is sometimes to take a brief break from writing C++, and switch to writing an interface in the style of C.</p>"},{"location":"blogpost/Budny/final/#creating-a-simple-c-example","title":"Creating a simple C++ example","text":"<p>To start, let's assume you have already designed an incredible C++ library, and you want to call it from a language that only supports a C FFI, like Python.</p> <pre><code>// File cool.hpp\n#ifndef MY_COOL_CLASS\n#define MY_COOL_CLASS\n\nclass myCoolClass {\n    myCoolClass() { /* construct whatever */ }\n\n    void doSomething();\n    int doSomethingElse(int);\n};\n\n#endif // MY_COOL_CLASS\n</code></pre> <p>Clearly this class must be very important and useful, so let's see the implementation file:</p> <pre><code>// File cool.cpp\n#include \"cool.hpp\"\n\n#include &lt;iostream&gt;\n\nvoid MyCoolClass::doSomething(){\n    std::cout &lt;&lt; \"Hello from C++!\" &lt;&lt; std::endl;\n}\n\nint MyCoolClass::doSomethingElse(int a){\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n    return a*a;\n}\n</code></pre> <p>Incredible.</p> <p>If we were writing a program to use this in C++, nothing here is unusual.</p> <pre><code>// File main.cpp\n#include \"cool.hpp\"\n\nint main(){\n    MyCoolClass c{};\n\n    c.doSomething();\n    int r = c.doSomethingElse(2);\n    c.doSomethingElse(r);\n}\n</code></pre> <p>We can compile this with something like the following:</p> <pre><code>g++ main.cpp cool.cpp -o coolfile\n</code></pre> <p>Finally, we can run our program, and get some output indicating that it works:</p> <pre><code>./coolfile\nHello from C++!\n2\n4\n</code></pre> <p>This is all pretty straightforward, but we don't want to write our primary program in C++. Suppose we wanted to call this code from Python 3 instead. It's such a useful library after all, who wouldn't want to use it from other languages?</p>"},{"location":"blogpost/Budny/final/#creating-a-c-api","title":"Creating a C API","text":"<p>The next step is to revise our C++ source to expose a C API. One way to do that could be the following, using <code>extern \"C\"</code>. This tells the linker to expose these functions as C functions, instead of C++ functions. C++ renames functions internally to support things like function overloads; <code>extern \"C\"</code> disables this. Since we will be treating this like a C API, it is necessary to expose the functions as C functions.</p> <p>In our case, we could add the following to our header file, just after the class definition:</p> <pre><code>// File cool.hpp\nclass MyCoolClass { /* ... */ };\n\nextern \"C\" {\n    MyCoolClass* MyCoolClass_create();\n    void MyCoolClass_doSomething(MyCoolClass*);\n    int MyCoolClass_doSomethingElse(MyCoolClass*, int);\n    void MyCoolClass_destroy(MyCoolClass*);\n}\n</code></pre> <p>Of course, we need to modify our implementation as well to support this new API. This will usually just be a bunch of function wrappers, with a hint of memory management sprinkled in for those constructors and destructors.</p> <pre><code>// File cool.cpp\n\nMyCoolClass* MyCoolClass_create(){\n    return new MyCoolClass();\n}\n\nvoid MyCoolClass_doSomething(MyCoolClass* cc){\n    cc-&gt;doSomething();\n}\n\nint MyCoolClass_doSomethingElse(MyCoolClass* cc, int argument){\n    return cc-&gt;doSomethingElse(argument);\n}\n\nvoid MyCoolClass_destroy(MyCoolClass* cc){\n    delete cc;\n}\n</code></pre> <p>Notice that, because we are dealing with a C API for our C++ program, we are using raw pointers and in this case are manually managing memory. Be careful - it's easy to miss something here and cause a memory leak or a crash!</p>"},{"location":"blogpost/Budny/final/#shared-objects-dlls","title":"Shared objects / DLLs","text":"<p>Python expects a dynamically linked library (DLL) or shared object, so we need to compile as a DLL or shared object. With g++, this looks like:</p> <pre><code>g++ -fPIC cool.cpp -shared -o cool.so\n</code></pre> <p>The two important flags here are <code>-fPIC</code>, which specifies that we are compiling position-independent code, and <code>-shared</code>, which specifies that we are making a shared object. Our output file here will be <code>cool.so</code>.</p> <p>It's not all that different from compiling a regular executable.</p>"},{"location":"blogpost/Budny/final/#using-pythons-ctypes-module","title":"Using Python's ctypes module","text":"<p>On the Python side, we might now attempt to construct a program with similar behavior our C++ main program. Notice that we need to load the shared object/DLL from before here:</p> <pre><code>// File main.py\nimport ctypes\nfrom ctypes import cdll\n\ncool = cdll.LoadLibrary(\"./cool.so\")\n\ncc = cool.MyCoolClass_create()\n\ncool.MyCoolClass_doSomething(cc)\n\nres = cool.MyCoolClass_doSomethingElse(cc, 2)\ncool.MyCoolClass_doSomethingElse(cc, res)\n\ncool.MyCoolClass_destroy(cc)\n</code></pre> <p>We can then run this with something like <code>python3 main.py</code>, load our library, and... oh, it broke.</p> <pre><code>Hello from C++!\n2\n4\nSegmentation fault (core dumped)\n</code></pre> <p>The ctypes module is useful, but it isn't magic. Most importantly, it assumes that your arguments and return types are all integers, but we want to work with an object here, which means a pointer. To resolve this, we need to specify the function arguments and returns.</p> <pre><code>// File main.py\n// Imports here\n\n# Setup here: arugment and return types\n# Otherwise it defaults to int for everything, which can and will break pointers\ncool.MyCoolClass_doSomething.argtypes = []\ncool.MyCoolClass_create.restype = ctypes.c_void_p\n\ncool.MyCoolClass_doSomething.argtypes = [ctypes.c_void_p]\ncool.MyCoolClass_doSomething.restype = None\n\ncool.MyCoolClass_doSomethingElse.argtypes = [ctypes.c_void_p, ctypes.c_int]\ncool.MyCoolClass_doSomethingElse.restype = ctypes.c_int\n\ncool.MyCoolClass_destroy.argtypes = [ctypes.c_void_p]\ncool.MyCoolClass_destroy.restype = None\n\n// Rest of code here\n// ...\n</code></pre> <p>Now, our output is what we would expect:</p> <pre><code>Hello from C++!\n2\n4\n</code></pre>"},{"location":"blogpost/Budny/final/#cleanup","title":"Cleanup","text":"<p>Of course, this does not look very nice on the Python side now. It suffers from the same problem that our C++ code had, which is that now you have to interact with a C-style API. Since this example deals with a library, it might be useful to now create a wrapper on the Python side as well. It is quite simple to now wrap our ctypes C wrapper in a Python class...</p> <pre><code>// File cool.py\nimport ctypes\nfrom ctypes import cdll\n\ncool = cdll.LoadLibrary(\"./cool.so\")\n\n# Setup here: arugment and return types\n# (defaults to int for everything, which can break pointers)\ncool.MyCoolClass_doSomething.argtypes = []\ncool.MyCoolClass_create.restype = ctypes.c_void_p\n\ncool.MyCoolClass_doSomething.argtypes = [ctypes.c_void_p]\ncool.MyCoolClass_doSomething.restype = None\n\ncool.MyCoolClass_doSomethingElse.argtypes = [ctypes.c_void_p, ctypes.c_int]\ncool.MyCoolClass_doSomethingElse.restype = ctypes.c_int\n\ncool.MyCoolClass_destroy.argtypes = [ctypes.c_void_p]\ncool.MyCoolClass_destroy.restype = None\n\n# Wrapper class for C wrapper API for our C++ class\nclass MyCoolClass:\n    def __init__(self):\n        self._cc = cool.MyCoolClass_create()\n\n    def doSomething(self):\n        cool.MyCoolClass_doSomething(self._cc)\n\n    def doSomethingElse(self, value):\n        return cool.MyCoolClass_doSomethingElse(self._cc, value)\n\n    def __del__(self):\n        cool.MyCoolClass_destroy(self._cc)\n</code></pre> <p>This finally leaves our main file, now much more closely resembling our C++ main function as we have restored the original form of our library:</p> <pre><code>// File main.py                     # // File main.cpp\nfrom cool import MyCoolClass        # #include \"cool.hpp\"\n                                    # \n                                    # int main(){\nc = MyCoolClass()                   #     MyCoolClass c{};\n                                    #     \nc.doSomething()                     #     c.doSomething();\nres = c.doSomethingElse(2)          #     int res = c.doSomethingElse(2);\nc.doSomethingElse(res)              #     c.doSomethingElse(4);\n                                    # }\n</code></pre> <p>This still has the expected output, in addition to the source being much more readable.</p> <pre><code>Hello from C++!\n2\n4\n</code></pre>"},{"location":"blogpost/Budny/final/#conclusion","title":"Conclusion","text":"<p>This may have seemed like a lot of work, most of which was repeating information we already had. Naturally, there are several libraries that automate some or most of this process, such as pybind11 or Boost.Python. Which library is best for your use is left as an exercise to the reader.</p> <p>Even so, there is a clear advantage to being able to reuse code you have already created. As the scope of a project grows, the proportion of overhead to functionality decreases as well - especially if you use a library to automate the more repetitive parts.</p>"},{"location":"blogpost/Budny/final/#examples","title":"Examples","text":"<p>If you're looking for some examples of libraries that do this, many large performance sensitive Python libraries are implemented this way. This includes examples such as</p> <ul> <li>numpy</li> <li>scipy</li> <li>matplotlib</li> </ul> <p>Many of these libraries use portions implemented in C or C++ (often both) to speed up operations that would be much slower in Python. There are also projects like Emscripten, which allow C++ libraries to be compiled to WebAssembly to then be called from JavaScript (also typically using a C FFI).</p>"},{"location":"blogpost/Budny/final/#useful-resources","title":"Useful resources","text":"<p>Further reading on the details, as well as the resources used when writing this post:</p> <ul> <li>https://isocpp.org/wiki/faq/mixing-c-and-cpp - information on <code>extern \"C\"</code>, as well as mixing C and C++ in general</li> <li>https://docs.python.org/3/library/ctypes.html - information about the ctypes module, including all the supported types</li> <li>https://en.wikipedia.org/wiki/Foreign_function_interface - An overview of foreign function interfaces, including descriptions for many languages</li> <li>https://stackoverflow.com/questions/145270/calling-c-c-from-python#145649 - A similar guide used as a reference when starting this one. Several other answers list potential libraries to use as well.</li> </ul>"},{"location":"blogpost/Carr/draft/","title":"Lambdas in C++","text":""},{"location":"blogpost/Carr/draft/#about-lambdas","title":"About Lambdas","text":"<p>Lambdas are local function objects (classes) defined \"on the fly\" that are useful for short snippets of code that are not necessary elsewhere. Many times lambdas are seen being used in algorithms of the std namespace. Lambdas can be assigned to variables, so that if there are many different uses, there is no need to rewrite the lambda code - the variable can be used. Lambdas have the ability to be for specific types or generic (can be for many different types). The main parts of a lambda are the capture clause, the parameter list, mutable specification, and lambda body. In the following sections, examples will be worked through to further understanding of lambdas and their anatomy. </p>"},{"location":"blogpost/Carr/draft/#form-of-a-lambda","title":"Form of a Lambda","text":"<p>Lambdas are in the form of:</p> <pre><code>[capture clause] (parameter list) mutable specification {body}\n</code></pre> <p>The capture clause allows variables outside the scope of the lambda to be used within the lambda. Next, the parameter list contains the variables the lambda uses. The mutable specification allows the lambda to modify variables captured through the capture clause. Lastly, the body of the lambda contains the work (code) the lambda is doing. </p>"},{"location":"blogpost/Carr/draft/#basic-lambda-example","title":"Basic Lambda Example","text":"<pre><code>int main() {\n    // define vector\n    std::vector&lt;int&gt; v {1, 29, -10, 32, 11, -4, 17, 4, 2, 9};\n\n    // find first element that is less than 0\n    auto it = std::find_if(v.begin(), v.end(),\n                           [] (int num) {\n                                return num &lt; 0;\n                           });\n\n    // print out element that is less than 0\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;    \n\n    return 0;\n}\n</code></pre> <p>In this example, a simple lambda is used with the <code>find_if</code> std algorithm to find the first element that is less than zero. The lambda in this example has nothing in its capture clause, has no mutable specification, and no exception specification. The parameter list simply takes in an integer, as the vector is a vector of integers. The lambda body is a simple return statement that checks if the integer is less than zero.  </p>"},{"location":"blogpost/Carr/draft/#lambda-as-a-variable-example","title":"Lambda as a Variable Example","text":"<pre><code>int main() {\n    // define vector\n    std::vector&lt;int&gt; v {1, 29, -10, 32, 11, -4, 17, 4, 2, 9};\n\n    // create lambda and store it in a variable\n    auto lessThanZero = [] (int num) {\n        return num &lt; 0;\n    };\n\n    // find first element that is less than 0\n    auto it = std::find_if(v.begin(), v.end(), lessThanZero);\n\n    // count all elements that are less than 0\n    auto count = std::count_if(v.begin(), v.end(), lessThanZero);\n\n    // print out element that is less than 0\n    std::cout &lt;&lt; \"First element less than 0: \" &lt;&lt; *it &lt;&lt; std::endl;  \n\n    // print out number of elements less than 0\n    std::cout &lt;&lt; \"Number of elements less than 0: \" &lt;&lt; count &lt;&lt; std::endl;  \n\n    return 0;\n}\n</code></pre> <p>Lambdas can be assigned to variables. This is useful when there are multiple uses for the same lambda in a single scope. By assigning the lambda to a variable, the lambda is only written one time, but can be used many times in that scope. This results in much cleaner code. </p> <p>In this example, a lambda is used to find the first element that is less than zero, and also count the number of elements that are less than zero in the vector <code>v</code>. As seen in vector <code>v</code>, the first element less than zero is -10, and the number of elements less than zero is 2 (-10 and -4).</p>"},{"location":"blogpost/Carr/draft/#using-lambda-capture","title":"Using Lambda Capture","text":"<pre><code>int main() {\n    // define vector\n    std::vector&lt;int&gt; v {1, 29, -10, 32, 11, -4, 17, 4, 2, 9};\n\n    // define min and max\n    int min = 8;\n    int max = 15;\n\n    // create lambda and store it in a variable\n    auto inRange = [min, max] (int num) {\n        return num &lt; max &amp;&amp; num &gt; min;\n    };\n\n    // find first element that is in range\n    auto it = std::find_if(v.begin(), v.end(), inRange);\n\n    // count all elements that are in range\n    auto count = std::count_if(v.begin(), v.end(), inRange);\n\n    // print out element that is in range\n    std::cout &lt;&lt; \"First element in range (8, 15): \" &lt;&lt; *it &lt;&lt; std::endl;  \n\n    // print out number of elements in range\n    std::cout &lt;&lt; \"Number of elements in range (8, 15): \" &lt;&lt; count &lt;&lt; std::endl;  \n\n    return 0;\n}\n</code></pre> <p>This example is similar to the previous example. However, in this case, the lambda capture is being used. Captures in lambdas (the []) allow the lambda to access variables defined in the same scope as the lambda. The lambda is no longer limited to variables passed in as parameters/variables defined inside of the lambda body. </p> <p>There is a min and max defined in the same scope as the lambda, and these are the two values seen in the capture - <code>[min, max]</code>. Now, instead of having a <code>lessThanZero</code> lambda, it is an <code>inRange</code> lambda, which uses the min and max to find the first element in range and count the number of elements in range for vector <code>v</code>. </p>"},{"location":"blogpost/Carr/draft/#using-lambda-capture-and-mutable-specification","title":"Using Lambda Capture and Mutable Specification","text":"<pre><code>int main() {\n    // define string\n    std::string message = \"Hello\";\n\n    // define lambda\n    auto improveMessage = [&amp;message] (std::string mess) mutable {\n        message += mess;\n    };\n\n    // call lambda to improve message\n    improveMessage(\" my name is Grant. Welcome to the C++ Lambdas Blogpost!\");\n\n    // look at new message!\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n</code></pre> <p>Specifying a lambda as mutable is a sometimes useful tool when working with captures. In certain situations, it may be necessary/helpful to be able to modify values captured by the lambda. In the example above, a lambda is used to improve a message. </p> <p>Due to the lambda capturing the string <code>message</code> by reference, any change done to it inside the lambda body modifies the variable outside of the lambda as well. After using this lambda, the string <code>message</code> will contain the text </p> <pre><code>\"Hello my name is Grant. Welcome to the C++ Lambdas Blogpost!\".\n</code></pre> <p>However, if instead the lambda were to look like this:</p> <pre><code>    auto improveMessage = [message] (std::string mess) mutable {\n        message += mess;\n    };\n</code></pre> <p>The string <code>message</code> would only be modified inside of the lambda body. Outside of the lambda, since <code>message</code> is not captured by reference, it would still only contain \"Hello\". It is important to understand these rules when specifying a lambda as mutable and using the lambda capture: * Variables captured by reference and <code>mutable</code> lambda - if the variables captured by the lambda are modified in the lambda body, they will be modified outside the lambda as well.  * Variables captured normally and <code>mutable</code> lambda - if the variables captured by the lambda are modified in the lambda body, they will only be modified inside the lambda. The variables will still hold their original value after/outside the lamdba.</p>"},{"location":"blogpost/Carr/draft/#generic-lambdas","title":"Generic Lambdas","text":"<pre><code>int main() {\n    // generic lambda\n    auto combineOnce = [] (auto var) {\n        return var + var;\n    };\n\n    std::cout &lt;&lt; \"Combining integers: \" &lt;&lt; combineOnce(3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Combining floats: \" &lt;&lt; combineOnce(2.2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Combining string: \" &lt;&lt; combineOnce(std::string{\"Grant\"}) &lt;&lt; std::endl;\n}\n</code></pre> <p>Lambdas have the ability to be generic. Similar to templated functions, lambdas can act almost as if it were a templated function. By making the parameters type <code>auto</code>, lambdas are able to handle many different types. In this example, strings, floats, and integers are all able to work with the lambda function <code>combineOnce</code>. One important thing to understand is this lambda will only work with types that can be added together. The types a generic lambda are sufficient for depend on the operations occurring inside the lambda body. </p> <p>This example has the following outputs:</p> <pre><code>Combining integers: 6\nCombining floats: 2.2\nCombining string: GrantGrant\n</code></pre>"},{"location":"blogpost/Carr/draft/#lambdas-as-constexpr","title":"Lambdas as Constexpr","text":"<pre><code>int main() {\n    // generic lambda as constexpr\n    constexpr auto sum = [] (const auto &amp;var_one, const auto &amp;var_two) {\n        return var_one + var_two;\n    };\n\n    std::cout &lt;&lt; \"Summing integers: \" &lt;&lt; sum(3, 7) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Summing floats: \" &lt;&lt; sum(2.2, 3.3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Summing string: \" &lt;&lt; sum(std::string{\"Grant\"}, std::string{\" Lambda\"}) &lt;&lt; std::endl;\n}\n</code></pre> <p>Another interesting feature of lambdas is they can be declared as constexpr. This declares that it is possible to evaluate the value of the lambda at compile time. The benefits of computing at compile time rather than runtime is that it helps the program run faster and use less memory. Lambdas are also implicity constexpr if their result satisfies the requirements of a constexpr function. </p> <p>An example that would cause an error would be declaring a lambda as <code>constexpr</code> but then making it <code>mutable</code>. If the lambda has any captures, those must also be const. </p> <p>The output of the example above is as follows:</p> <pre><code>Summing integers: 10\nSumming floats: 5.5\nSumming string: Grant Lambda\n</code></pre>"},{"location":"blogpost/Carr/draft/#lambda-as-function-parameter","title":"Lambda as Function Parameter","text":"<pre><code>// templated function that uses a generic lambda and generic types\ntemplate &lt;typename F, typename T&gt;\nvoid UseLambda(F lambda, T var1, T var2) {\n    std::cout &lt;&lt; lambda(var1, var2) &lt;&lt; std::endl;\n}\n\nint main() {\n    // generic lambda as constexpr\n    auto sum = [] (const auto &amp;var_one, const auto &amp;var_two) {\n        return var_one + var_two;\n    };\n\n    // send lambda to function\n    UseLambda(sum, 3, 6);\n    UseLambda(sum, 3.7, 2.1);\n    UseLambda(sum, std::string{\"Hello\"}, std::string{\" World\"});\n}\n</code></pre> <p>Another unique property of lambdas is their ability to be sent to other functions as a parameter. As a lambda is really just an object, it can be sent and used in functions where it is not defined. As the lambda type is somewhat unknown (it is declared as <code>auto</code>), the function that wants to use the lambda must be a templated function. In this example, the lambda <code>sum</code> is a generic lambda - it can work for many different types. The parameters required for the lambda are also sent to the function <code>UseLambda</code>, and due to the lambda being generic, these are templated types as well. </p>"},{"location":"blogpost/Carr/draft/#wrap-up","title":"Wrap Up","text":"<p>Lambdas have many different uses: * Simple, short, local, inline functions that do not require creating a new function. * Can be assigned to variables if used in many different locations. This makes code easily understandable and improves readability. * The capture of a lambda allows it to use and edit variables outside of the lambda body.     * Adding the <code>mutable</code> specification allows lambdas to change variables captured.  * Lambdas can be generic. Similar to templated functions, lambdas declared with <code>auto</code> type parameters are generic and can work for many different types depending on the operations occurring in the lambda body.  * Lambdas can be declared and implicitly <code>constexpr</code>. This allows the lambda to be evaluated at compile time, possibly speeding up code.  * Functions can have a parameter that is a lambda. Due to lambdas being an object, they can be sent to other functions to be used in. The function using a lambda as a parameter must be a templated function to allow use. </p>"},{"location":"blogpost/Carr/draft/#references","title":"References","text":"<ul> <li>https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170</li> </ul>"},{"location":"blogpost/Carr/final/","title":"Lambdas in C++","text":""},{"location":"blogpost/Carr/final/#about-lambdas","title":"About Lambdas","text":"<p>Lambdas are local function objects (classes) defined \"on the fly\" that are useful for short snippets of code that are not necessary elsewhere. Many times lambdas are seen being used in algorithms of the std namespace. Lambdas can be assigned to variables, so that if there are many different uses, there is no need to rewrite the lambda code - the variable can be used. Lambdas have the ability to be for specific types or generic (can be for many different types). The main parts of a lambda are the capture clause, the parameter list, mutable specification, and lambda body. In the following sections, examples will be worked through to further understanding of lambdas and their anatomy. </p>"},{"location":"blogpost/Carr/final/#form-of-a-lambda","title":"Form of a Lambda","text":"<p>Lambdas are in the form of:</p> <pre><code>[capture clause] (parameter list) mutable specification {body}\n</code></pre> <p>The capture clause allows variables outside the scope of the lambda to be used within the lambda. Next, the parameter list contains the variables the lambda uses. The mutable specification allows the lambda to modify variables captured through the capture clause. Lastly, the body of the lambda contains the work (code) the lambda is doing. </p>"},{"location":"blogpost/Carr/final/#basic-lambda-example","title":"Basic Lambda Example","text":"<pre><code>int main() {\n    // define vector\n    std::vector&lt;int&gt; v {1, 29, -10, 32, 11, -4, 17, 4, 2, 9};\n\n    // find first element that is less than 0\n    auto it = std::find_if(v.begin(), v.end(),\n                           [] (int num) {\n                                return num &lt; 0;\n                           });\n\n    // print out element that is less than 0\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;    \n\n    return 0;\n}\n</code></pre> <p>In this example, a simple lambda is used with the <code>find_if</code> std algorithm to find the first element that is less than zero. The lambda in this example has nothing in its capture clause, has no mutable specification, and no exception specification. The parameter list simply takes in an integer, as the vector is a vector of integers. The lambda body is a simple return statement that checks if the integer is less than zero.  </p>"},{"location":"blogpost/Carr/final/#lambda-as-a-variable-example","title":"Lambda as a Variable Example","text":"<pre><code>int main() {\n    // define vector\n    std::vector&lt;int&gt; v {1, 29, -10, 32, 11, -4, 17, 4, 2, 9};\n\n    // create lambda and store it in a variable\n    auto lessThanZero = [] (int num) {\n        return num &lt; 0;\n    };\n\n    // find first element that is less than 0\n    auto it = std::find_if(v.begin(), v.end(), lessThanZero);\n\n    // count all elements that are less than 0\n    auto count = std::count_if(v.begin(), v.end(), lessThanZero);\n\n    // print out element that is less than 0\n    std::cout &lt;&lt; \"First element less than 0: \" &lt;&lt; *it &lt;&lt; std::endl;  \n\n    // print out number of elements less than 0\n    std::cout &lt;&lt; \"Number of elements less than 0: \" &lt;&lt; count &lt;&lt; std::endl;  \n\n    return 0;\n}\n</code></pre> <p>Lambdas can be assigned to variables. This is useful when there are multiple uses for the same lambda in a single scope. By assigning the lambda to a variable, the lambda is only written one time, but can be used many times in that scope. This results in much cleaner code. </p> <p>In this example, a lambda is used to find the first element that is less than zero, and also count the number of elements that are less than zero in the vector <code>v</code>. As seen in vector <code>v</code>, the first element less than zero is -10, and the number of elements less than zero is 2 (-10 and -4).</p>"},{"location":"blogpost/Carr/final/#using-lambda-capture","title":"Using Lambda Capture","text":"<pre><code>int main() {\n    // define vector\n    std::vector&lt;int&gt; v {1, 29, -10, 32, 11, -4, 17, 4, 2, 9};\n\n    // define min and max\n    int min = 8;\n    int max = 15;\n\n    // create lambda and store it in a variable\n    auto inRange = [min, max] (int num) {\n        return num &lt; max &amp;&amp; num &gt; min;\n    };\n\n    // find first element that is in range\n    auto it = std::find_if(v.begin(), v.end(), inRange);\n\n    // count all elements that are in range\n    auto count = std::count_if(v.begin(), v.end(), inRange);\n\n    // print out element that is in range\n    std::cout &lt;&lt; \"First element in range (8, 15): \" &lt;&lt; *it &lt;&lt; std::endl;  \n\n    // print out number of elements in range\n    std::cout &lt;&lt; \"Number of elements in range (8, 15): \" &lt;&lt; count &lt;&lt; std::endl;  \n\n    return 0;\n}\n</code></pre> <p>This example is similar to the previous example. However, in this case, the lambda capture is being used. Captures in lambdas (the []) allow the lambda to access variables defined in the same scope as the lambda. The lambda is no longer limited to variables passed in as parameters/variables defined inside of the lambda body. </p> <p>There is a min and max defined in the same scope as the lambda, and these are the two values seen in the capture - <code>[min, max]</code>. Now, instead of having a <code>lessThanZero</code> lambda, it is an <code>inRange</code> lambda, which uses the min and max to find the first element in range and count the number of elements in range for vector <code>v</code>. </p>"},{"location":"blogpost/Carr/final/#using-lambda-capture-and-mutable-specification","title":"Using Lambda Capture and Mutable Specification","text":"<pre><code>int main() {\n    // define string\n    std::string message = \"Hello\";\n\n    // define lambda\n    auto improveMessage = [&amp;message] (std::string mess) mutable {\n        message += mess;\n    };\n\n    // call lambda to improve message\n    improveMessage(\" my name is Grant. Welcome to the C++ Lambdas Blogpost!\");\n\n    // look at new message!\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n</code></pre> <p>Specifying a lambda as mutable is a sometimes useful tool when working with captures. In certain situations, it may be necessary/helpful to be able to modify values captured by the lambda. In the example above, a lambda is used to improve a message. </p> <p>Due to the lambda capturing the string <code>message</code> by reference, any change done to it inside the lambda body modifies the variable outside of the lambda as well. After using this lambda, the string <code>message</code> will contain the text </p> <pre><code>\"Hello my name is Grant. Welcome to the C++ Lambdas Blogpost!\".\n</code></pre> <p>However, if instead the lambda were to look like this:</p> <pre><code>    auto improveMessage = [message] (std::string mess) mutable {\n        message += mess;\n    };\n</code></pre> <p>The string <code>message</code> would only be modified inside of the lambda body. Outside of the lambda, since <code>message</code> is not captured by reference, it would still only contain \"Hello\". It is important to understand these rules when specifying a lambda as mutable and using the lambda capture: * Variables captured by reference and <code>mutable</code> lambda - if the variables captured by the lambda are modified in the lambda body, they will be modified outside the lambda as well.  * Variables captured normally and <code>mutable</code> lambda - if the variables captured by the lambda are modified in the lambda body, they will only be modified inside the lambda. The variables will still hold their original value after/outside the lamdba.</p>"},{"location":"blogpost/Carr/final/#generic-lambdas","title":"Generic Lambdas","text":"<pre><code>int main() {\n    // generic lambda\n    auto combineOnce = [] (auto var) {\n        return var + var;\n    };\n\n    std::cout &lt;&lt; \"Combining integers: \" &lt;&lt; combineOnce(3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Combining floats: \" &lt;&lt; combineOnce(2.2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Combining string: \" &lt;&lt; combineOnce(std::string{\"Grant\"}) &lt;&lt; std::endl;\n}\n</code></pre> <p>Lambdas have the ability to be generic. Similar to templated functions, lambdas can act almost as if it were a templated function. By making the parameters type <code>auto</code>, lambdas are able to handle many different types. In this example, strings, floats, and integers are all able to work with the lambda function <code>combineOnce</code>. One important thing to understand is this lambda will only work with types that can be added together. The types a generic lambda are sufficient for depend on the operations occurring inside the lambda body. </p> <p>This example has the following outputs:</p> <pre><code>Combining integers: 6\nCombining floats: 2.2\nCombining string: GrantGrant\n</code></pre>"},{"location":"blogpost/Carr/final/#lambdas-as-constexpr","title":"Lambdas as Constexpr","text":"<pre><code>int main() {\n    // generic lambda as constexpr\n    constexpr auto sum = [] (const auto &amp;var_one, const auto &amp;var_two) {\n        return var_one + var_two;\n    };\n\n    std::cout &lt;&lt; \"Summing integers: \" &lt;&lt; sum(3, 7) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Summing floats: \" &lt;&lt; sum(2.2, 3.3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Summing string: \" &lt;&lt; sum(std::string{\"Grant\"}, std::string{\" Lambda\"}) &lt;&lt; std::endl;\n}\n</code></pre> <p>Another interesting feature of lambdas is they can be declared as constexpr. This declares that it is possible to evaluate the value of the lambda at compile time. The benefits of computing at compile time rather than runtime is that it helps the program run faster and use less memory. Lambdas are also implicity constexpr if their result satisfies the requirements of a constexpr function. </p> <p>An example that would cause an error would be declaring a lambda as <code>constexpr</code> but then making it <code>mutable</code>. If the lambda has any captures, those must also be const. </p> <p>The output of the example above is as follows:</p> <pre><code>Summing integers: 10\nSumming floats: 5.5\nSumming string: Grant Lambda\n</code></pre>"},{"location":"blogpost/Carr/final/#lambda-as-function-parameter","title":"Lambda as Function Parameter","text":"<pre><code>// templated function that uses a generic lambda and generic types\ntemplate &lt;typename F, typename T&gt;\nvoid UseLambda(F lambda, T var1, T var2) {\n    std::cout &lt;&lt; lambda(var1, var2) &lt;&lt; std::endl;\n}\n\nint main() {\n    // generic lambda as constexpr\n    auto sum = [] (const auto &amp;var_one, const auto &amp;var_two) {\n        return var_one + var_two;\n    };\n\n    // send lambda to function\n    UseLambda(sum, 3, 6);\n    UseLambda(sum, 3.7, 2.1);\n    UseLambda(sum, std::string{\"Hello\"}, std::string{\" World\"});\n}\n</code></pre> <p>Another unique property of lambdas is their ability to be sent to other functions as a parameter. As a lambda is really just an object, it can be sent and used in functions where it is not defined. As the lambda type is somewhat unknown (it is declared as <code>auto</code>), the function that wants to use the lambda must be a templated function. In this example, the lambda <code>sum</code> is a generic lambda - it can work for many different types. The parameters required for the lambda are also sent to the function <code>UseLambda</code>, and due to the lambda being generic, these are templated types as well. </p>"},{"location":"blogpost/Carr/final/#wrap-up","title":"Wrap Up","text":"<p>Lambdas have many different uses: * Simple, short, local, inline functions that do not require creating a new function. * Can be assigned to variables if used in many different locations. This makes code easily understandable and improves readability. * The capture of a lambda allows it to use and edit variables outside of the lambda body.     * Adding the <code>mutable</code> specification allows lambdas to change variables captured.  * Lambdas can be generic. Similar to templated functions, lambdas declared with <code>auto</code> type parameters are generic and can work for many different types depending on the operations occurring in the lambda body.  * Lambdas can be declared and implicitly <code>constexpr</code>. This allows the lambda to be evaluated at compile time, possibly speeding up code.  * Functions can have a parameter that is a lambda. Due to lambdas being an object, they can be sent to other functions to be used in. The function using a lambda as a parameter must be a templated function to allow use. </p>"},{"location":"blogpost/Carr/final/#references","title":"References","text":"<ul> <li>https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170</li> </ul>"},{"location":"blogpost/Chandok/draft/","title":"Exploring Computer Vision with OpenCV and C++","text":""},{"location":"blogpost/Chandok/draft/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Installation</li> <li>Windows</li> <li>Object Detection</li> </ul>"},{"location":"blogpost/Chandok/draft/#introduction","title":"Introduction","text":"<p>OpenCV is a powerful open source computer vision and machine learning library. Originally developed by Intel, it was later supported by Willow Garage then Itseez (which was later acquired by Intel). The library is cross-platform and free for use.</p> <p>OpenCV was designed for computational efficiency and with a strong focus on real-time applications. Written in optimized C/C++, the library can take advantage of multi-core processing. Enabled with OpenCL, it can take advantage of the hardware acceleration of the underlying heterogeneous compute platform.</p> <p>Adopted all around the world, OpenCV has more than 47 thousand people of user community and estimated number of downloads exceeding 14 million. Usage ranges from interactive art, to mines inspection, stitching maps on the web or through advanced robotics.</p> <p>Today we will be exploring the basics of OpenCV and how to use it with C++. We'll be developing a Face Detection algorithm. Face detection is a fundamental task in computer vision that involves locating and identifying human faces in images or video streams. It has a wide range of applications, from photography and video analysis to security systems and facial recognition.</p>"},{"location":"blogpost/Chandok/draft/#installation","title":"Installation","text":""},{"location":"blogpost/Chandok/draft/#windows","title":"Windows","text":"<ul> <li>Download the latest version of OpenCV from here</li> <li>Download the latest version of CMake from here</li> <li>Extract the zip file to a folder</li> <li>Add the path to the bin folder to the environment variable</li> <li>Add the path to the lib folder to the environment variable</li> <li>Open CLion and create a new project</li> <li>Add the following lines to the CMakeLists.txt file</li> </ul> <pre><code>cmake_minimum_required(VERSION 3.26)\nproject(Blog)\n\nset(CMAKE_CXX_STANDARD 17)\n\nfind_package(OpenCV REQUIRED)\n\nset(SOURCE_FILES main.cpp)\n\nadd_executable(Blog ${SOURCE_FILES})\n\ntarget_link_libraries(Blog PRIVATE ${OpenCV_LIBS})\n</code></pre> <ul> <li>Create a new file called main.cpp and add the following lines</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n\nint main(int argc, char** argv )\n{\n\n    cv::Mat image;\n    image = cv::imread(\"C:/Users/rajme/Desktop/Rajmeet/MSU/Comp Science/CSE 491 - C++ Capstone/Blog/banana.jpeg\");\n    if ( !image.data )\n    {\n        printf(\"No image data \\n\");\n        return -1;\n    }\n    namedWindow(\"Display Image\", cv::WINDOW_AUTOSIZE );\n    imshow(\"Display Image\", image);\n    cv::waitKey(0);\n    return 0;\n}\n</code></pre> <ul> <li>Run the project and you should see the image</li> </ul>"},{"location":"blogpost/Chandok/draft/#object-detection","title":"Object Detection","text":""},{"location":"blogpost/Chandok/draft/#what-is-object-detection","title":"What is Object Detection?","text":"<p>Object detection is a computer vision technique that allows us to identify and locate objects in an image or video. With this kind of identification and localization, object detection can be used to count objects in a scene and determine and track their precise locations, all while accurately labeling them.</p>"},{"location":"blogpost/Chandok/draft/#applications-of-object-detection","title":"Applications of Object Detection","text":"<p>Object detection has many applications, including: - Object Tracking - Security Systems - Autonomous Vehicles</p>"},{"location":"blogpost/Chandok/draft/#how-can-we-detect-objects-in-images","title":"How can we detect objects in images?","text":"<p>There are many different algorithms that can be used to detect objects in images. Some of the most popular algorithms are: - Haar Cascades - Deep Learning - Histogram of Oriented Gradients (HOG)</p> <p>We'll be using Haar Cascades for this project. Haar Cascade classifiers are an effective way for object detection. This method was proposed by Paul Viola and Michael Jones in their paper Rapid Object Detection using a Boosted Cascade of Simple Features in 2001. It is a machine learning based approach where a cascade function is trained from a lot of positive and negative images. It is then used to detect objects in other images.</p>"},{"location":"blogpost/Chandok/draft/#features-and-training","title":"Features and Training","text":"<p>Each feature is a single value obtained by subtracting sum of pixels under the white rectangle from sum of pixels under the black rectangle.</p> <p></p> <p>Training - It is possible to train it on whatever we want, but OpenCV already contains many pre-trained classifiers for face, eyes, smile etc. - We will be using the face classifier for this project - The training process is very time consuming and requires a lot of positive and negative images - </p>"},{"location":"blogpost/Chandok/draft/#code","title":"CODE","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;opencv2/objdetect.hpp&gt;\n#include &lt;opencv2/highgui.hpp&gt;\n#include &lt;opencv2/imgproc.hpp&gt;\n#include &lt;opencv2/videoio.hpp&gt;\n\ncv::CascadeClassifier face_cascade;\n\nvoid faceDetection(cv::Mat frame)\n{\n    cv::Mat frame_gray;\n\n    // Convert to gray so that we don't have to deal with color and reduce computation time\n    cv::cvtColor(frame, frame_gray, cv::COLOR_BGR2GRAY);\n\n    // Detect faces\n    std::vector&lt;cv::Rect&gt; faces;\n    face_cascade.detectMultiScale(frame_gray, faces);\n\n    for (auto &amp; face : faces)\n    {\n        cv::Point center(face.x + face.width/2, face.y + face.height/2);\n        cv::ellipse(frame, center, cv::Size(face.width/2, face.height/2), 0, 0, 360, cv::Scalar(255, 0, 255), 4);\n\n        cv::Mat faceROI = frame_gray(face);\n    }\n\n    cv::imshow(\"Face Detection\", frame);\n}\n\nint main()\n{\n    std::string faceClassifierPath = R\"(C:\\opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_alt.xml)\";\n\n    if (!face_cascade.load(faceClassifierPath))\n    {\n        std::cout &lt;&lt; \"Error loading face classifier\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::cout &lt;&lt; \"Face classifier loaded successfully\" &lt;&lt; std::endl;\n\n\n    cv::VideoCapture cap(1);\n\n    if (!cap.isOpened())\n    {\n        std::cout &lt;&lt; \"Error opening camera\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    while (cap.read(frame))\n    {\n        if (frame.empty())\n        {\n            std::cout &lt;&lt; \"Error reading frame\" &lt;&lt; std::endl;\n            break;\n        }\n\n        faceDetection(frame);\n\n        if (cv::waitKey(10) == 'q')\n        {\n            break;\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"blogpost/Chandok/draft/#output","title":"Output","text":""},{"location":"blogpost/Chandok/final/","title":"Exploring Computer Vision with OpenCV and C++","text":""},{"location":"blogpost/Chandok/final/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li> <p>Installation</p> <ul> <li>Windows</li> <li>Mac</li> </ul> </li> <li> <p>Object Detection</p> <ul> <li>What is Object Detection?</li> <li>Applications of Object Detection</li> <li>How can we detect objects in images?</li> <li>Haar Cascades</li> <li>Features and Training</li> <li>Code</li> <li>Output</li> </ul> </li> <li> <p>References</p> </li> </ul>"},{"location":"blogpost/Chandok/final/#introduction","title":"Introduction","text":"<p>OpenCV is a powerful open source computer vision and machine learning library. Originally developed by Intel, it was later supported by Willow Garage then Itseez (which was later acquired by Intel). The library is cross-platform and free for use.</p> <p>OpenCV was designed for computational efficiency and with a strong focus on real-time applications. Written in optimized C/C++, the library can take advantage of multi-core processing. Enabled with OpenCL, it can take advantage of the hardware acceleration of the underlying heterogeneous compute platform.</p> <p>Adopted all around the world, OpenCV has more than 47 thousand people of user community and estimated number of downloads exceeding 14 million. Usage ranges from interactive art, to mines inspection, stitching maps on the web or through advanced robotics.</p> <p>Today we will be exploring the basics of OpenCV and how to use it with C++. We'll be developing a Face Detection algorithm. Face detection is a fundamental task in computer vision that involves locating and identifying human faces in images or video streams. It has a wide range of applications, from photography and video analysis to security systems and facial recognition.</p>"},{"location":"blogpost/Chandok/final/#installation","title":"Installation","text":""},{"location":"blogpost/Chandok/final/#windows","title":"Windows","text":"<ul> <li>Download the latest version of OpenCV from here</li> <li>Download the latest version of CMake from here</li> <li>Extract the zip file to a folder</li> <li>Add the path to the bin folder to the environment variable</li> <li>Add the path to the lib folder to the environment variable</li> <li>Open CLion and create a new project</li> <li>Add the following lines to the CMakeLists.txt file</li> </ul>"},{"location":"blogpost/Chandok/final/#mac","title":"Mac","text":"<ul> <li>Download the latest version of OpenCV from here</li> <li>Download the latest version of CMake from here</li> <li>Install the dmg package and launch it from Applications.</li> <li>From the CMake app window, choose menu Tools \u2013&gt; How to Install For Command Line Use. Then, follow the instructions from the pop-up there.</li> <li>Install folder will be /usr/bin/ by default, submit it by choosing Install command line links.</li> <li>Open CLion and create a new project</li> <li>Add the following lines to the CMakeLists.txt file</li> </ul> <pre><code>cmake_minimum_required(VERSION 3.26)\nproject(Blog)\n\nset(CMAKE_CXX_STANDARD 17)\n\nfind_package(OpenCV REQUIRED)\n\nset(SOURCE_FILES main.cpp)\n\nadd_executable(Blog ${SOURCE_FILES})\n\ntarget_link_libraries(Blog PRIVATE ${OpenCV_LIBS})\n</code></pre> <ul> <li>To ensure that OpenCV is installed and working correctly, we will try to display an image.</li> <li>Create a new file called main.cpp and add the following lines.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;string&gt;\n\nint main(int argc, char** argv )\n{\n    // Declare a variable to hold the image\n    cv::Mat image;\n\n    // TODO: Provide the path to the image you want to load\n    const std::string filename = \"TODO: Path to image\";\n    image = cv::imread(filename);\n\n    // Check if the image data was loaded successfully\n    if ( !image.data )\n    {\n        // Print an error message if the image data is not available\n        printf(\"No image data \\n\");\n        return -1;\n    }\n\n    // Create a window with the name \"Display Image\" and set its size automatically\n    namedWindow(\"Display Image\", cv::WINDOW_AUTOSIZE );\n\n    // Display the loaded image in the created window\n    imshow(\"Display Image\", image);\n\n    // Wait for a key press event (0 means wait indefinitely)\n    cv::waitKey(0);\n\n    return 0;\n}\n\n</code></pre> <ul> <li>Run the project, and you should see the image displayed in a window</li> </ul>"},{"location":"blogpost/Chandok/final/#possible-errors","title":"Possible Errors","text":"<ul> <li>If you get an error saying that the program can't start because opencv_worldXXX.dll is missing from your computer, you need to add the path to the bin folder to the environment variable</li> <li>If you get an error saying that the program can't start because MSVCP140D.dll is missing from your computer, you need to install the Visual C++ Redistributable for Visual Studio. You can download it from here</li> </ul>"},{"location":"blogpost/Chandok/final/#object-detection","title":"Object Detection","text":""},{"location":"blogpost/Chandok/final/#what-is-object-detection","title":"What is Object Detection?","text":"<p>Object detection is a computer vision technique that allows us to identify and locate objects in an image or video. With this kind of identification and localization, object detection can be used to count objects in a scene and determine and track their precise locations, all while accurately labeling them.</p>"},{"location":"blogpost/Chandok/final/#applications-of-object-detection","title":"Applications of Object Detection","text":"<p>Object detection has many applications, including: - Object Tracking - Security Systems - Autonomous Vehicles</p>"},{"location":"blogpost/Chandok/final/#how-can-we-detect-objects-in-images","title":"How can we detect objects in images?","text":"<p>There are many different algorithms that can be used to detect objects in images. Some of the most popular algorithms are: - Haar Cascades - Deep Learning - Histogram of Oriented Gradients (HOG)</p>"},{"location":"blogpost/Chandok/final/#haar-cascades","title":"Haar Cascades","text":"<p>We'll be using Haar Cascades for this project. Haar Cascade classifiers are an effective way for object detection. This method was proposed by Paul Viola and Michael Jones in their paper Rapid Object Detection using a Boosted Cascade of Simple Features in 2001. Haar cascade is an algorithm that can detect objects in images, irrespective of their scale in image and location.</p> <p>This algorithm is not so complex and can run in real-time. We can train a haar-cascade detector to detect various objects like faces, cars, buildings, fruits, etc. Let's try to understand how we can train harr cascades</p>"},{"location":"blogpost/Chandok/final/#features-and-training","title":"Features and Training","text":"<p>The first step is to collect the Haar features. A Haar feature is essentially calculations that are performed on adjacent rectangular regions at a specific location in a detection window. The calculation involves summing the pixel intensities in each region and calculating the differences between the sums.</p> <p>So to summarize, each feature is a single value obtained by subtracting sum of pixels under the white rectangle from sum of pixels under the black rectangle.</p> <p></p> <p>Training - The next step is to train the classifier. We need to provide a lot of positive and negative images to the classifier where positive images contain the images which we want our classifier to identify and negative images contain images that do not contain the object we want to detect. - The classifier is trained by extracting Haar features from each image to select a small number of critical features that can be used to identify the object. - Here's a visualization for Harr Cascade training</p> <p></p> <p>(Source: https://www.youtube.com/watch?v=hPCTwxF0qf4&amp;t=69s&amp;ab_channel=AnkurDivekar)</p> <ul> <li>Since we are using OpenCV, we don't need to worry about training the classifier. OpenCV comes with a lot of pre-trained classifiers that we can use for our project. We'll be using the Haar Cascade Classifier for face detection.</li> <li>OpenCV already contains many pre-trained classifiers for face, eyes, smile, etc. Those XML files are stored in the opencv/data/haarcascades/ folder.</li> <li>We'll be using the haarcascade_frontalface_alt.xml classifier for our project.   Here's the code:</li> </ul>"},{"location":"blogpost/Chandok/final/#code","title":"CODE","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;opencv2/objdetect.hpp&gt;\n#include &lt;opencv2/highgui.hpp&gt;\n#include &lt;opencv2/imgproc.hpp&gt;\n#include &lt;opencv2/videoio.hpp&gt;\n\ncv::CascadeClassifier face_cascade;\n\n// Function to perform face detection on the given frame\nvoid faceDetection(cv::Mat frame)\n{\n    // Convert the frame to grayscale to simplify face detection\n    cv::Mat frame_gray;\n    cv::cvtColor(frame, frame_gray, cv::COLOR_BGR2GRAY);\n\n    // Detect faces in the grayscale frame\n    std::vector&lt;cv::Rect&gt; faces;\n    face_cascade.detectMultiScale(frame_gray, faces);\n\n    // Draw ellipses around detected faces\n    for (auto &amp;face : faces)\n    {\n        // Calculate the center and draw an ellipse around the face\n        cv::Point center(face.x + face.width/2, face.y + face.height/2);\n        cv::ellipse(frame, center, cv::Size(face.width/2, face.height/2), 0, 0, 360, cv::Scalar(255, 0, 255), 4);\n\n        // Extract the region of interest (ROI) for each detected face (in grayscale)\n        cv::Mat faceROI = frame_gray(face);\n    }\n\n    // Display the frame with face detection\n    cv::imshow(\"Face Detection\", frame);\n}\n\nint main()\n{\n    // Path to the Haar cascade classifier for face detection\n    // TOOD: Provide the path to the classifier\n    // This classifier is provided with OpenCV and can be found in the opencv/data/haarcascades folder\n    std::string faceClassifierPath = R\"(TODO: Path to classifier)\";\n\n    // Load the face cascade classifier\n    if (!face_cascade.load(faceClassifierPath))\n    {\n        std::cout &lt;&lt; \"Error loading face classifier\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::cout &lt;&lt; \"Face classifier loaded successfully\" &lt;&lt; std::endl;\n\n    // Open the default camera (camera index 0)\n    cv::VideoCapture cap(1);\n\n    // Check if the camera is opened successfully\n    if (!cap.isOpened())\n    {\n        std::cout &lt;&lt; \"Error opening camera\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    cv::Mat frame;\n    // Main loop to capture frames from the camera and perform face detection\n    while (cap.read(frame))\n    {\n        // Check if the frame is empty\n        if (frame.empty())\n        {\n            std::cout &lt;&lt; \"Error reading frame\" &lt;&lt; std::endl;\n            break;\n        }\n\n        // Perform face detection on the current frame\n        faceDetection(frame);\n\n        // Break the loop if the 'q' key is pressed\n        if (cv::waitKey(10) == 'q')\n        {\n            break;\n        }\n    }\n\n    return 0;\n}\n\n</code></pre>"},{"location":"blogpost/Chandok/final/#output","title":"Output","text":""},{"location":"blogpost/Chandok/final/#references","title":"References","text":"<ul> <li>https://docs.opencv.org/2.4/doc/tutorials/objdetect/cascade_classifier/cascade_classifier.html</li> <li>https://www.youtube.com/watch?v=hPCTwxF0qf4&amp;t=69s&amp;ab_channel=AnkurDivekar</li> <li>https://medium.com/analytics-vidhya/haar-cascades-explained-38210e57970d</li> </ul>"},{"location":"blogpost/Du/final/","title":"Final","text":"<p>Welcome to the delightful world of C++ lambdas\u2014a tool that transforms verbose code into a symphony of succinctness. These anonymous functions are the unsung heroes of in-line execution, allowing you to capture variables and craft compact code blocks right where you need them. Whether you're sorting data with a custom touch or iterating with finesse, lambdas are your ticket to efficient, readable code. As we peel back the layers of this powerful feature, you'll discover how to harness it in your C++ endeavors, making your programming journey not just more productive, but also more enjoyable.</p> <p>A lambda expression can capture variables from its enclosing scope, take parameters, and deduce or define a return type. The capture clause of a lambda can be particularly nuanced. It can capture local variables by value (copied into the lambda) or by reference, and it can even capture the <code>this</code> pointer to access members of the enclosing class.</p> <p>In simple terms, a Lambda function is also a function whose syntax is defined as follows:</p> <p>The code is as follows.</p> <pre><code>[capture](parameters) mutable -&gt;return-type{statement}\n</code></pre> <ol> <li><code>[capture]</code>: Capture list. The capture list always appears at the beginning of a Lambda function. In fact, [] is a Lambda quote. The compiler determines whether the next code is a Lambda function based on this quote. Capture lists can capture variables in context for use by Lambda functions.</li> </ol> <p>2.<code>(parameters)</code>: the list of parameters. This is the same as the parameter list of a normal function. If you don't need to pass parameters, you can omit them along with the parentheses \"()\".</p> <ol> <li><code>mutable</code>: mutable modifier. By default, a Lambda function is always a const function, mutable removes its constancy. When using this modifier</li> </ol> <p>When using this modifier, the argument list cannot be omitted (even if the arguments are empty).</p> <p>4.<code>-&gt;return-type</code>: the return type. Declare the return type of a function in the form of a traced return type. We can also omit the symbol \"-&gt;\" along with the return value when it is not needed. In addition, in cases where the return type is explicit, it can be omitted to allow the compiler to derive the return type.</p> <p>5.<code>{statement}:</code>the body of the function. The content is the same as a normal function, but in addition to parameters, all captured variables can be used.</p> <p>The biggest difference from normal functions is that, in addition to being able to use arguments, Lambda functions can access some data in context via a capture list. Specifically, a capture list describes what data in the context is available to Lambda and how it can be used (as value-passing or reference-passing). Syntactically, included in \"[]\" is the capture list, which consists of multiple capture items separated by commas. Capture lists have the following forms:</p> <p>1.<code>[var]</code> indicates that the variable var is captured by value passing;</p> <ol> <li> <p><code>[=]</code> indicates that all parent-scoped variables (including this) are captured by value passing;</p> </li> <li> <p><code>[&amp;var]</code> indicates that the variable var is captured by reference passing;</p> </li> </ol> <p>4.<code>[&amp;]</code> indicates that the reference passing method captures all parent-scoped variables (including this);</p> <ol> <li><code>[this]</code> means that value passing captures the current this pointer.</li> </ol> <p>Above mentioned a parent scope, that is, the statement block containing the Lambda function, in layman's terms, is the \"{}\" code block containing Lambda. The above list of captures can also be combined, for example:</p> <p>1.<code>[=,&amp;a,&amp;b]</code> captures variables a and b by reference, and all other variables by value.</p> <p>2.<code>[&amp;,a,this]</code> means that variables a and this are captured by value passing, and all other variables are captured by reference passing.</p> <p>The important thing is, however, that capture lists do not allow variables to be passed repeatedly. The following examples are typical of duplicates, which can lead to compile-time errors. For example:</p> <p>3.<code>[=,a]</code> Here all the variables have been captured by value passing, but the a is duplicated, which will result in an error.</p> <p>4.<code>[&amp;,&amp;this]</code> Here &amp; has captured all the variables by reference passing, and capturing this is also a duplication.</p> <p>Let\u2019s see an example, the basic version of lambda with no parameter or return value. </p> <pre><code>auto func1 = [](){ cout &lt;&lt; \"hello world!\" &lt;&lt; endl; };\nfunc1();\n</code></pre> <p>Here, <code>func1</code> is a lambda function that, when called, prints \"hello world!\" to the standard output. It's defined with an empty capture clause <code>[]</code>, indicating that it does not capture any variables from its enclosing scope. </p> <pre><code>auto func2 = [](int a, int b)-&gt;int {return a + b; };\ncout&lt;&lt;func2(20, 30)&lt;&lt;endl;\n</code></pre> <p>And here, <code>func2</code>, which is a lambda function whose arguments and return value are integers, it returns the sum of 2 integer parameters, in the cout line, the function return value is 50.</p> <p>In addition, we can also use the lambda to capture the reference. In the following code, the lambda has access to the variables from the enclosing scope by their references, not by their values. </p> <pre><code>int x = 10;\nauto lambda_by_value = [x]() mutable { x = 42; }; // capture x by value\nauto lambda_by_reference = [&amp;x]() { x = 42; }; // capture x by reference\n\nlambda_by_value();// Here x is still 10, because the lambda internally modifies a copy of x\n\nlambda_by_reference();// Here x becomes 42, because lambda modifies x directly by reference\n</code></pre> <p>In summary, In a lambda expression, the capture list corresponds to the types of member variables within a class, while the return type and parameter list correspond to those of the <code>operator()</code> method's return type and parameter list, respectively. Now we are going to talk more about the usage of lambda.</p> <p>Sometimes, the lambda can be used to replace some old methods when dealing with a problem. For instance, consider a simple calculator that performs arithmetic operations based on user input. Traditionally, this could be handled with a <code>switch</code> statement, as shown in the following code:</p> <pre><code>// Function that performs arithmetic based on the user's choice.\nint operation(int choice, int a, int b) {\n    switch (choice) {\n        case 1: // If the user chooses 1, perform addition.\n            return a + b;\n        case 2: // If the user chooses 2, perform subtraction.\n            return a - b;\n        case 3: // If the user chooses 3, perform multiplication.\n            return a * b;\n        case 4: // If the user chooses 4, perform division.\n            return a / b;\n        default: // If the user input doesn't match any case, throw an error.\n            throw std::invalid_argument(\"Invalid operation\");\n    }\n}\n\n// Usage example:\n// int result = operation(2, 10, 15); // This would perform subtraction: 10 - 15\n</code></pre> <p>In this example, the <code>operation</code> function takes the user's choice and two integer operands as arguments. The <code>switch</code> statement inside the function checks the value of <code>choice</code> and executes the operation associated with that value. If the user enters a number that isn't 1, 2, 3, or 4, the default case throws an exception, indicating an invalid operation was chosen.</p> <p>This code is used for a simple calculator program where the user is prompted to input their choice of operation along with the two numbers they wish to calculate. The result of the operation is then returned and can be displayed or used elsewhere in the program.</p> <p>This method is straightforward, but as the number of operations grows, the <code>switch</code> statement becomes lengthy and harder to manage. Moreover, each time a new operation is added or an existing one is changed, the entire <code>switch</code> must be revisited and potentially modified, which can introduce errors. However, we can use lambda expressions to create a more elegant and scalable solution. Lambdas allow us to define functions on the fly and store them in a map, associating each arithmetic operation with a unique key. Here's how we could reimagine our calculator using lambdas:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;functional&gt;\n\nint main() {\n    // A map associating operation codes with corresponding lambda expressions\n    std::map&lt;int, std::function&lt;int(int, int)&gt;&gt; calculateMap{\n        {1, [](int a, int b) { return a + b; }}, // Addition\n        {2, [](int a, int b) { return a - b; }}, // Subtraction\n        {3, [](int a, int b) { return a * b; }}, // Multiplication\n        {4, [](int a, int b) { return a / b; }}  // Division\n    };\n\n    std::cout &lt;&lt; \"Enter operation code (1 for add, 2 for subtract, 3 for multiply, 4 for divide): \";\n    int choice;\n    std::cin &gt;&gt; choice;\n\n    // Execute the chosen operation with the operands 10 and 15\n    std::cout &lt;&lt; \"10 op 15: \" &lt;&lt; calculateMap[choice](10, 15) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>In this lambda-based method, each arithmetic operation is a small, self-contained lambda function stored in <code>calculateMap</code>. When the program runs, it asks for the user's input to select an operation. The user's choice then directly maps to the corresponding lambda, which is executed with two predefined operands (in this example, <code>10</code> and <code>15</code>).</p> <p>This approach is beneficial because adding a new operation is as simple as adding a new entry to the <code>calculateMap</code>. There's no need to modify any existing <code>switch</code> or <code>if</code> structures, and the code related to each arithmetic operation is neatly encapsulated within its lambda. This method is not only clearer but also reduces the likelihood of errors that can occur when dealing with multiple branching paths. Furthermore, this structure naturally lends itself to more complex scenarios, such as adding additional functionality without disrupting the existing codebase. It is a testament to the power and flexibility that lambda expressions bring to C++ programming.</p> <p>For instance, if we want to add the modulus operation into the calculator, by using switch the code would need to be modified as follows:</p> <pre><code>#include &lt;iostream&gt;\n\nint operation(int choice, int a, int b) {\n    switch (choice) {\n        case 1: return a + b; // Addition\n        case 2: return a - b; // Subtraction\n        case 3: return a * b; // Multiplication\n        case 4: return a / b; // Division\n        case 5: return a % b; // Modulus (new operation)\n        default: throw std::invalid_argument(\"Invalid operation\");\n    }\n}\n\nint main() {\n    std::cout &lt;&lt; \"Enter operation code (1 for add, 2 for subtract, 3 for multiply, 4 for divide, 5 for modulus): \";\n    int choice, a = 10, b = 15;\n    std::cin &gt;&gt; choice;\n\n    try {\n        int result = operation(choice, a, b);\n        std::cout &lt;&lt; \"Result: \" &lt;&lt; result &lt;&lt; std::endl;\n    } catch (const std::invalid_argument&amp; e) {\n        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>In this <code>switch</code> statement example, we must modify the <code>operation</code> function every time a new operation is added. This can quickly become unwieldy and prone to errors, especially as the number of operations grows. we must also handle the default case to catch any invalid operation codes, which adds additional complexity.</p> <p>Now, let's compare this with the lambda approach:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;functional&gt;\n\nint main() {\n    std::map&lt;int, std::function&lt;int(int, int)&gt;&gt; calculateMap{\n        {1, [](int a, int b) { return a + b; }},\n        {2, [](int a, int b) { return a - b; }},\n        {3, [](int a, int b) { return a * b; }},\n        {4, [](int a, int b) { return a / b; }},\n        {5, [](int a, int b) { return a % b; }} // Easily added new operation\n    };\n\n    std::cout &lt;&lt; \"Enter operation code: \";\n    int choice, a = 10, b = 15;\n    std::cin &gt;&gt; choice;\n\n    try {\n        std::cout &lt;&lt; \"Result: \" &lt;&lt; calculateMap.at(choice)(a, b) &lt;&lt; std::endl;\n    } catch (const std::out_of_range&amp; e) {\n        std::cerr &lt;&lt; \"Invalid operation code.\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>With lambdas, you can add a new operation to the <code>calculateMap</code> without changing any other code. Each operation is self-contained, and the map itself handles invalid operation codes with a simple <code>try-catch</code> block. In conclusion, while both <code>switch</code> statements and lambdas can achieve the same result, the lambda approach in C++ is typically more maintainable and scalable, particularly when dealing with a growing set of operations. Yet, one must be cautious. Capturing by reference can inadvertently extend the lifetime of stack variables, potentially leading to undefined behavior if the lambda outlives its capture scope. Additionally, each lambda has an associated cost with state storage \u2014 the more you capture, the larger the state. For example, capturing large objects by value can significantly increase the size of the lambda's closure object, which can impact performance. </p> <p>In this exploration of C++ lambda expressions, we have systematically introduced their fundamental syntax and practical applications. A focal point of the discussion was the implementation of a rudimentary calculator program, where lambda expressions were juxtaposed with traditional switch-case constructs. Through a meticulous comparison and performance analysis, we underscored the superior maintainability and scalability of lambdas. They not only streamline the codebase but also exhibit potential performance advantages through in-line execution and overhead reduction. This comprehensive overview substantiates the assertion that lambda expressions are an indispensable instrument in the contemporary C++ developer's repertoire, facilitating the creation of code that is both elegant and performant.</p> <pre><code>\n</code></pre>"},{"location":"blogpost/Garvey/draft/","title":"Using AI to Solve AI","text":""},{"location":"blogpost/Garvey/draft/#lauren-garvey-october-2023","title":"Lauren Garvey, October 2023","text":""},{"location":"blogpost/Garvey/draft/#for-cse-491-at-msu","title":"For CSE 491 at MSU","text":"<p>In a previous semester, I took a course on introduction to AI. Rather than using an AI tool, we were given projects that were more about the math behind decision-making, all set against the backdrop of trying to guide Pacman to complete certain goals in a given world. The first project was about basic search algorithms and some simple alternative goals, such as hitting all four corners of the map or eating every food pellet. The second was on optimization, specifically with linear and integer programming as a means to look at feasible intersection points, constraints, and cost vectors. The third was about reinforcement learning, where variations on rewards and moves were utilized in getting Pacman to the best outcome. The fourth and final project was on Bayesian networks, where Pacman sensed the world around him to locate and chase invisible ghosts. All of these projects were developed at UC Berkeley, primarily by John DeNero and Dan Klein[^1].</p> <p>Having now completed the course, I was curious about how an AI would fare against solving these AI problems. I specifically wanted to have ChatGPT solve one of these projects, so I could then compare it to my own solutions. I wasn't terribly interested in the first project, since the functions included searches like breadth-first, depth-first, A*, and uniform cost search, all of which are fairly common and not likely to be interesting if I asked ChatGPT to implement them. The second project involved a decent amount of problem formulation based on a given scenario, which seemed like it would be more focused on getting ChatGPT to come up with a relevant problem, instead of solving one. This left reinforcement learning and Bayesian networks, and I frankly think the former would be more exciting to solve with ChatGPT.</p> <p>Since this project is still in use for the course, I won't go into the specifics of how ChatGPT solved it, but rather deconstruct what worked and what didn't, as well as some of the back-and-forth it took to reach the final output.</p>"},{"location":"blogpost/Garvey/draft/#part-1-value-iteration","title":"Part 1 -  Value Iteration","text":"<p>As described in the project, value iteration computes k-step estimates of the optimal values, V<sub>k</sub>. To begin with, I prompted ChatGPT with the following:</p> <p><code>Can you please write some C++ value iteration functions for me? The first would be 'runValueIteration'. This function should iterate over the values and update accordingly. It should call 'computeQValuefromValues(state, action)', which computes the Q-value of 'action' in 'state' from a given value function.</code></p> <p>The resulting code was pretty solid, as it knew to keep track of the maximum Q-value, but it was slightly off in its method. Similar to my implementation, ChatGPT used a vector to store all of the values, and ran the <code>std::max_element</code> algorithm once per loop to update the values at that specific state. It was missing a final step, though, as the overall values also needed to keep track of a mapping from <code>state</code> to <code>max_Q_value</code> for that state. After pointing this out, ChatGPT added the appropriate line as needed.</p> <p>I also asked ChatGPT to write the <code>computeActionFromValues(state)</code> and the <code>computeQValueFromValues(state, action)</code> functions, but because these were simple implementations that involved iterating over every possible Q-Value and action, things looked clean from the outset. The only sticking point was in the Q-Value function, where there was some confusion with the math being performed. Ideally, it would perform in accordance with the value iteration state update equation:</p> <p></p> <p>Or, equivalently:</p> <p><code>(The next value at state s) = maximum of the sum over s' of (probability * (reward + gamma * Vk(S')))</code></p> <p>In this equation, 'gamma' is the discount factor, ranging from 0 to 1. As gamma gets closer to 1, the agent values future rewards more closely to immediate rewards, while a gamma value of zero will make the agent only value immediate rewards. V<sub>k</sub>(S') represents the estimated value of the next state, S', in the Q-value computation. This equation is supposed to consider both the immediate reward and the potential future rewards, and return the final Q-Value to the <code>runValueIteration</code> function as a candidate for the best possible value. The trouble came when ChatGPT tried to write this function, and instead of keeping a running total of the Q-value for the single state and action, it initially did something similar to its behavior on the first function: It stored every intermediate total in a vector of doubles, then returned only the maximum element from that vector. I assume this is from trying to find the 'best' Q-Value, rather than recognizing that the running total applied to the entirety of the passed-in <code>state</code> and <code>action</code> arguments. Similarly to before, once I pointed this out, it was a simple fix of switching from the vector behavior to a single running total.</p> <p>As an interesting aside, I later had to go back and re-prompt ChatGPT with the same question, because I'd misplaced its version of the code and wanted to compare another function with it. When I asked the same question with the same phrasing, it kept what I assume was a map of the current value at a state to that state's Q-value. I can't say for sure, since the type was not explicitly defined in the code, and no such map was given in the starter code. The reason this caught my attention is that, instead of making an additional vector to track the intermediate totals, it seemingly stored them in the 'current value' map as it went along, and swapped in the new Q-value when it was greater than the old value. I'm not sure how it landed on this different behavior, since both times, the prompts were only preceded by me saying 'hi!' before requesting it to write the code.</p>"},{"location":"blogpost/Garvey/draft/#part-2-asynchronous-value-iteration","title":"Part 2 - Asynchronous Value Iteration","text":"<p>This version of the iteration is 'asynchronous' because it only updates one state per iteration, instead of a batch-style update like before. That is, on the i'th iteration, it should update the value of the i'th state in the states list. Following is the prompt I gave ChatGPT:</p> <p><code>Before, I had you write a C++ function called 'runValueIteration', which iterated over and updated the values, calling 'computeQValuefromValues' in the process. Can you please do this again, but instead of updating all of the values, have it only update the value of the i'th state in the states list on the i'th iteration?</code></p> <p>Again, the general idea was correct, but there were a few small tweaks that needed to be made. First, ChatGPT was tracking whether the function had converged, which wasn't necessarily incorrect, but rather solved a different edge case than the one I'd intended. It was supposed to terminate once every iteration had been checked and updated as needed, since there was nowhere to progress if Pacman was at an end state. Instead, it checked for convergence based on whether the difference between the old and the new value at a given state was less than a specified value 'epsilon.' This is incorrect for a couple of reasons, not least of which is that no epsilon was provided, neither in my prompt nor in the starter code. My best guess is that this use of epsilon was as an early exit strategy, but the overall function was wrapped within the clause comparing the value difference to epsilon. Then, within that 'while' wrapper, there was a for-loop going over every iteration, as I specified. Given the epsilon condition, it would hit each iteration several times over, which is inconsistent with my prompt. I'm unsure whether I needed to be more clear, or if ChatGPT just pulled what it knew of generic asynchronous value iteration and spat that back out.</p>"},{"location":"blogpost/Garvey/draft/#part-3-prioritized-sweeping-value-iteration","title":"Part 3 - Prioritized Sweeping Value Iteration","text":"<p>Similar to parts 1 and 2, this section required a new implementation of <code>runValueIteration</code>, now with an effort to focus updates of state values in such a way that the policy was likely to change. The instructions were rather specific in terms of the algorithm to follow when implementing the function, so instead of giving ChatGPT an easy way out, I prompted with a more general description:</p> <p><code>Could you please implement another version of 'runValueIteration' in C++, but this time, have it do a simplified version of the standard prioritized sweeping algorithm? We are given the following: predecessors of a state 's' are all states with a nonzero probability of reaching 's' by taking some action'a'. 'Theta' represents our tolerance for error when deciding whether to update a state's value.</code></p> <p>As before, the code was generally correct, but it was a little more general than it ought to have been. The first step was to compute the predecessors of every state, which ChatGPT did correctly, but there could have been an additional check for whether a state was terminal, since those didn't need to be dealt with for our purposes. Similar to my second prompting with the first part, it assumed a variable 'current values' could be indexed by a state, and stored the running maximum Q-Value in that variable as needed. It used a priority queue and updated as expected, but there was a snag involving the variable 'theta.' This is perhaps due to the ambiguity regarding theta in the prompt, as ChatGPT decided that a state's priority needed to surpass the value of theta to merit updating, when in fact it should have depended on the difference between the maximum Q-Value at a state and the predecessor's value.</p>"},{"location":"blogpost/Garvey/draft/#part-4-q-learning","title":"Part 4 - Q-Learning","text":"<p>For all of the functions written so far, all of the reinforcement learning was in-place, such that Pacman was given the optimal path before taking his first move. The back half of the project focused on the case where Pacman did not necessarily have this information at the outset, and instead had to learn as he went\u2014this is closer to the general idea of 'reinforcement learning' as I would conceptualize it.</p> <p>I asked ChatGPT to implement the Q-Learning agent stub as it was provided in the starter code, largely by prompting it with each function declaration and giving it the details we had when doing the project in class. The functions of note were <code>update(state, action, nextState, reward)</code>, <code>computeValueFromQValues(state)</code>, <code>getQValue(state, action)</code>, <code>computeActionFromQValues(state)</code>, and <code>getAction(state)</code>. Individually, these functions were all rather simple, and the complexity came more from all of them needing to be operational in order to call each other.</p> <p><code>getQValue</code> only needed to return the Q-Value at a given <code>(state, action)</code> tuple, which relied on storing the Q-Values for the agent somewhere in its class. The manner of storing those as a member variable is the only way I really expected ChatGPT's implementation to differ from mine, as there wasn't a specific instruction for how to do so, but there are a couple different data structures it could have conceivably used.</p> <p><code>getAction</code> was also straight-forward, as it simply needed to return a random action with a probability of the member value <code>epsilon</code>, and otherwise return an action using a pre-defined function.</p> <p><code>computeValueFromQValues</code> and <code>computeActionFromQValues</code> were similar to each other, as both relied on iterating over the possible actions and finding the maximum relevant value. I was a little surprised to see that ChatGPT did this directly in both functions, since to me, the fact that the functions were so similar would lend itself well to combining them in a helper function. I probably shouldn't be too put-off, because I did the same thing for my project, but I felt that ChatGPT could have had the combined fore- and hindsight to do less work with that sort of thing. I do also have the advantage of knowing that my code works from having previously turned it in, which makes it easier to see where ChatGPT's (and my) implementation could have been improved.</p> <p>Finally, <code>update</code> had a fairly predictable solution, as it directly relied on calculating the reward transition and saving that as appropriate into the chosen storage member variable. The only error came in from certain member variables like <code>alpha</code> and <code>discount</code> not being known to ChatGPT, so it set them to a static number at the beginning of the function. On correction of this part, ChatGPT's code was again fine.</p>"},{"location":"blogpost/Garvey/draft/#part-5-conclusion","title":"Part 5 - Conclusion","text":"<p>Despite my more optimistic hopes, ChatGPT did pretty well on completing this project, and probably would've gotten at least a solid 75% before any corrective prompting or interpretation on my part. I knew better than to expect it would be a complete disaster, given that using AI for coding classes is becoming a more prevalent concern (or tool, depending on who you ask), but I thought it might not be quite so seamless. I imagine the moderate success is due to the fact that, as ChatGPT has gotten more popular, it's gotten better at producing something useful directly out of the gate, rather than after considerable re-prompting. A simple search like 'increased use of ChatGPT in coding classes' returns several tutorials on how to use the AI to one's advantage, and even some forum posts asking whether it's even worth it to bother learning coding anymore.</p> <p>It would be foolish to ignore the obvious benefits of using ChatGPT for lower-level coding problems, such as a seasoned developer verifying that their syntax and behavior is correct, but plenty of people have already pointed out the concerns with it, too. This post alone is one such example, where the only actual coding on my part was running ChatGPT's code, and figuring out where and why it didn't work. The point of the original project obviously did include some user debugging, such that we could learn the reasoning behind what they were having us implement, but that wasn't all of it. Only doing the trouble-shooting, to the point that any actual coding on our part would have been what we fed ChatGPT, certainly wouldn't have been as beneficial to learning the material as us doing the work ourselves.</p> <p>There isn't necessarily some grand point to be made here, especially when the same idea has already been restated and picked apart in more official capacities, but it still seems worthwhile to consider the difference in ChatGPT across disciplines. While only an anecdote, there is an article[^2] about a professor, C.W. Howell, who had his students generate an essay with ChatGPT, and then grade it themselves. According to Howell, all of the essays had errors, including citing sources that didn't even exist. The article goes more in-depth on the students' reactions to the essays and mistakes, but I bring it up because those errors seem much more egregious than the ones I encountered when having ChatGPT do this project. The errors I saw were all relatively minor, and often based on the fact that there was some variable ChatGPT didn't know about, or else a method it didn't know to call. It's hard to delineate where the line is, but I do think it's interesting that the AI seems more adept at certain topics than others, at least anecdotally.</p> <p>[^1]: The Pacman AI projects were developed at UC Berkeley (http://ai.berkeley.edu). The core projects and autograders were primarily created by John DeNero (denero@cs.berkeley.edu) and Dan Klein (klein@cs.berkeley.edu). [^2]: Howell, C.W. \u201cDon\u2019t Want Students to Rely on ChatGPT? Have Them Use It.\u201d Wired, Conde Nast, 6 June 2023, www.wired.com/story/dont-want-students-to-rely-on-chatgpt-have-them-use-it/.</p>"},{"location":"blogpost/Garvey/final/","title":"Using AI to Solve AI","text":""},{"location":"blogpost/Garvey/final/#lauren-garvey-november-2023","title":"Lauren Garvey, November 2023","text":""},{"location":"blogpost/Garvey/final/#for-cse-491-at-msu","title":"For CSE 491 at MSU","text":"<p>In a previous semester, I took a course on introduction to AI. Rather than using an AI tool, we were given projects that were more about the math behind decision-making, all set against the backdrop of trying to guide Pacman to complete certain goals in a given world. The first project was about basic search algorithms and some simple alternative goals, such as hitting all four corners of the map or eating every food pellet. The second was on optimization, specifically with linear and integer programming as a means to look at feasible intersection points, constraints, and cost vectors. The third was about reinforcement learning, where variations on rewards and moves were utilized in getting Pacman to the best outcome. The fourth and final project was on Bayesian networks, where Pacman sensed the world around him to locate and chase invisible ghosts. All of these projects were developed at UC Berkeley, primarily by John DeNero and Dan Klein[^1].</p> <p>Having now completed the course, I was curious about how an AI would fare against solving these AI problems. I specifically wanted to have ChatGPT solve one of these projects, so I could then compare it to my own solutions. I wasn't terribly interested in the first project, since the functions included searches like breadth-first, depth-first, A*, and uniform cost search, all of which are fairly common and not likely to be interesting if I asked ChatGPT to implement them. The second project involved a decent amount of problem formulation based on a given scenario, which seemed like it would be more focused on getting ChatGPT to come up with a relevant problem, instead of solving one. This left reinforcement learning and Bayesian networks, and I frankly think the former would be more exciting to solve with ChatGPT.</p> <p>Since this project is still in use for the course, I won't go into the specifics of how ChatGPT solved it, but rather deconstruct what worked and what didn't, as well as some of the back-and-forth it took to reach the final output.</p>"},{"location":"blogpost/Garvey/final/#part-1-value-iteration","title":"Part 1 -  Value Iteration","text":"<p>As described in the project, value iteration computes k-step estimates of the optimal values, $V_k$. In simpler terms, it looks at Pacman's \"score\" at each possible step, and picks the direction that optimizes that score. This happens in a batch, meaning the best values at every possible state are calculated. Provided in the project specs was the following image, which demonstrates how taking certain steps from the bottom left starting position could result in better scores.</p> <p></p> <p>To begin with, I prompted ChatGPT with the following:</p> <p><code>Can you please write some C++ value iteration functions for me? The first would be 'runValueIteration'. This function should iterate over the values and update accordingly. It should call 'computeQValuefromValues(state, action)', which computes the Q-value of 'action' in 'state' from a given value function.</code></p> <p>The resulting code was pretty solid, as it knew to keep track of the maximum Q-value, but it was slightly off in its method. Similar to my implementation, ChatGPT used a vector to store all of the values, and ran the <code>std::max_element</code> algorithm once per loop to update the values at that specific state. It was missing a final step, though, as the overall values also needed to keep track of a mapping from <code>state</code> to <code>max_Q_value</code> for that state. After pointing this out, ChatGPT added the appropriate line as needed.</p> <p>I also asked ChatGPT to write the <code>computeActionFromValues(state)</code> and the <code>computeQValueFromValues(state, action)</code> functions, but because these were simple implementations that involved iterating over every possible Q-Value and action, things looked clean from the outset. The only sticking point was in the Q-Value function, where there was some confusion with the math being performed. Ideally, it would perform in accordance with the value iteration state update equation:</p> <p></p> <p>Or, equivalently:</p> <p><code>(The next value at state s) = maximum of the sum over s' of (probability * (reward + gamma * Vk(S')))</code></p> <p>In this equation, 'gamma' is the discount factor, ranging from 0 to 1. As gamma gets closer to 1, the agent values future rewards more closely to immediate rewards, while a gamma value of zero will make the agent only value immediate rewards. V<sub>k</sub>(S') represents the estimated value of the next state, S', in the Q-value computation. This equation is supposed to consider both the immediate reward and the potential future rewards, and return the final Q-Value to the <code>runValueIteration</code> function as a candidate for the best possible value.</p> <p>In terms of how this mattered to Pacman, consider the following images:</p> <p></p> <p>Pacman is in a very desirable position here - he has plenty of food pellets nearby, and with Inky and Clyde far away, he is not in any immediate danger. He could keep gathering food pellets and staying alive, both of which are worth points. Since this would result in a higher score for this sort of position (one where Pacman is near food pellets, but not near ghosts), positions (or \"states\") similar to this one would be correlated to a higher score, or \"value.\"</p> <p></p> <p>Here, Pacman is much worse off. He is only one wrong step away from dying to Clyde, and a few moves away from being caught by another ghost. Additionally, he only has one food pellet readily available, even if it is a bigger one - these functions don't know that power pellets would normally let Pacman eat a ghost. All of this together would result in a position similar to this (near a ghost, and not near much food) having a very low score, or \"value,\" so the corresponding state would not be prioritized as much in the functions above.</p> <p>Taken together, if these two states were fed to the function, the one assigned to $V_{k+1}(s)$ would be the state with the better value - namely, the first of the two. Over a greater number of states with less obvious differences, it becomes more important to select one with a higher value, while also considering the probability of ever reaching that state.</p>"},{"location":"blogpost/Garvey/final/#part-1-critique","title":"Part 1 Critique","text":"<p>The trouble came when ChatGPT tried to write this function, and instead of keeping a running total of the Q-value for the single state and action, it initially did something similar to its behavior on the first function: It stored every intermediate total in a vector of doubles, then returned only the maximum element from that vector. I assume this is from trying to find the 'best' Q-Value, rather than recognizing that the running total applied to the entirety of the passed-in <code>state</code> and <code>action</code> arguments. Similarly to before, once I pointed this out, it was a simple fix of switching from the vector behavior to a single running total.</p> <p>As an interesting aside, I later had to go back and re-prompt ChatGPT with the same question, because I'd misplaced its version of the code and wanted to compare another function with it. When I asked the same question with the same phrasing, it kept what I assume was a map of the current value at a state to that state's Q-value. I can't say for sure, since the type was not explicitly defined in the code, and no such map was given in the starter code. The reason this caught my attention is that, instead of making an additional vector to track the intermediate totals, it seemingly stored them in the 'current value' map as it went along, and swapped in the new Q-value when it was greater than the old value. I'm not sure how it landed on this different behavior, since both times, the prompts were only preceded by me saying 'hi!' before requesting it to write the code.</p>"},{"location":"blogpost/Garvey/final/#part-2-asynchronous-value-iteration","title":"Part 2 - Asynchronous Value Iteration","text":"<p>This version of the iteration is 'asynchronous' because it only updates one state per iteration, instead of a batch-style update like before. That is, on the i'th iteration, it should update the value of the i'th state in the states list. Following is the prompt I gave ChatGPT:</p> <p><code>Before, I had you write a C++ function called 'runValueIteration', which iterated over and updated the values, calling 'computeQValuefromValues' in the process. Can you please do this again, but instead of updating all of the values, have it only update the value of the i'th state in the states list on the i'th iteration?</code></p> <p>Consider again the first image provided in Part 1:</p> <p></p> <p>With the value iteration function before, every state's possible values were considered. For asynchronous iteration, we can begin by looking at the squares labelled $0.27$ and $0.22$. On the first iteration, with $i=0$, we would look at state $0$, and calculate its value, which turns out to be $0.27$. We would ignore all the other states. The next time through with $i=1$, state $1$ would be considered, and given its value of $0.22$. All of the states are visited once per loop in this fashion, and after each has been seen once, the cycle begins again at $i=0$. It starts over like this because there is new information for each state about its neighbors. For example, suppose the square directly above the state happened to be valued at $0.7$ - then a state leading there would be worth more, right? So the state labelled $0.27$ would then earn a higher value on its turn through the iteration.</p>"},{"location":"blogpost/Garvey/final/#part-2-critique","title":"Part 2 Critique","text":"<p>Again, the general idea was correct, but there were a few small tweaks that needed to be made. First, ChatGPT was tracking whether the function had converged, which wasn't necessarily incorrect, but rather solved a different edge case than the one I'd intended. It was supposed to terminate once every iteration had been checked and updated as needed, since there was nowhere to progress if Pacman was at an end state. Instead, it checked for convergence based on whether the difference between the old and the new value at a given state was less than a specified value 'epsilon.' This is incorrect for a couple of reasons, not least of which is that no epsilon was provided, neither in my prompt nor in the starter code. My best guess is that this use of epsilon was as an early exit strategy, but the overall function was wrapped within the clause comparing the value difference to epsilon. Then, within that 'while' wrapper, there was a for-loop going over every iteration, as I specified. Given the epsilon condition, it would hit each iteration several times over, which is inconsistent with my prompt. I'm unsure whether I needed to be more clear, or if ChatGPT just pulled what it knew of generic asynchronous value iteration and spat that back out.</p>"},{"location":"blogpost/Garvey/final/#part-3-prioritized-sweeping-value-iteration","title":"Part 3 - Prioritized Sweeping Value Iteration","text":"<p>Similar to parts 1 and 2, this section required a new implementation of <code>runValueIteration</code>, now with an effort to focus updates of state values in such a way that the policy was likely to change. Where before it cared about every state's updated value, though, this part looked more at updating values if that seemed likely to matter overall. For example, in the grid used prior, that bottom-right square labeled $0.13$ is unreachable, so this function ought not waste its time calculating its value every time.</p> <p>The instructions were rather specific in terms of the algorithm to follow when implementing the function, so instead of giving ChatGPT an easy way out, I prompted with a more general description:</p> <p><code>Could you please implement another version of 'runValueIteration' in C++, but this time, have it do a simplified version of the standard prioritized sweeping algorithm? We are given the following: predecessors of a state 's' are all states with a nonzero probability of reaching 's' by taking some action'a'. 'Theta' represents our tolerance for error when deciding whether to update a state's value.</code></p> <p>As before, the code was generally correct, but it was a little more basic than it ought to have been. The first step was to compute the predecessors of every state, which ChatGPT did correctly, but there could have been an additional check for whether a state was terminal, since those didn't need to be dealt with for our purposes. Similar to my second prompting with the first part, it assumed a variable 'current values' could be indexed by a state, and stored the running maximum Q-Value in that variable as needed. It used a priority queue and updated as expected, but there was a snag involving the variable 'theta.' This is perhaps due to the ambiguity regarding theta in the prompt, as ChatGPT decided that a state's priority needed to surpass the value of theta to merit updating, when in fact it should have depended on the difference between the maximum Q-Value at a state and the predecessor's value.</p>"},{"location":"blogpost/Garvey/final/#part-4-q-learning","title":"Part 4 - Q-Learning","text":"<p>For all of the functions written so far, the reinforcement learning was in-place, such that Pacman was given the optimal path before taking his first move. The back half of the project focused on the case where Pacman did not necessarily have this information at the outset, and instead had to learn as he went\u2014this is closer to the general idea of 'reinforcement learning' as I would conceptualize it.</p> <p>Consider this image:</p> <p></p> <p>Similar to the first three parts, Pacman begins in the bottom left, and the goal state is at the top right. The values along the top come from manually guiding Pacman directly upward, then directly to the right. The project specs mention how the agent \"leaves learning in its wake\" - that is, after reaching the goal with the north-then-east path, there's a brief trail showing how each state's value improved with their proximity to the goal. Since the rewards diminish with distance from the goal, the state directly above the start remained at zero, and since none of the other states were explored, they all remained zero as well. This is also why the goal is less than $1$ - Pacman doesn't know that this is a goal state with a value of $1$, only that he gets a good reward when he reaches that state.</p> <p>I asked ChatGPT to implement the Q-Learning agent stub as it was provided in the starter code, largely by prompting it with each function declaration and giving it the details we had when doing the project in class. The functions of note were <code>update(state, action, nextState, reward)</code>, <code>computeValueFromQValues(state)</code>, <code>getQValue(state, action)</code>, <code>computeActionFromQValues(state)</code>, and <code>getAction(state)</code>. Individually, these functions were all rather simple, and the complexity came more from all of them needing to be operational in order to call each other.</p>"},{"location":"blogpost/Garvey/final/#part-4-critique","title":"Part 4 Critique","text":"<p><code>getQValue</code> only needed to return the Q-Value at a given <code>(state, action)</code> tuple, which relied on storing the Q-Values for the agent somewhere in its class. The manner of storing those as a member variable is the only way I really expected ChatGPT's implementation to differ from mine, as there wasn't a specific instruction for how to do so, but there are a couple different data structures it could have conceivably used.</p> <p><code>getAction</code> was also straight-forward, as it simply needed to return a random action with a probability of the member value <code>epsilon</code>, and otherwise return an action using a pre-defined function.</p> <p><code>computeValueFromQValues</code> and <code>computeActionFromQValues</code> were similar to each other, as both relied on iterating over the possible actions and finding the maximum relevant value. I was a little surprised to see that ChatGPT did this directly in both functions, since to me, the fact that the functions were so similar would lend itself well to combining them in a helper function. I probably shouldn't be too put-off, because I did the same thing for my project, but I felt that ChatGPT could have had the combined fore- and hindsight to do less work with that sort of thing. I do also have the advantage of knowing that my code works from having previously turned it in, which makes it easier to see where ChatGPT's (and my) implementation could have been improved.</p> <p>Finally, <code>update</code> had a fairly predictable solution, as it directly relied on calculating the reward transition and saving that as appropriate into the chosen storage member variable. The only error came in from certain member variables like <code>alpha</code> and <code>discount</code> not being known to ChatGPT, so it set them to a static number at the beginning of the function. On correction of this part, ChatGPT's code was again fine.</p>"},{"location":"blogpost/Garvey/final/#part-5-conclusion","title":"Part 5 - Conclusion","text":"<p>Despite my more optimistic hopes, ChatGPT did pretty well on completing this project, and probably would've gotten at least a solid 75% before any corrective prompting or interpretation on my part. I knew better than to expect it would be a complete disaster, given that using AI for coding classes is becoming a more prevalent concern (or tool, depending on who you ask), but I thought it might not be quite so seamless. I imagine the moderate success is due to the fact that, as ChatGPT has gotten more popular, it's gotten better at producing something useful directly out of the gate, rather than after considerable re-prompting. A simple search like 'increased use of ChatGPT in coding classes' returns several tutorials on how to use the AI to one's advantage, and even some forum posts asking whether it's even worth it to bother learning coding anymore.</p> <p>It would be foolish to ignore the obvious benefits of using ChatGPT for lower-level coding problems, such as a seasoned developer verifying that their syntax and behavior is correct, but plenty of people have already pointed out the concerns with it, too. This post alone is one such example, where the only actual coding on my part was running ChatGPT's code, and figuring out where and why it didn't work. The point of the original project obviously did include some user debugging, such that we could learn the reasoning behind what they were having us implement, but that wasn't all of it. Only doing the trouble-shooting, to the point that any actual coding on our part would have been what we fed ChatGPT, certainly wouldn't have been as beneficial to learning the material as us doing the work ourselves.</p> <p>There isn't necessarily some grand point to be made here, especially when the same idea has already been restated and picked apart in more official capacities, but it still seems worthwhile to consider the difference in ChatGPT across disciplines. While only an anecdote, there is an article[^2] about a professor, C.W. Howell, who had his students generate an essay with ChatGPT, and then grade it themselves. According to Howell, all of the essays had errors, including citing sources that didn't even exist. The article goes more in-depth on the students' reactions to the essays and mistakes, but I bring it up because those errors seem much more egregious than the ones I encountered when having ChatGPT do this project. The errors I saw were all relatively minor, and often based on the fact that there was some variable ChatGPT didn't know about, or else a method it didn't know to call. It's hard to delineate where the line is, but I do think it's interesting that the AI seems more adept at certain topics than others, at least anecdotally.</p> <p>[^1]: The Pacman AI projects were developed at UC Berkeley (http://ai.berkeley.edu). The core projects and autograders were primarily created by John DeNero (denero@cs.berkeley.edu) and Dan Klein (klein@cs.berkeley.edu). [^2]: Howell, C.W. \u201cDon\u2019t Want Students to Rely on ChatGPT? Have Them Use It.\u201d Wired, Conde Nast, 6 June 2023, www.wired.com/story/dont-want-students-to-rely-on-chatgpt-have-them-use-it/.</p>"},{"location":"blogpost/Gu/final/","title":"ChatGPT Dynamic Programming Solution Analysis","text":""},{"location":"blogpost/Gu/final/#synopsis","title":"Synopsis:","text":"<p>ChatGPT is a powerful tool that allows users to prompt a LLM (Large Language Model) about any questions that they may have. One way this AI is used in the Computer Science sector to produce solutions to various algoirhtmic problems. One category of problems that ChatGPT is still not proficient in generating solutions to is DP (Dynamic Programming). This blog post will analyze basic to advanced DP problems and analyze ChatGPT's solutions to them. </p>"},{"location":"blogpost/Gu/final/#house-robbers","title":"House Robbers:","text":"<p>The house robbers problem is a simple DP problem where you have to find the maximum sum of non-adjacent elements of a list. So, for example, if you have a list that contains [2, 10, 12, 5, 20], then the maximum sum will be 34. </p>"},{"location":"blogpost/Gu/final/#chatgpts-solution","title":"ChatGPT's Solution","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint rob(std::vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    if (n == 1) return nums[0];\n\n    std::vector&lt;int&gt; max_money(n, 0);\n\n    // Base cases\n    max_money[0] = nums[0];\n    max_money[1] = std::max(nums[0], nums[1]);\n\n    // Fill the array using a bottom-up approach\n    for (int i = 2; i &lt; n; ++i) {\n        max_money[i] = std::max(max_money[i - 1], max_money[i - 2] + nums[i]);\n    }\n\n    // The maximum money that can be robbed is in the last cell of the array\n    return max_money[n - 1];\n}\n\nint main() {\n    std::vector&lt;int&gt; nums = {1, 2, 3, 1};\n    int result = rob(nums);\n    std::cout &lt;&lt; \"Maximum amount of money that can be robbed: \" &lt;&lt; result &lt;&lt; std::endl;  // Output: 4\n    return 0;\n}\n</code></pre> <p>House Robbers is famous for being the most simple DP problem and that's why I'm not surprised that ChatGPT's solution to it is completely correct. The base cases cover everything necessary and the list plus the loop calculate the max at each index of the input, leaving the maximum sum at the last index of the list. Since a problem this simple is easy for ChatGPT to solve, let's move on to a more difficult problem. </p>"},{"location":"blogpost/Gu/final/#edit-distance","title":"Edit Distance","text":"<p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word:</p> <p>Insert a character Delete a character Replace a character</p> <p>Example 1:</p> <p>Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation:  horse -&gt; rorse (replace 'h' with 'r') rorse -&gt; rose (remove 'r') rose -&gt; ros (remove 'e')</p>"},{"location":"blogpost/Gu/final/#chatgpts-solution_1","title":"ChatGPT's Solution","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint minEditDistance(std::string word1, std::string word2) {\n    int m = word1.length();\n    int n = word2.length();\n\n    // Initialize a 2D vector to store the minimum edit distances\n    std::vector&lt;std::vector&lt;int&gt;&gt; dp(m + 1, std::vector&lt;int&gt;(n + 1, 0));\n\n    // Base cases: cost of converting an empty string to a non-empty string\n    for (int i = 0; i &lt;= m; i++) {\n        dp[i][0] = i;\n    }\n\n    for (int j = 0; j &lt;= n; j++) {\n        dp[0][j] = j;\n    }\n\n    // Fill the matrix using dynamic programming\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + std::min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    std::string word1 = \"horse\";\n    std::string word2 = \"ros\";\n    int result = minEditDistance(word1, word2);\n    std::cout &lt;&lt; \"Minimum number of operations: \" &lt;&lt; result &lt;&lt; std::endl;  // Output: 3\n    return 0;\n}\n</code></pre> <p>This problem is a harder one that requires a 2D array that saves the edit distance from a substring of length i of word1 and a substring of length j of word2. I am not extremely surprised that ChatGPT was able to generate this one correctly, but I wasn't expecting it to be the optimal solution. The code does exactly what the solution requires, filling the 2D array with a decision between the four cases: the two letters being the same, in which case you just put the value at i - 1 and j - 1, and the insert, delete, and replace case where you take the minimum of 1 + i - 1 and j, 1 + i and j - 1, and 1 + i - 1 and j - 1. </p>"},{"location":"blogpost/Gu/final/#wildcard-matching","title":"Wildcard Matching","text":"<p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:</p> <p>'?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).</p> <p>Example 1:</p> <p>Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\".</p>"},{"location":"blogpost/Gu/final/#chatgpts-solution_2","title":"ChatGPT's Solution","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nbool isMatch(std::string s, std::string p) {\n    int m = s.length();\n    int n = p.length();\n\n    // Initialize a 2D DP vector with false values\n    std::vector&lt;std::vector&lt;bool&gt;&gt; dp(m + 1, std::vector&lt;bool&gt;(n + 1, false));\n    dp[0][0] = true;\n\n    // Fill the DP vector\n    for (int j = 1; j &lt;= n; j++) {\n        if (p[j - 1] == '*') {\n            dp[0][j] = dp[0][j - 1];\n        }\n    }\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n            } else if (p[j - 1] == '?' || p[j - 1] == s[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    std::string s1 = \"aa\";\n    std::string p1 = \"a\";\n    std::cout &lt;&lt; \"Output: \" &lt;&lt; (isMatch(s1, p1) ? \"True\" : \"False\") &lt;&lt; std::endl;  // Output: False\n\n    std::string s2 = \"adceb\";\n    std::string p2 = \"*a*b\";\n    std::cout &lt;&lt; \"Output: \" &lt;&lt; (isMatch(s2, p2) ? \"True\" : \"False\") &lt;&lt; std::endl;  // Output: True\n\n    return 0;\n}\n</code></pre> <p>This problem is quite harder than the first two that I examined before, however, ChatGPT is still able to produce the most efficient solution. I am suspecting that this is because I am pulling the coding prompts from Leetcode. For the next few, I will stump ChatGPT and analyze where its solution went wrong and how to fix it. </p>"},{"location":"blogpost/Gu/final/#beautiful-numbers","title":"Beautiful Numbers","text":"<p>You are given positive integers low, high, and k.</p> <p>A number is beautiful if it meets both of the following conditions:</p> <p>The count of even digits in the number is equal to the count of odd digits. The number is divisible by k. Return the number of beautiful integers in the range [low, high].</p>"},{"location":"blogpost/Gu/final/#chatgpts-solution_3","title":"ChatGPT's Solution","text":"<pre><code>#include &lt;iostream&gt;\n\nbool isBeautiful(int num) {\n    int even_count = 0, odd_count = 0;\n    while (num &gt; 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n        num /= 10;\n    }\n    return even_count == odd_count;\n}\n\nint countBeautiful(int low, int high, int k) {\n    int beautiful_count = 0;\n\n    for (int num = low; num &lt;= high; num++) {\n        if (num % k == 0 &amp;&amp; isBeautiful(num)) {\n            beautiful_count += 1;\n        }\n    }\n\n    return beautiful_count;\n}\n\nint main() {\n    int low = 10;\n    int high = 20;\n    int k = 3;\n    int result = countBeautiful(low, high, k);\n    std::cout &lt;&lt; \"Output: \" &lt;&lt; result &lt;&lt; std::endl;  // Output: 2\n    return 0;\n}\n</code></pre> <p>It seems like ChatGPT was stumped with this problem because the solution it produced is O(N), which isn't the most efficient solution. The most efficient solution requires very complicated DP. As for the ChatGPT solution, it is syntactically and logically accurate, but it is just the naive solution. So, I asked ChatGPT to give me a more efficient solution. </p>"},{"location":"blogpost/Gu/final/#chatgpts-solution-more-optimized","title":"ChatGPT's Solution \"More Optimized\"","text":"<pre><code>#include &lt;iostream&gt;\n\nstd::pair&lt;int, int&gt; countDigits(int num) {\n    int even_count = 0, odd_count = 0;\n    while (num &gt; 0) {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n        num /= 10;\n    }\n    return std::make_pair(even_count, odd_count);\n}\n\nint countBeautiful(int low, int high, int k) {\n    int beautiful_count = 0;\n\n    // Iterate through numbers with equal even and odd digits\n    for (int num = low; num &lt;= high; num++) {\n        std::pair&lt;int, int&gt; counts = countDigits(num);\n        int even_count = counts.first;\n        int odd_count = counts.second;\n\n        if (even_count == odd_count &amp;&amp; num % k == 0) {\n            beautiful_count += 1;\n        }\n    }\n\n    return beautiful_count;\n}\n\nint main() {\n    int low = 10;\n    int high = 20;\n    int k = 3;\n    int result = countBeautiful(low, high, k);\n    std::cout &lt;&lt; \"Output: \" &lt;&lt; result &lt;&lt; std::endl;  // Output: 2\n    return 0;\n}\n</code></pre> <p>This is the solution produced by ChatGPT when I asked it for a more efficient solution. It claims that this solution reduces the search space, however, the for loop still runs for O(N) time. The only change of the function was to return the number of odd and even digits instead of returning a boolean, however, these numbers are used in an and statement to produce a boolean anyways, so this solution actually requires more computations than the one ChatGPT gave before. Both the syntax and logic are correct again, but it is obvious that ChatGPT does not automatically know about the DP solution when not prompted about it. </p>"},{"location":"blogpost/Gu/final/#count-of-non-consecutive-ones-in-binary-range","title":"Count of Non-Consecutive Ones in Binary Range","text":"<p>Given two positive integers \u2018L\u2019 and \u2018R\u2018, the task is to return the number of the integers in the range [L, R] inclusive, whose binary representations do not contain consecutive ones where 0 \u2264 l \u2264 r \u2264 10^9.</p>"},{"location":"blogpost/Gu/final/#chatgpts-solution_4","title":"ChatGPT's Solution","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint countNonConsecutiveOnes(int L, int R) {\n    int count = 0;\n\n    for (int i = L; i &lt;= R; ++i) {\n        bool consecutiveOnes = false;\n        int num = i;\n\n        while (num &gt; 0) {\n            int lastBit = num &amp; 1;\n            num &gt;&gt;= 1;\n\n            if (lastBit == 1 &amp;&amp; (num &amp; 1) == 1) {\n                consecutiveOnes = true;\n                break;\n            }\n        }\n\n        if (!consecutiveOnes) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    // Example usage\n    int L = 10;\n    int R = 20;\n\n    int result = countNonConsecutiveOnes(L, R);\n\n    cout &lt;&lt; \"Number of integers with non-consecutive ones in binary representation: \" &lt;&lt; result &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>The code that ChatGPT generates solves the problem, however, it is quite inefficient when compared with the most efficient solution. The most optimized solution for this problem uses a 3D array to save answers seen before, which makes the time complexity close to linear. For the ChatGPT solution, there is no use of any additional memory to store previous answers, so because of this, ChatGPT's solution has to search through the whole answer space for each number, which leads to a runtime closer to exponential than linear. </p>"},{"location":"blogpost/Gu/final/#chatgpts-more-optimal-solution","title":"ChatGPT's More Optimal Solution","text":"<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint countNonConsecutiveOnes(int L, int R) {\n    auto getBit = [](int num, int pos) -&gt; int {\n        return (num &gt;&gt; pos) &amp; 1;\n    };\n\n    int count = 0;\n\n    for (int bitPos = 30; bitPos &gt;= 0; --bitPos) {\n        int bitL = getBit(L, bitPos);\n        int bitR = getBit(R, bitPos);\n\n        if (bitL == 1 &amp;&amp; bitR == 1) {\n            // If both bits are 1, no more valid numbers for this bit position\n            break;\n        }\n\n        if (bitL == 0 &amp;&amp; bitR == 0) {\n            // If both bits are 0, the count remains the same\n        } else if (bitL == 0 &amp;&amp; bitR == 1) {\n            // If transitioning from 0 to 1, valid numbers for this bit position are counted from both states\n            count += (1 &lt;&lt; bitPos);\n        } else if (bitL == 1 &amp;&amp; bitR == 0) {\n            // If transitioning from 1 to 0, no more valid numbers for this bit position\n            break;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    // Example usage\n    int L = 10;\n    int R = 20;\n\n    int result = countNonConsecutiveOnes(L, R);\n\n    cout &lt;&lt; \"Number of integers with non-consecutive ones in binary representation: \" &lt;&lt; result &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>This solution is not that much more efficient than the last, it now just uses more space to keep track of numbers that end with 0 and numbers that end with 1. That is not the right intuition to approach this problem with DP. It is also interesting how ChatGPT states that it uses DP in the generated output, however, there is no DP readily apparent in the solution. It seems as if ChatGPT does not know what path to go down in order to approach this problem. I am not surprised as a DP problem requiring a 3D array is one that I did not suspect AI to be able to solve yet. </p>"},{"location":"blogpost/Gu/final/#probability-of-winning-in-a-die-throw-game","title":"Probability of Winning In a Die-Throw Game","text":"<p>Given that 2 players are playing a die-throw game. The game is one player throws a die and he got a point, he can move forward accordingly to the point. All occurrences to get the point have equal probability. Let player1 start a point x and player2 start a point y. Player 1 can receive a point up to A, and Player 2 can receive a point up to B.  When a player in the position p and point got in the die q, he can move forward a minimum of (p+q) and W. The first player to reach W wins the game. Find the probability modulo that player 1 wins if he goes first modulo 998244353.</p>"},{"location":"blogpost/Gu/final/#chatgpts-solution_5","title":"ChatGPT's Solution","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nconst int MOD = 998244353;\n\nint calculateProbability(int x, int y, int A, int B, int W, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; dp) {\n    if (x &gt;= W) return 1;\n    if (y &gt;= W) return 0;\n    if (dp[x][y] != -1) return dp[x][y];\n\n    long long totalWays = 0;\n    for (int q = 1; q &lt;= A; ++q) {\n        if (x + q &lt; W) {\n            totalWays = (totalWays + calculateProbability(y, x + q, B, A, W, dp)) % MOD;\n        }\n    }\n\n    return dp[x][y] = totalWays;\n}\n\nint main() {\n    int x, y, A, B, W;\n\n    // Example input values\n    x = 1;\n    y = 1;\n    A = 2;\n    B = 2;\n    W = 5;\n\n    // Create a memoization table\n    std::vector&lt;std::vector&lt;int&gt;&gt; dp(W + 1, std::vector&lt;int&gt;(W + 1, -1));\n\n    int result = calculateProbability(x, y, A, B, W, dp);\n\n    std::cout &lt;&lt; \"Probability of player 1 winning: \" &lt;&lt; result &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>This solution is unique because it uses a 2D array when a 3D array is required. It is not taking into consideration finding a dimension of possible solutions that are required to find the optimal solution, which is the probability of winning. To be frank, I would say this is a problem that ChatGPT itself was confused on how to approach. The time complexity for this solution is exponential, while the most efficient solution is one that is in the range of quadratic runtime. </p>"},{"location":"blogpost/Gu/final/#chatgpts-more-optimized-solution","title":"ChatGPT's More Optimized Solution","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nconst int MOD = 998244353;\n\nint calculateProbability(int x, int y, int A, int B, int W, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; dp) {\n    // Base case: if player 1 is already at or beyond W, he wins\n    if (x &gt;= W) return 1;\n\n    // If player 2 is already at or beyond W, player 1 cannot win from this state\n    if (y &gt;= W) return 0;\n\n    // If the probability is already calculated, return it\n    if (dp[x][y] != -1) return dp[x][y];\n\n    long long totalWays = 0;\n\n    // Iterate through all possible outcomes of player 1's throw\n    for (int q = 1; q &lt;= A; ++q) {\n        if (x + q &lt; W) {\n            // If player 1's throw is valid, recursively calculate the probability\n            totalWays = (totalWays + calculateProbability(y, x + q, B, A, W, dp)) % MOD;\n        }\n    }\n\n    // Store the calculated probability in the memoization table\n    return dp[x][y] = totalWays;\n}\n\nint main() {\n    int x, y, A, B, W;\n\n    // Example input values\n    x = 1;\n    y = 1;\n    A = 2;\n    B = 2;\n    W = 5;\n\n    // Create a memoization table\n    std::vector&lt;std::vector&lt;int&gt;&gt; dp(W + 1, std::vector&lt;int&gt;(W + 1, -1));\n\n    int result = calculateProbability(x, y, A, B, W, dp);\n\n    std::cout &lt;&lt; \"Probability of player 1 winning: \" &lt;&lt; result &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>I asked ChatGPT to generate a more efficient solution and it provided me with the same solution again, but with an explanation with how it's different. It claims that it now iterates through the states in reverse order, but there is nothing in the code that reflects that. In addition, it states that it uses a top-down dynamic programming approach, but the solution is the same as what was provided before. It seems as if ChatGPT is completely stumped on this problem. </p> <p>Link to the Chat: https://chat.openai.com/share/bc30b6b9-ee73-40ae-85fe-06df74f10b10</p> <p>The first half contains Python solutions that I then converted to C++ and the second half contains the solutions directly generated as C++. </p>"},{"location":"blogpost/Kanphade/final/","title":"An Efficiency Comparison between Hash Maps and Bloom Filters in C++","text":"<p>Monika Kanphade - November 9<sup>th</sup>, 2023</p>"},{"location":"blogpost/Kanphade/final/#what-is-a-hash-map","title":"What is a Hash Map?","text":"<p>Hash Maps are a data structure resembling a dictionary, storing elements in a key-value fashion. \\ They use buckets to store values in unique keys determined by hash functions. \\ The keys are unique indexes into the data structure that allow efficient retrival of a certain value from the lookup table.</p> <p>How does it work?</p> <p>Hash Maps work like a dictionary storing key-value pairs. The specific bucket that the key-value pair \\  gets mapped to is dependant on the Hash Function used to calculate it. </p> <p>For example, if you wanted to store numbers efficiently, one hash function you could use to store them \\  in seperate buckets would be to differentiate based on the digit in the tens place of each number, \\  resulting in buckets for digits 0-9. </p> <ul> <li>The number 13 would go in Bucket 3  </li> <li>The number 27 would go in Bucket 7  </li> <li>The number 5 would go in Bucket 5  </li> <li>The number 147238674 would go in Bucket 4  </li> </ul> <p>Retrieval or search of the values is based on running the key through the Hash Function and determining if the \\ exact value is present in the location returned.</p> <p></p>"},{"location":"blogpost/Kanphade/final/#implementation-in-c","title":"Implementation in C++:","text":"<pre><code>#include &lt;iostream&gt; \n#include &lt;unordered_map&gt;  \n#include &lt;string&gt;\n\nint main() { \n\n    // Initialization of Unordered map (Hash map)\n    std::unordered_map&lt;std::string, std::string&gt; hash_map; \n\n    // Inserting values by using [] operator \n    hash_map[\"name\"] = \"Monika\"; \n    hash_map[\"age\"] = \"21\"; \n    hash_map[\"job\"] = \"student\"; \n\n    // Traversing an unordered map \n    for (auto pair : hash_map) \n        std::cout &lt;&lt; pair.first &lt;&lt; \" \" &lt;&lt; pair.second &lt;&lt; std::endl; \n\n}\n</code></pre>"},{"location":"blogpost/Kanphade/final/#what-is-a-bloom-filter","title":"What is a Bloom filter?","text":"<p>Bloom filters are a probabalistic data structure that determine if a given key has been seen by the structure before. \\ Oftentimes, they are used to determine data that has not been seen yet for particularly large datasets, however, \\ the larger the dataset the more likely the bloom filter is to report a false positive (i.e. claiming that a key has been \\ seen before when it hasn't).</p> <p>How does it work?</p> <p>A Bloom Filter works similarly to a Hash Map, with some distinct differences. It works like a dictionary, however, \\ instead of storing the exact key-value pairs, it stores a numerical representation (usually a bit representation) \\ of the value. It determines what bits are to be set (in a sequence of n bits determined at initialization of \\ the Bloom Filter), by one or more Hash Functions. </p> <p>For example, using keys from the image below, we can initialize the Bloom Filter's length n to 12 bits, \\ all set to 0. According to a Hash Function (I won't specifiy the details of how it works for simplicity's sake), \\ if I input the word 'cat' the function might output bits 1 and 6 to be set (starting from 0).</p> <ul> <li>The word 'cat' sets bits 1 and 6  </li> <li>The word 'dog' sets bits 0 and 9  </li> <li>The word 'hat' sets bits 4 and 8  </li> </ul> <p>In order to check whether one of these words is present in the Bloom Filter, you would simply evaluate the Hash Function \\ for that word and if all the calculated bits are set to a 1, then it has most likely been seen.</p> <p>I say most likely under the pretense that the calculation may be a false positive. The idea of false positives comes \\ from the idea that the more bits set, the less unique the encoding of the word becomes. </p> <p>In our example, say you want to know whether the word 'hog' has been seen or not. You run it through the Hash Function \\ and it calculates that bits 4 and 9 must be set to 1 in order to return True. Well, looking at our Bloom Filter, \\ we can say that bits 4 and 9 have been set to 1, but not necessarily together. They were set under the context of other \\ words being seen. This pattern would mean that the Bloom Filter returning True for the word 'hog' would be a \\ false positive as we never actually saw it.</p> <p>Some ways to reduce the number of false postives appearing in your Bloom Filter search would be to increase the \\ size of the array of bits, increase the number of Hash Functions used to create more unique outcomes in which bits to set, \\ or reduce the size of the data being input.</p> <p></p>"},{"location":"blogpost/Kanphade/final/#implementation-in-c_1","title":"Implementation in C++:","text":"<p>From: https://github.com/ArashPartow/bloom/blob/master/bloom_filter.hpp</p> <pre><code>#include &lt;iostream&gt; \n#include &lt;unordered_map&gt;  \n#include &lt;string&gt;\n\nint main() {\n\n    // Initialization of Bloom filter\n    bloom_parameters parameters;\n    parameters.projected_element_count = 10;    // number of elements to insert\n    parameters.false_positive_probability = 0.0001;\n    parameters.compute_optimal_parameters();\n    bloom_filter bloom_filter(parameters);\n\n    // Inserting values using .insert() function\n    bloom_filter.insert(\"cat\");\n    bloom_filter.insert(\"dog\");\n    bloom_filter.insert(\"hat\");\n\n    // Check if Bloom filter has seen a unique key\n    std::cout &lt;&lt; bloom_filter.contains(\"cat\") &lt;&lt; std::endl; // True\n    std::cout &lt;&lt; bloom_filter.contains(\"bat\") &lt;&lt; std::endl; // False\n\n}\n\n</code></pre>"},{"location":"blogpost/Kanphade/final/#behind-the-scenes","title":"Behind the scenes","text":""},{"location":"blogpost/Kanphade/final/#space-complexity","title":"Space Complexity:","text":""},{"location":"blogpost/Kanphade/final/#hash-map","title":"Hash Map:","text":"<p>Hash maps are oftentimes represented as an array containing n key-value pairs. The size of the array is dynamic, \\ but the space complexity may also depend on the size m of the items it is storing. Different data types have \\ different sizes.</p> <ul> <li>Best case: O(n) - When items stored in the array are type int, bool, etc.</li> <li>Worst case: O(n<sup>m</sup>) - When items stored in the array are type string, objects, etc.</li> </ul>"},{"location":"blogpost/Kanphade/final/#bloom-filter","title":"Bloom Filter:","text":"<p>Bloom filters are also represented by an array, however, instead of containing the literal representation of the keys \\ themselves, it contains a set number m of bits then can be set upon seeing a unique key. This makes them very \\ space-efficient as the size is not dynamic.</p> <ul> <li>Best/Worst case: O(m) - The size of the bit array</li> </ul>"},{"location":"blogpost/Kanphade/final/#time-complexity","title":"Time Complexity:","text":""},{"location":"blogpost/Kanphade/final/#hash-map_1","title":"Hash Map:","text":"<p>The time it takes for a Hash map to INSERT, DELETE, and SEARCH for data depends on a multitude of factors, \\ such as the size of the buckets and whether they hold a singular item, and what the Hash function being used to map \\ key-value pairs looks like. Collisions may increase the time complexity but can be prevented by a good hash function \\ allowing uniform data distribution.</p> <ul> <li>Best case: O(1) - When a key maps to a single value</li> <li>Worst case: O(n) - When a key maps to multiple values</li> </ul>"},{"location":"blogpost/Kanphade/final/#bloom-filter_1","title":"Bloom Filter:","text":"<p>The time it takes for a Bloom filter to INSERT and SEARCH for data depends on the number k hash functions \\ implemented. Everytime a key is inserted into the bloom filter all hash functions must be applied for the key to \\ attain its mapped bit values. When searching, the Bloom filter simply checks if all hash functions return a 1, \\ indicating that bit was set.</p> <ul> <li>Best/Worst case: O(k) - The number of hash functions implemented</li> </ul>"},{"location":"blogpost/Kanphade/final/#code-review","title":"Code Review","text":""},{"location":"blogpost/Kanphade/final/#insertion-tests","title":"Insertion Tests:","text":"<pre><code>// Testing hash map insertion\nfor (int i = 0; i &lt; 10000; i++) {\n    hash_map[i] = i;\n}\n\n&gt;&gt;&gt; Time Elapsed: 14007 microseconds\n\n// Testing bloom filter insertion\nfor (int j = 0; j &lt; 10000; j++) {\n    bloom_filter.insert(j);\n}\n\n&gt;&gt;&gt; Time Elapsed: 1926 microseconds\n</code></pre> <p>Bloom filter wins!</p>"},{"location":"blogpost/Kanphade/final/#search-tests","title":"Search Tests:","text":"<pre><code>// Testing hash map search\nfor (int i = 0; i &lt; 10000; i++) {\n    hash_map.find(i);\n}\n\n&gt;&gt;&gt; Time Elapsed: 1008 microseconds\n\n// Testing bloom filter search\nfor (int j = 0; j &lt; 10000; j++) {\n    bloom_filter.contains(j);\n}   \n\n&gt;&gt;&gt; Time Elapsed: 1996 microseconds\n</code></pre> <p>Hash map wins!</p>"},{"location":"blogpost/Kanphade/final/#space-complexity-tests","title":"Space Complexity Tests:","text":"<pre><code>// Insert 3 items into hash map\nhash_map[\"name\"] = \"Monika\"; \nhash_map[\"age\"] = \"21\"; \nhash_map[\"job\"] = \"student\"; \n\nstd::cout &lt;&lt; sizeof(hash_map) &lt;&lt; std::endl;\n\n&gt;&gt;&gt; Size: 56 bytes\n\n// Insert 3 items into bloom filter\nbloom_filter.insert(\"cat\");\nbloom_filter.insert(\"dog\");\nbloom_filter.insert(\"hat\");\n\nstd::cout &lt;&lt; sizeof(bloom_filter.size()) &lt;&lt; std::endl;\n\n&gt;&gt;&gt; Size: 8 bytes\n</code></pre> <p>Bloom filter wins!</p>"},{"location":"blogpost/Kanphade/final/#summary","title":"Summary","text":"<p>Overall, Bloom filters and Hash maps have their unique properties can allow the user an advantage in certain situations. \\ Say you wanted to keep track of a large dataset for which you did not have enough memory to hold the individual instances \\ of the data, a Bloom filter would be a perfect solution if the possibility of false positives wasn't an issue. However, \\ if you needed to ensure accuracy about whether something is in the data and require some form of deletion, a Hash map \\ would be the way to go as Bloom filters have trouble implementing a way to delete values.</p>"},{"location":"blogpost/Kight/final/","title":"Bit Packing Blog Post : Matt Kight","text":""},{"location":"blogpost/Kight/final/#fall-2023","title":"Fall 2023","text":""},{"location":"blogpost/Kight/final/#introduction-understanding-bit-packing-in-c","title":"Introduction: Understanding Bit Packing in C++","text":"<p>Precision and efficiency are hallmarks in C++ programming. Bit packing is a technique that may seem perplexing at first, but it wields a profound influence on how memory is allocated and manipulated within your programs. Welcome to the fascinating world of bit packing where you can achieve a level of precision that breaks free from the byte boundaries to saving memory, and boost performance.</p> <p>In this blog post, we will embark on a journey to demystify bit packing. We will delve into why it matters, how it works, and how you can leverage this technique to optimize your C++ code. By the end of this journey, you'll be equipped with the knowledge and tools to harness the power of bit packing in your own projects.</p> <p>So, let's roll up our sleeves and begin our exploration of bit packing in C++. We'll unlock the secrets of memory efficiency and performance optimization, one bit at a time.</p>"},{"location":"blogpost/Kight/final/#why-bit-packing-matters","title":"Why Bit Packing Matters","text":"<p>In the world of C++ programming, efficiency is a critical concern. Every byte of memory and every CPU cycle can make a substantial difference in the performance of your applications. This is where bit packing shines as a valuable technique, and understanding why it matters is crucial.</p>"},{"location":"blogpost/Kight/final/#1-memory-efficiency","title":"1. Memory Efficiency:","text":"<p>Bit packing is primarily employed to save memory. In C++, data structures are typically allocated in byte-sized units, which can lead to memory wastage when dealing with data that doesn't neatly fit into these units. Consider a simple Boolean value \u2013 it only needs one bit to represent true or false, but C++ allocates a whole byte (8 bits) for it. By bit packing, you can precisely represent data in the smallest possible unit, reducing the memory overhead of your program.</p> <p>This memory efficiency is especially critical in scenarios where resources are limited. For instance, in embedded systems, where memory is scarce, bit packing can be a game-changer. It allows you to maximize the use of limited memory, enabling the development of more efficient and cost-effective systems.</p>"},{"location":"blogpost/Kight/final/#2-performance-optimization","title":"2. Performance Optimization:","text":"<p>Bit packing isn't just about saving memory; it's also about improving performance. In modern computer architectures, memory access times and cache efficiency are major determinants of how fast your code runs. When you use bit packing to store data in smaller units, you can reduce memory access times. This means that your CPU can fetch and manipulate data more quickly, leading to a noticeable performance boost.</p> <p>Furthermore, compact data structures are cache-friendly. Caches store data in blocks, and when your data structures are small due to bit packing, more of them can fit into a single cache line. This results in fewer cache misses, which can have a dramatic impact on execution speed as accessing the cache is 10-100 times faster than accessing via RAM.</p> <p>Let's take the following program as an example:</p> <pre><code>// Note : Example program is modified from ChatGPT program\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nconst int NUM_FLAGS = 1000000;  // Number of boolean flags\n\nstruct UnpackedFlags {\n  bool flags[NUM_FLAGS];\n};\n\nstruct BitFieldFlags {\n  struct {\n    unsigned int flag1 : 1;\n    unsigned int flag2 : 1;\n    unsigned int flag3 : 1;\n    unsigned int flag4 : 1;\n  } bits[NUM_FLAGS/4];\n};\n\n// Function to process flags without bit fields\nvoid ProcessUnpackedFlags(const UnpackedFlags&amp; data) {\n  for (int i = 0; i &lt; NUM_FLAGS; ++i) {\n    // Process individual flags\n    bool flag = data.flags[i];\n    // Do some work with the flag (e.g., a trivial operation)\n    bool result = !flag;\n  }\n}\n\n// Function to process flags with bit fields\nvoid ProcessBitFieldFlags(const BitFieldFlags&amp; data) {\n  for (int i = 0; i &lt; (NUM_FLAGS / 4); ++i) {\n    auto &amp; flagBits = data.bits[i];\n    // Process bit fields\n    bool flag1 = flagBits.flag1;\n    bool flag2 = flagBits.flag2;\n    bool flag3 = flagBits.flag3;\n    bool flag4 = flagBits.flag4;\n\n  }\n}\n\nint main() {\n  int NUM_TRIALS = 1000;\n  std::chrono::duration&lt;double&gt; elapsedUnpacked = std::chrono::duration&lt;double&gt;::zero();\n  std::chrono::duration&lt;double&gt; elapsedBitField = std::chrono::duration&lt;double&gt;::zero();\n\n  for (int i = 0; i &lt; NUM_TRIALS; ++i){\n    UnpackedFlags unpackedData;\n    BitFieldFlags bitFieldData;\n\n    // Initialize data\n    for (int i = 0; i &lt; NUM_FLAGS; ++i) {\n      unpackedData.flags[i] = (i % 2 == 0);  // Set every other flag to true\n      bitFieldData.bits[i / 4].flag1 = (i % 2 == 0);\n      bitFieldData.bits[i / 4].flag2 = (i % 2 == 0);\n      bitFieldData.bits[i / 4].flag3 = (i % 2 == 0);\n      bitFieldData.bits[i / 4].flag4 = (i % 2 == 0);\n      // ... Initialize more flags here\n    }\n\n    // Measure time for processing unpacked flags\n    auto startUnpacked = std::chrono::high_resolution_clock::now();\n    ProcessUnpackedFlags(unpackedData);\n    auto endUnpacked = std::chrono::high_resolution_clock::now();\n    elapsedUnpacked += endUnpacked - startUnpacked;\n\n    // Measure time for processing bit field flags\n    auto startBitField = std::chrono::high_resolution_clock::now();\n    ProcessBitFieldFlags(bitFieldData);\n    auto endBitField = std::chrono::high_resolution_clock::now();\n    elapsedBitField += endBitField - startBitField;\n  }\n\n\n  std::cout &lt;&lt; \"Average time for processing &lt;&lt; NUM_TRIALS &lt;&lt; unpacked flags: \" &lt;&lt; elapsedUnpacked.count()/NUM_TRIALS &lt;&lt; \" seconds\\n\";\n  std::cout &lt;&lt; \"Average time for processing &lt;&lt; NUM_TRIALS &lt;&lt; bit field flags: \" &lt;&lt; elapsedBitField.count()/NUM_TRIALS &lt;&lt; \" seconds\\n\";\n\n\n  return 0;\n}\n</code></pre> <p>The output on my following machine is as follows:</p> <pre><code>Average time for processing 1000 unpacked flags: 0.00173472 seconds\nAverage time for processing 1000 bit field flags: 0.00135095 seconds\n</code></pre> <p>The use of bitfields has sped up our program by ~25%. Note this may not be the same output depending on compiler and hardware used.</p>"},{"location":"blogpost/Kight/final/#3-data-serialization","title":"3. Data Serialization:","text":"<p>Bit packing plays a vital role in data serialization and deserialization. When you're transmitting data over a network or storing it in a file, it's essential to minimize the data's size. Smaller data sizes mean faster transmission and less storage space required. Bit packing helps you achieve this goal by efficiently encoding and decoding data for communication or storage.</p> <p>In conclusion, bit packing is not just a niche concept; it's a fundamental technique that allows C++ programmers to save memory, boost performance, and efficiently work with data. It's a tool that becomes increasingly valuable in scenarios where resource constraints and performance optimization are critical. In the following sections, we'll explore how to implement bit packing in C++ and leverage its advantages in your projects.</p>"},{"location":"blogpost/Kight/final/#how-to-use-bit-packing","title":"How to use Bit Packing","text":"<p>Now lets go over the syntax of bit packing. Things to note:</p> <ul> <li>Only integral data types are allowed to be used in bit packing</li> <li>These are int, long, short, byte, and char</li> <li>Can work either with classes or structs</li> </ul> <pre><code>struct StructName {\n    dataType fieldName : width;\n    // more bit-field members...\n};\n</code></pre> <p>Below is an example implementation of where bit packing can become useful.</p> <pre><code>struct PackedFlags {\n    unsigned int flag1 : 1; // 1 bit for flag 1\n    unsigned int flag2 : 1; // 1 bit for flag 2\n    unsigned int flag3 : 1; // 1 bit for flag 3\n    unsigned int flag4 : 1; // 1 bit for flag 4\n    unsigned int flag5 : 1; // 1 bit for flag 5\n    unsigned int flag6 : 1; // 1 bit for flag 6\n    unsigned int flag7 : 1; // 1 bit for flag 7\n    unsigned int flag8 : 1; // 1 bit for flag 8\n};\n</code></pre> <pre><code>struct Flags {\n    bool flag1;\n    bool flag2;\n    bool flag3;\n    bool flag4;\n    bool flag5;\n    bool flag6;\n    bool flag7;\n    bool flag8;\n};\n</code></pre> <p>This will create 2 structs. Each struct can hold 8 boolean values. The top one employs bit-packing where the bottom one does not.</p> <pre><code>PackedFlags packedFlags;\nFlags flags;\nstd::cout &lt;&lt; sizeof(packedFlags) &lt;&lt; std::endl;  // Prints 4\nstd::cout &lt;&lt; sizeof(flags) &lt;&lt; std::endl;        // Prints 8\n</code></pre> <p>When printing out the size of each of these structs the bit packing was 50% smaller than the normal operation. Please note that this will not always be the case and can be compiler and system dependent.</p> <p>This space-saving is an essential reason as to why you would use bit packing.</p>"},{"location":"blogpost/Kight/final/#downsides","title":"Downsides:","text":"<p>While there are many upsides to creating classes and structs that hold specify number of bits can be great to save space it does not come without some downsides.</p>"},{"location":"blogpost/Kight/final/#no-pointers-to-member-variables","title":"No pointers to member variables","text":"<p>Bit packing, while efficient in terms of memory utilization, does introduce certain limitations, one of which is the challenge of creating pointers to individual member variables within a struct or class. The nature of bit packing blurs the clear boundary between where one variable starts and another ends, as they share the same memory space. This makes it difficult to create direct pointers to specific member variables, which is a common operation in C++. Pointers are essential for various operations, such as passing references to specific data or for efficient memory manipulation. In the context of bit packing, accessing individual variables often requires complex bit-level operations, making the code less intuitive and potentially more error-prone when compared to conventional member access using pointers.</p> <p>Using the structs above will create a compile time error</p> <pre><code>auto x = &amp;packedFlags.flag1;\n</code></pre>"},{"location":"blogpost/Kight/final/#possible-speed-loss-due-to-time-accessing-bits","title":"Possible speed loss due to time accessing bits","text":"<p>While the example above demonstrated an approximate 25% improvement in processing time by employing bit packing, it's essential to acknowledge that this performance gain is not always guaranteed. The effectiveness of bit packing depends on various factors, including the specific hardware architecture and the compiler being used. In certain situations, accessing individual bits within packed data structures can be slower than dealing with larger byte-sized memory units. This is because modern hardware is often designed to handle memory in larger chunks, such as bytes or words, and may not be as optimized for bit-level operations. As a result, the benefits of bit packing may vary, and in some cases, it might not provide a significant performance boost, or it could even lead to a slowdown due to the overhead introduced by bit manipulation.</p>"},{"location":"blogpost/Kight/final/#conclusion","title":"Conclusion:","text":"<p>Unleashing the power of bit packing in the world of C++ programming, where every byte counts and efficiency is paramount, bit packing stands as a beacon of ingenuity. Through our journey in this blog post, we've unlocked the secrets of bit packing and discovered its pivotal role in memory efficiency and performance optimization. This seemingly niche concept offers substantial advantages that transcend the world of game development and embedded systems, extending its influence into various domains of software engineering. Bit packing is the tool that allows you to seize control over your data, manipulating it with precision, and crafting lean, agile data structures.</p> <p>Whether you're developing for resource-constrained environments, seeking to maximize the performance of your applications, or simply looking for ways to optimize memory usage, bit packing is a technique that you can't afford to ignore. It's not just a coding technique; it's a game-changer, enabling you to make the most of your resources, reduce memory overhead, and achieve faster execution. As you continue your journey in the world of C++, remember that bit packing is your ally, waiting to help you craft more efficient and responsive code. So, go ahead, implement bit packing, and unleash its transformative power in your C++ projects.</p>"},{"location":"blogpost/Kight/final/#sources","title":"Sources:","text":"<ol> <li>Geeks For Geeks Article</li> <li>CPP Reference for Bit Packing</li> <li>ChatGPT Chat Log</li> </ol>"},{"location":"blogpost/Lablanc/final/","title":"Coroutines Tutorial","text":"<p>Let's dive into the advanced C++ topic of coroutines, discussing what they are, how they're used, and their importance!</p>"},{"location":"blogpost/Lablanc/final/#what-are-coroutines","title":"What are coroutines?","text":"<p>C++ coroutines, introduced in C++20, offer a streamlined approach to asynchronous and concurrent programming. They enable you to craft asynchronous code that closely resembles synchronous programming, enhancing code clarity and maintainability. </p> <p>Coroutines can temporarily pause their execution at designated points, later resuming from where they left off. This pause-and-resume behavior allows other tasks to be executed in the interim. Furthermore, they operate without relying on a traditional stack, suspending execution by returning to the caller and storing the necessary data separately from the stack. In essence, this stackless mechanism stores the coroutine's data, or coroutine frame, on the heap.</p> <p>Below is a great example of the coroutine functionality: </p> <p> </p>"},{"location":"blogpost/Lablanc/final/#different-types-of-coroutines","title":"Different types of coroutines","text":"<p>Generally, coroutines can be categorized into two primary types: + Generator coroutine: designed for producing sequences + Task coroutine: employed for asynchronous programming</p>"},{"location":"blogpost/Lablanc/final/#generator-coroutines","title":"Generator coroutines","text":"<p>Generator coroutines exhibit a unique behavior. They generate sequences of values in a lazy, on-demand manner, yielding each value individually when requested by the consumer. This is achieved through the use of the co_yield keyword, which enables you to generate values without the need to compute the entire sequence in advance. Generator coroutines are particularly valuable when implementing iterators or implementing a mechanism for efficient lazy sequence processing. Below is an example of a simple generator coroutine.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;coroutine&gt;\n\ngenerator&lt;int&gt; GenerateNumbers(int from, int to) {\n  for (int i = from; i &lt;= to; ++i) {\n    co_yield i;\n  }\n}\n\nint main() {\n  for (int number: GenerateNumbers(1, 5)) {\n    std::cout &lt;&lt; number &lt;&lt; \" \";\n  }\n}\n</code></pre> <p>In this example, we define the generator coroutine called generateNumbers that yields a sequence of numbers using co_yield with \u201cfrom\u201d and \u201cto\u201d.</p> <p>Output:</p> <pre><code>1 2 3 4 5\n</code></pre>"},{"location":"blogpost/Lablanc/final/#task-coroutines","title":"Task coroutines","text":"<p>On the other hand, task coroutines serve the purpose of enabling you to await asynchronous operations without causing the calling thread to become blocked. These coroutines make extensive use of the co_await keyword, which effectively pauses their execution until the awaited operation has concluded. Various operations that can be awaited encompass I/O tasks (which we'll delve into shortly), network requests, and timers. To illustrate the concept, here's a straightforward task coroutine that emulates an asynchronous operation.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;coroutine&gt;\n#include &lt;chrono&gt;\n\nstd::task&lt;void&gt; AsyncTask() {\n  // Simulate an asynchronous task\n  std::cout &lt;&lt; \"Async task started.\" &lt;&lt; std::endl;\n\n  // Simulate an asynchronous operation\n  co_await std::suspend_for(std::chrono::seconds(2));\n\n  std::cout &lt;&lt; \"Async task completed.\" &lt;&lt; std::endl;\n}\n\nint main() {\n  // Start the asynchronous task using 'resume'\n  AsyncTask().resume();\n\n  // Continue with other work while the async task is in progress\n  std::this_thread::sleep_for(std::chrono::seconds(3));\n\n  std::cout &lt;&lt; \"Main function continues to run asynchronously.\" &lt;&lt; std::endl;\n\n  return 0;\n}\n\n</code></pre> <p>We define a task coroutine called asyncTask that simulates an asynchronous operation using std::suspend_for. Using the co_await keyword to suspend execution, we allow other tasks to run concurrently during the delay. In the main function, we start the coroutine by calling resume(), and while the async task is in progress, the main function continues to execute other code concurrently.</p> <p>Output:</p> <pre><code>Async task started.\nMain function continues to run asynchronously.\nAsync task completed.\n</code></pre>"},{"location":"blogpost/Lablanc/final/#how-do-we-implement-coroutines","title":"How do we implement coroutines?","text":"<ul> <li>Must be using C++20</li> <li>Include the coroutine header --&gt; <code>#include &lt;coroutine&gt;</code></li> <li>Define the coroutine function</li> </ul>"},{"location":"blogpost/Lablanc/final/#defining-a-coroutine-function","title":"Defining a coroutine function","text":"<p>The cppreference definition states, \u201ca function is a coroutine if its definition contains any of the following:\u201d + <code>co_await</code> \u2013 for suspending execution until resumed + <code>co_yield</code> \u2013 for suspending execution and returning a value + <code>co_return</code> \u2013 for completing execution and returning a value</p>"},{"location":"blogpost/Lablanc/final/#return-types","title":"Return types","text":"<p>Coroutines can have different return types \u2013 similar to a regular function \u2013 that depend on the specific behavior you want to achieve.</p> <p><code>void</code> \u2013 when the coroutine doesn\u2019t return any meaningful result   + suitable for coroutines that primarily have side effects or perform asynchronous operations without producing a value</p> <p><code>std::suspend_never</code> - when you want the coroutine to run to completion without ever suspending   + appropriate for lightweight, non-blocking tasks that don\u2019t need to wait for other operations</p> <p><code>std::suspend_always</code> \u2013 when you want the coroutine to suspend immediately upon entry and never resume   + useful for cases when you don\u2019t intend to perform any work in the coroutine</p> <p><code>std::coroutine_handle&lt;&gt;</code> - a low-level coroutine used for customizing coroutine handling</p> <p><code>std::task&lt;T&gt;</code> or <code>std::task&lt;void&gt;</code> - should be used for high level asynchronous programming   + suitable for representing asynchronous operations as tasks and can be used with libraries that provide abstractions</p> <p><code>custom promise types</code> - for more complex coroutines that need to return values, manage state, or implement advanced coroutine behavior</p>"},{"location":"blogpost/Lablanc/final/#custom-coroutines","title":"Custom coroutines","text":"<p>As mentioned earlier, custom coroutines come in handy if we want to return specific values, manage the state, or even implement advanced coroutine behavior. Let's jump into everything you need in order to accomplish this.</p>"},{"location":"blogpost/Lablanc/final/#define-the-promise_type-structure-or-class","title":"Define the promise_type structure or class","text":"<p>The promise_type is a structure associated with a coroutine that is responsible for managing the coroutine\u2019s state and returning the final result. It allows developers to define how a coroutine behaves during its lifetime, such as managing resources, handling exceptions, and controlling the flow of execution. This structure encapsulates the logic related to the coroutine's lifetime and interactions, providing a means for developers to tailor coroutine behavior to specific application requirements.</p> <p>Now let's get into the essential and commonly used members</p> <p>\ud83d\udd34 REQUIRED \ud83d\udfe2 TYPICALLY REQUIRED</p>"},{"location":"blogpost/Lablanc/final/#essential-members","title":"Essential members:","text":"<p>\ud83d\udd34<code>get_returned_object()</code> - returns an instance of the object (this is where the coroutine\u2019s result is stored)</p> <p>\ud83d\udd34<code>unhandled_exception()</code> \u2013 for proper exception handling within the coroutine</p> <p>\ud83d\udfe2<code>return_void()</code> \u2013 allows the promise to finalize the coroutine\u2019s results (required if coroutine returns void)</p> <p>\ud83d\udfe2<code>initial_susend()</code> \u2013 specifies whether the coroutine should suspend immediately upon entering by deciding whether to perform some initial setup or suspend right away      + use when you want to control the suspension behavior of the coroutine when it starts</p> <p>\ud83d\udfe2<code>final_suspend()</code> \u2013 specifies whether the coroutine should suspend after the last value (generator), or when the coroutine is complete     + use when you want to control the suspension behavior of the coroutine after producing all values or completing its task</p>"},{"location":"blogpost/Lablanc/final/#commonly-used-members","title":"Commonly used members:","text":"<p><code>yield_value()</code> - allows the coroutine to yield a value using co_yield     + most common in generator coroutines</p> <p><code>await_suspend()</code> \u2013 allows custom logic to be applied when the coroutine is suspended</p> <p><code>await_resume()</code> \u2013 used when the coroutine resumes after a \"suspend\", usually to retrieve the result of the awaited tasks</p> <p><code>get_return_object_on_allocation_failure()</code> \u2013 used to handle resource allocation failures when creating the coroutine promise; can provide an alternative object in case of allocation failure</p> <p><code>rethrow_if_nested(task&lt;...&gt;)</code> \u2013 used for proper exception handling in nested tasks; ensures that exceptions thrown in nested tasks are rethrown correctly</p> <p> Now that we have the basics covered on customizable coroutines, let's dive into the first example that designs a chat coroutine! </p>"},{"location":"blogpost/Lablanc/final/#custom-chat-example","title":"Custom chat example","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;coroutine&gt;\n#include &lt;string&gt;\n\nstruct Chat {\n\n    struct promise_type {\n        std::string msgOut{}, msgIn{}; // this stores values going into or coming out of the coroutine\n\n        void unhandled_exception() noexcept {}; // what to do when there's an exception\n        Chat get_return_object() { return Chat(this); } // coroutine creation\n        std::suspend_always initial_suspend() noexcept { return{}; } // startup\n        std::suspend_always yield_value(std::string msg) noexcept // value from co_yield\n        {\n            msgOut = std::move(msg);\n            return {};\n        }\n\n        auto await_transform(std::string) noexcept // value from co_await\n        {\n            struct awaiter { //&gt; these can be customized instead of using suspend_always or suspend_never\n                promise_type&amp; pt;\n                constexpr bool await_ready() const noexcept { return true; }\n                std::string await_resume() const noexcept { return std::move(pt.msgIn); }\n                void await_suspend(std::coroutine_handle&lt;&gt;) const noexcept {}\n\n            };\n\n            return awaiter{*this};\n        }\n\n        void return_value(std::string msg) noexcept { msgOut = std::move(msg); } // value from co_return\n        std::suspend_always final_suspend() noexcept { return {}; }  // ending\n\n    };\n</code></pre> <p>We create a coroutine called Chat with the promise_type struct nested inside. At the bottom, the chat coroutine has a return_value function that is callable from the co_return keyword. We also set final_suspend to suspend_always, meaning when the coroutine is finished, it will always suspend, or in other words, terminate.</p> <p>Taking a look into the promise_type struct, you will notice it\u2019s nested inside the chat coroutine. We include member variables to store values that will come in and go out of the coroutine.  As mentioned before, we include the essential member functions: + <code>C++   void unhandled_exception() noexcept {};</code>     handles any exceptions</p> <ul> <li> <p><code>C++   Chat get_return_object() { return Chat(this); }</code>   returns the coroutine object when first created</p> </li> <li> <p><code>C++   std::suspend_always initial_suspend() noexcept { return{}; }</code>     the coroutine is initially suspended before it starts executing, implying the coroutine will need to be explicitly resumed using the <code>resume()</code> member function (here)</p> </li> <li> <p><code>C++     std::suspend_always final_suspend() noexcept { return {}; }</code>     terminates the coroutine when finished</p> </li> </ul> <p>You will also noticed the commonly used member functions mentioned before: </p> <ul> <li> <p><code>C++   std::suspend_always yield_value(std::string msg) noexcept // value from co_yield     {         msgOut = std::move(msg);         return {};     }</code>     which stores the value from the co_yield keyword into the msgOut member variable. Additionally, the await_transform member function is part of the coroutine\u2019s promise type, and can be called using the co_await keyword. Inside the await_transform function contains a local awaiter structure which is responsible for controlling the behavior of the coroutine when co_await is used. You will notice the awaiter object has:</p> </li> <li> <p><code>C++   promise_type&amp; pt;</code>     the awaiter struct constructor takes a reference to the promise type allowing the awaiter to access the state and control the behavior of the coroutine</p> </li> <li> <p><code>C++   constexpr bool await_ready() const noexcept { return true; }</code>     called when the co_await expression is evaluated; will return a boolean indicating whether the awaited value is immediately available</p> </li> <li> <p><code>C++   std::string await_resume() const noexcept { return std::move(pt.msgIn); }</code>     called when the coroutine is ready to resume after suspension. In this case, it retrieves the awaited value from the coroutines promise type, specifically moving pt.msgIn and returning it as a string</p> </li> <li> <p><code>C++   void await_suspend(std::coroutine_handle&lt;&gt;) const noexcept {}</code>     called when the coroutine is about to be suspended after the co_await expression is evaluated. In this case, it doesn\u2019t perform any specific suspension action</p> </li> </ul> <p> Moving on, we will look more closely at the chat structure</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;coroutine&gt;\n#include &lt;string&gt;\n\nstruct Chat {\n\n    struct promise_type {...};\n\n    using Handle = std::coroutine_handle&lt;promise_type&gt;;  // shortcut\n    Handle mCoroHdl{};\n\n    explicit Chat(promise_type *p) : mCoroHdl{Handle::from_promise(*p)} {} // get the handle from the promise\n    Chat(Chat &amp;&amp; rhs) : mCoroHdl{std::exchange(rhs.mCoroHdl, nullptr)} {} // move only\n\n    /// Destructor\n    ~Chat()\n    {\n        if (mCoroHdl) { mCoroHdl.destroy(); }\n    }\n\n    std::string listen() // activate the coroutine and listen\n    {\n        if (not mCoroHdl.done()) { mCoroHdl.resume(); }\n        return std::move(mCoroHdl.promise().msgOut);\n    }\n\n    void answer(std::string msg) const // send data to the coroutine and activate it\n    {\n        mCoroHdl.promise().msgIn = msg;\n        if (not mCoroHdl.done()) { mCoroHdl.resume(); }\n    }\n\n};\n</code></pre> <p>We use the</p> <pre><code>using Handle = std::coroutine_handle&lt;promise_type&gt;;\nHandle mCoroHdl{};\n</code></pre> <p>which allows us to customize our coroutine handling to create an alias named Handle and declare mCoroHdl as a member variable of type Handle which will be used to control the execution of the coroutine</p> <p>We create a Chat instance and initialize mCoroHdl with the coroutine handle created from the provided promise:</p> <pre><code>  explicit Chat(promise_type *p) : mCoroHdl{Handle::from_promise(*p)} {}\n</code></pre> <p>Additionally, we create the move constructor for Chat that takes an rvalue reference to another Chat instance and moves the coroutine handle from rhs to the current object:</p> <pre><code>  Chat(Chat &amp;&amp; rhs) : mCoroHdl{std::exchange(rhs.mCoroHdl, nullptr)}\n</code></pre> <p>Although it\u2019s not necessary, it can be beneficial if you want to optimize memory and performance, are worried about resource management, or just need to transfer ownership. For instance, if your object is managing a large buffer, it would be highly beneficial to transfer ownership rather than copying it</p> <p>Continuing, we create a listen function which is used to activate the coroutine and listen for a response. It first checks if the coroutine is done, if not, it calls resume() to advance the coroutine\u2019s execution. In this example, it returns the restored response in the promise\u2019s msgOut member:</p> <pre><code>  std::string listen()\n    {\n        if (not mCoroHdl.done()) { mCoroHdl.resume(); }\n        return std::move(mCoroHdl.promise().msgOut);\n    }\n</code></pre> <p>Lastly, we create an answer function used to send data to the coroutine and activate it by storing the provided message in the promise\u2019s msgIn member and again check if the coroutine is done. If not, it resumes:</p> <pre><code>  void answer(std::string msg) const\n    {\n        mCoroHdl.promise().msgIn = msg;\n        if (not mCoroHdl.done()) { mCoroHdl.resume(); }\n    }\n</code></pre> <p> Let's get into the last part of this chat coroutine</p> <pre><code>Chat Fun()\n{\n    co_yield \"Hi, what's your name?\\n\"; // suspends coroutine w/ output message\n    std::string name = co_await std::string{}; // suspends coroutine w/ input message\n    co_return \"Nice to meet you, \" + name + \"!\\n\"; // ends coroutine and returns final message\n\n}\n\nint main()\n{\n    std::string input;\n    Chat chat = Fun();\n    std::cout &lt;&lt; chat.listen();\n\n    std::getline(std::cin, input);\n    chat.answer(input);\n\n    std::cout &lt;&lt; chat.listen();\n    return 0;\n\n}\n</code></pre> <p>Finally, we define the Fun() coroutine function. We create a Chat object named chat and begin the coroutine\u2019s execution and the initial message is displayed with <code>chat.listen()</code>. We use <code>chat.answer()</code> to send the user\u2019s input as a response to the coroutine which will continue executing after the co_await line on line 65. And at the end, we call <code>chat.listen()</code> activating the coroutine to return the final message.</p> <p>This is a great example of how a coroutine can be used to simulate the conversation, with the coroutine yielding messages, awaiting user input, and finally returning a response. </p> <p></p>"},{"location":"blogpost/Lablanc/final/#custom-vector-example","title":"Custom vector example","text":"<p>Here is another example of a customizable generator coroutine that interleaves two vectors:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;coroutine&gt;\n#include &lt;vector&gt;\n\nstruct Generator {\n\n    struct promise_type {\n        int val{};\n\n        Generator get_return_object() { return Generator(this); }\n        std::suspend_never initial_suspend() noexcept { return {}; }\n        std::suspend_always final_suspend() noexcept { return {}; }\n        std::suspend_always yield_value(int v)\n        {\n            val = v;\n            return {};\n        }\n        void unhandled_exception() {}\n    };\n\n    using Handle = std::coroutine_handle&lt;promise_type&gt;;\n    Handle mCorohdl{};\n\n    explicit Generator(promise_type* p) : mCorohdl{Handle::from_promise(*p)} {}\n\n    Generator (Generator&amp;&amp; rhs) : mCorohdl{std::exchange(rhs.mCorohdl, nullptr)} {}\n    ~Generator()\n    {\n        if (mCorohdl) { mCorohdl.destroy(); }\n    }\n\n    int value() const { return mCorohdl.promise().val; }\n    bool finished() const { return mCorohdl.done(); }\n    void resume()\n    {\n        if (not finished()) { mCorohdl.resume(); }\n    }\n};\n\nGenerator interleaved(std::vector&lt;int&gt; a, std::vector&lt;int&gt; b)\n{\n    auto lamb = [](std::vector&lt;int&gt;&amp; v)-&gt;Generator {\n        for (const auto &amp;e : v) {\n            co_yield e;\n        }\n    };\n\n    auto x = lamb(a);\n    auto y = lamb(b);\n\n    while (not x.finished() or not y.finished()) {\n        if (not x.finished()) {\n            co_yield x.value();\n            x.resume();\n        }\n\n        if (not y.finished()) {\n            co_yield y.value();\n            y.resume();\n        }\n    }\n}\n\nint main()\n{\n    std::vector a{1, 3, 5, 7, 9};\n    std::vector b{2, 4, 6, 8, 10};\n\n    Generator g(interleaved(std::move(a), std::move(b)));\n\n    while (not g.finished())\n    {\n        std::cout &lt;&lt; g.value() &lt;&lt; \"\\n\";\n        g.resume();\n    }\n\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"blogpost/Lablanc/final/#generator-struct","title":"Generator struct","text":"<ul> <li>Custom coroutine type designed to generate and yield values</li> <li>Defines the promise_type struct ultimately customizing the coroutine behavior</li> <li>The generator type uses a coroutine handle (std::corourtine_handle) to manage the coroutine\u2019s execution</li> <li>Provides a method to check if the coroutine is finished, obtain the current yielded value, and manually resume the coroutine</li> <li>Struct manages the destruction of the coroutine handle in its destructor</li> </ul>"},{"location":"blogpost/Lablanc/final/#interleaved-function","title":"Interleaved function","text":"<ul> <li>Takes two vectors as input (a &amp; b)</li> <li>Inside the function, it defines the lambda function that takes a reference to the vector and creates a Generator for it</li> <li>The lambda iterates through the input vector and yields each element in the vector using co_yield</li> <li>Interleaves the values from the two Generator instances, x and y, in the while loop</li> <li>Yields values from x and y and if either x or y are not finished, it resumes the respective generator</li> </ul>"},{"location":"blogpost/Lablanc/final/#main-function","title":"Main function","text":"<ul> <li>The two vectors are defined (a &amp; b)</li> <li>Interleaved function is called and its results are stored in a generator called g</li> <li>The values are printed to the console, and the generator is manually resumed</li> </ul>"},{"location":"blogpost/Lablanc/final/#why-use-coroutines","title":"Why use coroutines?","text":"<p>Coroutines provide a more efficient and manageable way to achieve concurrency, making them valuable for tasks involving parallelism, scalability, and asynchronous operations. They contribute to cleaner and more readable code while avoiding some of the challenges associated with traditional multithreading approaches.</p> <p>They are particularly useful for handling requests or interacting with databases ultimately improving the responsiveness of applications. When a coroutine encounters an I/O operation, it can yield control back to the event loop, allowing other tasks to run which was shown in both the custom examples. </p> <p>Coroutines are often integrated with event loops, which are a fundamental component of event-driven programming. The event loop manages the scheduling and execution of coroutines, ensuring that events are processed efficiently and that the application remains responsive</p> <p>Additionally, if you are worried about resources such as memory, coroutines are extremely useful for resource management. Coroutines are more resource-efficient than creating a thread or process for every asynchronous task. They can be executed on a limited number of threads, which saves memory and resources. </p> <p> \ud83c\udf89\ud83c\udf89\ud83c\udf89Congrats! You've finished the tutorial!\ud83c\udf89\ud83c\udf89\ud83c\udf89</p> <p>I hope this tutorial was helpful and you have a better understanding of C++ coroutines!</p>"},{"location":"blogpost/Lablanc/final/#references","title":"References","text":"<p>https://en.cppreference.com/w/cpp/language/coroutines</p> <p>https://stackoverflow.com/questions/71153205/c-coroutine-when-how-to-use</p> <p>https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html</p> <p>https://www.geeksforgeeks.org/coroutines-in-c-cpp/</p> <p>ChatGPT</p>"},{"location":"blogpost/Lichtman/final/","title":"Final","text":"<p>By: Chase Lichtman</p> <p>C++ is a very expansive programming language that lets the user do many different things.</p> <p>However, the standard library does have its own limitations and is not able to allow the user t sometimes to expand their horizons on their programs. That is where libraries come in, to support C++ and make the users experience more diverse. One of the most expansive libraries that C++ has to offer is wxWidgets. wxWidgets allows a whole new world of C++! Instead of having outputs only to the terminal, we are now able to make screens and graphics and are now able to display high levels of code! Downloading wxWidgets was a bit of a hassle. I downloaded it from the website, https://wxwidgets.org/downloads/ and unzipped it. With that on my computer.</p> <p>To get it working and compiled I followed my professor's guide to how to set it up on my IDE CLion while also using a CMAKE file. If you would like to try and get this running, I would highly recommend watching</p> <p>This will show you how to dudes the library. The author does his in linux, but he shows and tells the listener the changes that would be made if it was windows. I believe the hardest part of getting this library working is adding it to the CMAKE file and getting it running, but the video gives some assistance with this problem.</p> <p>The functions in the wxWidgets library are very straightforward and are easy to incorporate into your code. I will show a few functions and their uses later in this post.</p> <p>We need to first create our window that we want to show. I have created a frame class and added an Initialize function to it. In it, we have called the function Create. The parameters include- a parent (in this case we have none), an Id, the title of the frame, a default positioning, and how big to make the screen. This allows us to create a window with our specific parameters.</p> <p>We can call the window whatever we want and determine how big the window will end up being.</p> <p>{width=\"6.5in\" height=\"3.2111111111111112in\"}</p> <p>With a Frame class and an Initialize function made, we can now start making a new frame to try and make a popup window. The show function is apart of the wxWindows class from the library that lets us show the window.</p> <p>{width=\"6.5in\" height=\"3.6861100174978128in\"}</p> <p>With that being set, we can now run our program. wxWidgets makes it very easy to run without needing a main function. In our main.cpp, we just need to call wxIMPLEMENT_APP with our class name and that will run the program.</p> <p>{width=\"4.041666666666667in\" height=\"1.0416666666666667in\"}</p> <p>With that running we will get a popup window! We have officially ditched the terminal and have a whole new world to display our code and make new and exciting programs.</p> <p>{width=\"6.5in\" height=\"5.026388888888889in\"}</p> <p>We are now able to use our imaginations and create whatever scene we want. wxWidgets has plenty of classes allowing us to showcase and display our creative minds. There are pens to draw out lines and functions like wxColour that can change the color of those lines. We are also able to change the background with the function SetBackground(*wx...) with whatever color we want replacing the ellipses all in caps (EX. wxYELLOW).</p> <p>In this example I have made a new view class. Here we can initialize what we want to see on the screen and be able to paint and draw pictures. The bind function will then call our paint function. We can see that OnPaint has a parameter of a reference to a wxPaintEvent. We can see it is not being used in the function. This paint event is used for when a window's content needs to be changed or repainted. This may be a bit confusing, but we can see what in Bind all we have to do is &amp;View::OnPaint. The paint event is just there to be like \"Hey the window needs to be painted over again.\" The wxAutoBufferedPaintDC is a huge object. This will act as our canvas and make it so we can add things to the screen. We then ask it to set the background to yellow.</p> <p>{width=\"6.5in\" height=\"3.1777777777777776in\"}</p> <p>After declaring these functions, let's go back to our frame class and initialize our new view. After creating the frame let's make a new view object. We will then pass the frame that we just created into it and initialize the view with the InitializeT function we made in the view class. The \"this\" parameter for the InitializeT function just indicates that we are working with a pointer to the frame that is in the function.</p> <p>{width=\"5.933333333333334in\" height=\"2.183332239720035in\"}</p> <p>Once this is all done and we run again, we can now see that the entire background is yellow!</p> <p>{width=\"6.5in\" height=\"5.184722222222222in\"}</p> <p>The last thing I want to show you is to draw something onto our background. With wxWidgets this is fairly simple. We just need to make a pen and set that pen to a color. Then we just need to call the Drawline function with the parameters of how long to make the line and where to place the line</p> <p>{width=\"3.466666666666667in\" height=\"0.5916655730533683in\"}</p> <p>Here is the results.</p> <p>{width=\"3.3916666666666666in\" height=\"2.716666666666667in\"}</p> <p>That is just the surface of what this library can accomplish. We can make full pictures with different shapes and all different colors plus text.</p> <p>All in all, this library is pretty simple to set up and can get something popping up on our systems in a matter of minutes. The functions are straight forward to use an add to your code and their reference page is filled with detail and description of each function, plus thousands of other uses of this library that I did not even get to. I believe the hardest thing with this library is getting it set up and configured properly on your system (but that goes for all libraries that are not apart of</p> <p>the standard library). This library is a must go to for someone wanting to start getting into graphics and wants to elevate their C++ programming to a whole new level!</p>"},{"location":"blogpost/Magal/final/","title":"Final","text":"<p>GameNetworkingSockets: gamertime</p> <p>Krish Magal</p> <p>Any modern video game has some online aspect to it, whether it's online multiplayer, in game shop, or cloud saves. Developers can spend a large amount of time trying to find good libraries to use for their games, and some are difficult to use without additional libraries, further\\ complicating the process.</p> <p>One library that makes a strong case to be used in the development of video games is Valve Software's GameNetworkingSockets (GNS) library.</p> <p>This library is one created by one of the largest names in video games, Valve Software, best known for the creation of Steam and its following products. This library is supposedly very well made and preferred by many studios trying to publish games on Steam.</p> <p>One of the main devs of this library stated that \"The main interface class is named SteamNetworkingSockets, and many files have \\\"steam\\\" in their name. But Steam is not needed. If you don\\'t make games or aren\\'t on Steam, feel free to use this code for whatever purpose you want.\"</p> <p>Without further ado, lets pull back the curtain and see what we can find. When getting started, I found the easiest thing for me to do was to set up a simple C++ project. One great thing about this library is that there are multiple wrappers available, so that you can code in either C# or Python, showing just how accessible this library is!</p> <p>For this, I set up a simple CMake project. I found it was the easiest way that I could get up and running, since I've got a decent amount of experience with it. Of course, you can set up your configuration any way you like, so mileage may vary. Below is an example of what your\\ CMakeLists.txt might look like just to get started, we could be updating</p> <p>this.</p> <p>{width=\"6.5in\" height=\"7.337498906386702in\"}</p> <p>As you can see, it's very simple to be able to fetch the library from GitHub, but the other 2 libraries required are locally installed! I've linked install guides for both Protobuf and OpenSSL down at the bottom If you're interested in checking out the GitHub repo, I've linked it For this</p> <p>project, I've set up a simple P2P messaging system. P2P games are great for LAN parties, and games that don't need a true internet connection.</p> <p>Here's a simple main function that creates 2 players and binds them to 2 sockets. Once the sockets have been bound, the client begins polling for incoming messages.</p> <p>{width=\"5.665277777777778in\" height=\"4.234721128608924in\"}</p> <p>Here you can see a simple main function that shows the instantiation of players 1 and 2. Since we are establishing a P2P connection, both of those connections are established right after. Next, we have a while true loop. This is to poll for incoming messages from both players, where the handler for incoming messages is called.</p> <p>Here's what we might do when we get a message:</p> <p>{width=\"6.2in\" height=\"3.5861111111111112in\"}</p> <p>This function here describes the behavior we might execute when the manager receives a message from its peers. This allows us to measure the length of the message and then, if the message is not empty, display the received message.</p> <p>{width=\"6.5in\" height=\"7.111111111111111in\"}</p> <p>{width=\"6.5in\" height=\"2.313888888888889in\"}</p> <p>Here, you can see the above implementation of what a client might look like. We set up the client identity using our network information and connect to our remote host.Make Sure to set SteamNetworkingIPAddr::IPv4Localhost(0) with the appropriate remote address. This sends a message, \"Hello, Server!\" when it connects, and has an infinite loop to poll for pings.</p> <p>Here is our output from the server.</p> <p>{width=\"3.738888888888889in\" height=\"1.0208333333333333in\"}</p> <p>These are very basic examples, however, and a true client should include error handling, connection management (such as reconnection logic), proper message encoding/decoding, and potentially asynchronous\\ processing or event-driven architecture. You would also need to properly handle user input or game events to trigger sending messages and reacting to incoming messages accordingly.</p> <p>Unfortunately, there are large issues with GNS that make it rather\\ cumbersome and difficult to use. GNS requires the use of another library, Protocol Buffer a.k.a. Protobuf for serialization as well as OpenSSL. GNS has Protobuf and OpenSSL hard coded into its code, so unfortunately you</p> <p>can't use your own preferred libraries. These are large amounts of</p> <p>information so I've linked a few installation guides.</p> <p>Here's the most recent CVE report on the vulnerability score of the GNS library for anyone considering using this library in a personal game or other project.</p> <p>{width=\"6.5in\" height=\"1.6291666666666667in\"}</p> <p>It currently features a score of 7.5, a high vulnerability score. Let's break it down.</p> <p>{width=\"6.5in\" height=\"1.386111111111111in\"}</p> <p>As you can see here, this flaw features a low attack complexity and a high availability impact. Developers can rest easy however, as it has neither any confidentiality impact nor any integrity impact. Unfortunately, it's not made clear if this is the proprietary version, or rather the open-source version. I would hope that some brave network engineer found a way to fix this.</p> <p>In conclusion, after going through the setup and development process, I would not recommend using this library for beginners. It's difficult to set up, with it requiring 2 additional libraries, which were a pain to install and link. An easier to use alternative would be SFML, which has multiple modules, including graphics and a simple, yet powerful networking module. I hope you found this piece informative!</p>"},{"location":"blogpost/Meehan/final/","title":"Final","text":"<p>Kevin Meehan October 18, 2023 CSE 491 Professor Ofria Wordle (By ChatGPT)         As of November 29th, 2022, AI for software engineers was hard to come by that could immensely help them write code. However, with the launch of ChatGPT, this was about to change. Software engineers could now interact with this AI and ask it almost any question about software, ranging from introductory knowledge of a new language, to debugging hundreds of lines of code and getting an answer within seconds. Although ChatGPT is extremely smart, it is only as smart as the person asking it questions is. Today, I will be using ChatGPT to write a medium sized program and analyzing what it does good, what it does bad, and what can be improved on.         Wordle is a popular game that people can play where there is a five letter word and the goal is to guess the word in six guesses. If a letter is guessed correctly, it will be in green; if the letter guessed is in the word, but it is in the wrong location, it will be yellow; and if the letter is guessed incorrectly, it will be in gray. Because writing a software program that runs in c++ will be difficult to exactly replicate the original Wordle game, I had to come up with a slightly different way the player could interact with the program and play the game. This was my initial statement to ChatGPT. Figure 1         With this statement, I got a partially functioning Wordle game with some errors, but ChatGPT has the right idea about the whole game. The first error was in the response of the program to the player guessing the word. For example, I tried this initial project out by guessing the word \u201cswamp\u201d as my first word and the correct word was \u201cworld\u201d. The program returned \u201c10000\u201d and it should have returned \u201c01000\u201d because the letter \u2018w\u2019 was in the word, but in the wrong location. ChatGPT responded with this code to compare the word guessed to the target word.</p> <p>Figure 2 (Chat GPT\u2019s first version of CompareWords() function)</p> <p>Figure 3 (ChatGPT\u2019s correct and final version of CompareWords() function)         These two functions are very similar, but do a couple things differently when assembling the response string. This function gets called after the user types in a word. The \u2018target\u2019 string is the string of the hidden word the player is trying to guess, and the \u2018guess\u2019 string is the word the player inputted as its guess. The first function does not take into consideration the location of the given number in the string \u2018result\u2019 like the final function. It strictly finds a letter that is either correct, incorrect, or partially correct and adds it to the end of the string result. In the final function, however, it specifies the index of where each number should be. It does this by making a string filled with zeros and then updating each number as it goes on. The first function, however, just creates an empty string and adds numbers onto it as it goes. As we can see in line 48 in Figure 3 compared to line 121 in Figure 2, both functions check for matched letters first. In the first function, if it finds a matched letter, it adds a \u20182\u2019 to the end of the string. In the second function, however, it modifies the string of zeros to change the correct position of the correct letter to a \u20182\u2019. </p> <pre><code>    The next problem I had was that the code provided only gave a handful of words to use as the hidden word. I wanted to have more words to be used so the player wouldn\u2019t be getting the same words every time. This brought up a problem, however, because the c++ standard library does not have a way to import English words, let alone five letter English words. This was not a problem for ChatGPT though, because it mentioned a couple ways of solving this issue. The way I chose was to use a text file and fill up the text file with as many five letter words I wanted. ChatGPT recommended a few different sites, but I chose this website \u201chttps://7esl.com/5-letter-words/#5_Letter_Words_with_A\u201d. From here, I was able to copy and paste all the five letter words into a text file and have ChatGPT write a function to pull a random word from the text file and use that as the hidden word.\n</code></pre> <p>Figure 4</p> <p>Figure 5         These two functions in Figure 4 and 5 were produced by ChatGPT after I filled up the text file with five letter words and it worked perfectly. What happens in the main function is it calls LoadWordList() with the file path to the text file I created and loads each individual word into a vector of strings. It then calls the GenerateRandomWord() function and returns a randomized word inside the list it just created.  This code works perfectly, but there are a few things that I think it could improve on. The first being the \u2018if\u2019 statement in line 116 of Figure 4. Every word in the text file is already five letters, so someone might say that it is redundant, but one argument could be made that it is always good to double check as it could cause the program to crash if there was a typo of some sort. Another thing is that each time the program is run, it has to loop through every single word in the text file (561 to be exact). Because this number is relatively small, performance issues are irrelevant. However, if I was going about solving this problem, I would have made a database that stored all the words and then generated a random number inside the GenerateWord() function and directly pulled a word from the database. This way, I wouldn\u2019t have to worry about recreating a list of all the words every time the program is run. </p> <p>Figure 6 (Main Function Created by ChatGPT)         The main function for this program isn\u2019t too complicated because no comparing or pulling data needs to be done. What ChatGPT does nicely is for the whole program, it makes helper functions for the information processing of the program. Whether it be comparing strings, loading in data, or simply choosing a random word, this code is put into helper functions. The code in main actually worked perfectly the very first time as well. The issues I had were in the helper functions. The main code had to be updated a couple times for when the helper functions got changed, but the structure and functionality of the code inside main worked perfectly. The logic for the main is extremely straightforward and I cannot think of a way to improve ChatGPT\u2019s code. Figure 7 (Templated LoadWordList function)</p> <p>Figure 8 (Templated GenerateRandomWord function)</p> <p>Figure 9 (Templated CompareWords function)         One way of improving this project would be by using templated functions. This would improve everything if someone were to want to change the game to a number guessing game, or anything not involving words. In order to do this, I asked ChatGPT to modify the entire project and use templated functions instead. ChatGPT came up with a new project, and correctly modified all the helper functions. I plugged everything into CLion and the project worked just as it did before. In order to test to see if it really worked, I deleted the text file with the five letter words and plugged in a bunch of random five number integers. After doing this, I also had to make a couple more small changes, such as deleting the transform function that turns every letter to lowercase, but besides that, the new number guessing game worked as well. Although this new game with numbers does not have much skill involved like a Wordle game does (it consists of randomly guessing numbers and using process of elimination for numbers guessed in the wrong place), it demonstrates that ChatGPT\u2019s new templated functions work correctly. As seen in figures 7-9, ChatGPT didn\u2019t have to change very much to the project to change the functions to templated functions. The main thing it had to do was add \u201ctemplate \u201d above the function declaration, as well as change the variable type to a \u2018T\u2019 instead of \u2018string\u2019.         By using ChatGPT, I was able to make this program work correctly in about 30 minutes. If I were to write the code myself, it would probably take at least three hours, and would definitely not be as efficient compared to ChatGPT\u2019s code. However, unless there was a user talking with ChatGPT while writing this program, this program would not work correctly. ChatGPT does not have a mind of its own and is only as smart as the user. This brings a great balance between human and AI interaction and the way they have to interact in order to achieve a common goal."},{"location":"blogpost/Mihailovic/","title":"Index","text":"<p>My .md file is the final draft, the other files inside this folder supplement the final markdown file.</p>"},{"location":"blogpost/Mihailovic/final/","title":"FAISS in C++","text":"<p>For this C++ library review, we will be discussing the FAISS (Facebook AI Similarity Search) library. According to Meta's own website, it \"allows developers to quickly search for embeddings of multimedia documents that are similar to each other\" (1). This capability has many different applications, and in this review, we will be delving into similarity searches of text. For text-based searches, FAISS can read text converted to numerical vectors (referred to as embeddings) in order to compare similar pieces of data. I will be demonstrating this capability with a dataset of 200 sentences.</p> <p>To begin, I will discuss how I installed FAISS. As far as my IDE goes, I am using CLion with CMake, and my OS is Windows 10. I simply cloned the FAISS git repo and continued from there. A pattern that quickly emerges is that there are many other things to install that FAISS is dependent on. The first of these is the NVIDIA CUDA Compiler. If you attempt to run FAISS without CUDA, you will get this error: \"Failed to find nvcc. Compiler requires the CUDA toolkit\". After this, I needed to install BLAS (Basic Linear Algebra Subprograms), as FAISS needs BLAS libraries for certain operations. Installing Intel oneAPI Math Kernel Library accomplished this for me. Installing both of these took considerable effort, and I ran into plenty of errors while attempting to compile the library with them.</p> <p>Next, I ran into this error: \"Could NOT find SWIG\". If you are unaware, FAISS is written in C++ (or else, why would I be writing about it?) -- with complete wrappers for Python. I was unaware until hours after getting everything else working, but FAISS is almost always used with a Python wrapper. All videos and guides online use FAISS with Python, and by default, FAISS expects you to do the same. Because we are working in C++, we do not need SWIG. Achieving this was simple enough: changing the CMake configuration to \"-DFAISS_ENABLE_PYTHON=OFF\".</p> <p>At this point, I thought I would be good to go. However, upon attempting to build my project with FAISS, I kept running into an error that \"unistd.h\" not found. After doing some research, I found out that this is a Unix header file, and not available on Windows systems. Although the official FAISS GitHub repository states that \"Faiss is supported on x86_64 machines on Linux, OSX, and Windows\" (2), I had a difficult time getting it working. I started to worry at this point, because I was afraid I would not be able to run FAISS on my system. My first attempt to fix this problem was to clone a git repo that ported FAISS for Windows. Unfortunately, that did not work for me.</p> <p>My solution to this problem was using WSL (Windows Subsystem for Linux). This allowed me to work in a Linux environment and avoid running into Windows-specific compiler issues. At first, I was having a lot of issues with my CMake profile. Luckily, a WSL toolchain is provided in CLion. After modifying my CMake profile to use the WSL toolchain, and adding the appropriate links in my CMakeLists.txt, I was able to finally build my project with FAISS.</p> <p>To rate my experience installing FAISS as a Windows and C++ user, I would give it a 1.5/5. Difficulty installing CUDA/ BLAS, not being able to work directly in Windows, and lack of support for C++ FAISS use online, were the biggest reasons for me. If you want to use this library, it may be a better idea to use it with Python if possible.</p> <p>Next, it is time to put FAISS to the test. In order to demonstrate its capabilities, I want to conduct a similarity search with text. First, I needed some text to work with, so I asked ChatGPT to generate 200 different sentences for me. I wrote these sentences into a .txt file line by line.</p> <p></p> <p>Next, I needed an embedding framework to transform text into vectors with numerical representations. I downloaded a 4GB file that contained a 300d pre-trained model for text, in order to perform this transformation. However, this part was quite difficult for me to accomplish. First of all, most of these embedding libraries were for Python, (e.g. the Sentence Transformers). I then tried to use the FastText for C++, but I had issues compiling and getting it to work with CLion/CMake.</p> <p>After running into many different problems, using FastText with Python was much easier. Working with Python in VSCode and WSL did the trick for me. Mind you, I just decided to use a Python file to transform the text into embeddings, and then write that all to a .csv file.</p> <pre><code>import fasttext\nimport csv\n\n# Load the pre-trained FastText model\nmodel = fasttext.load_model('cc.en.300.bin')\n\n# Open the file in read mode and a CSV file in write mode\nwith open('sentences.txt', 'r') as file, open('vectors.csv', 'w', newline='') as out_file:\n    writer = csv.writer(out_file)\n    for sentence in file:\n        sentence = sentence.strip()\n        vector = model.get_sentence_vector(sentence).tolist()\n        writer.writerow(vector)\n</code></pre> <p></p> <p>The actual code that works with FAISS is still in C++ and is simply reading in the .csv file. As I previously explained, these vectors have 300 dimensions (so the .csv file has 300 rows of decimal values), and there are 200 vectors. These vectors are specifically pre-trained for words \u2013 if you wanted to work with images, you would want to find another model.</p> <p>First, I read the embeddings into an array with a function I made called load_vectors. Then, I created a flat array to hold these embeddings in a format that is suitable for FAISS. I allocated memory for the array using the fact that it has 300 dimensions with 200 vectors. Then, with \"faiss::IndexFlatL2 index(d);\", a Faiss index was created for L2 (Euclidean) distance searches. This helps us figure out how similar two vectors (texts) are \u2013 there are 300 points in the Euclidean space for 1 vector, and the closer these points match up to other vectors, the closer the text is. \"index.add(nb, data.get());\" just adds all the vectors to the FAISS index.</p> <pre><code>std::vector&lt;std::vector&lt;float&gt;&gt; vectors = load_vectors(\"vectors.csv\");\nint d = 300; // 300 dimensions\nint nb = vectors.size(); // number of vectors: 200\n\n// Converting vectors to a single flat array\nstd::unique_ptr&lt;float[]&gt; data(new float[nb * d]);\nfor (int i = 0; i &lt; nb; i++) {\n    for (int j = 0; j &lt; d; j++) {\n        data[i * d + j] = vectors[i][j];\n    }\n}\n\n// Creates a FAISS index for L2 (Euclidean) distance\nfaiss::IndexFlatL2 index(d);\n\n// Adds vectors to the index\nindex.add(nb, data.get());\n</code></pre> <p>Next, I created an array called query_vector which has 300 elements in it. some_index is a value that the user can modify to their liking \u2013 it takes the nth vector in the array of 200 (i.e., the nth sentence), and compares that to all the other ones. query_vector is made to store all elements from the index we want to search with. We define k, which is the number of nearest neighbors we want. If we want the 5 most similar sentences, we set k to be 5. The distances vector holds the distance in Euclidean space between the query and the neighbor, and indices simply holds the index of the neighbor.</p> <pre><code>float query_vector[d];\n\nint some_index = 9;  // the index in the sentences.txt that will be searched against\nfor (int i = 0; i &lt; d; i++) {\n    query_vector[i] = vectors[some_index][i];\n}\n\nint k = 10; // number of nearest neighbors you want\nstd::unique_ptr&lt;float[]&gt; distances(new float[k]);\nstd::unique_ptr&lt;int64_t[]&gt; indices(new int64_t[k]);\n\nindex.search(1, query_vector, k, distances.get(), indices.get());\n</code></pre> <p>Then, the FAISS search function finally finds the closest vectors keeping all of these things in mind.</p> <pre><code>std::vector&lt;std::string&gt; sentences = load_sentences(\"sentences.txt\");\n\nfor (int i = 0; i &lt; 10; i++) {  // Top 10 results\n    std::cout &lt;&lt; \"Index: \" &lt;&lt; indices[i] &lt;&lt; \" Distance: \" &lt;&lt; distances[i]\n              &lt;&lt; \" Sentence: \" &lt;&lt; sentences[indices[i]] &lt;&lt; std::endl;\n}\n</code></pre> <p>To display the search results, I indexed the original .txt file of sentences I had, and indexed it for each corresponding neighbor. Let's see the results of searching by the 10th index, which corresponds to this sentence: \"The envoy expressed optimism about future collaborations.\":</p> <p></p> <p>As you can see, there are 10 results, as I set the k value to 10. Off first-glance, you can see that the closest results all begin with \"The\". That's a good start, but not very specific. At first, I wasn't sure if FAISS was actually working or not. To test this, I searched with the 1st index: \"The party's vision resonates with the aspirations of the youth.\":</p> <p></p> <p>And then I added a sentence to sentences.txt that was almost identical to that one, to see if FAISS was actually working. If it was, that sentence would be the closest one and have a very short distance. Here are the results:</p> <p></p> <p>Luckily, this worked exactly how I wanted it to; the second result (index 6) is one that I manually added. Now, I knew my code was working.</p> <p>Overall, I would say I enjoyed using the FAISS library. It was very difficult to install for me because a few different libraries were not working. However, the end result can be very useful depending on what you are working on. For example, my implementation of FAISS search can help to find documents similar to the one you are looking at. However, there are many more use cases. If you wanted to do a similarity search with faces instead, you can generate vectors based on image data using a different pre-trained model, and then follow the same steps I did. The same can even be done for audio clips! Overall, I would recommend the FAISS library for quick similarity searches in C++ on Mac and Linux, but would recommend another library for Windows users due to lack of support.</p>"},{"location":"blogpost/Mihailovic/final/#citations","title":"Citations","text":"<ol> <li>https://engineering.fb.com/2017/03/29/data-infrastructure/faiss-a-library-for-efficient-similarity-search</li> <li>https://github.com/facebookresearch/faiss/blob/main/INSTALL.md</li> </ol>"},{"location":"blogpost/Murrani/draft/","title":"Comparative Analysis of Djikstra\u2019s and A* Algorithms","text":"<p>Yousif Murrani</p>"},{"location":"blogpost/Murrani/draft/#introduction","title":"Introduction","text":"<p>Have you ever wondered how your GPS knows the exact quickest directions to get you to your destination or how  a video game enemy will always move exactly towards you no matter what\u2019s in their way? It\u2019s all thanks to pathfinding  algorithms. Pathfinding algorithms are crucial in today's world, whether it\u2019s to get you to work on time or to optimize  your code. In this article, we\u2019ll dive into the two biggest powerhouses of the pathfinding world: Dijkstra\u2019s  and the A* Algorithms.</p> <p>We will start off with Dijkstra\u2019s algorithm and explore its core concepts as well as its limitations. Then, we will  look at the more modern approach of the A* algorithm and see where it might be the better approach.</p> <p>In this blog, we will take an in-depth look at Dijkstra\u2019s algorithm, providing pseudocode and some examples  then we will do the same for A*. In the examples, we\u2019ll test out both algorithms in scenarios of different difficulty  for the algorithms to figure out and see how long it takes each one to complete the task. Afterwards, we\u2019ll compare  the two in terms of efficiency so that you know which to use in each scenario.</p>"},{"location":"blogpost/Murrani/draft/#dijkstras-algorithm","title":"Dijkstra\u2019s Algorithm","text":""},{"location":"blogpost/Murrani/draft/#overview","title":"Overview","text":"<p>One of the most popular pathfinding algorithms in the world is Dijkstra\u2019s algorithm, published by Edsger W. Dijkstra  in 1959. The algorithm was designed to find the shortest path between a given node and every other node in a  positive-weighted graph, essentially making it a Greedy Algorithm. It can also be classified as a Search Algorithm.  The algorithm can also be changed to find the shortest path between any given starting node and a destination node  then stopping. The data structures used within the code are usually a priority queue or a heap to optimize it.</p> <p>Here is a Gif showing how Dijkstra's Algorithm Works in Real Time:</p> <p></p>"},{"location":"blogpost/Murrani/draft/#pseudocode","title":"Pseudocode","text":"<pre><code>void Dijkstra(int graph[6][6], int src) // adjacency matrix used is 6x6\n{\n    int dist[6]; // integer array to calculate minimum distance for each node.\n    bool Tset[6]; // boolean array to mark visited/unvisited for each node.\n\n    // Set the nodes with infinity distance except for the initial node and mark them unvisited.\n    for (int i = 0; i &lt; 6; i++)\n    {\n        dist[i] = INT_MAX;\n        Tset[i] = false;\n    }\n\n    dist[src] = 0; // Source vertex distance is set to zero.\n\n    for (int i = 0; i &lt; 6; i++)\n    {\n        int m = minimumDist(dist, Tset); // vertex not yet included.\n        Tset[m] = true; // m with minimum distance included in Tset.\n\n        for (int i = 0; i &lt; 6; i++)\n        {\n            // Updating the minimum distance for the particular node.\n            if (!Tset[i] &amp;&amp; graph[m][i] &amp;&amp; dist[m] != INT_MAX &amp;&amp; dist[m] + graph[m][i] &lt; dist[i])\n                dist[i] = dist[m] + graph[m][i];\n        }\n    }\n\n    cout &lt;&lt; \"Vertex\\t\\tDistance from source\" &lt;&lt; endl;\n\n    for (int i = 0; i &lt; 6; i++)\n    {\n        char str = 65 + i; // Ascii values for printing A, B, C, ...\n        cout &lt;&lt; str &lt;&lt; \"\\t\\t\\t\" &lt;&lt; dist[i] &lt;&lt; endl;\n    }\n}\n</code></pre>"},{"location":"blogpost/Murrani/draft/#examples","title":"Examples","text":""},{"location":"blogpost/Murrani/draft/#timespace-complexity","title":"Time/Space Complexity","text":"<p>Here are the Time and Space complexities for Dijkstra's Algorithm:</p> <p>Time Complexity: O((|V| + |E|) * log(V))</p> <p>Space Complexity: O((|V| + |E|)) </p> <p>In the formulas, 'V' represents the number of Vertices (nodes) in the graph while 'E' represents the number of  Edges (connections between nodes) in the weighted graph. Using these two numbers, we can calculate the Big-O notation of Dijkstra's Algorithm.</p> <p>This is best shown in this graph:</p> <p></p> <p>While it starts out very similar to an O(n) algorithm, we can see that it starts to curve upwards more rapidly near the end. This leads us to believe that it's time complexity will be somewhere between O(nlog(n)) and O(n^2), as shown below:</p> <p></p>"},{"location":"blogpost/Murrani/draft/#applications","title":"Applications","text":""},{"location":"blogpost/Murrani/draft/#a-algorithm","title":"A* Algorithm","text":""},{"location":"blogpost/Murrani/draft/#overview_1","title":"Overview","text":"<p>The A (referred to as 'A-Star') Algorithm, like its predecessor Dijkstra's, is a very powerful pathfinding algorithm  designed to find the shortest path between a starting node and a destination node. However, unlike Dijkstra's,  the A is only a Search Algorithm. Another feature that sets A* apart is its ability to use a heuristic, which is a  function that can help it find the solution more quickly, albeit giving up some level of accuracy and precision. This  algorithm was actually created as a part of the Shakey Project,  which was building a robot that could choose its own actions. However, it has since become popular in many different  pathfinding uses.</p> <p>Here is a quick showcase of the A* Algorithm working with four different heuristics:</p> <p></p> <p>In the Gif, from left to right, the A* method is increasingly using a heuristic that prefers points that are closer  to the goal. When not using a heuristic, the algorithm becomes extremely similar to Dijkstra's.</p>"},{"location":"blogpost/Murrani/draft/#pseudocode_1","title":"Pseudocode","text":"<pre><code>// A* (star) Pathfinding// Initialize both open and closed list \nlet the openList equal empty list of nodes \nlet the closedList equal empty list of nodes// Add the start node \nput the startNode on the openList (leave it's f at zero)// Loop until you find the end \nwhile the openList is not empty    // Get the current node \n    let the currentNode equal the node with the least f value \n    remove the currentNode from the openList \n    add the currentNode to the closedList    // Found the goal \n    if currentNode is the goal \n        Congratz! You've found the end! Backtrack to get path    // Generate children \n    let the children of the currentNode equal the adjacent nodes \n\n   for each child in the children        // Child is on the closedList \n        if child is in the closedList \n            continue to beginning of for loop        // Create the f, g, and h values \n        child.g = currentNode.g + distance between child and current \n        child.h = distance from child to end \n        child.f = child.g + child.h        // Child is already in openList \n        if child.position is in the openList's nodes positions \n            if the child.g is higher than the openList node's g \n                continue to beginning of for loop        // Add the child to the openList \n        add the child to the openList \n</code></pre>"},{"location":"blogpost/Murrani/draft/#examples_1","title":"Examples","text":""},{"location":"blogpost/Murrani/draft/#timespace-complexity_1","title":"Time/Space Complexity","text":"<p>The Time and space complexity of the A* Algorithm is dependent on the heuristic used  for the algorithm. At best, it  could be O(1), at worst it would have the time and space complexity of Dijkstra\u2019s Algorithm.</p>"},{"location":"blogpost/Murrani/draft/#applications_1","title":"Applications","text":""},{"location":"blogpost/Murrani/draft/#comparing-the-two-algorithms","title":"Comparing the Two Algorithms","text":""},{"location":"blogpost/Murrani/draft/#key-features","title":"Key Features","text":""},{"location":"blogpost/Murrani/draft/#when-to-use","title":"When To Use","text":""},{"location":"blogpost/Murrani/draft/#differences-and-similarities","title":"Differences and Similarities","text":""},{"location":"blogpost/Murrani/draft/#efficiency-analysis","title":"Efficiency Analysis","text":""},{"location":"blogpost/Murrani/draft/#overall-efficiency-of-each","title":"Overall Efficiency of Each","text":""},{"location":"blogpost/Murrani/draft/#why-is-efficiency-important","title":"Why is Efficiency Important","text":""},{"location":"blogpost/Murrani/draft/#visual-comparison","title":"Visual Comparison","text":"<p>Here is a quick video showing the two different algorithms' pathfinding:</p> <p>https://www.youtube.com/watch?v=19h1g22hby8</p>"},{"location":"blogpost/Murrani/draft/#conclusion","title":"Conclusion","text":""},{"location":"blogpost/Murrani/draft/#summary-of-findings","title":"Summary of Findings","text":""},{"location":"blogpost/Murrani/draft/#recommended-uses","title":"Recommended Uses","text":""},{"location":"blogpost/Murrani/draft/#possible-future-developments","title":"Possible Future Developments","text":""},{"location":"blogpost/Murrani/draft/#references","title":"References","text":"<p>https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</p> <p>https://favtutor.com/blogs/dijkstras-algorithm-cpp</p> <p>https://www.educative.io/answers/how-to-implement-dijkstras-algorithm-in-cpp</p> <p>https://www.happycoders.eu/algorithms/dijkstras-algorithm-java/</p> <p>https://en.wikipedia.org/wiki/A*_search_algorithm</p> <p>https://www.educative.io/answers/what-is-the-a-star-algorithm</p> <p>https://www.freecodecamp.org/news/big-o-cheat-sheet-time-complexity-chart/</p> <p>https://www.geeksforgeeks.org/a-search-algorithm/</p> <p>https://medium.com/@nicholas.w.swift/easy-a-star-pathfinding-7e6689c7f7b2 </p>"},{"location":"blogpost/Murrani/final/","title":"Comparative Analysis of Djikstra\u2019s and A* Algorithms","text":"<p>Yousif Murrani</p>"},{"location":"blogpost/Murrani/final/#introduction","title":"Introduction","text":"<p>Have you ever wondered how your GPS knows the exact quickest directions to get you to your destination or how  a video game enemy will always move exactly towards you no matter what\u2019s in their way? It\u2019s all thanks to pathfinding  algorithms. Pathfinding algorithms are crucial in today's world, whether it\u2019s to get you to work on time or to optimize  your code. In this article, we\u2019ll dive into the two biggest powerhouses of the pathfinding world: Dijkstra\u2019s  and the A* Algorithms.</p> <p>We will start off with Dijkstra\u2019s algorithm and explore its core concepts as well as its limitations. Then, we will  look at the more modern approach of the A* algorithm and see where it might be the better approach.</p> <p>In this blog, we will take an in-depth look at Dijkstra\u2019s algorithm, providing pseudocode and some examples  then we will do the same for A*. In the examples, we\u2019ll test out both algorithms in scenarios of different difficulty  for the algorithms to figure out and see how long it takes each one to complete the task. Afterward, we\u2019ll compare  the two in terms of efficiency so that you know which to use in each scenario.</p>"},{"location":"blogpost/Murrani/final/#dijkstras-algorithm","title":"Dijkstra\u2019s Algorithm","text":""},{"location":"blogpost/Murrani/final/#overview","title":"Overview","text":"<p>One of the most popular pathfinding algorithms in the world is Dijkstra\u2019s algorithm, published by Edsger W. Dijkstra  in 1959 [1]. The algorithm was designed to find the shortest path between a given node and every other node in a  positive-weighted graph, essentially making it a Greedy Algorithm (an algorithm designed to make the best possible choice at every step without considering the future result). It can also be classified as a Search Algorithm.  The algorithm can also be changed to find the shortest path between any given starting node and a destination node  then stopping. The data structures used within the code are usually a priority queue or a heap to optimize it.</p> <p>Here is a Gif showing how Dijkstra's Algorithm Works in Real Time:</p> <p> [1]</p>"},{"location":"blogpost/Murrani/final/#pseudocode","title":"Pseudocode","text":"<pre><code>function dijkstra(G, S)\n    /// Initialize distance and previous arrays\n    for each vertex V in G\n        distance[V] &lt;- infinite  // Set initial distance to infinity\n        previous[V] &lt;- NULL      // Set previous vertex to NULL\n        If V != S, add V to Priority Queue Q  // Add all vertices to the priority queue except the source\n\n    distance[S] &lt;- 0  // Set distance from source to itself to 0, as it's the starting point\n\n    /// Main loop to find the shortest paths\n    while Q IS NOT EMPTY\n        U &lt;- Extract MIN from Q  // Extract vertex with minimum distance from the priority queue\n        for each unvisited neighbour V of U\n            tempDistance &lt;- distance[U] + edge_weight(U, V)  // Calculate the tentative distance\n            if tempDistance &lt; distance[V]\n                distance[V] &lt;- tempDistance  // Update the distance\n                previous[V] &lt;- U  // Update the previous vertex for the current vertex V\n\n    /// Return the final distance and previous arrays\n    return distance[], previous[]\n</code></pre> <p>[10]</p>"},{"location":"blogpost/Murrani/final/#timespace-complexity","title":"Time/Space Complexity","text":"<p>Time and Space Complexity are two very important concepts in the realm of Computer Science. Time Complexity refers to the amount of time an algorithm takes to run based on the amount of inputs (n). Space Complexity is similar, but refers to the amount of memory (space) allocated to run the code.</p> <p>Here are the Time and Space complexities for Dijkstra's Algorithm:</p> <p>Time Complexity: O((|V| + |E|) * log(V))</p> <p>Space Complexity: O((|V| + |E|))  [3]</p> <p>In the formulas, 'V' represents the number of Vertices (nodes) in the graph while 'E' represents the number of  Edges (connections between nodes) in the weighted graph. Using these two numbers, we can calculate the Big-O notation of Dijkstra's Algorithm.</p> <p>This is best shown in this graph:</p> <p> [4]</p> <p>While it starts out very similar to an O(n) algorithm, we can see that it starts to curve upwards more rapidly near the end. This leads us to believe that its time complexity will be somewhere between O(nlog(n)) and O(n^2), as shown below:</p> <p> [6]</p>"},{"location":"blogpost/Murrani/final/#applications","title":"Applications","text":"<ul> <li>Route Planning: Dijkstra's is used extensively in route planning and navigation systems, helping find the shortest path between locations and defining an accessible route between them.</li> <li>Network Packet Routing: One of the biggest use cases for the algorithm is helping find the shortest path between nodes so that routers can quickly send packets from a source to a destination.</li> <li>Pathfinding in Video Games: As mentioned earlier, many game developers also incorporate Dijkstra's in video games, allowing the game characters to navigate the maps they are a part of with efficiency. [2],[8]</li> </ul>"},{"location":"blogpost/Murrani/final/#a-algorithm","title":"A* Algorithm","text":""},{"location":"blogpost/Murrani/final/#overview_1","title":"Overview","text":"<p>The A (referred to as 'A-Star') Algorithm, like its predecessor Dijkstra's, is a very powerful pathfinding algorithm  designed to find the shortest path between a starting node and a destination node. However, unlike Dijkstra's,  the A is only a Search Algorithm and not a Greedy Algorithm. This is because A takes into consideration the overall result, and not just the best option at the current step. Another feature that sets A apart is its ability to use a heuristic, which is a  function that can help it find the solution more quickly, albeit giving up some level of accuracy and precision [6]. This  algorithm was actually created as a part of the Shakey Project,  which was building a robot that could choose its own actions. However, it has since become popular in many different  pathfinding uses [5].</p> <p>Here is a quick showcase of the A* Algorithm working with four different heuristics:</p> <p> [5]</p> <p>In the Gif, from left to right, the A* method is increasingly using a heuristic that prefers points that are closer  to the goal. When not using a heuristic, the algorithm becomes extremely similar to Dijkstra's.</p>"},{"location":"blogpost/Murrani/final/#pseudocode_1","title":"Pseudocode","text":"<pre><code>make an openlist containing only the starting node\nmake an empty closed list\nwhile (the destination node has not been reached):\n   consider the node with the lowest f score in the open list\n   if (this node is our destination node) :\n       we are finished \n   if not:\n       put the current node in the closed list and look at all of its neighbors\n       for (each neighbor of the current node):\n           if (neighbor has lower g value than current and is in the closed list) :\n               replace the neighbor with the new, lower, g value \n               current node is now the neighbors parent            \n           else if (current g value is lower and this neighbor is in the open list ) :\n               replace the neighbor with the new, lower, g value \n               change the neighbors parent to our current node\n\n           else if this neighbor is not in both lists:\n               add it to the open list and set its g\n</code></pre> <p>[11]</p>"},{"location":"blogpost/Murrani/final/#timespace-complexity_1","title":"Time/Space Complexity","text":"<p>The Time and space complexity of the A* Algorithm is dependent on the heuristic used  for the algorithm. At best, it  could be O(1), at worst it would have the time and space complexity of Dijkstra\u2019s Algorithm. That means that depending on the heuristic implemented in the algorithm, the code will either run in constant time ( O(1) ), or it can take as long as Dijkstra's algorithm, O((|V| + |E|) * log(V)) [5].</p>"},{"location":"blogpost/Murrani/final/#applications_1","title":"Applications","text":"<ul> <li>Robotics: A is used commonly in the Robotics field, helping robots navigate by finding optimal paths around obstacles. This is actually the first real-world application of A as it was created for the Shakey Project to help a robot navigate a room.</li> <li>Machine Learning: The algorithm is also used in Artificial Intelligence models to optimize decision-making in the system, leading to a faster and more efficient AI.</li> <li>Pathfinding in Video Games: Similar to Dijkstra's, A* is also great for providing a pathfinding method in many video  games. Due to its ability to use heuristic, it also provides developers with the ability to have different levels of accuracy for the path the characters take. [9]</li> </ul> <p>This video shows how A* works in a 2D grid by always trying to move towards its goal location:</p> <p>https://www.youtube.com/watch?v=19h1g22hby8</p>"},{"location":"blogpost/Murrani/final/#comparing-the-two-algorithms","title":"Comparing the Two Algorithms","text":""},{"location":"blogpost/Murrani/final/#key-features","title":"Key Features","text":"<p>While A and Dijkstra's are both very efficient pathfinding algorithms, they differ in their methods. Some key features of the A Algorithm are:</p> <ul> <li>Informed Search: As mentioned earlier, A* performs an informed search when finding the shortest path. This means that it keeps track of the cost from the current vertex to the goal vertex and bases its search off that.</li> <li>Heuristic: Using a good heuristic, A* can narrow its choices down so that it takes the fewest steps possible while still maintaining the correct path.</li> <li>G(n) and H(n) Values: To evaluate which node it should move to, A* sums the cost of the distance between the start node and the current node ( G(n) ) to the cost of the distance between the current node and goal node ( H(n) ).</li> </ul> <p>These features allow A* to compete with Dijkstra's, who's key features include:</p> <ul> <li>Uninformed Search: Dijkstra's does not take into account the location of the goal node. This allows it to make the best decision at every step without worrying about the overall result and assuming that these desicions will lead to the optimal solution.</li> <li>Optimal Paths: Assuming that all the edges between the nodes are non-negative, Dijkstra's will find the shortesy path  between the start node to every other node on the map.</li> <li>Total Exploration: Dijkstra's algorithm explores every vertex on the graph and finds the shortest path to all of them, including the goal vertex.</li> </ul>"},{"location":"blogpost/Murrani/final/#when-to-use","title":"When To Use","text":"<p>Knowing when to use Dijkstra's Algorithm or the A* Algorithm is very important as it can change the speed of your code significantly. </p> <p>Dijkstra's is the usually better choice when the graph is sparse, meaning that there are fewer vertices than edges, as it tends to perform better with fewer nodes. Another reason to use Dijkstra's is if you need to find the shortest path to all the other nodes in the graph and not just the goal node. Lastly, if a good heuristic is not available, it is safer to use Dijkstra's than to use A* with a bad heuristic.</p> <p>However, if you do have a good heuristic function on hand, A is most definitely the go-to method. With a good heuristic, A can be much faster as it only focuses on reaching the goal node and not finding paths to every other node. This also leads A to work better in dense graphs with many nodes, as it gives the algorithm more options to reach the destination. Due to A exploring fewer nodes overall than Dijkstra's, A* uses less memory to reach the destination. This is very important if you have a constraint on the Space Complexity of your program.</p>"},{"location":"blogpost/Murrani/final/#differences-and-similarities","title":"Differences and Similarities","text":"<p>Dijkstra's and A* Algorithms are very similar to each other, which is why they are always debated on in terms of effectiveness and efficiency. There main similarities include:</p> <ul> <li>Main Objective: Both algorithms are used for pathfinding in graphs, mainly for finding the shortest path between a start node and a goal node.</li> <li>Weighted Graphs: The two algorithms are used on weighted graphs where each edge between two vertices has a specific numerical weight.</li> <li>Node Tracking: Both keep track of nodes that they have already visited to ensure that they don't accidentally re-visit the same node more than once.</li> <li>Priority Queue: A priority queue data structure is most commonly used in both algorithms to select a node for the next step.</li> </ul> <p>While they are very similar, the two also have some major differences, the biggest ones being:</p> <ul> <li>Heuristic: The A* Algorithm's use of a heuristic function is one of the biggest differences. Dijkstra's does not rely on one when performing its search.</li> <li>Time/Space Complexity: Dijkstra's commonly has a greater time and space complexity than A* because of its need to search all the nodes in the graph. This is very obvious when dealing with a denser graph.</li> <li>Overall Completeness: Dijkstra's Algorithm will search through the entire graph and explore each of the nodes, while A* takes a more efficient approach and focuses only on the nodes that will help it reach its goal faster.</li> </ul>"},{"location":"blogpost/Murrani/final/#efficiency-analysis","title":"Efficiency Analysis","text":""},{"location":"blogpost/Murrani/final/#why-is-efficiency-important","title":"Why is Efficiency Important","text":"<p>Efficiency is one of, if not the most, important aspects of good code. Since some of these algorithms are used in essential and valuable operations, making sure the algorithm is capable of handling large amounts of data at a  proficient speed is of the utmost importance.</p>"},{"location":"blogpost/Murrani/final/#overall-efficiency-of-each","title":"Overall Efficiency of Each","text":"<p>Dijkstra's algorithm is most efficient when you have a small amount of nodes and a large amount of edges between  those nodes. This type of graph, a sparse graph, allows Dijkstra's to work at its full potential. Dijkstra's is also the most efficient pathfinding algorithm if you don't know the location of your goal node. This is because Dijkstra's algorithm searches through all of its surrounding nodes until it finds the correct one. However, this does lead it to have a larger Time and Space Complexity.</p> <p>A, on the other hand, works best when there is a large amount of nodes in the graph. This denser graph, put together wil a good heuristic function, allows A to find the goal node extremely fast. However, A* is very reliant on its heuristic function, meaning that if the heuristic is non-admissible, the algorithm will be ineffective and have a  hard time finding the goal.</p>"},{"location":"blogpost/Murrani/final/#visual-comparison","title":"Visual Comparison","text":"<p>Here is a quick video showing the two different algorithms' pathfinding in real time:</p> <p>https://www.youtube.com/watch?app=desktop&amp;v=g024lzsknDo</p> <p>As shown in the video, A tends to work much quicker than Dijkstra's when trying to find the goal node. This is due to Dijkstra's method of searching all the nodes around its current node before moving forward. However, this is not always the case. As shown at 1:30 in the video, Dijkstra's will actually work faster than A in some situations.</p>"},{"location":"blogpost/Murrani/final/#conclusion","title":"Conclusion","text":"<p>In the dynamic world of pathfinding algorithms, Dijkstra's Algorithm and the A* Algorithm emerge as the top two contenders, leaving all others in the dust. Both with unique strengths and applications, it is evident that their differences play vital roles in terms of what situation they would be most useful in.</p>"},{"location":"blogpost/Murrani/final/#summary-of-findings","title":"Summary of Findings","text":"<p>Dijkstra's Algorithm, a pathfinding powerhouse since its creation in 1959, shows why it has stayed relevant in the ever-changing  world of computer science because of its efficiency when it comes to positively weighted graphs. By performing an uninformed  search, it is able to make the best decision at every step of the process and is guaranteed to find the shortest path if it exists.</p> <p>Its modern competitor, the A Algorithm, shows off that an informed search, or knowing where the end goal is, can be just as good, if not better, than an uninformed search. A also introduces the concept of using a heuristic function to help lessen the burden of pathfinding. Equipped with a good heuristic, A* does not need to search all nodes in a graph like Dijkstra's, but instead moves directly to the goal in a very efficient manner.</p>"},{"location":"blogpost/Murrani/final/#recommended-uses","title":"Recommended Uses","text":"<p>While both have proven to be very useful algorithms, each has cases where it will clearly shine. In scenarios where the edges represent costs or distances, Dijkstra's is the more optimal option as exploring all the nodes in the graph is necessary. This algorithm will work even better if the graph is sparse. However, if the scenario calls for efficiency  or there is a time constraint, the more modern A should be the go-to algorithm. With a powerful heuristic, A can reduce its time and space complexity to near-constant. This will also work especially well if the graph is very dense.</p>"},{"location":"blogpost/Murrani/final/#possible-future-developments","title":"Possible Future Developments","text":"<p>As technology continues to grow and evolve, the field of pathfinding algorithms will also grow alongside it. In the  future, a more evolved heuristic may be created that will allow A to work in all sorts of graphs, dense or sparse.  Advancements in parallel processing may also help advance Dijkstra's Algorithm, allowing it to handle large sets of  data in a more efficient manner. Another possibility is that in the coming years, we will see a new pathfinding algorithm rise, one that will incorporate all the advantages of A and Dijkstra's without any of the disadvantages.</p> <p>In conclusion, the choice between using Dijkstra's Algorithm or the A* Algorithm depends entirely on the situation that the algorithm is being incorporated into. There is no one-size-fits-all solution, but these two algorithms can be used most  effectively if they are integrated into the correct scenario. Despite both being around for many years, they are still invaluable tools that every programmer should know how to use to optimize pathfinding, whether it's for networks,  creating video games, or just for fun.</p>"},{"location":"blogpost/Murrani/final/#references","title":"References","text":"<p>[1] \u201cDijkstra\u2019s Algorithm.\u201d Wikipedia, Wikimedia Foundation, 6 Nov. 2023,     https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm.</p> <p>[2] Bhadaniya, Shivali. \u201cDijkstra\u2019s Algorithm in C++: Shortest Path Algorithm.\u201d FavTutor, 20 May 2021,     https://favtutor.com/blogs/dijkstras-algorithm-cpp.</p> <p>[3] \u201cEducative Answers - Trusted Answers to Developer Questions.\u201d Educative,     www.educative.io/answers/how-to-implement-dijkstras-algorithm-in-cpp. Accessed 19 Nov. 2023.</p> <p>[4] Woltmann, Sven. \u201cDijkstra\u2019s Algorithm (with Java Examples).\u201d HappyCoders.Eu, HappyCoders.eu, 25 Nov. 2020,     www.happycoders.eu/algorithms/dijkstras-algorithm-java/.</p> <p>[5] \u201cA Search Algorithm.\u201d Wikipedia, Wikimedia Foundation, 13 Oct. 2023,     https://en.wikipedia.org/wiki/A_search_algorithm.</p> <p>[6] Olawanle, Joel. \u201cBig O Cheat Sheet \u2013 Time Complexity Chart.\u201d freeCodeCamp.Org, freeCodeCamp.org, 25 Oct. 2022,     www.freecodecamp.org/news/big-o-cheat-sheet-time-complexity-chart/.</p> <p>[7] \u201cA* Search Algorithm.\u201d GeeksforGeeks, GeeksforGeeks, 8 Mar. 2023,     www.geeksforgeeks.org/a-search-algorithm/.</p> <p>[8] Bhattacharyya, Soumalya. \u201cHow Is Dijkstra\u2019s Algorithm Used in the Real World?\u201d Analytics Steps, 11 Sept. 2023,     www.analyticssteps.com/blogs/how-dijkstras-algorithm-used-real-world.</p> <p>[9] S, Ravikiran A. \u201cA* Algorithm Concepts and Implementation.\u201d Simplilearn.Com, Simplilearn, 17 Oct. 2023,     www.simplilearn.com/tutorials/artificial-intelligence-tutorial/a-star-algorithm.</p> <p>[10] \u201cDijkstra\u2019s Algorithm.\u201d Programiz,      www.programiz.com/dsa/dijkstra-algorithm. Accessed 19 Nov. 2023.</p> <p>[11] \"A* Search\" Brilliant.org. Retrieved 19:35, November 19, 2023,     from https://brilliant.org/wiki/a-star-search/</p>"},{"location":"blogpost/Mussa/draft/","title":"Draft","text":""},{"location":"blogpost/Mussa/draft/#memory-management-library-in-c","title":"Memory management library in C++","text":"<p>Author: Yones Mussa</p>"},{"location":"blogpost/Mussa/draft/#introduction","title":"Introduction:","text":"<p>C++ is a powerful language, but it can also be complex, especially when it comes to memory management. If you are not careful, you can easily end up with memory leaks, which can lead to performance problems and crashes. To help with memory management, C++ provides several smart pointer classes. </p> <p>Understanding smart pointers, specifically <code>unique_ptr</code> and <code>shared_ptr</code>, is vital for efficient and safe memory management in modern C++ development. This means that you do not have to worry about manually deallocating memory when you are finished with it. These classes have different ownership semantics, and they should be used in different situations.</p>"},{"location":"blogpost/Mussa/draft/#ownership-semantics","title":"Ownership semantics","text":"<p>unique_ptr: A <code>unique_ptr</code> can only own one object at a time. When a <code>unique_ptr</code> goes out of scope, the object it owns is automatically deleted.</p> <p>shared_ptr: A <code>shared_ptr</code> can own one or more objects at a time. Multiple <code>shared_ptr</code> objects can point to the same object. When the last <code>shared_ptr</code> to an object goes out of scope, the object is automatically deleted.</p> <p>Knowing when to use <code>unique_ptr</code> and <code>shared_ptr</code> is essential in C++ programming. Use <code>unique_ptr</code> when you require sole ownership of an object, particularly for managing dynamically allocated local variables.On the other hand, opt for <code>shared_ptr</code> when you need to share ownership of an object across multiple pointers. </p> <p>By understanding these distinctions, you can make informed decisions about which smart pointer to employ, ensuring efficient memory management and minimizing potential pitfalls in your C++ projects.</p> <p>When to use <code>unique_ptr</code>: You should use <code>unique_ptr</code> when you want to have exclusive ownership of an object. For example, you might use <code>unique_ptr</code> to manage the lifetime of a local variable that is allocated dynamically.</p> <p>Here is an example of how to use <code>unique_ptr</code>:</p> <pre><code>#include &lt;memory&gt;\n\nint main() {\n  // Create a unique_ptr to a new Rectangle object.\n  std::unique_ptr&lt;Rectangle&gt; rectangle(new Rectangle(10, 5));\n\n  // Use the rectangle object.\n  std::cout &lt;&lt; rectangle-&gt;area() &lt;&lt; std::endl; // Prints 50\n\n  // When the unique_ptr goes out of scope, the rectangle object will be automatically deleted.\n}\n</code></pre> <p>When to use shared_ptr:</p> <p>You should use <code>shared_ptr</code> when you need to share ownership of an object with multiple pointers. For example, you might use <code>shared_ptr</code> to manage the lifetime of an object that is passed to a function or returned from a function.</p> <p>Here is an example of how to use <code>shared_ptr</code>:</p> <pre><code>#include &lt;memory&gt;\n\nstd::shared_ptr&lt;Rectangle&gt; createRectangle() {\n  // Create a shared_ptr to a new Rectangle object.\n  return std::make_shared&lt;Rectangle&gt;(10, 5);\n}\n\nint main() {\n  // Get a shared_ptr to a rectangle object.\n  std::shared_ptr&lt;Rectangle&gt; rectangle = createRectangle();\n\n  // Use the rectangle object.\n  std::cout &lt;&lt; rectangle-&gt;area() &lt;&lt; std::endl; // Prints 50\n\n  // Pass the shared_ptr to another function.\n  doSomethingWithRectangle(rectangle);\n\n  // The rectangle object will be automatically deleted when the last shared_ptr to it goes out of scope.\n}\n</code></pre>"},{"location":"blogpost/Mussa/draft/#pitfalls","title":"Pitfalls","text":"<p>Using <code>unique_ptr</code> and <code>shared_ptr</code> in C++ offers significant advantages in managing memory and resources. However, there are pitfalls that developers should be aware of. One common issue is the occurrence of dangling pointers, which happens when a smart pointer points to an object that has been deleted or has gone out of scope - <code>Dangling pointers:</code> A dangling pointer is a pointer that points to an object that has already been deleted</p> <ul> <li><code>Circular references:</code> A circular reference is a situation where two or more objects point to each other</li> </ul> <p>It's crucial to be mindful of these pitfalls and structure your code in a way that avoids these issues, ensuring robust memory management in your C++ applications.</p>"},{"location":"blogpost/Mussa/draft/#conclusion","title":"Conclusion","text":"<p>Mastering smart pointers like <code>unique_ptr</code> and <code>shared_ptr</code> is crucial for effective and secure memory management in modern C++ development. <code>unique_ptr</code> is employed when exclusive ownership of an object is needed, especially for dynamically allocated local variables, whereas  <code>shared_ptr</code> is chosen for scenarios requiring shared ownership across multiple pointers. </p> <p>By understanding these these differences, developers are better equipped to choose the right smart pointer for their project, ensuring efficient memory management and avoiding potential pitfalls. Always check the smart pointer's validity before using it to avoid common pitfalls l,ike dangling pointers which can lead to crashes. Additionally, use caution when creating connections between objects using shared pointers. It's advised to use other pointers in these situations to avoid circular references, which frequently result in memory leaks.</p> <p>Smart pointers offer automatic memory management, prevent memory leaks, and enhance code readability and maintainability, making them a best practice in C++ development for crafting efficient and dependable code.</p>"},{"location":"blogpost/Mussa/final/","title":"Final","text":""},{"location":"blogpost/Mussa/final/#understanding-smart-pointers-in-c-a-comprehensive-guide","title":"Understanding Smart Pointers in C++: A Comprehensive Guide","text":"<p>Introduction</p> <p>C++, with its vast capabilities and expressive syntax, stands as one of the most widely used programming languages. However, its power comes with a degree of complexity, particularly in the realm of memory management. Raw pointers, while providing direct manipulation of memory, can lead to memory leaks, dangling pointers, and overall program instability if not handled with utmost care.</p> <p>To alleviate these challenges and promote safer memory management practices, C++ introduced smart pointers. These classes act as wrappers around raw pointers, automating memory deallocation and enhancing overall resource utilization. Understanding and effectively employing smart pointers is crucial for modern C++ development.</p> <p>Types of Smart Pointers</p> <p>C++ offers two primary types of smart pointers: <code>unique_ptr</code> and <code>shared_ptr</code>. Each possesses distinct ownership semantics and serves specific purposes.</p> <p><code>unique_ptr</code>: Exclusive Ownership</p> <p>A <code>unique_ptr</code> maintains exclusive ownership of the object it points to. This implies that only one <code>unique_ptr</code> can own a particular object at any given time. When a <code>unique_ptr</code> goes out of scope, the object it points to is automatically deleted. This mechanism ensures that dynamically allocated memory is released promptly, preventing memory leaks.</p> <p><code>shared_ptr</code>: Shared Ownership</p> <p>Unlike <code>unique_ptr</code>, a <code>shared_ptr</code> can share ownership of an object with multiple <code>shared_ptr</code>s. As the name suggests, multiple <code>shared_ptr</code>s can point to the same object, incrementing its reference count. When the last <code>shared_ptr</code> to an object goes out of scope, the object is deleted. This shared ownership model is particularly useful in situations where multiple components of a program need to access and manage the same resource.</p> <p>When to Use <code>unique_ptr</code></p> <p><code>unique_ptr</code> is the preferred choice when exclusive ownership of an object is required. This is particularly relevant for managing dynamically allocated local variables. For instance, if a function allocates memory for an object, using a <code>unique_ptr</code> ensures that the object is deleted when the function exits, preventing memory leaks.</p> <p>When to Use <code>shared_ptr</code></p> <p><code>shared_ptr</code> comes into play when ownership of an object needs to be shared across multiple pointers or components of a program. For example, if a function creates an object and returns it to the caller, using a <code>shared_ptr</code> allows both the function and the caller to manage the object's lifetime.</p> <p>Practical Examples</p> <p>To illustrate the usage of <code>unique_ptr</code> and <code>shared_ptr</code>, consider the following examples:</p> <p>Using <code>unique_ptr</code> for Local Variables</p> <pre><code>#include &lt;memory&gt;\n\nvoid manipulateRectangle(const std::unique_ptr&lt;Rectangle&gt;&amp; rectangle) {\n  // Perform operations on the rectangle object\n  rectangle-&gt;setWidth(10);\n  rectangle-&gt;setHeight(20);\n  std::cout &lt;&lt; rectangle-&gt;area() &lt;&lt; std::endl; // Output: 200\n}\n\nint main() {\n  std::unique_ptr&lt;Rectangle&gt; rectangle(new Rectangle(5, 4));\n  manipulateRectangle(rectangle);\n\n  // When the main function exits, the `unique_ptr` goes out of scope, and the Rectangle object is automatically deleted.\n}\n</code></pre> <p>Using <code>shared_ptr</code> for Shared Ownership</p> <pre><code>#include &lt;memory&gt;\n\nstd::shared_ptr&lt;Rectangle&gt; createRectangle() {\n  return std::make_shared&lt;Rectangle&gt;(10, 5);\n}\n\nint main() {\n  std::shared_ptr&lt;Rectangle&gt; rectangle1 = createRectangle();\n  std::shared_ptr&lt;Rectangle&gt; rectangle2 = rectangle1;\n\n  // Both rectangle1 and rectangle2 point to the same Rectangle object\n  std::cout &lt;&lt; rectangle1-&gt;area() &lt;&lt; std::endl; // Output: 50\n  std::cout &lt;&lt; rectangle2-&gt;area() &lt;&lt; std::endl; // Output: 50\n\n  // The Rectangle object will be automatically deleted when both rectangle1 and rectangle2 go out of scope.\n}\n</code></pre> <p>Pitfalls to Avoid</p> <p>While smart pointers offer significant advantages in memory management, there are pitfalls that developers should be aware of:</p> <ul> <li> <p>Dangling Pointers: A dangling pointer occurs when a smart pointer points to an object that has been deleted or has gone out of scope. This can lead to undefined behavior and program crashes.</p> </li> <li> <p>Circular References: A circular reference arises when two or more objects point to each other, creating a dependency loop. This can lead to memory leaks and prevent objects from being deleted.</p> </li> </ul> <p>Best Practices</p> <p>To effectively utilize smart pointers, adhere to these best practices:</p> <ul> <li> <p>Use smart pointers consistently: Replace raw pointers with smart pointers whenever possible to streamline memory management and reduce the risk of errors.</p> </li> <li> <p>Understand ownership semantics: Clearly differentiate between <code>unique_ptr</code> and <code>shared_ptr</code> based on the specific ownership requirements of the object.</p> </li> <li> <p>Check for validity before use: Before dereferencing or accessing a smart pointer, ensure its validity to avoid dangling pointer issues.</p> </li> <li> <p>Avoid circular references: Carefully design object relationships to prevent circular references, which can lead to memory leaks.</p> </li> <li> <p>Use raw pointers sparingly: Raw pointers should only be used in situations where smart pointers are not applicable or when direct memory manipulation is essential.</p> </li> </ul> <p>Conclusion</p> <p>Mastering smart pointers like <code>unique_ptr</code> and <code>shared_ptr</code> is crucial for effective and secure memory management in modern C++ development. <code>unique_ptr</code> is employed when exclusive ownership of an object is needed, especially for dynamically allocated local variables, whereas  <code>shared_ptr</code> is chosen for scenarios requiring shared ownership across multiple pointers. </p> <p>By understanding these these differences, developers are better equipped to choose the right smart pointer for their project, ensuring efficient memory management and avoiding potential pitfalls. Always check the smart pointer's validity before using it to avoid common pitfalls l,ike dangling pointers which can lead to crashes. Additionally, use caution when creating connections between objects using shared pointers. It's advised to use other pointers in these situations to avoid circular references, which frequently result in memory leaks.</p> <p>Smart pointers offer automatic memory management, prevent memory leaks, and enhance code readability and maintainability, making them a best practice in C++ development for crafting efficient and dependable code.</p>"},{"location":"blogpost/Newaz/draft/","title":"Navigating the C++ Ranges Library: A User's Journey","text":"<p>If you've been keeping an eye on C++ developments, you've probably heard of the C++ Ranges library, introduced in C++20. This library promises to revolutionize the way we work with sequences of data, making our code cleaner, more expressive, and efficient. But what's it like for a newcomer to download, compile, and integrate this library into their code? In this blog post, I'm going to share my experience and insights on working with the C++ Ranges library.</p>"},{"location":"blogpost/Newaz/draft/#getting-started","title":"Getting Started","text":""},{"location":"blogpost/Newaz/draft/#download-and-compilation","title":"Download and Compilation","text":"<p>The first step is to download and compile the C++ Ranges library. In my experience, this was surprisingly straightforward. Many modern C++ compilers, like GCC and Clang, have already integrated the Ranges library, so you don't need to install it separately. However, if you're working with an older compiler, you might need to ensure it's C++20 compliant or use a library that provides the Ranges functionality.</p>"},{"location":"blogpost/Newaz/draft/#exploring-the-basics","title":"Exploring the Basics","text":"<p>The C++ Ranges library offers a set of components, including range adaptors, range views, and range algorithms. These components are designed to make your code more elegant and efficient. As a new user, it's essential to understand the basics:</p> <ul> <li> <p>Range Adaptors: These are composable operations that can be applied to ranges. They include functions like <code>filter</code>, <code>transform</code>, and <code>sort</code>. Think of them as tools to streamline your data processing.</p> </li> <li> <p>Range Views: These are lightweight, non-owning, and lazy representations of ranges. They're excellent for avoiding unnecessary data copying and enabling complex, composable operations.</p> </li> <li> <p>Range Algorithms: These are familiar algorithms like <code>std::for_each</code> and <code>std::find_if</code> that can be applied directly to ranges. They make your code more concise and expressive.</p> </li> <li> <p>Range Concepts: These are a set of requirements that a range must satisfy to be used with the Ranges library. They're designed to make your code more robust and maintainable.</p> </li> <li> <p>Range Access: These are a set of utilities that can be used with ranges. They include functions like <code>std::size</code> and <code>std::empty</code>. They're useful for writing more concise code.</p> </li> </ul>"},{"location":"blogpost/Newaz/draft/#integration-into-your-code","title":"Integration into Your Code","text":"<p>Integrating the C++ Ranges library into your code can be both exciting and challenging. It's exciting because you can start writing more expressive code. It's challenging because you may encounter compatibility issues with older code or compilers.</p>"},{"location":"blogpost/Newaz/draft/#compatibility","title":"Compatibility","text":"<p>If you're working with a codebase that was written in older versions of C++, integrating the Ranges library can be a bit tricky. You may need to refactor your code to make it C++20 compatible. This can be time-consuming but is often worth it for the benefits you'll gain in terms of code readability and maintainability.</p>"},{"location":"blogpost/Newaz/draft/#code-examples","title":"Code Examples","text":"<p>Here's a simple example of how to use the Ranges library to filter even numbers from a vector:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;ranges&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8};\n    auto evens = numbers | std::views::filter([](int x) { return x % 2 == 0; });\n\n    for (int num : evens) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"blogpost/Newaz/draft/#recommendations","title":"Recommendations","text":"<p>The C++ Ranges library is a powerful addition to the language, but it may not be suitable for every project. Here are some situations where I would recommend its use:</p> <ul> <li> <p>New Projects: If you're starting a new project or working on a codebase that can easily adopt C++20, definitely give the Ranges library a try. It will make your code more expressive and readable.</p> </li> <li> <p>Refactoring Opportunities: If you have an existing codebase that you're planning to refactor, consider integrating the Ranges library. Refactoring provides an excellent chance to transition to modern C++ practices.</p> </li> <li> <p>Teaching and Learning: If you're teaching or learning C++, the Ranges library is a fantastic way to illustrate modern C++ features and coding practices.</p> </li> </ul>"},{"location":"blogpost/Newaz/draft/#tips-for-new-users","title":"Tips for New Users","text":"<p>For those new to the C++ Ranges library, here are some tips:</p> <ul> <li> <p>Familiarize yourself with the basic components: Range Adaptors, Range Views, and Range Algorithms.</p> </li> <li> <p>Start with small, manageable projects to experiment with the library.</p> </li> <li> <p>Read the official documentation and online resources to deepen your understanding.</p> </li> <li> <p>Be patient. Learning and integrating a new library takes time, but the benefits are worth it.</p> </li> </ul> <p>In conclusion, the C++ Ranges library is a valuable addition to the C++ language. While there may be challenges in integrating it into your code, the improved code quality and expressiveness it offers make it a worthy investment. If you're a new user, take your time to learn and experiment, and you'll discover the power of the C++ Ranges library in no time.</p>"},{"location":"blogpost/Newaz/draft/#happy-coding","title":"Happy coding!","text":""},{"location":"blogpost/Newaz/final/","title":"Navigating the C++ Ranges Library: A User's Journey","text":""},{"location":"blogpost/Newaz/final/#by-ahmad-arman-newaz","title":"By Ahmad Arman Newaz","text":"<p>If you've been keeping an eye on C++ developments, you've probably heard of the C++ Ranges library, introduced in C++20.  This library promises to revolutionize the way we work with sequences of data, making our code cleaner, more expressive, and more efficient. But what's it like for a newcomer to download, compile, and integrate this library into their code? In  this blog post, I'm going to share my experience and insights on working with the C++ Ranges library.</p>"},{"location":"blogpost/Newaz/final/#getting-started","title":"Getting Started","text":""},{"location":"blogpost/Newaz/final/#download-and-compilation","title":"Download and Compilation","text":"<p>The first step is to download and compile the C++ Ranges library. In my experience, this was surprisingly  straightforward. Many modern C++ compilers, like GCC and Clang, have already integrated the Ranges library, so you don't need to install it separately. However, if you're working with an older compiler, you might need to ensure it's C++20  compliant or use a library that provides the Ranges functionality.</p>"},{"location":"blogpost/Newaz/final/#exploring-the-basics","title":"Exploring the Basics","text":"<p>The C++ Ranges library offers a set of components, including range adaptors, range views, and range algorithms. These  components are designed to make your code more elegant and efficient. As a new user, it's essential to understand the  basics:</p> <ul> <li> <p>Range Adaptors: These are composable operations that can be applied to ranges. They include functions like  <code>filter</code>, <code>transform</code>, and <code>sort</code>. Think of them as tools to streamline your data processing.</p> </li> <li> <p>Range Views: These are lightweight, non-owning, and lazy representations of ranges. They're excellent for avoiding unnecessary data copying and enabling complex, composable operations.</p> </li> <li> <p>Range Algorithms: These are familiar algorithms like <code>std::for_each</code> and <code>std::find_if</code> that can be applied  directly to ranges. They make your code more concise and expressive.</p> </li> <li> <p>Range Concepts: These are a set of requirements that a range must satisfy to be used with the Ranges library.  They're designed to make your code more robust and maintainable.</p> </li> <li> <p>Range Access: These are a set of utilities that can be used with ranges. They include functions like <code>std::size</code>  and <code>std::empty</code>. They're useful for writing more concise code.</p> </li> </ul>"},{"location":"blogpost/Newaz/final/#integration-into-your-code","title":"Integration into Your Code","text":"<p>Integrating the C++ Ranges library into your code can be both exciting and challenging. It's exciting because you can  start writing more expressive code. It's challenging because you may encounter compatibility issues with older code or  compilers.</p>"},{"location":"blogpost/Newaz/final/#compatibility","title":"Compatibility","text":"<p>If you're working with a codebase that was written in older versions of C++, integrating the Ranges library can be a bit tricky. You may need to refactor your code to make it C++20 compatible. This can be time-consuming but is often worth it for the benefits you'll gain in terms of code readability and maintainability.</p>"},{"location":"blogpost/Newaz/final/#code-examples","title":"Code Examples","text":"<p>Here's a simple example of how to use the Ranges library to filter even numbers from a vector:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;ranges&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8};\n    auto evens = numbers | std::views::filter([](int x) { return x % 2 == 0; });\n\n    for (int num : evens) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre> <p>Compare this to the equivalent code without the Ranges library:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8};\n\n    // Without Ranges library\n    std::vector&lt;int&gt; evens;\n    for (int num : numbers) {\n        if (num % 2 == 0) {\n            evens.push_back(num);\n        }\n    }\n\n    // Print the result\n    for (int num : evens) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre> <p>As you can see, the code is more concise and readable with the Ranges library. Even though the above code uses similar  logic, ranges makes it more efficient because it avoids unnecessary data copying.  </p> <p>Lets see another example where we take the above code and add the functionality to square the remaining odd numbers.</p>"},{"location":"blogpost/Newaz/final/#using-c-ranges-library","title":"Using C++ Ranges Library:","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;ranges&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    // Using Ranges library\n    auto result = numbers | std::views::filter([](int x) { return x % 2 != 0; })\n                           | std::views::transform([](int x) { return x * x; });\n\n    // Print the result\n    for (int val : result) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"blogpost/Newaz/final/#without-c-ranges-library","title":"Without C++ Ranges Library:","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    // Without Ranges library\n    std::vector&lt;int&gt; filtered_and_squared;\n    for (int num : numbers) {\n        if (num % 2 != 0) {\n            filtered_and_squared.push_back(num * num);\n        }\n    }\n\n    // Print the result\n    for (int val : filtered_and_squared) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre> <p>In this example, the Ranges library version is more concise and expressive. It allows you to chain operations in a  pipeline-like fashion, making the code easier to read and maintain. The equivalent code without the Ranges library  requires explicit loops and temporary storage, making it more verbose.</p>"},{"location":"blogpost/Newaz/final/#disadvantages","title":"Disadvantages","text":"<p>While the C++ Ranges library offers many benefits, it also has some disadvantages. Here are a few: - Compatibility: If you're working with an older codebase, you may need to refactor your code to make it C++20 - Performance: The Ranges library can be slower than equivalent code without it. This is because it uses lazy  evaluation, which can be inefficient in some cases. - Complexity: Transitioning from traditional C++ code to a more functional and range-based style can have a learning curve for some developers. It might take time for teams to become proficient in using the new syntax and fully  understanding the intricacies of the library. - Community Adoption Pace:: The C++ community is still in the process of adopting the Ranges library. This means  some developers may not be familiar with it yet, which can make it harder to integrate into your codebase. - Library Size: The Ranges library is a large library, which can make it harder to integrate into your codebase.</p>"},{"location":"blogpost/Newaz/final/#tips-for-troubleshooting-the-c-ranges-library","title":"Tips for Troubleshooting the C++ Ranges Library","text":""},{"location":"blogpost/Newaz/final/#1-compiler-support-and-language-version","title":"1. Compiler Support and Language Version","text":"<ul> <li> <p>Issue: Ensure that your compiler supports C++20 features, as the Ranges library is introduced in C++20.</p> </li> <li> <p>Troubleshooting:</p> <ul> <li>Check your compiler's documentation to verify C++20 support.</li> <li>Upgrade to a newer version of the compiler if needed.</li> <li>Enable C++20 support explicitly in your project settings.</li> </ul> </li> </ul>"},{"location":"blogpost/Newaz/final/#2-integration-with-existing-code","title":"2. Integration with Existing Code","text":"<ul> <li> <p>Issue: Integrating the Ranges library into an existing codebase may lead to compatibility issues.</p> </li> <li> <p>Troubleshooting:</p> <ul> <li>Gradually introduce Ranges functionality to parts of the code.</li> <li>Consider refactoring smaller sections of the code first to test compatibility.</li> <li>Address any conflicts with existing functions or naming conventions.</li> </ul> </li> </ul>"},{"location":"blogpost/Newaz/final/#3-undefined-or-unintended-behavior","title":"3. Undefined or Unintended Behavior","text":"<ul> <li> <p>Issue: Unexpected behavior or runtime errors may occur if the Ranges library is not used correctly.</p> </li> <li> <p>Troubleshooting:</p> <ul> <li>Review the documentation and examples to ensure proper usage of range adaptors, views, and algorithms.</li> <li>Verify that lambdas or predicates provided to functions like <code>filter</code> or <code>transform</code> are well-formed.</li> <li>Use debugging tools to inspect the state of variables and ranges during runtime.</li> </ul> </li> </ul>"},{"location":"blogpost/Newaz/final/#4-tooling-and-ide-support","title":"4. Tooling and IDE Support","text":"<ul> <li> <p>Issue: Some IDEs or development tools might not fully support C++20 features or provide accurate code assistance for the Ranges library.</p> </li> <li> <p>Troubleshooting:</p> <ul> <li>Check for updates to your IDE that include better support for C++20 and the Ranges library.</li> <li>Use online resources or community forums to seek advice on configuring your IDE for optimal Ranges library support.</li> </ul> </li> </ul>"},{"location":"blogpost/Newaz/final/#recommendations","title":"Recommendations","text":"<p>The C++ Ranges library is a powerful addition to the language, but it may not be suitable for every project. Here are  some situations where I would recommend its use:</p> <ul> <li> <p>New Projects: If you're starting a new project or working on a codebase that can easily adopt C++20, definitely  give the Ranges library a try. It will make your code more expressive and readable.</p> </li> <li> <p>Refactoring Opportunities: If you have an existing codebase that you're planning to refactor, consider integrating the Ranges library. Refactoring provides an excellent chance to transition to modern C++ practices.</p> </li> <li> <p>Teaching and Learning: If you're teaching or learning C++, the Ranges library is a fantastic way to illustrate  modern C++ features and coding practices.</p> </li> </ul>"},{"location":"blogpost/Newaz/final/#tips-for-new-users","title":"Tips for New Users","text":"<p>For those new to the C++ Ranges library, here are some tips:</p> <ul> <li> <p>Familiarize yourself with the basic components: Range Adaptors, Range Views, and Range Algorithms.</p> </li> <li> <p>Start with small, manageable projects to experiment with the library.</p> </li> <li> <p>Read the official documentation and online resources to deepen your understanding.</p> </li> <li> <p>Be patient. Learning and integrating a new library takes time, but the benefits are worth it.</p> </li> </ul> <p>In conclusion, the C++ Ranges library is a valuable addition to the C++ language. While there may be challenges in  integrating it into your code, the improved code quality and expressiveness it offers make it a worthy investment. If  you're a new user, take your time to learn and experiment, and you'll discover the power of the C++ Ranges library in no time.</p>"},{"location":"blogpost/Newaz/final/#footnotes","title":"Footnotes","text":""},{"location":"blogpost/Newaz/final/#stdviewsfilter","title":"std::views::filter","text":"<ul> <li>Description: The filter function is a range adaptor that creates a view containing only the elements that satisfy  a specified predicate.</li> <li>Example:</li> </ul> <pre><code>auto evens = numbers | std::views::filter([](int x) { return x % 2 == 0; });\n</code></pre> <ul> <li>Output: <code>2 4 6 8</code></li> <li>This creates a view('evens') that contains only the even numbers from the vector('numbers').</li> </ul>"},{"location":"blogpost/Newaz/final/#stdviewstransform","title":"std::views::transform","text":"<ul> <li>Description: The transform function is a range adaptor that creates a view with transformed elements, applying a  specified unary operation to each element.</li> <li>Example:</li> </ul> <pre><code>auto squares = numbers | std::views::transform([](int x) { return x * x; });\n</code></pre> <ul> <li>Output: <code>1 4 9 16 25 36 49 64 81 100</code></li> <li>This creates a view('squares') with each element being the square of the corresponding element in the original  'numbers' range.</li> </ul>"},{"location":"blogpost/Newaz/final/#stdviewssort","title":"std::views::sort","text":"<ul> <li>Description: The sort function is a range adaptor that creates a view with sorted elements, applying a specified compartor to each element.</li> <li>Example:</li> </ul> <pre><code>std::ranges::sort(numbers);\n</code></pre> <ul> <li>Output: <code>1 2 3 4 5 6 7 8 9 10</code></li> <li>This sorts the numbers range in ascending order.</li> </ul>"},{"location":"blogpost/Newaz/final/#stdfor_each","title":"std::for_each","text":"<ul> <li>Description: The for_each function is a range algorithm that applies a specified function to each element in a range.</li> <li>Example:</li> </ul> <pre><code>std::for_each(numbers.begin(), numbers.end(), [](int x) {\n    // do something with x\n});\n</code></pre> <ul> <li>This applies the specified function to each element in the numbers range.</li> </ul>"},{"location":"blogpost/Newaz/final/#stdfind_if","title":"std::find_if","text":"<ul> <li>Description: The find_if function is a range algorithm that finds the first element in a range that satisfies a specified predicate.</li> <li>Example:</li> </ul> <pre><code>auto it = std::find_if(numbers.begin(), numbers.end(), [](int x) {\n    return x % 2 == 0;\n});\n</code></pre> <ul> <li>This finds the first even number in the numbers range and returns an iterator to it.</li> </ul>"},{"location":"blogpost/Newaz/final/#link-to-library","title":"Link to Library:","text":"<p>This is a link to the C++ Ranges library documentation: https://en.cppreference.com/w/cpp/ranges</p>"},{"location":"blogpost/Newaz/final/#happy-coding","title":"Happy coding!","text":""},{"location":"blogpost/ODell/final/","title":"Final","text":"<p>Raylib: A Powerful Building Block For Old and New</p> <p>Zane O'Dell</p> <p>Whether you use powerful tools such as Unreal Engine or are writing your game in VIM, C++ is a powerful language that has the capability to create any number of games, using almost any number of software tools.</p> <p>One such tool that can be used is a library written in native C called Raylib. Raylib is a library used for creating games, and has various functions for different aspects of game development. One thing Raylib prides itself on is its lack of a GUI or external tools/editors. Raylib, as they claim on their official website ( [Raylib] ), does not provide a large set of API documentation or a plethora of tutorials for programmers to utilize, and encourages its users to dive right into making things with its API and getting comfortable using its library cheat sheet to gain knowledge of its inner workings.</p> <p>With all of that being said, let's dive right into using Raylib to create a simple game using its tools. The kind of game that will be made is a simple catch game, in which the player will move left and right across the screen catching an item that falls from the top of the screen while avoiding other obstacles that fall from the top of the screen.</p> <p>In getting started with Raylib, I followed the install instructions on the website, and using Visual Studio Code as my IDE of preference, we can start creating our simple game.</p> <p>In order to use Raylib with C++, there are some additional steps to set it up in VSCode. It was a bit difficult to get it set up with my IDE. However, I did find a tutorial to be helpful that is linked here: [Raylib VSCode tutorial].</p> <p>While it is possible to write any game using Raylib fully in C, using C++ allows for more flexibility and levels of abstraction. So, in writing our catch game, we'll be making use of classes and inheritance features that are missing in C.</p> <p>Let's start with the main function.</p> <p></p> <p>As the function call suggests, SetTargetFPS sets the frames per second that our game will run at, which in our case is 60.</p> <p>Next, we should create our window that the game will be played in. Rather than just using Raylib's functionality in the main function we can create our own C++ classes that utilize Raylib and abstract them.</p> <p>The first class we can make is a GameWindow, in gamewindow.hpp\\ \\ </p> <p></p> <p>Again, we can start from the top and work our way down.</p> <p>Within the class we have various member variables, all denoted in their naming scheme with a \"m_\" prefix. We have the height of the window, the width, and the title of the window as a string literal, represented as a const char *, which will show up on the top of the window once the program is run.</p> <p>Next, we have more interesting variables. Firstly, we have a string literal that is a file path to the texture we wish to use for the background, and then an actual Texture2D instance that will hold our texture pointed at by the filepath. Finally, we have a score for our game as an integer, representing how many times the player has caught our star in succession.</p> <p>All member variables of the GameWindow other than the score will be passed in through the class constructor, initializing the object ready for use as shown on line 15 of the main function.</p> <p>With our window created, we can move into creating the main objects of our game, being the star that we catch, and the bucket that we catch it in. As they both are objects within our game, we can create a base class for both of these objects, being a GameObject class.</p> <p></p> <p></p> <p>This class will act as the basis for both of our main pieces of the game, being the star and bucket as mentioned previously. Each of these objects will have shared class member variables, such as a width, height, x position, y position, a file path to a texture and a texture itself, a reference to the window that it is a part of, being our GameWindow instance, a rectangle, indicating its physical space in the game used to detect collisions, and a boolean stating whether or not the object's rectangle is colliding with another object's rectangle.</p> <p>In regards to the object's creation via its constructor, each object will take in those member variables, other than a Texture2D and a rectangle, as those will be either loaded/created within the constructor itself, as shown above. Specifically, the m_rect member variable is a struct that contains four parameters, being the x and y positions, and then the width and height of the rectangle. The LoadTexture function will take in a file path, and return a Texture2D object that is the texture pointed at by the file path.</p> <p>Afterwards, we can call DrawObject, which calls a Raylib C function that draws the texture at a x position and y position. Afterwards, we have various getters and setters for member variables of the class, followed by a pure virtual function, denoted by the \"0\" after the function declaration. The behavior within the Update function, which is called every frame, will be special for each object so we can make it a pure virtual function.</p> <p>With our base object class created, now we can make the classes for our actual objects, starting with Bucket.</p> <p></p> <p>Other than the constructor, which is derived from the base class, we only need to implement our Update function specifically for the bucket. Essentially, we use Raylib functions to detect input from the keyboard, and depending on the key (left or right arrow key), we move the position of the object and its rectangle/collider to the left or right.</p> <p>Next, we can move on to the Star class.</p> <p></p> <p>Just like Bucket, we are able to use an initializer list for the constructor and override the Update function. In this function, we have the star fall at a certain rate every frame. After that, we just check if the star is past the bottom of the screen, or if it is colliding with the bucket. If so, we reset the star's position, towards the top of the screen at a random x value within a certain range. If the star was reset by colliding, we call the increase score function from the window reference. If not, we reset the score entirely.</p> <p></p> <p>Here within the main function is the rest of the game loop. We begin by seeing if the star and bucket are colliding and tell both objects if they are colliding. Then, we call their respective update functions and draw the objects. In Raylib, we have to have any drawing done in between the BeginDrawing and EndDrawing functions.</p> <p>Our final result is this: </p> <p>We have our bucket moving left and right when detecting left and right arrow keys as input, the bucket and star colliding and adding/resetting the score, and the star moving down and resetting upon a collision or it reaching the bottom of the screen. While a simple game, it makes use of some of the more used functions that Raylib as a library provides.</p> <p>Overall, Raylib is extremely easy to use and learn. While the official website does not directly have a lot of tutorials to boast, there are plenty of external resources outside of the documentation that programmers can utilize in their game creation journey.</p> <p>Below are multiple GitHub repositories of games that utilize Raylib in their development, including the simple game created for the purpose of this tutorial.</p> <p>Overall, I would give Raylib a more than satisfactory rating and would recommend it to any and all C/C++ programmers looking to make their own video games or game-like simulatory programs.</p> <p>Additional Resources:</p> <p>[Games created with Raylib]</p> <p>[Tutorial Catch Game]</p>"},{"location":"blogpost/Orvis/draft/","title":"ChatGPT Calculator","text":"<p>by Evan Orvis</p>"},{"location":"blogpost/Orvis/draft/#background","title":"Background","text":"<p>ChatGPT is a very powerful large language model-based chatbot that can be used in a variety of situations. Computer Scientists are able to use this technology in a variety of ways to help write simple programs. While AI is generally pretty good at mathematical functions, ChatGPT still has some areas that it struggles in. ChatGPT can create some good code, but when multiple things are added at a single time, it can easily forget how to </p>"},{"location":"blogpost/Orvis/draft/#simple-code-generation","title":"Simple Code Generation","text":"<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    double num1, num2;\n    char operation;\n\n    std::cout &lt;&lt; \"Enter the first number: \";\n    std::cin &gt;&gt; num1;\n\n    std::cout &lt;&lt; \"Enter an operation (+, -, *, /): \";\n    std::cin &gt;&gt; operation;\n\n    std::cout &lt;&lt; \"Enter the second number: \";\n    std::cin &gt;&gt; num2;\n\n    double result;\n\n    switch (operation) {\n        case '+':\n            result = num1 + num2;\n            break;\n        case '-':\n            result = num1 - num2;\n            break;\n        case '*':\n            result = num1 * num2;\n            break;\n        case '/':\n            if (num2 != 0) {\n                result = num1 / num2;\n            } else {\n                std::cout &lt;&lt; \"Error: Division by zero is not allowed.\" &lt;&lt; std::endl;\n                return 1; // Exit with an error code\n            }\n            break;\n        default:\n            std::cout &lt;&lt; \"Invalid operation. Please use +, -, *, or /.\" &lt;&lt; std::endl;\n            return 1; // Exit with an error code\n    }\n\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; num1 &lt;&lt; \" \" &lt;&lt; operation &lt;&lt; \" \" &lt;&lt; num2 &lt;&lt; \" = \" &lt;&lt; result &lt;&lt; std::endl;\n\nreturn 0;\n}\n</code></pre> <p>For this simple code, all that was asked for ChatGPT to write some C++ code that can do four simple arithmetic functions: addition, subtraction, multiplication, and division. In this regard, it creates quality code that is very efficient. For this simple code generation, it was a little surprising that ChatGPT used a switch statement, as it is a slightly more advanced and efficient method to handle operations. It was also surprising that ChatGPT knew to account for dividing by zero, as it is something that people can often overlook. ChatGPT overall created very good code that can do simple arithmetic operations.</p>"},{"location":"blogpost/Orvis/draft/#adding-more-features-to-the-code","title":"Adding more features to the code","text":"<p>Since the simple code generation was practically perfect, the level of difficulty needed to be increased. This was done by asking ChatGPT to add an ability to compute another operation and add operations for exponential, square root, and modulo operations.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; // For square root and exponentiation\n\nint main() {\n    char repeat;\n    do {\n        double num1, num2;\n        char operation;\n\n        std::cout &lt;&lt; \"Enter the first number: \";\n        std::cin &gt;&gt; num1;\n\n        std::cout &lt;&lt; \"Enter an operation (+, -, *, /, ^ (exponentiation), sqrt (square root), % (modulo)): \";\n        std::cin &gt;&gt; operation;\n\n        if (operation != 'sqrt' &amp;&amp; operation != '^' &amp;&amp; operation != '%') {\n            std::cout &lt;&lt; \"Enter the second number: \";\n            std::cin &gt;&gt; num2;\n        }\n\n        double result;\n\n        switch (operation) {\n            case '+':\n                result = num1 + num2;\n                break;\n            case '-':\n                result = num1 - num2;\n                break;\n            case '*':\n                result = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    result = num1 / num2;\n                } else {\n                    std::cout &lt;&lt; \"Error: Division by zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case '^':\n                result = std::pow(num1, num2);\n                break;\n            case 'sqrt':\n                result = std::sqrt(num1);\n                break;\n            case '%':\n                result = std::fmod(num1, num2);\n                break;\n            default:\n                std::cout &lt;&lt; \"Invalid operation. Please use +, -, *, /, ^, sqrt, or %.\" &lt;&lt; std::endl;\n                continue; // Repeat the loop\n        }\n\n        std::cout &lt;&lt; \"Result: \";\n        if (operation == 'sqrt') {\n            std::cout &lt;&lt; \"sqrt(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else {\n            std::cout &lt;&lt; num1 &lt;&lt; \" \" &lt;&lt; operation &lt;&lt; \" \" &lt;&lt; num2 &lt;&lt; \" = \" &lt;&lt; result;\n        }\n        std::cout &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Do you want to perform another operation? (y/n): \";\n        std::cin &gt;&gt; repeat;\n    } while (repeat == 'y' || repeat == 'Y');\n\n    return 0;\n}\n</code></pre> <p>This code is more complex and starts to show where ChatGPT struggles. The first problem that appeared was that the operation is being inputted as a char and ChatGPT set 'sqrt' as the char for square root operation, which is impossible to do. When pointed out, ChatGPT agreed and changed the operation to 's'. Another big error was that ChatGPT was excluding exponential and modulo operations from entering a second number, which is needed for both operations. These mistakes were both part of adding multiple operations where it looks like ChatGPT took the mathematical properties from the first operation and transposed them onto the others as well. It is impressive that ChatGPT includes the cmath library to be able to use simpler functions for operations. Overall, it is a little surprising that ChatGPT struggled with this code.</p>"},{"location":"blogpost/Orvis/draft/#adding-even-more-features","title":"Adding even more features","text":"<p>For the next section, since ChatGPT had failed to write complete code, it to see if more operations would break anything. For this, operations for absolute value, inverse, log, and natural log, as well as the ability to repeat operations with the result from the previous computation</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; // For mathematical functions\n\nint main() {\n    char repeat;\n    double result; // Variable to store the result\n\n    do {\n        double num1, num2;\n        char operation;\n\n        // If there is a previous result, use it as the new first number\n        if (result != 0.0) {\n            num1 = result;\n        }\n\n        std::cout &lt;&lt; \"Enter an operation (+, -, *, /, ^ (exponentiation), s (square root), % (modulo), i (inverse), a (absolute value), l (log), n (ln)): \";\n        std::cin &gt;&gt; operation;\n\n        if (operation != 's' &amp;&amp; operation != 'i' &amp;&amp; operation != 'a' &amp;&amp; operation != 'l' &amp;&amp; operation != 'n') {\n            std::cout &lt;&lt; \"Enter the second number: \";\n            std::cin &gt;&gt; num2;\n        }\n\n        switch (operation) {\n            case '+':\n                result = num1 + num2;\n                break;\n            case '-':\n                result = num1 - num2;\n                break;\n            case '*':\n                result = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    result = num1 / num2;\n                } else {\n                    std::cout &lt;&lt; \"Error: Division by zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case '^':\n                result = std::pow(num1, num2);\n                break;\n            case 's':\n                if (num1 &gt;= 0) {\n                    result = std::sqrt(num1);\n                } else {\n                    std::cout &lt;&lt; \"Error: Square root of a negative number is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'i':\n                if (num1 != 0) {\n                    result = 1 / num1;\n                } else {\n                    std::cout &lt;&lt; \"Error: Inverse of zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'a':\n                result = std::abs(num1);\n                break;\n            case 'l':\n                if (num1 &gt; 0 &amp;&amp; num2 &gt; 0) {\n                    result = std::log(num1) / std::log(num2);\n                } else {\n                    std::cout &lt;&lt; \"Error: Logarithm arguments must be positive.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'n':\n                if (num1 &gt; 0) {\n                    result = std::log(num1);\n                } else {\n                    std::cout &lt;&lt; \"Error: Natural logarithm argument must be positive.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case '%':\n                result = std::fmod(num1, num2);\n                break;\n            default:\n                std::cout &lt;&lt; \"Invalid operation. Please use +, -, *, /, ^, s, i, a, l, n, or %.\" &lt;&lt; std::endl;\n                continue; // Repeat the loop\n        }\n\n        std::cout &lt;&lt; \"Result: \";\n        if (operation == 's') {\n            std::cout &lt;&lt; \"sqrt(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'i') {\n            std::cout &lt;&lt; \"1 / \" &lt;&lt; num1 &lt;&lt; \" = \" &lt;&lt; result;\n        } else if (operation == 'a') {\n            std::cout &lt;&lt; \"| \" &lt;&lt; num1 &lt;&lt; \" | = \" &lt;&lt; result;\n        } else if (operation == 'l') {\n            std::cout &lt;&lt; \"log_\" &lt;&lt; num2 &lt;&lt; \"(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'n') {\n            std::cout &lt;&lt; \"ln(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else {\n            std::cout &lt;&lt; num1 &lt;&lt; \" \" &lt;&lt; operation &lt;&lt; \" \" &lt;&lt; num2 &lt;&lt; \" = \" &lt;&lt; result;\n        }\n        std::cout &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Do you want to perform another operation? (y/n): \";\n        std::cin &gt;&gt; repeat;\n    } while (repeat == 'y' || repeat == 'Y');\n\n    return 0;\n}\n\n</code></pre> <p>A lot was added and changed in this iteration, and it created multiple errors. The biggest one is removing the option to set the first number. It is unclear what caused this to happen, but a good guess is that when specifying the program to repeat with the result, the initial setter for the first number was removed. When this was pointed out, a setter for the first number was added and code for prompting the user about using the result from the previous operation was added, but this still had a problem. There was also another problem where log should have been set to base10 as a default; However, this is not a fault of the AI as it was not specified in the directions. When asked to only allow base10 and not require a second number, ChatGPT decided to remove num2 from the entire program and have a new numX input in each case statement that needed it. This created redundant code that could be simplified and when mentioned that the program should contain a second number, it was readded.</p>"},{"location":"blogpost/Orvis/draft/#inability-to-set-a-new-first-number","title":"Inability to set a new first number","text":"<pre><code>if (result != 0.0) {\n    char useResult;\n    std::cout &lt;&lt; \"Use the previous result (\" &lt;&lt; result &lt;&lt; \") as the new first number? (y/n): \";\n    std::cin &gt;&gt; useResult;\n    if (useResult == 'y' || useResult == 'Y') {\n    num1 = result;\n    }\n}\n</code></pre> <p>While the above code allowed the user to reuse the previous result as the first number, it does not allow the user to set a new first number. It should also be noted that if the result of the previous operation is zero, the following operation will use the previous first number instead of setting a new one.</p>"},{"location":"blogpost/Orvis/draft/#unwanted-removal-of-num2","title":"Unwanted removal of num2","text":"<pre><code>switch (operation) {\n    case '+':\n        double num2;\n        std::cout &lt;&lt; \"Enter the second number: \";\n        std::cin &gt;&gt; num2;\n        result = num1 + num2;\n        break;\n    case '-':\n        double num3;\n        std::cout &lt;&lt; \"Enter the second number: \";\n        std::cin &gt;&gt; num3;\n        result = num1 - num3;\n        break;\n    case '*':\n        double num4;\n        std::cout &lt;&lt; \"Enter the second number: \";\n        std::cin &gt;&gt; num4;\n        result = num1 * num4;\n        break;\n</code></pre> <p>As you can see in the small sample above, there was a user input in each of the cases that required a second number, which is redundant when you could have one member variable that does the same thing. When mentioned that a second number should still be in the program, the num2 member variable was readded and all redundant inputs were removed.</p>"},{"location":"blogpost/Orvis/draft/#final-addition-of-code","title":"Final addition of code","text":"<p>For the last part of adding complexity, an operation for factorial was added. Note that this was after all the previous problems were fixed and the goal is to see if it can add a single semi-complex function into the mix.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; // For mathematical functions\n\n// Function to calculate the factorial of a non-negative integer\ndouble factorial(int n) {\n    if (n &lt; 0) {\n        return -1; // Return -1 to indicate an error\n    }\n    if (n == 0) {\n        return 1; // 0! = 1\n    }\n    double result = 1;\n    for (int i = 1; i &lt;= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nint main() {\n    char repeat;\n    double result = 0.0; // Variable to store the result\n\n    do {\n        double num1;\n        double num2 = 0.0;\n        char operation;\n\n        // If there is a previous result, ask the user if they want to use it as the new first number\n        if (result != 0.0) {\n            char useResult;\n            std::cout &lt;&lt; \"Use the previous result (\" &lt;&lt; result &lt;&lt; \") as the new first number? (y/n): \";\n            std::cin &gt;&gt; useResult;\n            if (useResult == 'y' || useResult == 'Y') {\n                num1 = result;\n            } else {\n                std::cout &lt;&lt; \"Enter a new first number: \";\n                std::cin &gt;&gt; num1;\n            }\n        } else {\n            std::cout &lt;&lt; \"Enter the first number: \";\n            std::cin &gt;&gt; num1;\n        }\n\n        std::cout &lt;&lt; \"Enter an operation (+, -, *, /, ^ (exponentiation), s (square root), i (inverse), a (absolute value), l (log), n (ln), f (factorial)): \";\n        std::cin &gt;&gt; operation;\n\n        // For operations that do not require a second number, set it to 0.0 by default\n        if (operation != 's' &amp;&amp; operation != 'i' &amp;&amp; operation != 'a' &amp;&amp; operation != 'l' &amp;&amp; operation != 'n' &amp;&amp; operation != 'f') {\n            std::cout &lt;&lt; \"Enter the second number: \";\n            std::cin &gt;&gt; num2;\n        }\n\n        switch (operation) {\n            case '+':\n                result = num1 + num2;\n                break;\n            case '-':\n                result = num1 - num2;\n                break;\n            case '*':\n                result = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    result = num1 / num2;\n                } else {\n                    std::cout &lt;&lt; \"Error: Division by zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case '^':\n                result = std::pow(num1, num2);\n                break;\n            case 's':\n                if (num1 &gt;= 0) {\n                    result = std::sqrt(num1);\n                } else {\n                    std::cout &lt;&lt; \"Error: Square root of a negative number is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'i':\n                if (num1 != 0) {\n                    result = 1 / num1;\n                } else {\n                    std::cout &lt;&lt; \"Error: Inverse of zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'a':\n                result = std::abs(num1);\n                break;\n            case 'l':\n                if (num1 &gt; 0) {\n                    result = std::log10(num1); // Common logarithm (base 10)\n                } else {\n                    std::cout &lt;&lt; \"Error: Logarithm argument must be positive.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'n':\n                if (num1 &gt; 0) {\n                    result = std::log(num1); // Natural logarithm (base e)\n                } else {\n                    std::cout &lt;&lt; \"Error: Natural logarithm argument must be positive.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'f':\n                if (num1 &gt;= 0 &amp;&amp; std::floor(num1) == num1) {\n                    result = factorial(static_cast&lt;int&gt;(num1));\n                } else {\n                    std::cout &lt;&lt; \"Error: Factorial argument must be a non-negative integer.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            default:\n                std::cout &lt;&lt; \"Invalid operation. Please use +, -, *, /, ^, s, i, a, l, n, or f (factorial).\" &lt;&lt; std::endl;\n                continue; // Repeat the loop\n        }\n\n        std::cout &lt;&lt; \"Result: \";\n        if (operation == 's') {\n            std::cout &lt;&lt; \"sqrt(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'i') {\n            std::cout &lt;&lt; \"1 / \" &lt;&lt; num1 &lt;&lt; \" = \" &lt;&lt; result;\n        } else if (operation == 'a') {\n            std::cout &lt;&lt; \"| \" &lt;&lt; num1 &lt;&lt; \" | = \" &lt;&lt; result;\n        } else if (operation == 'l') {\n            std::cout &lt;&lt; \"log(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'n') {\n            std::cout &lt;&lt; \"ln(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'f') {\n            std::cout &lt;&lt; num1 &lt;&lt; \"! = \" &lt;&lt; result;\n        } else {\n            std::cout &lt;&lt; num1 &lt;&lt; \" \" &lt;&lt; operation &lt;&lt; \" \" &lt;&lt; num2 &lt;&lt; \" = \" &lt;&lt; result;\n        }\n        std::cout &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Do you want to perform another operation? (y/n): \";\n        std::cin &gt;&gt; repeat;\n    } while (repeat == 'y' || repeat == 'Y');\n\n    return 0;\n}\n\n</code></pre> <p>Looking at this code, it is impressive that ChatGPT created a good setup for a factorial operation. In the case statement for factorial, it checks if the first number is non-negative and an integer before casting the number to an integer for the factorial function. If it is not a positive number, or not an integer, the factorial function does not get run. The real surprise was inside the factorial function where ChatGPT created a factorial algorithm with a space complexity of O(1) by using a loop, which is much more efficient than the recursive algorithm which is O(n). It was a little surprising that after many mistakes along the way, ChatGPT was able to create a new operation and function that was efficient and free from errors.</p>"},{"location":"blogpost/Orvis/draft/#conclusion","title":"Conclusion","text":"<p>ChatGPT gets the general idea of creating a calculator correct and needs very specific inputs from the prompter to write good code. It is still important to review all the code that it creates, as it is very prone to even simple errors that beginner programmers can easily avoid. It was surprising that ChatGPT struggled with creating quality code as it is viewed in society as something that could \"replace programmers\". In actuality, ChatGPT is not close to this as it would need to be able to write efficient and quality code without many errors which is not the case. It could be good at getting an idea of how to write a function as it can create simple functions, but anything that starts to get more complex would need a programmer to do it.</p>"},{"location":"blogpost/Orvis/draft/#references","title":"References","text":"<p>https://chat.openai.com/share/6ff7db27-ee1c-4067-8abe-ce26c6bf2774</p> <p>I did ask a couple of the questions out of order as it appears here but there is an expectation that the code would remain the same regardless</p>"},{"location":"blogpost/Orvis/final/","title":"ChatGPT Calculator","text":"<p>by Evan Orvis</p>"},{"location":"blogpost/Orvis/final/#background","title":"Background","text":"<p>ChatGPT is a very powerful large language model-based chatbot that can be used in a variety of situations. Computer Scientists are able to use this technology in a variety of ways to help write simple programs. While AI is generally pretty good at mathematical functions, ChatGPT still has some areas that it struggles in. ChatGPT can create some quality and efficient code, but when multiple things are added at a single time, it can easily forget how to correctly add it all into the program.</p>"},{"location":"blogpost/Orvis/final/#simple-code-generation","title":"Simple Code Generation","text":"<p>The initial prompt for the simple code generation was: \"write me c++ code that can do addition, subtraction, multiplication, and division\".</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    double num1, num2;\n    char operation;\n\n    std::cout &lt;&lt; \"Enter the first number: \";\n    std::cin &gt;&gt; num1;\n\n    std::cout &lt;&lt; \"Enter an operation (+, -, *, /): \";\n    std::cin &gt;&gt; operation;\n\n    std::cout &lt;&lt; \"Enter the second number: \";\n    std::cin &gt;&gt; num2;\n\n    double result;\n\n    switch (operation) {\n        case '+':\n            result = num1 + num2;\n            break;\n        case '-':\n            result = num1 - num2;\n            break;\n        case '*':\n            result = num1 * num2;\n            break;\n        case '/':\n            if (num2 != 0) {\n                result = num1 / num2;\n            } else {\n                std::cout &lt;&lt; \"Error: Division by zero is not allowed.\" &lt;&lt; std::endl;\n                return 1; // Exit with an error code\n            }\n            break;\n        default:\n            std::cout &lt;&lt; \"Invalid operation. Please use +, -, *, or /.\" &lt;&lt; std::endl;\n            return 1; // Exit with an error code\n    }\n\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; num1 &lt;&lt; \" \" &lt;&lt; operation &lt;&lt; \" \" &lt;&lt; num2 &lt;&lt; \" = \" &lt;&lt; result &lt;&lt; std::endl;\n\nreturn 0;\n}\n</code></pre> <p>For this simple code, all that was asked for ChatGPT to write some C++ code that can do four simple arithmetic functions: addition, subtraction, multiplication, and division. In this regard, it creates quality code that is very efficient. For this simple code generation, it was a little surprising that ChatGPT used a switch statement, as it is a slightly more advanced and efficient method to handle operations. It was also surprising that ChatGPT knew to account for dividing by zero, as it is something that people can often overlook. ChatGPT overall created very good code that can do simple arithmetic operations.</p>"},{"location":"blogpost/Orvis/final/#adding-more-features-to-the-code","title":"Adding more features to the code","text":"<p>Since the simple code generation was practically perfect, the level of difficulty needed to be increased. This was done by asking ChatGPT to add an ability to compute another operation and add operations for exponential, square root, and modulo operations.</p> <p>The prompt for this section was the following: \"for the previous code, allow the user to repeat operations\" and \"Also allow exponential, square root, and modulo function as valid operation\".</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; // For square root and exponentiation\n\nint main() {\n    char repeat;\n    do {\n        double num1, num2;\n        char operation;\n\n        std::cout &lt;&lt; \"Enter the first number: \";\n        std::cin &gt;&gt; num1;\n\n        std::cout &lt;&lt; \"Enter an operation (+, -, *, /, ^ (exponentiation), sqrt (square root), % (modulo)): \";\n        std::cin &gt;&gt; operation;\n\n        if (operation != 'sqrt' &amp;&amp; operation != '^' &amp;&amp; operation != '%') {\n            std::cout &lt;&lt; \"Enter the second number: \";\n            std::cin &gt;&gt; num2;\n        }\n\n        double result;\n\n        switch (operation) {\n            case '+':\n                result = num1 + num2;\n                break;\n            case '-':\n                result = num1 - num2;\n                break;\n            case '*':\n                result = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    result = num1 / num2;\n                } else {\n                    std::cout &lt;&lt; \"Error: Division by zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case '^':\n                result = std::pow(num1, num2);\n                break;\n            case 'sqrt':\n                result = std::sqrt(num1);\n                break;\n            case '%':\n                result = std::fmod(num1, num2);\n                break;\n            default:\n                std::cout &lt;&lt; \"Invalid operation. Please use +, -, *, /, ^, sqrt, or %.\" &lt;&lt; std::endl;\n                continue; // Repeat the loop\n        }\n\n        std::cout &lt;&lt; \"Result: \";\n        if (operation == 'sqrt') {\n            std::cout &lt;&lt; \"sqrt(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else {\n            std::cout &lt;&lt; num1 &lt;&lt; \" \" &lt;&lt; operation &lt;&lt; \" \" &lt;&lt; num2 &lt;&lt; \" = \" &lt;&lt; result;\n        }\n        std::cout &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Do you want to perform another operation? (y/n): \";\n        std::cin &gt;&gt; repeat;\n    } while (repeat == 'y' || repeat == 'Y');\n\n    return 0;\n}\n</code></pre> <p>This code is more complex and starts to show where ChatGPT struggles. The first problem that appeared was that the operation is being inputted as a char and ChatGPT set 'sqrt' as the char for square root operation, which is impossible to do. When pointed out, ChatGPT agreed and changed the operation to 's'. Another big error was that ChatGPT was excluding exponential and modulo operations from entering a second number, which is needed for both operations. These mistakes were both part of adding multiple operations where it looks like ChatGPT took the mathematical properties from the first operation and transposed them onto the others as well. However, it is impressive that ChatGPT includes the cmath library to be able to use simpler functions for operations. Overall, it is a little surprising that ChatGPT struggled with this code.</p> <p>To fix these errors, the following prompts were used: \"sqrt is not a valid char\" and \"exponentiation and modulo need a second number\".</p>"},{"location":"blogpost/Orvis/final/#adding-even-more-features","title":"Adding even more features","text":"<p>For the next section, since ChatGPT had already failed to write complete code, it makes sense to see if more operations would break anything. For this, operations for absolute value, inverse, log, and natural log, as well as the ability to repeat operations with the result from the previous computation.</p> <p>This added a lot of functionality but took a few prompts to get it all in: \"add an inverse and absolute value operation\", \"also add log and ln operations\", and \"have the program automatically repeat with the result becoming the first number\".</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; // For mathematical functions\n\nint main() {\n    char repeat;\n    double result; // Variable to store the result\n\n    do {\n        double num1, num2;\n        char operation;\n\n        // If there is a previous result, use it as the new first number\n        if (result != 0.0) {\n            num1 = result;\n        }\n\n        std::cout &lt;&lt; \"Enter an operation (+, -, *, /, ^ (exponentiation), s (square root), % (modulo), i (inverse), a (absolute value), l (log), n (ln)): \";\n        std::cin &gt;&gt; operation;\n\n        if (operation != 's' &amp;&amp; operation != 'i' &amp;&amp; operation != 'a' &amp;&amp; operation != 'l' &amp;&amp; operation != 'n') {\n            std::cout &lt;&lt; \"Enter the second number: \";\n            std::cin &gt;&gt; num2;\n        }\n\n        switch (operation) {\n            case '+':\n                result = num1 + num2;\n                break;\n            case '-':\n                result = num1 - num2;\n                break;\n            case '*':\n                result = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    result = num1 / num2;\n                } else {\n                    std::cout &lt;&lt; \"Error: Division by zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case '^':\n                result = std::pow(num1, num2);\n                break;\n            case 's':\n                if (num1 &gt;= 0) {\n                    result = std::sqrt(num1);\n                } else {\n                    std::cout &lt;&lt; \"Error: Square root of a negative number is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'i':\n                if (num1 != 0) {\n                    result = 1 / num1;\n                } else {\n                    std::cout &lt;&lt; \"Error: Inverse of zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'a':\n                result = std::abs(num1);\n                break;\n            case 'l':\n                if (num1 &gt; 0 &amp;&amp; num2 &gt; 0) {\n                    result = std::log(num1) / std::log(num2);\n                } else {\n                    std::cout &lt;&lt; \"Error: Logarithm arguments must be positive.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'n':\n                if (num1 &gt; 0) {\n                    result = std::log(num1);\n                } else {\n                    std::cout &lt;&lt; \"Error: Natural logarithm argument must be positive.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case '%':\n                result = std::fmod(num1, num2);\n                break;\n            default:\n                std::cout &lt;&lt; \"Invalid operation. Please use +, -, *, /, ^, s, i, a, l, n, or %.\" &lt;&lt; std::endl;\n                continue; // Repeat the loop\n        }\n\n        std::cout &lt;&lt; \"Result: \";\n        if (operation == 's') {\n            std::cout &lt;&lt; \"sqrt(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'i') {\n            std::cout &lt;&lt; \"1 / \" &lt;&lt; num1 &lt;&lt; \" = \" &lt;&lt; result;\n        } else if (operation == 'a') {\n            std::cout &lt;&lt; \"| \" &lt;&lt; num1 &lt;&lt; \" | = \" &lt;&lt; result;\n        } else if (operation == 'l') {\n            std::cout &lt;&lt; \"log_\" &lt;&lt; num2 &lt;&lt; \"(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'n') {\n            std::cout &lt;&lt; \"ln(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else {\n            std::cout &lt;&lt; num1 &lt;&lt; \" \" &lt;&lt; operation &lt;&lt; \" \" &lt;&lt; num2 &lt;&lt; \" = \" &lt;&lt; result;\n        }\n        std::cout &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Do you want to perform another operation? (y/n): \";\n        std::cin &gt;&gt; repeat;\n    } while (repeat == 'y' || repeat == 'Y');\n\n    return 0;\n}\n\n</code></pre> <p>A lot was added and changed in this iteration, and it created multiple errors. The biggest one is removing the option to set the first number. It is unclear what caused this to happen, but a good guess is that when specifying the program to repeat with the result, the initial setter for the first number was removed. When this was pointed out, a setter for the first number was added and code for prompting the user about using the result from the previous operation was added, but this still had a problem. There was also another problem where log should have been set to base10 as a default; However, this is not a fault of the AI as it was not specified in the directions. When asked to only allow base10 and not require a second number, ChatGPT decided to remove num2 from the entire program and have a new numX input in each case statement that needed it. This created redundant code that could be simplified and when mentioned that the program should contain a second number, it was readded.</p> <p>The prompts to fix all these areas are as follows: \"this does not allow the user to set the initial number\", \"when printing out log, there should not be a second number as the default is base 10\", \"you still need a second number in the program, just not in log\", \"some more operations do not need a second number as well\", and \"I noticed that when the user does not want to use the previous result, there is no prompt for a new first number\".</p>"},{"location":"blogpost/Orvis/final/#inability-to-set-a-new-first-number","title":"Inability to set a new first number","text":"<pre><code>if (result != 0.0) {\n    char useResult;\n    std::cout &lt;&lt; \"Use the previous result (\" &lt;&lt; result &lt;&lt; \") as the new first number? (y/n): \";\n    std::cin &gt;&gt; useResult;\n    if (useResult == 'y' || useResult == 'Y') {\n    num1 = result;\n    }\n}\n</code></pre> <p>While the above code allowed the user to reuse the previous result as the first number, it does not allow the user to set a new first number. It should also be noted that if the result of the previous operation is zero, the following operation will use the previous first number instead of setting a new one.</p>"},{"location":"blogpost/Orvis/final/#unwanted-removal-of-num2","title":"Unwanted removal of num2","text":"<pre><code>switch (operation) {\n    case '+':\n        double num2;\n        std::cout &lt;&lt; \"Enter the second number: \";\n        std::cin &gt;&gt; num2;\n        result = num1 + num2;\n        break;\n    case '-':\n        double num3;\n        std::cout &lt;&lt; \"Enter the second number: \";\n        std::cin &gt;&gt; num3;\n        result = num1 - num3;\n        break;\n    case '*':\n        double num4;\n        std::cout &lt;&lt; \"Enter the second number: \";\n        std::cin &gt;&gt; num4;\n        result = num1 * num4;\n        break;\n</code></pre> <p>As you can see in the small sample above, there was a user input in each of the cases that required a second number, which is redundant when you could have one member variable that does the same thing. When mentioned that a second number should still be in the program, the num2 member variable was readded and all redundant inputs were removed.</p>"},{"location":"blogpost/Orvis/final/#final-addition-of-code","title":"Final addition of code","text":"<p>For the last part of adding complexity, an operation for factorial was added. Note that this was after all the previous problems were fixed and the goal is to see if it can add a single semi-complex function into the mix.</p> <p>The last prompt that was given was: \"add an operation for factorial\".</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; // For mathematical functions\n\n// Function to calculate the factorial of a non-negative integer\ndouble factorial(int n) {\n    if (n &lt; 0) {\n        return -1; // Return -1 to indicate an error\n    }\n    if (n == 0) {\n        return 1; // 0! = 1\n    }\n    double result = 1;\n    for (int i = 1; i &lt;= n; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nint main() {\n    char repeat;\n    double result = 0.0; // Variable to store the result\n\n    do {\n        double num1;\n        double num2 = 0.0;\n        char operation;\n\n        // If there is a previous result, ask the user if they want to use it as the new first number\n        if (result != 0.0) {\n            char useResult;\n            std::cout &lt;&lt; \"Use the previous result (\" &lt;&lt; result &lt;&lt; \") as the new first number? (y/n): \";\n            std::cin &gt;&gt; useResult;\n            if (useResult == 'y' || useResult == 'Y') {\n                num1 = result;\n            } else {\n                std::cout &lt;&lt; \"Enter a new first number: \";\n                std::cin &gt;&gt; num1;\n            }\n        } else {\n            std::cout &lt;&lt; \"Enter the first number: \";\n            std::cin &gt;&gt; num1;\n        }\n\n        std::cout &lt;&lt; \"Enter an operation (+, -, *, /, ^ (exponentiation), s (square root), i (inverse), a (absolute value), l (log), n (ln), f (factorial)): \";\n        std::cin &gt;&gt; operation;\n\n        // For operations that do not require a second number, set it to 0.0 by default\n        if (operation != 's' &amp;&amp; operation != 'i' &amp;&amp; operation != 'a' &amp;&amp; operation != 'l' &amp;&amp; operation != 'n' &amp;&amp; operation != 'f') {\n            std::cout &lt;&lt; \"Enter the second number: \";\n            std::cin &gt;&gt; num2;\n        }\n\n        switch (operation) {\n            case '+':\n                result = num1 + num2;\n                break;\n            case '-':\n                result = num1 - num2;\n                break;\n            case '*':\n                result = num1 * num2;\n                break;\n            case '/':\n                if (num2 != 0) {\n                    result = num1 / num2;\n                } else {\n                    std::cout &lt;&lt; \"Error: Division by zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case '^':\n                result = std::pow(num1, num2);\n                break;\n            case 's':\n                if (num1 &gt;= 0) {\n                    result = std::sqrt(num1);\n                } else {\n                    std::cout &lt;&lt; \"Error: Square root of a negative number is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'i':\n                if (num1 != 0) {\n                    result = 1 / num1;\n                } else {\n                    std::cout &lt;&lt; \"Error: Inverse of zero is not allowed.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'a':\n                result = std::abs(num1);\n                break;\n            case 'l':\n                if (num1 &gt; 0) {\n                    result = std::log10(num1); // Common logarithm (base 10)\n                } else {\n                    std::cout &lt;&lt; \"Error: Logarithm argument must be positive.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'n':\n                if (num1 &gt; 0) {\n                    result = std::log(num1); // Natural logarithm (base e)\n                } else {\n                    std::cout &lt;&lt; \"Error: Natural logarithm argument must be positive.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            case 'f':\n                if (num1 &gt;= 0 &amp;&amp; std::floor(num1) == num1) {\n                    result = factorial(static_cast&lt;int&gt;(num1));\n                } else {\n                    std::cout &lt;&lt; \"Error: Factorial argument must be a non-negative integer.\" &lt;&lt; std::endl;\n                    continue; // Repeat the loop\n                }\n                break;\n            default:\n                std::cout &lt;&lt; \"Invalid operation. Please use +, -, *, /, ^, s, i, a, l, n, or f (factorial).\" &lt;&lt; std::endl;\n                continue; // Repeat the loop\n        }\n\n        std::cout &lt;&lt; \"Result: \";\n        if (operation == 's') {\n            std::cout &lt;&lt; \"sqrt(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'i') {\n            std::cout &lt;&lt; \"1 / \" &lt;&lt; num1 &lt;&lt; \" = \" &lt;&lt; result;\n        } else if (operation == 'a') {\n            std::cout &lt;&lt; \"| \" &lt;&lt; num1 &lt;&lt; \" | = \" &lt;&lt; result;\n        } else if (operation == 'l') {\n            std::cout &lt;&lt; \"log(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'n') {\n            std::cout &lt;&lt; \"ln(\" &lt;&lt; num1 &lt;&lt; \") = \" &lt;&lt; result;\n        } else if (operation == 'f') {\n            std::cout &lt;&lt; num1 &lt;&lt; \"! = \" &lt;&lt; result;\n        } else {\n            std::cout &lt;&lt; num1 &lt;&lt; \" \" &lt;&lt; operation &lt;&lt; \" \" &lt;&lt; num2 &lt;&lt; \" = \" &lt;&lt; result;\n        }\n        std::cout &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Do you want to perform another operation? (y/n): \";\n        std::cin &gt;&gt; repeat;\n    } while (repeat == 'y' || repeat == 'Y');\n\n    return 0;\n}\n\n</code></pre> <p>Looking at this code, it is impressive that ChatGPT created a good setup for a factorial operation. In the case statement for factorial, it checks if the first number is non-negative and an integer before casting the number to an integer for the factorial function. If it is not a positive number, or not an integer, the factorial function does not get run. The real surprise was inside the factorial function where ChatGPT created a factorial algorithm with a space complexity of O(1) by using a loop, which is much more efficient than the recursive algorithm which is O(n). It was a little surprising that after many mistakes along the way, ChatGPT was able to create a new operation and function that was efficient and free from errors.</p> <p>Whenever errors were pointed out to ChatGPT, it quickly understood the problem and fixed it. Only in one situation did it not fully fix the problem was when removing the second number for the log function and ChatGPT removed the second variable for the entire program. Since every error that was created by ChatGPT in the code had to be individually found, the time that it took to review the code could have been spent on writing it without ChatGPT and may have even been able to save time in the end.</p>"},{"location":"blogpost/Orvis/final/#conclusion","title":"Conclusion","text":"<p>ChatGPT gets the general idea of creating a calculator correct and needs very specific inputs from the prompter to write good code. It is still important to review all the code that it creates, as it is very prone to even simple errors that beginner programmers can easily avoid. It was surprising that ChatGPT struggled with creating quality code as it is viewed in society as something that could \"replace programmers\". In actuality, ChatGPT is not close to this as it would need to be able to write efficient and quality code without many errors, which is not the case. It could be good at getting an idea of how to write a function as it can create simple functions, but anything that starts to get more complex would need a programmer to do it.</p>"},{"location":"blogpost/Orvis/final/#references","title":"References","text":"<p>https://chat.openai.com/share/6ff7db27-ee1c-4067-8abe-ce26c6bf2774</p> <p>I did ask a couple of the questions out of order as it appears here but there is an expectation that the code would remain the same regardless</p>"},{"location":"blogpost/Pham/final/","title":"Final","text":"<p>C++ Advanced Feature: std::ranges By Mui Pham</p> <p>Introduction The Ranges Library was added to the standard template library in c++20. But before we get into the details of the library,  we\u2019d like to ask a few questions to underline the relevance of Ranges. Why should you care about Ranges? How does learning  about Ranges further enrich your experience as a programmer? How does this connect to the broader picture?</p> <p>So why should you care about Ranges? Well, let's take at a block of code and see how a c++ efficient programmer would have written this program before c++20 Ranges.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;numeric&gt;\n\nint main() {\n    std::vector&lt;int&gt; vectorOfInt = {5,4,3,2,1,6,7,8,9,10};\n    std::vector&lt;int&gt; vec;\n\n    std::transform(vectorOfInt.begin(),vectorOfInt.end(), \n                   std::back_inserter(vec),[](int i){return i*i;});\n    auto sumsq = std::accumulate(vec.begin(),vec.end(), 0);\n}\n</code></pre> <p>Summarizing the code: We used a lamda to square the elements of the vector of ints and copy the results into another vector. Then, we used the accumulate algorithm to find the sum of the squares.</p> <p>Now lets see how we write this code in c++20 Ranges</p> <pre><code>///Credit to Tristan Brindle (cppnorth 2022)\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;numeric&gt;\n\nint main() {\n    std::vector&lt;int&gt; vectorOfInt = {5,4,3,2,1,6,7,8,9,10};\n    std::vector&lt;int&gt; vec;\n\n    std::ranges::transform(vectorOfInt,vec.begin(),\n                           [](int i){return i*i;});\n    auto sumsq = std::accumulate(vec.begin(),vec.end(), 0);\n}\n~~~~\n\nSummary:\nThis code functions the same way as the code before it. However, there are two qualities of life\nto mention about the range version. One, the programmer doesn't have to pass the begin and end\niterator of the containers that are being operated on. They simply have to pass the container as \na whole. Two, the programmer no longer have to use a back_inserter to insert elements into the \ncontainer storing the results. They just have to pass the beginning iterator. With those two \nchanges, perhaps you can agree that the code is somewhat more legible.\n\nNote:\nThe range version of the STL algorithm are overloaded to take the beginning and ending iterator\nof the container that is being operated on. In this case, it returns the same type of iterator\nthat the STL algorithm would return. Here is where we start to introduce esoteric terminology to\nyou. When we pass a beginning and ending iterator to an algorithm, the implication is \nthat this container is present somewhere. This container is an Lvalue range. It has an address \nin memory where values are stored. Another way to think of it is that Lvalue ranges are allowed \nto be on the left side of the assignment operator, hence, its name: Lvalue. \n\n</code></pre> <pre><code>///example of a single argument range\nstd::vector&lt;int&gt; vec{1,2,3};\nstd::vector&lt;int&gt; vec2;\nstd::ranges::transform(vec, vec2.begin(),\n                       [](int i){ return i*i;});\n\n///example of a range being passed it's beginning and ending iterator\nstd::vector&lt;int&gt; vec{1,2,3};\nstd::vector&lt;int&gt; vec2;\nstd::ranges::transform(vec.begin(),vec.end(), vec2.begin(),\n                       [](int i){ return i*i;});\n</code></pre> <pre><code>\nThe reason this topic is broach is because when we pass a single argument for the container being \noperated on, it may not always be the case that the \"container\" is an L-value range. Container\nis in quotation because container is defined as a range that owns the elements. The reason why\nwe are precise with definition of container is because R-value range can be passed as arguments in the \nrange-ified version of the STL algorithms. You might see where this is going. R-value ranges don't own the\nelements. The elements from an R-value range only exist for the full expression. A full expression\nis a line of code that ends at the semi-colon. C++ doesn't have a guideline of where these temporary\nvalues have to exist temporarily. Every compiler define their own rules of where temporary\nvalues are stored. So, in the case that one argument range is passed, the iterator that returns is a \nborrowed iterator. But std::ranges::dangling is used with the template aliases of borrowed iterator and \nis the object that is instantiated if the range argument doesn't model borrowed ranges. This means if \nthe range argument isn't an L-value range, the STL algorithm that returns an iterator, will return \na std::range::dangling object. This is important because the iterator returned from the STL algorithm \nshould never dereference to a value that no longer exists in memory. That would be undefined \nbehavior. The dangling object is a wrapper object with no dereference operator defined, \nso if we tried to deference the dangling object, it will throw a compiler error. This error is ideal. \nWe caught undefined behavior at compile time.\n\nBut why go through the trouble of allowing R-value ranges to be passed as arguments? We use the concept\nof full expression to operate on a range that doesn't have to exist in memory for any other point in time, \nwe skip the process of storing that range in memory and work on the values immediately and \ndiscard it after the full expression. We take the above single range argument example and show the power\nof passing R-value ranges:\n\n</code></pre> <pre><code>///example of a single argument range\nstd::vector&lt;int&gt; vec{1,2,3};\nstd::vector&lt;int&gt; vec2;\nstd::ranges::transform(vec, vec2.begin(),\n                       [](int i){ return i*i;});\n\n///example of an R-value Range being passed as an argument\nstd::vector&lt;int&gt; vec2;\nstd::ranges::transform(std::vector&lt;int&gt;{1,2,3}, vec2.begin(),\n                       [](int i){ return i*i;});\n</code></pre> <pre><code>\nSummary:\nIn the single argument range implementation, we store the int values 1,2, and 3\ninto a vector of ints and then pass that vector into std::ranges::transform.\nIf we assume we don't use vec for anything other than calculating its elements squared,\nwe can skip assigning those values to an L-value range and pass those\nvalues immediately to std::ranges::transform on line 117. The logic in this implementation\nsaves us copy operations into a range.\n\nThe last topic to cover is std::views. A view is a range that doesn't own \nthe elements that the begin/end points to. A view is cheap to create, copy and move. \nThe idea of views is to lazily evaluate elements in a range on demand. This means \nthe value of a view element isn't computed until it is accessed. \nTo illustrate, we present a snippet of code:\n\n</code></pre> <p>///Credit to Hannes Hauswedell for code snippet</p>"},{"location":"blogpost/Pham/final/#include","title":"include","text":""},{"location":"blogpost/Pham/final/#include_1","title":"include","text":""},{"location":"blogpost/Pham/final/#include_2","title":"include  <p>int main() {     std::vector vec{1, 2, 3, 4, 5, 6};     auto v = vec | std::views::reverse | std::views::drop(2);</p> <pre><code>std::cout &lt;&lt; *v.begin() &lt;&lt; '\\n';\n</code></pre> <p>} ~~~</p> <p>Note: the | symbol is a pipe operation similarly to what you would find in the unix command line.</p> <p>The creation of the view object is done in these sequence of steps: vec which is a L-value range is piped through std::views::reverse which in turn creates a view adaptor. The view adaptor is  an intermediate object used to chain with other views to create a combined view adaptor. At the point that v in line 143 is assigned to the result, the combined adaptor returns a view object to the assignment operator. So v is a view object. Note that accessing 0th element of v is determined at the time of access which is on line 145, after the view has been created. It is done by first creating a reverse view of vec and then creating another view by  dropping the firsts 2 elements; hence, the element in v is the value 4. The idea of view is to conservatively iterate  over a range, and once iteration is necessary, we apply a recipe of operations on the element.</p>","text":""},{"location":"blogpost/Rackerby/final/","title":"Fantastic pointers and how to <code>std::launder</code> them","text":"<p>C++ has a wide variety of memory-management options, offering many different levels of abstraction. You do so manually using <code>new</code> and <code>delete</code>, forgoing the need to keep track of how much memory to allocate. You can utilize smart pointers to take advantage of RAII principles to automatically release memory. Even until C++ 23 there was support for garbage collection.</p> <p>These high-level abstractions have made memory-management and its associated bugs easier to work with. Modern C++ compilers have been fine-tuned to generate efficient low-level code from these abstractions, and optimizers aid in this step by making assumptions about the operations programmers are allowed to write. However, as a general-purpose systems programming language, C++ must give the programmer access to all levels of abstraction. This includes low levels that allow the user to write programs that violate assumptions the compiler makes. Here, we consider how <code>std::launder</code> acts as a back door when the compiler doesn't know how to handle certain uses of placement <code>new</code>.</p> <p>First, a brief overview of placement <code>new</code> and transparent replaceability. The familiar call to <code>operator new</code> (full documentation) is of the form <code>new &lt;type&gt; &lt;initializer&gt;</code>. For example:</p> <pre><code>struct Foo {\n    int bar;\n    int baz;\n}\n\n// Allocate the memory and initialize the object\nFoo* a = new Foo{1, 2};\n</code></pre> <p>This syntax both allocates memory and initializes it with the supplied arguments. However, if one wishes to decouple the memory allocation from its initialization, a different syntax called placement <code>new</code> exists for that purpose.</p> <pre><code>new (address_to_store_memory_at) &lt;type&gt; &lt;initializer&gt;\n</code></pre> <p>Cppreference provides an example of such:</p> <pre><code>struct C {\n    int i;\n    void f();\n    const C&amp; operator=(const C&amp;);\n};\n\nconst C&amp; C::operator=(const C&amp; other)\n{\n    if (this != &amp;other) {\n        this-&gt;~C();          // lifetime of *this ends\n        new (this) C(other); // new object of type C created\n        f();                 // well-defined\n    }\n    return *this;\n}\n\nC c1;\nC c2;\nc1 = c2; // well-defined\nc1.f();  // well-defined; c1 refers to a new object of type C\n</code></pre> <p>We've reused the same memory that was allocated for <code>c1</code> instead of allocating new memory. There are many reasons outside the scope of this article as to why one would want to separate allocation from initialization, but some simple ones are: - It's faster to reuse pre-allocated memory than it is to allocate new memory - When writing code for an embedded system that has memory-mapped hardware, one needs to reuse the same fixed address</p> <p>The above operations were well-defined because object <code>c1</code> was transparently replaceable by <code>c2</code>.</p> <p>According to Cppreference:</p> <p>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the original object is transparently replaceable by the new object. </p> <p>Object <code>x</code> is transparently replaceable by object <code>y</code> if: - the storage for <code>y</code> exactly overlays the storage location which <code>x</code> occupied - <code>y</code> is of the same type as <code>x</code> (ignoring the top-level cv-qualifiers) - <code>x</code> is not a complete const object - neither <code>x</code> nor <code>y</code> is a base class subobject, or a member subobject declared with [no_unique_address] - either      - <code>x</code> and <code>y</code> are both complete objects, or     - <code>x</code> and <code>y</code> are direct subobjects of objects <code>ox</code> and <code>oy</code> respectively, and <code>ox</code> is transparently replaceable by <code>oy</code>.</p> <p>Some of these definitions are outside of this article's scope, but the most important non-obvious definition is that of subobjects. You can think of a base class subobject as a class that other classes derive from, for which memory must be allocated inside the derived class.</p> <p>These requirements suggest that transparent replacability is rather strict. The example was also a tad contrived: why go through all the trouble of writing a special copy assignment operator when <code>C &amp; c2_ref = c2</code> works just as fine?</p> <p>If we break the rules of transparent replaceability, it allows for more general memory-reuse. Recall our <code>Foo</code> struct:</p> <pre><code>struct Foo {\n    int bar;\n    int baz;\n}\n</code></pre> <p>Suppose we wanted to reuse the memory of anything with the same size and alignment as a <code>Foo</code>. We can do that by using an <code>unsigned char[]</code> or <code>std::byte []</code>:</p> <pre><code>struct Foo {\n    int bar;\n    int baz;\n}\n\n// Allocate enough memory to hold a Foo with the proper alignment\nalignas(Foo) unsigned char buf[sizeof(Foo)];\n// alignas(Foo) std::byte buf[sizeof(Foo)];\n\nFoo* foo_ptr = new(&amp;buf) Foo{1, 2}; // Construct a `Foo` object, placing it into the\n// pre-allocated storage at memory address of `buf`\n// and returning a pointer to that memory foo_ptr.\n</code></pre> <p>Note: the <code>alignas</code> specifier ensures that the byte-boundaries of the buffer are the same as that of a <code>Foo</code> (full documentation).</p> <p>Pre-allocating a chunk of bytes is more generic than in the first example, but it comes at the cost of some correctness. Suppose we tried to access that memory via the first pointer to it with <code>reinterpret_cast&lt;Foo *&gt;(&amp;buf)-&gt;bar</code>. This is actually undefined behavior: the underlying type of &amp;buf is <code>unsigned char*</code> and doesn't point to a <code>Foo</code> object. This means that an <code>unsigned char[]</code> is not transparently replaceable by a <code>Foo</code>. Even if <code>&amp;buf</code> and <code>foo_ptr</code> point to the same address, their differing types mean that we cannot safely use them interchangeably. To solve the problem of not satisfying transparent replaceability, we must use <code>std::launder</code>.</p> <p>Launder has an esoteric definition on Cppreference:</p> <pre><code>template &lt;class T&gt;\n[[nodiscard]] constexpr T* launder(T* p) noexcept; // Since C++20\n</code></pre> <p>\"Provenance fence with respect to <code>p</code>. Returns a pointer to the same memory that <code>p</code> points to, but where the referent object is assumed to have a distinct lifetime and dynamic type. Formally, given  - the pointer <code>p</code> represents the address <code>A</code> of a byte in memory - an object <code>x</code> is located at the address <code>A</code> - <code>x</code> is within its lifetime - the type of <code>x</code> is the same as <code>T</code>, ignoring cv-qualifiers at every level ? - every byte that would be reachable through the result is reachable through <code>p</code> (bytes are reachable through a pointer that points to an object <code>y</code> if those bytes are within the storage of an object <code>z</code> that is pointer-interconvertible with <code>y</code>, or within the immediately enclosing array of which <code>z</code> is an element). </p> <p>Then <code>std::launder(p)</code> returns a value of type <code>T*</code> that points to the object <code>x</code>. Otherwise, the behavior is undefined. The program is ill-formed if <code>T</code> is a function type or (possibly cv-qualified) <code>void</code>.\"</p> <p>How does this arcane definition apply in this example?</p> <ol> <li><code>&amp;buf</code> points to an address A</li> <li>an object (let's call it <code>foo</code>) is located at A</li> <li>this object is within its lifetime (i.e. memory is allocated for it and it has been initialized)</li> <li>the type of <code>foo</code> is <code>Foo</code></li> <li>every byte in the returned pointer is reachable through <code>&amp;buf</code></li> </ol> <p>In order to safely reach the memory through <code>&amp;buf</code>, we must wrap the cast in a call to launder:</p> <pre><code>std::launder(reinterpret_cast&lt;Foo *&gt;(&amp;buf))-&gt;bar;\n</code></pre> <p>This informs the compiler that we can access the memory through that pointer because a call to launder effectively treats that pointer as if it were a freshly made object (similar to a normal call to <code>new</code>). The full example is below:</p> <pre><code>#include &lt;new&gt;\n\nstruct Foo {\n    int bar;\n    int baz;\n}\n\n// Stack-allocate enough memory to hold an int with the proper alignment\nalignas(Foo) unsigned char buf[sizeof(Foo)];\n\nFoo* foo_ptr = new(&amp;buf) Foo{0, 1}; // Construct a `Foo` object, placing it into the\n// pre-allocated storage at memory address of `buf`\n// and returning a pointer to that memory foo_ptr.\n\nfoo_ptr-&gt;bar = 2; // Ok, normal access\n\nreinterpret_cast&lt;Foo *&gt;(&amp;buf)-&gt;bar = 3 // Undefined behavior\n\nstd::launder(reinterpret_cast&lt;Foo *&gt;(&amp;buf))-&gt;bar = 4 // Ok, treated as a pointer to a fresh object\n</code></pre> <p>You're likely wondering, \"why not use <code>foo_ptr</code>? We already called placement <code>new</code>!\" There may be scenarios where we call placement <code>new</code> without saving its return value to a fresh pointer. Consider another example from Cppreference:</p> <pre><code>struct Base {\n    virtual int transmogrify();\n};\n\nstruct Derived : Base {\n    int transmogrify() override {\n        new(this) Base;\n        return 2;\n    }\n};\n\nint Base::transmogrify() {\n    new(this) Derived;\n    return 1;\n}\n\nstatic_assert(sizeof(Derived) == sizeof(Base));\n\nint main() {\n    // The new object failed to be transparently replaceable because\n    // it is a base subobject but the old object is a complete object.\n    Base base;\n    int n = base.transmogrify();\n    // int m = base.transmogrify(); // Undefined Behavior\n    int m = std::launder(&amp;base)-&gt;transmogrify(); // OK\n    assert(m + n == 3);\n}\n</code></pre> <p>Here is another case where transparent replacability fails: we attempt to replace a type <code>Base</code> with <code>Derived</code>, but <code>Base</code> is a base class subobject. The first call to <code>transmogrify</code> changes the underlying type of <code>base</code> from <code>Base</code> to <code>Derived</code>. However, the compiler views <code>base</code> as a <code>Base</code> object and doesn't know which call to <code>transmogrify</code> to use the second time. It assumes that the \"pointer\" to the memory at <code>base</code> and the actual type of the memory it points to should be the same, leading to undefined behavior. Once again, a band-aid solution here is to use <code>std::launder</code> to tell the compiler \"trust me, there really is a valid, freshly-made object at this address.\" Since launder doesn't affects its arguments, its return value must be stored in a variable in order to avoid the problem that not storing the result of placement <code>new</code> caused. </p> <p>What's the solution here? Unless we absolutely must use placement <code>new</code>, it's likely a better option to let each variable point to its own memory and/or to use higher-level memory-management options like smart pointers. In cases where we must use placement new, a good way to forgo this indirection is to save the result of placement <code>new</code> somewhere since we'll need to eventually call <code>std::launder</code> if we do not. Although <code>std::launder</code>'s use is niche, its necessity comes about when the compiler cannot reason about the memory lifetime of objects.</p>"},{"location":"blogpost/Rackerby/final/#resources-used","title":"Resources used","text":"<ul> <li>https://en.cppreference.com/w/cpp/utility/launder</li> <li>https://en.cppreference.com/w/cpp/language/new</li> <li>https://en.cppreference.com/w/cpp/types/byte</li> <li>https://en.cppreference.com/w/cpp/language/lifetime</li> <li>https://en.cppreference.com/w/cpp/language/object</li> </ul>"},{"location":"blogpost/Radcliffe/draft/","title":"Are PLF Library Collections More Efficient Than the STL?","text":""},{"location":"blogpost/Radcliffe/draft/#author-dominick-radcliffe","title":"Author: Dominick Radcliffe","text":"<p>Collections are a crucial aspect of software development and they hold the data we need. Therefore, it is vital that these data structures be efficient and effective. The C++ Standard Template Library (STL) most notably houses the vector data structure.</p> <p></p>"},{"location":"blogpost/Radcliffe/draft/#the-premise","title":"The Premise","text":"<p>The PLF library makes some bold claims with its list implementation by calling it a drop-in replacement for std::vector.</p> <p>Top 4 commonly used operations and their optimizations: - 293% faster insertion operations - 57% faster erasure - 77% faster sorting - 70% faster reversal</p> <p> </p>"},{"location":"blogpost/Radcliffe/draft/#the-setup","title":"The Setup","text":"<p>Creating a test environment with some simple test cases to collect benchmarks. Using GCC 6.3.0 as the compiler and Google Benchmark to log run efficiency and times.  </p> <p>Benchmarking will use CPU cycles to determine efficiency and each test will be run 5 times to calculate an average score.</p> <p>All tests will be setup in the style of unit tests to run benchmarks. Passing in a state to a range based for loop will now time that snippet:   <code>cpp   static void BM_SomeFunction(benchmark::State&amp; state) {     for (auto _ : state) {         // This code gets timed         SomeFunction();     } }</code>   Then you must register this function to run it:   <code>cpp   // Register the function as a benchmark BENCHMARK(BM_SomeFunction); // Run the benchmark BENCHMARK_MAIN();</code></p> <p> </p>"},{"location":"blogpost/Radcliffe/draft/#insertion","title":"Insertion","text":"<p>Benchmarking a simple <code>push_back</code> operation on each of the lists is a proper starting point:</p> <pre><code>static void BM_VectorInsert(benchmark::State&amp; state) {\n    std::vector&lt;int&gt; list = {1, 2, 3, 4};\n    for (auto _ : state) {\n        list.push_back(1);\n    }\n}\n\nstatic void BM_PLFInsert(benchmark::State&amp; state) {\n    plf::list&lt;int&gt; list = {1, 2, 3, 4};\n    for (auto _ : state) {\n        list.push_back(1);\n    }\n}\n</code></pre> <p>The results are as follows: Vec: 112000000 PLF: 21333333 Vec: 112000000 PLF: 32000000 Vec: 100000000 PLF: 28000000 Vec: 100000000 PLF: 24888889 Vec: 100000000 PLF: 44800000  </p> <p>This gives us a 72% average increase in efficiency, sweet!</p>"},{"location":"blogpost/Radcliffe/draft/#erasure","title":"Erasure","text":"<p>For removal, just removing the last element in the list should suffice for a meaningful test.</p> <pre><code>static void BM_VectorErase(benchmark::State&amp; state) {\n    std::vector&lt;int&gt; list = {1, 2, 3, 4};\n\n    for (auto _ : state) {\n        list.erase(list.begin() + 3);\n    }\n}\n\nstatic void BM_PLFErase(benchmark::State&amp; state) {\n    plf::list&lt;int&gt; list = {1, 2, 3, 4};\n\n    for (auto _ : state) {\n        list.remove(4);\n    }\n}\n</code></pre> <p>The results are as follows: Vec: 1000000000 PLF: 298666667 Vec: 1039200800 PLF: 235789474 Vec: 1000505701 PLF: 186666667 Vec: 1004000372 PLF: 194782609 Vec: 1000060500 PLF: 228072727  </p> <p>With that, we have an approximate 53% increase, a lot closer estimate to what is advertised unlike insertion.</p>"},{"location":"blogpost/Radcliffe/draft/#sorting","title":"Sorting","text":"<p>For sorting I'll just use a randomized list and sort the vector in ascending order.  </p> <pre><code>static void BM_VectorSort(benchmark::State&amp; state) {\n    std::vector&lt;int&gt; list = {4, 2, 1, 3};\n\n    for (auto _ : state) {\n        std::sort(list.begin(), list.end());\n    }\n}\n\nstatic void BM_PLFSort(benchmark::State&amp; state) {\n    plf::list&lt;int&gt; list = {4, 2, 1, 3};\n\n    for (auto _ : state) {\n        list.sort();\n    }\n}\n</code></pre> <p>The results are as follows: Vec: 172307692 PLF: 8960000 Vec: 298666667 PLF: 8960000 Vec: 213333333 PLF: 8960000 Vec: 235789474 PLF: 11150223 Vec: 235789474 PLF: 10000000  </p> <p>That's about a 95% increase which is great! The difference in using the standard library sort versus their built in method is quite significant.</p> <p> </p>"},{"location":"blogpost/Radcliffe/draft/#reversal","title":"Reversal","text":"<p>Reversing a list is the final topic I am going to cover, using our trusty code we have seen:  </p> <pre><code>static void BM_VectorRev(benchmark::State&amp; state) {\n    std::vector&lt;int&gt; list = {1, 2, 3, 4};\n\n    for (auto _ : state) {\n        std::reverse(list.begin(), list.end());\n    }\n}\n\nstatic void BM_PLFRev(benchmark::State&amp; state) {\n    plf::list&lt;int&gt; list = {1, 2, 3, 4};\n\n    for (auto _ : state) {\n        list.reverse();\n    }\n}\n</code></pre> <p>The results are as follows: Vec: 1002004080 PLF: 224000000 Vec: 1100306030 PLF: 248888889 Vec: 1020500611 PLF: 235789474 Vec: 1803040021 PLF: 224000000 Vec: 1040200390 PLF: 298666667</p> <p>That leaves us with an approximate 72% increase which is pretty spot on with what the PLF library claims.</p>"},{"location":"blogpost/Radcliffe/draft/#conclusion","title":"Conclusion","text":"<p>After conducting all my tests between plf::list and std::vector, I can confidently conclude that the efficiency claims made by the PLF library do indeed have a solid backing and some of the tests even came close or outperformed what was advertised. However, it is crucial to keep note of differences in compilers, optimization levels, and CPU architectures when reading statistics such as these.  </p> <p>I hope you now have an idea what type of collections you may consider using in your future projects for peak efficiency!</p>"},{"location":"blogpost/Radcliffe/final/","title":"Are PLF Library Collections More Efficient Than the STL?","text":""},{"location":"blogpost/Radcliffe/final/#author-dominick-radcliffe","title":"Author: Dominick Radcliffe","text":"<p>Collections are a crucial aspect of software development and they hold the data we need. Therefore, it is vital that these data structures be efficient and effective. The C++ Standard Template Library (STL) most notably houses the vector data structure.</p> <p></p>"},{"location":"blogpost/Radcliffe/final/#the-premise","title":"The Premise","text":"<p>The PLF library makes some bold claims with its list implementation by calling it a drop-in replacement for std::vector.</p> <p>Top 4 commonly used operations and their optimizations: - 293% faster insertion operations - 57% faster erasure - 77% faster sorting - 70% faster reversal</p> <p> </p>"},{"location":"blogpost/Radcliffe/final/#the-setup","title":"The Setup","text":"<p>Creating a test environment with some simple test cases to collect benchmarks. Using GCC 6.3.0 as the compiler and Google Benchmark to log run efficiency and times.</p> <p>Benchmarking will use CPU cycles to determine efficiency and each test will be run 5 times to calculate an average score. Tests with lists of 100 elements will also be benchmarked to show how the efficiency scales at larger capacities.</p> <p>All tests will be setup in the style of unit tests to run benchmarks. Passing in a state to a range based for loop will now time that snippet:   <code>cpp   static void BM_SomeFunction(benchmark::State&amp; state) { for (auto _ : state) { // This code gets timed SomeFunction(); } }</code> Then you must register this function to run it:   <code>cpp   // Register the function as a benchmark BENCHMARK(BM_SomeFunction); // Run the benchmark BENCHMARK_MAIN();</code></p> <p> </p>"},{"location":"blogpost/Radcliffe/final/#insertion","title":"Insertion","text":"<p>Benchmarking a simple <code>push_back</code> operation on each of the lists is a proper starting point:</p> <pre><code>static void BM_VectorInsert(benchmark::State&amp; state) {\n    std::vector&lt;int&gt; list = {1, 2, 3, 4};\n    for (auto _ : state) {\n        list.push_back(1);\n    }\n}\n\nstatic void BM_PLFInsert(benchmark::State&amp; state) {\n    plf::list&lt;int&gt; list = {1, 2, 3, 4};\n    for (auto _ : state) {\n        list.push_back(1);\n    }\n}\n</code></pre> <p>The results are as follows:</p> <pre><code> Run  |   Vector  |    PLF   |\n----- | --------- | -------- |  \n  1   | 112000000 | 21333333 |  \n  2   | 112000000 | 32000000 |  \n  3   | 100000000 | 28000000 |  \n  4   | 100000000 | 24888889 |  \n  5   | 100000000 | 44800000 |  \n</code></pre> <p>Now testing with 100 elements, we can see much higher values, but still a lot better on PLF:</p> <pre><code> Run  |   Vector  |    PLF   |\n----- | --------- | -------- |  \n  1   | 136533333 | 23578947 |  \n  2   | 115347127 | 38449042 |  \n  3   | 160563200 | 56000000 |  \n  4   | 112000000 | 22400000 |  \n  5   | 129486452 | 28000000 |  \n</code></pre> <p>When it comes to inserting elements, plf::list emerges as the undisputed champion, outperforming std::vector by a staggering 72%. Its constant time (O(1)) complexity for insertion ensures that adding elements remains swift and efficient, even as the data volume grows. In contrast, std::vector's linear (O(n)) complexity for insertion leads to a noticeable slowdown as more elements are added.</p>"},{"location":"blogpost/Radcliffe/final/#erasure","title":"Erasure","text":"<p>For removal, just removing the last element in the list should suffice for a meaningful test.</p> <pre><code>static void BM_VectorErase(benchmark::State&amp; state) {\n    std::vector&lt;int&gt; list = {1, 2, 3, 4};\n\n    for (auto _ : state) {\n        list.erase(list.begin() + 3);\n    }\n}\n\nstatic void BM_PLFErase(benchmark::State&amp; state) {\n    plf::list&lt;int&gt; list = {1, 2, 3, 4};\n\n    for (auto _ : state) {\n        list.remove(4);\n    }\n}\n</code></pre> <p>The results are as follows:</p> <pre><code> Run  |   Vector   |    PLF    |\n----- | ---------- | --------- |  \n  1   | 1000000000 | 298666667 |  \n  2   | 1039200800 | 235789474 |  \n  3   | 1000505701 | 186666667 |  \n  4   | 1004000372 | 194782609 |  \n  5   | 1000060500 | 228072727 |  \n</code></pre> <p>Now trying with the 100 element list, the efficiency is greatly noticeable:</p> <pre><code> Run  |   Vector  |   PLF    |\n----- | --------- | -------  |  \n  1   | 532371353 | 8092903  |  \n  2   | 560000000 | 11200000 |  \n  3   | 497777778 | 11200000 |  \n  4   | 640000000 | 11200000 |  \n  5   | 560000000 | 10000000 |  \n</code></pre> <p>When it comes to removing elements, plf::list proves yet again, delivering an impressive 53% efficiency increase over std::vector. Its constant time (O(1)) complexity for removal ensures that deleting elements remains swift and efficient, regardless of their position within the data structure. In contrast, std::vector's linear (O(n)) complexity for removal can lead to noticeable performance bottlenecks, especially when removing a large number of elements.</p>"},{"location":"blogpost/Radcliffe/final/#sorting","title":"Sorting","text":"<p>For sorting, I'll just use a randomized list and sort the vector in ascending order.</p> <pre><code>static void BM_VectorSort(benchmark::State&amp; state) {\n    std::vector&lt;int&gt; list = {4, 2, 1, 3};\n\n    for (auto _ : state) {\n        std::sort(list.begin(), list.end());\n    }\n}\n\nstatic void BM_PLFSort(benchmark::State&amp; state) {\n    plf::list&lt;int&gt; list = {4, 2, 1, 3};\n\n    for (auto _ : state) {\n        list.sort();\n    }\n}\n</code></pre> <p>The results are as follows:</p> <pre><code> Run  |   Vector   |    PLF   |\n----- | ---------- | -------- |  \n  1   | 172307692  | 8960000  |  \n  2   | 298666667  | 8960000  |  \n  3   | 213333333  | 8960000  |  \n  4   | 235789474  | 11150223 |  \n  5   | 235789474  | 10000000 |  \n</code></pre> <p>For a list of 100 elements, I'll create a reversed vector from 100 to 0. The results are drastically improved:</p> <pre><code> Run  |  Vector |   PLF   |\n----- | ------- | ------- |  \n  1   | 640000  | 896000  |  \n  2   | 896000  | 896000  |  \n  3   | 1120000 | 746667  |  \n  4   | 1493333 | 1120000 |  \n  5   | 1384166 | 1120000 |  \n</code></pre> <p>When it comes to sorting elements, plf::list reigns supreme, achieving a remarkable 95% efficiency boost over std::vector. Its custom-designed sorting algorithm operates with astounding efficiency, outpacing the standard library's sorting method by a significant margin.</p> <p> </p>"},{"location":"blogpost/Radcliffe/final/#reversal","title":"Reversal","text":"<p>Reversing a list is the final topic I am going to cover, using our trusty code we have seen:</p> <pre><code>static void BM_VectorRev(benchmark::State&amp; state) {\n    std::vector&lt;int&gt; list = {1, 2, 3, 4};\n\n    for (auto _ : state) {\n        std::reverse(list.begin(), list.end());\n    }\n}\n\nstatic void BM_PLFRev(benchmark::State&amp; state) {\n    plf::list&lt;int&gt; list = {1, 2, 3, 4};\n\n    for (auto _ : state) {\n        list.reverse();\n    }\n}\n</code></pre> <p>The results are as follows:</p> <pre><code> Run  |   Vector    |    PLF    |\n----- | ----------- | --------- |  \n  1   | 1002004080  | 224000000 |  \n  2   | 1100306030  | 248888889 |  \n  3   | 1020500611  | 235789474 |  \n  4   | 1803040021  | 224000000 |  \n  5   | 1040200390  | 298666667 |  \n</code></pre> <p>Benchmarking with list of 100 elements proves even better efficiency:</p> <pre><code> Run  |   Vector    |    PLF   |\n----- | ----------- | -------- |  \n  1   | 125440000   | 11200000 |  \n  2   | 64000000    | 10000000 |  \n  3   | 112000000   | 11200000 |  \n  4   | 89600000    | 8960000  |  \n  5   | 74666667    | 8960000  |  \n</code></pre> <p>When it comes to reversing elements, plf::list yet again did not disappoint, achieving an impressive 72% efficiency increase over std::vector. Its custom-designed reversal algorithm operates with remarkable efficiency, outpacing the standard library's reversal method by a significant margin.</p>"},{"location":"blogpost/Radcliffe/final/#conclusion","title":"Conclusion","text":"<p>After conducting all my tests between plf::list and std::vector, I can confidently conclude that the efficiency claims made by the PLF library do indeed have a solid backing and some of the tests even came close or outperformed what was advertised. However, it is crucial to keep note of differences in compilers, optimization levels, and CPU architectures when reading statistics such as these.</p> <p>I hope you now have an idea what type of collections you may consider using in your future projects for peak efficiency!</p>"},{"location":"blogpost/Rylko/final/","title":"OpenCV C++ Tutorial","text":"<p>OpenCV is a powerful computer vision (CV) library for various languages including Python, Java, and C++. In this blog post I will detail how to use some simple functions to read images, capture live video, and process images and videos in C++ with the help of OpenCV. I will assume that you have already downloaded and installed OpenCV as well as a C++ compiler and some sort of editor. I am using MinGW on Windows with VSCode, and I will be using a Makefile to help compile my code.</p>"},{"location":"blogpost/Rylko/final/#the-mat-class","title":"The Mat Class","text":"<p>The Mat (matrix) class is the most fundamental part of the OpenCV library. It represents an n-dimensional array (commonly two or three dimensions) and is often used to store data relating to images. For color images, OpenCV uses the BGR color format (blue, green, and red) to represent the intensity of each color in a pixel. The scale on which intensity is measured is called depth, which can be represented by various data types (8-bit and 16-bit signed and unsigned integers, 32-bit signed integers, and 32-bit and 64-bit floating-point numbers). Mixing the values can produce various colors, as seen below with a depth of 8 bits (0 to 255, unsigned).</p> <p></p> <p>Grayscale images use one value rather than three to denote intensity. Grayscale images are easy to work with for image processing operations because there is only one value per pixel. One important operation is called convolution, which takes a larger matrix (the image) and a smaller matrix (the kernel, made of up of weights). For each element in the larger matrix, the element and its surrounding elements are multiplied element-wise with the kernel and summed. The result is the element of the new matrix created by this operation. A simple example is below:</p> <p></p> <p>From https://docs.gimp.org/2.8/en/plug-in-convmatrix.html</p> <p>Different kernels create different effects on the image. To blur an image, simply use a kernel that averages the nearby pixels. For a 3x3 kernel, this would be a matrix consisting only of 1/9.</p>"},{"location":"blogpost/Rylko/final/#sobel-filters","title":"Sobel Filters","text":"<p>Sobel filters use a kernel to highlight changes in intensity, which is useful for edge detection. Typically, two kernels using discrete differentiation are used to determine an approximation of the derivative in the x and y directions, seen below.</p> <p></p> <p>From https://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm</p> <p>The result of the convolution at each point is the component of the gradient in the positive direction (right for x and down for y). The gradient has a magnitude and direction, calculated below. These gradients are used to detect the direction and intensity of edges in an image, which is helpful for object detection and other computer vision applications.</p> <p></p> <p>From https://theailearner.com/2019/05/24/first-order-derivative-kernels-for-edge-detection/</p>"},{"location":"blogpost/Rylko/final/#code-featuring-the-core-module","title":"Code (Featuring the Core Module)","text":"<p>Let\u2019s begin coding. You will need a C++ source file, some way to compile and execute it, and an image. It doesn\u2019t really matter what you use, as long as it\u2019s in color. I downloaded a picture of a rather handsome mascot for my project. The reason I am using a Makefile is because to compile programs with OpenCV, it will be necessary to include several modules like imgproc, imgcodecs, highgui, and core. I find it easy to set some variables and occasionally change them to fit my needs. Below is my Makefile as an example; naturally, you should change the inc and lib variables to the paths associated with those folders on your machine.</p> <p></p> <p>Whether you choose to compile with Makefiles, CMake, straight from the command line, or some other way, make sure the all the modules are included for this part. The names of the modules may differ depending on your version of OpenCV.</p> <p>We will start simple to make sure OpenCV works. This code will simply create a Mat, read the image into it, and display it in a window.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n\nint main() {\n    cv::Mat image;\n    image = cv::imread(\"sparty.jpg\");\n\n    if (image.empty()) {\n        std::cerr &lt;&lt; \"Image not read\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    cv::imshow(\"Original Image\", image);\n    cv::waitKey(0);\n    return 0;\n}\n</code></pre> <ul> <li>imread converts the image data into the Mat data format for use in OpenCV</li> <li>Then, we check if the image is empty before trying to display it</li> <li>imshow opens a window containing the Mat so we can see it</li> <li>waitKey keeps the window open until a key is pressed. The argument is the delay in milliseconds, and with a value of zero or less the function will wait indefinitely</li> </ul> <p></p> <p>The image I chose is a bit too large for my laptop display, which isn\u2019t helpful for the analysis we will do later. To remedy this, I will use the resize function before displaying the image.</p> <pre><code>cv::resize(image, image, cv::Size(640, 480));\n</code></pre> <ul> <li>The first argument is the source Mat, the Mat being read from</li> <li>The second argument is the destination, which can be a new Mat. I am using the same Mat for this example since I will have no need for the original Mat</li> <li>The third argument is a Size object, for which I am using magic numbers</li> </ul> <p></p> <p>This looks nicer. Let\u2019s start modifying the image. To create a new image in grayscale and display both images at once, I\u2019ll replace some code at the end with:</p> <pre><code>cv::Mat bwImage;\ncv::cvtColor(image, bwImage, cv::COLOR_BGR2GRAY);\n\ncv::imshow(\"Original Image\", image);\ncv::imshow(\"Grayscale Image\", bwImage);\ncv::waitKey(0);\nreturn 0;\n</code></pre> <p>Here, cv::COLOR_BGR2GRAY is an enumerator from cv::ColorConversionCodes. There are many conversions that OpenCV can perform, but this is the one we need now.</p> <p></p> <p>A good start. Now we will perform convolution with a Sobel filter on the grayscale image. Change the end of the main function to this:</p> <pre><code>cv::Mat xImage, yImage;\ncv::Sobel(bwImage, xImage, image.depth(), 1, 0);\ncv::Sobel(bwImage, yImage, image.depth(), 0, 1);\n\ncv::imshow(\"Original Image\", image);\ncv::imshow(\"Sobel X Image\", xImage);\ncv::imshow(\"Sobel Y Image\", yImage);\ncv::waitKey(0);\nreturn 0;\n</code></pre> <ul> <li>The first argument of the Sobel function is the source, and the second is the destination</li> <li>The third argument is the depth. You can use the depth() function of a Mat for this</li> <li>The fourth and fifth arguments are dx and dy. As mentioned before, we want the first derivative of either the x or y direction.</li> </ul> <p></p> <p>Note the difference in the edges shown between the two images. This is because two different kernels are used in the convolution. This allows the components of the gradient magnitude and direction to be calculated. Using some of the math above, I made this function to draw lines on the image to show the gradients on the image. Every ten pixels, this function reads the values from the images with the x and y sobel filters applied then draws a line based on the magnitude and direciton.</p> <pre><code>cv::Mat DrawGradients(const cv::Mat &amp; srcImage, const cv::Mat &amp;xImage, const cv::Mat &amp;yImage) {\n    cv::Mat newMat;\n    cv::cvtColor(srcImage, newMat, cv::COLOR_GRAY2BGR);\n    int interval = 10;\n\n    for (int y = 0; y &lt;= newMat.rows; y += interval) {\n        for (int x = 0; x &lt;= newMat.cols; x += interval) {\n            double Gx = xImage.at&lt;uint8_t&gt;(y, x) / 255.0;\n            double Gy = yImage.at&lt;uint8_t&gt;(y, x) / 255.0;\n            double G = sqrt(Gx * Gx + Gy * Gy);\n            double dir = atan2(Gy, Gx);\n            int xComponent = G * interval * cos(dir);\n            int yComponent = G * interval * sin(dir);\n\n            cv::Point p1 = cv::Point(x, y);\n            cv::Point p2 = cv::Point(x + xComponent, y + yComponent);\n            cv::line(newMat, p1, p2, cv::Scalar(0, 0, 255));\n        }\n    }\n\n    return newMat;\n}\n</code></pre> <ul> <li>I am using .at to get the value of the pixel at that point of the image. It must be specified as a uint8_t, the type of the values in the Mat. This will be different for different image formats, but this works for this tutorial</li> <li>I also divide the values by 255.0 to both normalize the values on a scale of 0 to 1 and convert it to a double for more precise math</li> <li>The sqrt function gets the square root, which we need for the gradient magnitude</li> <li>the atan2 function is a two-argument arctangent function so that the full range of angles can be considered</li> <li>Using the point constructor allows me to denote a point on the image in a way OpenCV understands</li> <li>the line function draws a line on the source image (newMat) from the first to the second point in a color, which I denote with cv::Scalar(0, 0, 255) which represents red in BGR. I used cv::cvtColor earlier so I could do this, as otherwise the lines would also be in grayscale</li> </ul> <p>Use the function like this; be sure to show the image in a new window too.</p> <pre><code>cv::Mat gradientImage = DrawGradients(bwImage, xImage, yImage);\n</code></pre> <p></p> <p>Note that the direction of the gradient is in the direction of change, so the lines don't necessarily outline the edges in the image. However, this information can be used for edge detection.</p> <p>To finish this part, I will write the images to new files. To do so, add this to the end of the main function:</p> <pre><code>cv::imwrite(\"sparty_x.png\", xImage);\ncv::imwrite(\"sparty_y.png\", yImage);\ncv::imwrite(\"sparty_gradient.png\", gradientImage);\n</code></pre> <p>This concludes the beginning part of the tutorial. This is what all my code looks like:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n\ncv::Mat DrawGradients(const cv::Mat &amp; srcImage, const cv::Mat &amp;xImage, const cv::Mat &amp;yImage) {\n    cv::Mat newMat;\n    cv::cvtColor(srcImage, newMat, cv::COLOR_GRAY2BGR);\n    int interval = 10;\n\n    for (int y = 0; y &lt;= newMat.rows; y += interval) {\n        for (int x = 0; x &lt;= newMat.cols; x += interval) {\n            double Gx = xImage.at&lt;uint8_t&gt;(y, x) / 255.0;\n            double Gy = yImage.at&lt;uint8_t&gt;(y, x) / 255.0;\n            double G = sqrt(Gx * Gx + Gy * Gy);\n            double dir = atan2(Gy, Gx);\n            int xComponent = G * interval * cos(dir);\n            int yComponent = G * interval * sin(dir);\n\n            cv::Point p1 = cv::Point(x, y);\n            cv::Point p2 = cv::Point(x + xComponent, y + yComponent);\n            cv::line(newMat, p1, p2, cv::Scalar(0, 0, 255));\n        }\n    }\n\n    return newMat;\n}\n\nint main() {\n    cv::Mat image;\n    image = cv::imread(\"sparty.jpg\");\n\n    if (image.empty()) {\n        std::cerr &lt;&lt; \"Image not read\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    cv::resize(image, image, cv::Size(640, 480));\n\n    cv::Mat bwImage;\n    cv::cvtColor(image, bwImage, cv::COLOR_BGR2GRAY);\n\n    cv::Mat xImage, yImage;\n    cv::Sobel(bwImage, xImage, image.depth(), 1, 0);\n    cv::Sobel(bwImage, yImage, image.depth(), 0, 1);\n    cv::Mat gradientImage = DrawGradients(bwImage, xImage, yImage);\n\n    cv::imshow(\"Original Image\", image);\n    cv::imshow(\"Sobel X Image\", xImage);\n    cv::imshow(\"Sobel Y Image\", yImage);\n    cv::imshow(\"Gradient Image\", gradientImage);\n    cv::waitKey(0);\n\n    cv::imwrite(\"sparty_x.png\", xImage);\n    cv::imwrite(\"sparty_y.png\", yImage);\n    cv::imwrite(\"sparty_gradient.png\", gradientImage);\n    return 0;\n}\n</code></pre> <p>By now, you should understand Mat objects, how to read and write images, and how to perform some basic operations on Mats.</p>"},{"location":"blogpost/Rylko/final/#live-video","title":"Live video","text":"<p>For this part, you will need to use the video and videoio modules in addition to the ones used in the previous part. This will allow you to process and capture video. Start with this code:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n\nint main() {\n    cv::VideoCapture cam(0);\n\n    if (!cam.isOpened()) {\n        std::cerr &lt;&lt; \"Could not open the camera.\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    cv::Mat frame;\n    bool running = true;\n    while (running) {\n        cam &gt;&gt; frame;\n\n        if (frame.empty()) {\n            std::cerr &lt;&lt; \"Could not capture a frame.\" &lt;&lt; std::endl;\n            break;\n        }\n\n        cv::imshow(\"Camera Feed\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            running = false;\n        }\n    }\n\n    cam.release();\n\n    return 0;\n}\n</code></pre> <ul> <li>The VideoCapture constructor takes a device ID, the default laptop camera should be 0</li> <li>Use cam &gt;&gt; frame to place the current frame from the camera into the frame Mat</li> <li>Repeatedly use imshow to update the window</li> <li>The waitkey function returns an integer corresponding to the key pressed on the keyboard (or -1 if no key is pressed during the time interval). Adding a delay of one millisecond allows the program to read input from the keyboard</li> <li>Release the camera at the end of the program, to be clean</li> </ul> <p></p> <p>Hey, that\u2019s me. I promise the window shows video. Normal video gets boring after a while, so let\u2019s apply some filters. After capturing the frame but before placing it in the window, change the Mat to grayscale add the familiar Sobel filter with this code:</p> <pre><code>cv::cvtColor(frame, frame, cv::COLOR_BGR2GRAY);\ncv::Sobel(frame, frame, frame.depth(), 1, 0);\ncv::imshow(\"Camera Feed\", frame);\n</code></pre> <p></p> <p>Now, for fun, I'll put on the gradients like I did in the previous section. Add the DrawGradients function to the file, then replace the above code with:</p> <pre><code>cv::cvtColor(frame, frame, cv::COLOR_BGR2GRAY);\ncv::Sobel(frame, xImage, frame.depth(), 1, 0);\ncv::Sobel(frame, yImage, frame.depth(), 0, 1);\nframe = DrawGradients(frame, xImage, yImage);\ncv::imshow(\"Camera Feed\", frame);\n</code></pre> <p></p> <p>Admittedly, he gradients are a bit difficult to detect on my camera because the image isn't very sharp.</p> <p>By now, you should understand how to use the VideoCapture class to use a camera for live video and how to perform operations on frames from the capture. This is all my code from this part:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n\ncv::Mat DrawGradients(const cv::Mat &amp; srcImage, const cv::Mat &amp;xImage, const cv::Mat &amp;yImage) {\n    cv::Mat newMat;\n    cv::cvtColor(srcImage, newMat, cv::COLOR_GRAY2BGR);\n    int interval = 10;\n\n    for (int y = 0; y &lt;= newMat.rows; y += interval) {\n        for (int x = 0; x &lt;= newMat.cols; x += interval) {\n            double Gx = xImage.at&lt;uint8_t&gt;(y, x) / 255.0;\n            double Gy = yImage.at&lt;uint8_t&gt;(y, x) / 255.0;\n            double G = sqrt(Gx * Gx + Gy * Gy);\n            double dir = atan2(Gy, Gx);\n            int xComponent = G * interval * cos(dir);\n            int yComponent = G * interval * sin(dir);\n\n            cv::Point p1 = cv::Point(x, y);\n            cv::Point p2 = cv::Point(x + xComponent, y + yComponent);\n            cv::line(newMat, p1, p2, cv::Scalar(0, 0, 255));\n        }\n    }\n\n    return newMat;\n}\n\nint main() {\n    cv::VideoCapture cam(0);\n\n    if (!cam.isOpened()) {\n        std::cerr &lt;&lt; \"Could not open the camera.\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    cv::Mat frame, xImage, yImage;\n    bool running = true;\n    while (running) {\n        cam &gt;&gt; frame;\n\n        if (frame.empty()) {\n            std::cerr &lt;&lt; \"Could not capture a frame.\" &lt;&lt; std::endl;\n            break;\n        }\n\n        cv::cvtColor(frame, frame, cv::COLOR_BGR2GRAY);\n        cv::Sobel(frame, xImage, frame.depth(), 1, 0);\n        cv::Sobel(frame, yImage, frame.depth(), 0, 1);\n        frame = DrawGradients(frame, xImage, yImage);\n        cv::imshow(\"Camera Feed\", frame);\n\n        if (cv::waitKey(1) == 'q') {\n            running = false;\n        }\n    }\n\n    cam.release();\n\n    return 0;\n}\n</code></pre>"},{"location":"blogpost/Rylko/final/#conclusion","title":"Conclusion","text":"<p>OpenCV is a huge library with many functionalities. In the functions I used throughout this tutorial, there are several optional parameters which I chose not to detail for the sake of simplicity. Even then, this is only a small corner of the library; OpenCV includes modules for 3D reconstruction, feature detection, deep neural networks, object detection, iOS support, CUDA support, and much more. My hope with this tutorial is that I provided a good foundation of knowledge about computer vision and the tools to explore more of the library and its features.</p>"},{"location":"blogpost/Schulte/final/","title":"Procedural Dungeon Plugin For Unreal Engine","text":"<p>Paul Schulte</p> <p>Over the past few years, the Roguelike (or Roguelite) genre of games have seen a rise in popularity. For those who aren\u2019t familiar with the genre, these games focus on the player going through a randomly generated map, defeating increasingly strong enemies all while the player gets progressively stronger as well through stronger items. A large emphasis is placed on the randomly generated map due to the fact that the player is expected to run through it dozens, if not hundreds of times, and that can easily get repetitive if each run isn\u2019t much different than the last. That\u2019s why I was interested in checking out and experimenting with this plugin.</p>"},{"location":"blogpost/Schulte/final/#library-overview","title":"Library Overview","text":"<p>This plugin is developed by GitHub user BenPyton for, as of writing this, Unreal Engine versions 4.2, 5.0, 5.1, and 5.2. It provides a variety of resources to help with generating 3D dungeons using custom rooms and generation logic. It also has very good documentation that explains how to use the provided features along with many example use cases and how they could be implemented.</p>"},{"location":"blogpost/Schulte/final/#disclaimer","title":"Disclaimer","text":"<p>Before I start explaining how to use the plugin, I should specify that I\u2019m using version 3.0.0 of the plugin with Unreal version 5.2.1, Visual Studio 2022, and Windows 10. You may get different results by using different versions, and this information could become obsolete with future updates.</p>"},{"location":"blogpost/Schulte/final/#setting-up-the-unreal-project","title":"Setting Up The Unreal Project","text":"<p>Before you get started with the plugin, you\u2019ll need to install some basic things to get the project set up. If you already have Unreal installed and are adding this to an existing project, feel free to skip to Installing The Plugin.</p>"},{"location":"blogpost/Schulte/final/#installing-unreal-engine","title":"Installing Unreal Engine","text":"<p>The first and most important thing you need to install is Unreal Engine. To do this, you have to install the Epic Games Launcher. Once that is installed, go to the Unreal Engine section on the left.</p> <p></p> <p>From there, add a new engine version. Select 5.2.1 by selecting the drop down next to the default version. (Note: I already have it installed, so it does not appear on my list of options).</p> <p></p>"},{"location":"blogpost/Schulte/final/#installing-visual-studio","title":"Installing Visual Studio","text":"<p>Once Unreal is installed, download Visual Studio 2022. This is used by Unreal to generate C++ files and is the default recommended editor. While it is being installed, you will be prompted to select some components to install. Make sure you select \u201c.NET desktop environment\u201d, \u201cDesktop development with C++\u201d, and \u201cGame development with C++\u201d.</p> <p></p>"},{"location":"blogpost/Schulte/final/#installing-the-demo-project","title":"Installing The Demo Project","text":"<p>I\u2019m using the provided demo project. This is not a requirement, however I found it to be useful for testing the library as a whole. Just go to the Demo Project repository and download the project. From there, extract the zip file and open the DungeonExample.uproject file. It should then open up the project in Unreal. You will see many errors pop up saying that there are missing classes/files. This will get fixed once the plugin is installed. You can now close the project.</p>"},{"location":"blogpost/Schulte/final/#installing-the-plugin","title":"Installing The Plugin","text":"<p>Now for the plugin itself. Download it from its GitHub repository and extract it. Then move the folder into the \u201cPlugins\u201d folder in the project\u2019s root directory. If you are using the demo project or don\u2019t already have any plugins installed, create the folder yourself. Once that is done, open the .uproject file again to launch the project. You will most likely be prompted to resolve something with the plugin. Accept it, and then the project will open.</p>"},{"location":"blogpost/Schulte/final/#using-the-plugin","title":"Using The Plugin","text":""},{"location":"blogpost/Schulte/final/#exploring-the-demo-project","title":"Exploring The Demo Project","text":"<p>Once everything is set up, you can finally use the plugin. In the demo project, once you hit run and then the Enter key, a random dungeon will be generated.</p> <p></p> <p>This is done using the \u201cBP_MyDungeonGenerator\u201d actor in the level. This extends the plugin\u2019s \u201cDungeonGenerator\u201d class and is where all of the logic goes. If you click to edit it in the level hierarchy, you will be taken to the class blueprint. For those unfamiliar with Unreal\u2019s blueprint system, it consists of drag and drop modules that let you easily see and configure logic flows in the game. The functions themselves are written in C++, but their use is abstracted to the blueprint.</p>"},{"location":"blogpost/Schulte/final/#default-configuration","title":"Default Configuration","text":"<p>Back to the blueprint page. There will be several tabs across the top for the class functions, but we\u2019ll get to that in a bit. First, let\u2019s see the details of class on the right. Most of it is generic Unreal stuff, so I\u2019m just going to focus on the \u201cDefault\u201d and \u201cProcedural Generation\u201d sections.</p> <p></p> <p>Starting at the top, we have several default rooms for \u201cStart\u201d, \u201cEnd\u201d, and \u201cKey\u201d. These are Room Data objects. We\u2019ll get to how to create those later, but for now, just know that they store information about each room segment including the physical room itself. These default rooms are pretty self-explanatory. The player spawns in the Start Room, a key spawns in the Key Room, and the end of the level is the End Room.</p> <p>Next there are \u201cRandom Rooms\u201d. These are all of the rooms in between such as random corridors, staircases, etc.</p> <p>Then there are \u201cRoom Before Key\u201d and \u201cAdditional Rooms\u201d. These are also self-explanatory. They determine the minimum number of rooms should be placed before a key room is placed and then the minimum number of additional rooms should be placed before the end room is placed.</p> <p>On to the Procedural Generation section. The \u201cUse Generator Transform\u201d checkbox determines where the first room is spawned. If unchecked, it defaults to (0, 0, 0) without any rotation. If it is enabled, the first room will be transformed to match the position and rotation of the DungeonGenerator actor.</p> <p>\u201cGeneration Type\u201d determines what algorithm is used to generate the dungeon. \u201cDepth First\u201d results in a more direct and linear dungeon, while \u201cBreadth First\u201d results in one with longer dead ends.</p> <p>Lastly, there is the \u201cSeed Type\u201d. This determines the seed used for the random generation. \u201cRandom\u201d will use a random seed each time, while \u201cAuto Increment\u201d and \u201cFixed\u201d both let you provide a set seed for repeatable results. The difference with \u201cAuto Increment\u201d is that if the DungeonGenerator is called again, the seed will be incremented by the given amount. This is useful if there are multiple levels or worlds in a single playthrough. Using the one seed, every world will still be different, however they will be generated in the same order every time.</p>"},{"location":"blogpost/Schulte/final/#overriding-functions","title":"Overriding Functions","text":"<p>Now for the functions at the top I mentioned before. Those are the class functions. There are a few that need to be overridden as well as a few optional ones that can give you more control over the generation process. For this blog, I\u2019ll just go over the required ones and include example implementations using Unreal Blueprints followed by the rough C++ equivalent implemented in a class extending <code>ProceduralDungeon</code>.</p> <p>First is \u201cChoose First Room\u201d. This is pretty straightforward. All it does is determine which room to use as the start room. In the demo project, this is just the \u201cStart Room\u201d defined earlier, however additional logic can be added here to have a variety of start rooms to choose from.</p> <p></p> <pre><code>URoomData* ChooseFirstRoom() {\n    return StartRoom; /// Pointer to a URoomData object\n}\n</code></pre> <p>Then there is \u201cChoose Next Room\u201d. This is the core of how rooms are placed. You can add whatever you want in here to determine room placement. All that has to be returned is a Room Date object.</p> <p></p> <pre><code>URoomData* ChooseNextRoom(const URoomData* CurrentRoom, const FDoorDef&amp; DoorData) {\n    // Graph is a pointer to a DungeonGraph object\n    // KeyRoom is a pointer to a URoomData object\n    // HasAlreadyRoomData returns true if the given room has already been placed\n    bool hasKeyRoom = Graph-&gt;HasAlreadyRoomData(KeyRoom);\n    // Count returns the current number of placed rooms\n    int32 numRooms = Graph-&gt;Count();\n\n    // RoomBeforeKey is the setting from Default Configuration\n    // Returns the Key Room if one hasn't been placed and there are enough rooms placed already\n    if (!hasKeyRoom &amp;&amp; numRooms &gt; RoomBeforeKey) {\n        return KeyRoom;\n    }\n\n    // AdditionalROoms is the setting from Default Configuration\n    // Returns the End Room if a Key Room hasn't been placed and enough total rooms have been placed\n    if (hasKeyRoom &amp;&amp; numRooms &gt; RoomBeforeKey + AdditionalRooms) {\n        return EndRoom;\n    } else {\n        // RandomRooms is the setting from Default Configuration\n        // GetRoomDataWithExclusion returns a random room excluding the provided one\n        URoomData* newRoom = GetRoomDataWithExclusion(RandomRooms, [CurrentRoom]);\n        return newRoom;\n    }\n}\n</code></pre> <p>Next is \u201cContinue To Add Room\u201d. This determines if more rooms should be added. In the example, it just checks to see if the End Room has been placed yet.</p> <p></p> <pre><code>bool ContinueToAddRoom() {\n    // Only continue placing rooms if the End Room hasn't been placed\n    return !Graph-&gt;HasAlreadyRoomData(EndRoom);\n}\n</code></pre> <p>Then there is \u201cChoose Door\u201d. I\u2019ll go over this in more detail once I get to Room Data objects, but every room has specific location(s) that doors can spawn, which lead to other rooms. The logic here determines what should be placed in a door space. In the example, it only chooses between a door and wall entity, however this can be expanded to include different kinds of doors, walls specific per room, etc.</p> <p></p> <pre><code>Door ChooseDoor(const URoomData* CurrentRoom, const URoomData* NextRoom, const UDoorType* DoorType) {\n    if (CurrentRoom-&gt;IsValid() &amp;&amp; NextRoom-&gt;IsValid()) {\n        // Door object representing a normal door\n        return Door;\n    }\n\n    // Door object representing no door, or a wall\n    return Wall;\n}\n</code></pre> <p>Lastly, there is \u201cIs Valid Dungeon\u201d. This determines whether or not the current generation is considered valid. In the example, it just checks that there is both a key and end room placed. If this returns true, the rooms will be placed into the level. If it returns false, the dungeon will be discarded and it will try to generate a new dungeon.</p> <p></p> <pre><code>bool IsValidDungeon() {\n    bool hasKeyRoom = Graph-&gt;HasAlreadyRoomData(KeyRoom);\n    bool hasEndRoom = Graph-&gt;HasAlreadyRoomData(EndRoom);\n\n    // Dungeon is valid if both Key and End Rooms have been placed\n    return hasKeyRoom &amp;&amp; hasEndRoom;\n}\n</code></pre>"},{"location":"blogpost/Schulte/final/#custom-rooms","title":"Custom Rooms","text":"<p>At long last, we\u2019re finally talking about rooms. These are broken down into Room Data and Room Levels.</p> <p>To start, you can go to the Content Browser, then to Content &gt; Data &gt; Rooms. Then right-click go to Procedural Dungeon and select Room Data.</p> <p></p> <p>From there, you can either use the default RoomData class or create your own to hold custom data. The demo creates \u201cBP_MyRoomData\u201d, which extends the base RoomData class.</p> <p></p> <p>Now for the physical rooms, or Room Levels. Go back to the Content directory and down to Maps &gt; Rooms. Right click and create a new Level. Double click on the new Level, and it will switch to it.</p> <p></p> <p>Go back to the level viewer and change the editor mode from Selection to Dungeon Room. This is a custom mode made to easily create and edit rooms.</p> <p></p> <p>When you do this, you will be prompted to reparent this level with its associated Room Data. If that doesn\u2019t work, manually assign the Room Data you created as well as the new Room Level. With that completed, you can now start building the room.</p> <p></p> <p>You can place down whatever assets you like and can treat this just like any other Unreal level. Just click and drag the white corners of the red cube to change the bounding box for the room. After that is done, you can go back to the top left and select \u201cDoor\u201d to place possible door locations. These are the blue rectangles. They even automatically snap to the grid for easier placement. (Note: I recommend changing the View Mode at the top from \u201cLit\u201d to \u201cUnlit\u201d for the demo project. Otherwise if you don\u2019t include any light sources, the entire level is pitch black)</p> <p></p>"},{"location":"blogpost/Schulte/final/#conclusion","title":"Conclusion","text":"<p>As you can see, this is a very robust and customizable plugin. It takes care of most of the hard parts and allows you to focus on the logic, design, and implementation of the game itself. It is also (as of the time of writing this) still being actively developed, so if you find any bugs or have new feature ideas, there\u2019s a good chance you\u2019ll get a response.</p> <p>If you\u2019re at all interested in game development and Roguelikes, or even if you\u2019re just looking for a fun programming project, I\u2019d highly recommend checking out this plugin. I know I\u2019ll be using it more in the future.</p>"},{"location":"blogpost/Seguin/final/","title":"Experimenting with ChatGPT - Creating a simulation for DPS tests","text":"<p>As a long time MMO player (sufferer?), one of the greatest challenges I face on a regular basis is not some difficult boss or mechanic; \\ it\u2019s the dreaded Update Day. Because a new update means changes to gear, abilities, and more. And that means it\u2019s  time to go through the \\ process of testing all that stuff to see what performs best. I\u2019ve often thought to myself, a far-off look in my eye, \u201cWouldn\u2019t it be nice \\ if I could speed this up?\u201d Well, I finally decided to start on that project - and who better to help me out than my good old friend ChatGPT?</p> <p>I decided that I would try to get ChatGPT to write the code from descriptions of what I wanted, without me directly telling it what code \\ to write (spoiler: this would not last). So I loaded it up, and gave it this prompt:</p> <p></p> <p>And this is what I got:</p> <p></p> <p>Pretty good! It creates a target dummy, hits it til it\u2019s dead, and then reports the time it took to kill. There\u2019s one slight problem though - \\ it doesn\u2019t compile. The line that initializes the random number generator has three left parentheses, and two right parentheses. ChatGPT was \\ more than happy to correct its mistake, and then I asked it to calculate the time taken based on some arbitrary tick, instead of wall-clock \\ time. And this is the relevant code:</p> <p></p> <p>Alright, but the whole point is that I want to speed up the testing process, not wait around while it runs! So I asked it to fix that, and \\ it did so by introducing a tickDuration variable that could be used to calculate the time taken. Good. At this point I had a barebones \\ framework that worked fine. Surely extending more functionality would be easy as pie, right?</p> <p>Next I figured I\u2019d have to change it from taking (damagePerHit) damage every tick, to having an ability that would fire off damage, but only \\ once per second. Relevant ChatGPT code (Mismatched brackets from here on out are my own doing when copying code):</p> <p></p> <p>Aaaand we\u2019re back to using wall-clock time. This, I would find out, would be a recurring theme throughout this project. Upon requesting \\ wall-clock time not be used, ChatGPT made it calculate time based on the number of ticks\u2026but it also left in a line that had the loop sleep on\\  each iteration. I also noticed that it had, at some point, reintroduced the mismatched parentheses error on the random number generator line \\  (another recurring theme). So it fixed both issues, and I requested that it make the number of ticks in a second a variable instead of a \\  hard-coded value, so that it could be easily changed. It did so, and back came the sleeping on each iteration of the loop. Fixed that, and I \\  figured it was time for something a little more in-depth. I asked ChatGPT to implement an ability that would, upon being used, deal (x) damage \\  every (y) seconds, for a total duration of (z) seconds. Important code:</p> <p></p> <p>This wasn\u2019t too bad, but it did have a number of issues, such as the while loop now ending prematurely when the first ability ran out, instead \\ of only when the dummy died. It also brought back sleeping on each loop iteration, to which I responded in no uncertain terms:</p> <p></p> <p>This actually worked, and I did not see another sleep_for call for the rest of the project. This was about the point when I really had to start \\ going back-and-forth with ChatGPT to fix the issues in the code. I was still trying not to tell it what code to write, and after a handful of \\ exchanges, I made my first suggestion to to the AI:</p> <p></p> <p>It promptly took my suggestion, and used it to create code that still didn\u2019t work. After several more back-and-forths (including fixing some very \\ simple syntax errors), with me being extremely specific about what I wanted, I finally got code that almost functioned correctly. The ability \\ class now looked like this:</p> <p></p> <p>And the relevant part of the loop body like this:</p> <p></p> <p>The next issue I had to solve was that comparing doubles in the canDealDamage and updateActivity functions was prone to floating point errors. So \\ I asked ChatGPT to fix this issue by doing the comparison using an epsilon. An epsilon, for those who have never had the absolute pleasure of \\ dealing with floating point errors, is a small number that basically amounts to a tolerance for inequality. It\u2019s a number that says, if you\u2019re \\ not exactly equal, but within \u201cthis\u201d close of being equal, then that\u2019s acceptable, you count as being equal. So this is what ChatGPT gave me:</p> <p></p> <p>And this is where I made the biggest mistake of the entire project:</p> <p></p> <p>After having to correct ChatGPT so many times so far, I got overconfident and corrected it without testing its code first, thinking it made a \\ mistake in the calculation. It told me:</p> <p></p> <p>And it made the change I requested. This would be the bane of my existence for the rest of the project. I tested the new code, and promptly \\ realized I had made a mistake, and ChatGPT\u2019s code was correct. I asked it to revert the change, and it happily agreed, and spat back out the \\ same code with my error in it. I told it that it was right and I was wrong, and it agreed, and gave me the same incorrect code. Finally I \\ resorted to straight-up telling it the exact code to use:</p> <p></p> <p>Finally, mercifully, it fixed the functions, and the code worked more or less correctly to my specifications to that point. Progress!</p> <p>The next step I figured wouldn\u2019t be too bad - in a real game, you wouldn\u2019t be able to cast two abilities at the same time, so I asked ChatGPT to \\ make it so that only one ability could be cast at a time, and after an ability was cast, the loop would have to wait for one second before casting \\ another ability. The results were\u2026not great. It changed the ability class, giving each ability a member variable which limited that specific \\ ability to being cast no more than once every second - an individual cooldown:</p> <p></p> <p>This isn\u2019t what I wanted, and also didn\u2019t work right anyway. What I was looking for was a shared cooldown between any and all abilities. After some \\ back-and-forths, I had this:</p> <p></p> <p>And I made a simple request:</p> <p></p> <p>Very easy. I told it exactly what to do. (At this point I had long given up on never telling it what code to write.) What it gave me was bizarre. \\ It completely removed the if statement entirely, moving all of the cooldown related code back into the ability class, and basically going back to \\ the code above. I told it that what it gave me wasn\u2019t what I asked for, and it responded by apologizing, and nuking the cooldown code entirely so \\ that there was nothing left of it, as well as removing good sections of code, like the updateActivity function. At this point, I could see the \\ entire project crumbling before my eyes, and so I made the most drastic request of the project:</p> <p></p> <p>And I provided ChatGPT with the full text of the code that it had generated before I asked for a shared cooldown. This worked, and I got back to a \\ functioning version of the code. Seeing that I could resort to this if I needed to, I decided to try again. I asked it to give the abilities a \\ shared cooldown\u2026and it did so almost flawlessly. It gave me just about exactly what I wanted. This is the full text of what I had at this point, \\ for anyone interested (there won\u2019t be a quiz):</p> <p></p> <p></p> <p>The only issue that I could see was that the comparison sharedCooldown &lt;= 0.0 could run into floating point errors. And this is where my fatal \\ mistake came back to haunt me. I asked it to fix the issue using an epsilon, which it did\u2026and it simultaneously changed the comparisons in the \\ canDealDamage and updateActivity functions back to the erroneous ones I had given it earlier. I asked it to fix those\u2026and it broke the \\ sharedCooldown comparison. I had to go back-and-forth with ChatGPT about a half-dozen times just to get these comparisons correct. And I would \\ continue to battle with it over these comparisons for the rest of the project.</p> <p>At this point, I was mostly happy with the functionality, but if I wanted this project to be even remotely useful, it would need to be able to \\ handle more than two abilities at once. So I asked it to give me a vector of abilities instead of hard-coding in the functionality for two. I \\ received this chunk of code in my main function (irrelevant parts omitted once again):</p> <p></p> <p>I was quite happy with what ChatGPT gave me here; it worked flawlessly\u2026other than breaking the epsilon comparisons again. I had it fix those again, \\ and then I requested that each ability be given a priority, and for it to iterate over the abilities based on highest priority. Pertinent code:</p> <p></p> <p>It gave me a nice custom sort and sorted the abilities for me - great! All I had to do was have it fix the epsilon comparisons again, fix an error, \\ fix the epsilon comparisons again, and fix some edge-case bugs, and I had a properly functioning program. Lovely. At this point I decided to test \\ ChatGPT\u2019s knowledge of the program we had created. I asked it:</p> <p></p> <p>Now I already knew that the answer was yes. The original specification for the damage over time ability was (x) damage, every (y) seconds, for a \\ total of (z) seconds. The code we had created worked such that when an ability was cast it immediately dealt damage, so it would be a simple matter \\ of having an ability where y and z were set to 0. But what would ChatGPT\u2019s answer be? Well:</p> <p></p> <p>\u2026not exactly ideal. I pointed out:</p> <p></p> <p>And it agreed that my way was better. I had it print out the entire body of code and everything looked good. I debated ending here, but decided \\ there was one more bit of functionality I had to include. Remember the issue of individual vs. shared cooldowns? What I wanted back then was a \\ shared cooldown, but it would be good to have both of them implemented. So I asked the AI, and it gave me what I can only describe as garbage. It \\ broke the working code, and when I told it what was wrong, it broke the code even further. I ended up going back to the last resort method of \\ telling it the entire body of code that it had given me before. After a second attempt I got it working right and I was ready to wrap the whole \\ thing up. There were just a handful of smaller issues with code structure and quality that I wanted to fix. During these smaller fixes, ChatGPT \\ often responded to me with small snippets of code instead of the entirety of the code, like so:</p> <p></p> <p>\u201cNo problem,\u201d I thought. \u201cThis works well, and it doesn\u2019t print out a hundred lines of code for one small change.\u201d If only I had known what was \\ coming next\u2026because after making all the small changes I wanted, I had it print out the whole thing all together to make sure everything was right\u2026\\ and it had forgotten a bunch of the code. It took a good twenty or so requests to get it back to something close to what it should have been. But \\ finally, I had something that resembled a proper simulation. You can change the list of abilities, and it will simulate hitting a target dummy with \\ them based on the priorities you set. Other things can be changed as well, such as the tick rate and the shared cooldown. In an accurate simulation, \\ of course, there\u2019s a lot more that goes into the damage of an ability than just a flat number. Buffs, debuffs, critical hits - I have a lot more to \\ improve on before I can use it to do my testing for me - but that\u2019s a project for another day.</p> <p>What did I learn, though, about using ChatGPT for projects like this? In no particular order: - ChatGPT does great with smaller projects and individual snippets, but struggles to keep larger projects cohesive - It does not tell you you\u2019re wrong - if you tell it to do something a certain way, it will absolutely do it - Being very specific with what you want is more likely to get you what you want - Asking it to print out the entire body of code instead of snippets seems to help it remember the whole thing - Asking it to stop generating code using sleep_for worked, asking it to always use a certain epsilon comparison did not work - Even if you can get it to generate code that works, it can\u2019t always give you good answers about how or why it works - The style and readability are generally quite good; it loves to put helpful comments in the code - On the other hand, it seems to like hard-coded values, so if you want those values to be easily changed, watch out for that</p> <p>ChatGPT conversation log:</p> <p>https://chat.openai.com/share/61b56d0c-6599-4926-8e01-4a4d26a7eb27</p> <p>Full body of code:</p> <p></p> <p></p>"},{"location":"blogpost/Situ/draft/","title":"Review of PyTorch C++ API","text":""},{"location":"blogpost/Situ/draft/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Knowledge of using PyTorch in Python</li> <li>Basic C++ knowledge</li> </ul>"},{"location":"blogpost/Situ/draft/#introduction","title":"Introduction","text":"<p>PyTorch is a library for Python for machine learning. It is written in C++ and Python is used to interface with the library. This makes it have the performance of C++ while being easy to use. So why use the C++ API? PyTorch gives the following reasons: * The ability to make use of C++ multi-threading, since Python has a global interpreter lock which prevents true multi-threading. * It can be used to integrate with existing C++ code. * Python's low performance is too much of a cost for your application.</p> <p>Of course, You may just prefer writing C++ rather than Python.</p> <p>The C++ API is designed to be extremely similar to how PyTorch is used in Python, so that it is straightforward to use. One of the tips that they give is to write the code like you would in Python, while abiding to C++ syntax [2].</p>"},{"location":"blogpost/Situ/draft/#installation","title":"Installation","text":"<p>The setup for the library is pretty straightforward if you only want to use the CPU for PyTorch. These instructions worked without modification. The installation for GPU support is a lot more involved, and I was not able to install PyTorch with GPU support. GPU support requires additional dependencies such as CUDA and a different version of the library, and I had many errors trying to get CMake to find the CUDA related binaries. I use Windows, and there's a lot more information in various forums about installing PyTorch with CUDA on Linux distributions, so Linux users will have an easier time.</p>"},{"location":"blogpost/Situ/draft/#documentation","title":"Documentation","text":"<p>The documentation can be found here. There is a significant portion of functions that are missing documentation.</p>"},{"location":"blogpost/Situ/draft/#minimal-example","title":"Minimal Example","text":"<p>The installation guide gives the following example:</p> <pre><code>#include &lt;torch/torch.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n  torch::Tensor tensor = torch::rand({2, 3});\n  std::cout &lt;&lt; tensor &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code> 0.3828  0.0383  0.8342\n 0.3193  0.1213  0.6756\n[ CPUFloatType{2,3} ]\n</code></pre> <p>This is the equivalent Python code:</p> <pre><code>import torch\n\ntensor = torch.rand(2, 3)\nprint(tensor)\n</code></pre> <p>Output:</p> <pre><code>tensor([[0.5879, 0.5029, 0.1522],\n        [0.0165, 0.1526, 0.8701]])\n</code></pre> <p>Aside from the random numbers, the results are pretty similar. If we use a large tensor size, such as [2,3,4], we see the following output:</p> <p>C++ Output:</p> <pre><code>(1,.,.) = \n  0.6969  0.9800  0.9234  0.7233\n  0.3798  0.5593  0.0248  0.4228\n  0.7216  0.3585  0.0960  0.8017\n\n(2,.,.) =\n  0.9224  0.8513  0.3186  0.1017\n  0.5374  0.5361  0.1317  0.0175\n  0.2660  0.0787  0.0405  0.9669\n[ CPUFloatType{2,3,4} ]\n</code></pre> <p>Python Output:</p> <pre><code>tensor([[[0.9271, 0.0307, 0.6839, 0.0347],\n         [0.2656, 0.7255, 0.8338, 0.8732],\n         [0.1196, 0.7630, 0.2806, 0.6407]],\n\n        [[0.9917, 0.8121, 0.7952, 0.1987],\n         [0.9438, 0.6141, 0.3507, 0.5229],\n         [0.8222, 0.0517, 0.3564, 0.0864]]])\n</code></pre> <p>The C++ output includes the index for each 2D slice of the tensor, which can be useful for debugging. You can easily lose track of which slice you're looking at in Python, especially if you printed out a large tensor.</p>"},{"location":"blogpost/Situ/draft/#creating-a-module","title":"Creating a Module","text":"<p>A Module is the base class for neural networks in PyTorch. It can hold other Modules as attributes, and PyTorch will keep track of them as children in a tree structure when we use <code>register_module</code>. This is useful for saving and loading models, moving models between types and devices, and most importantly for training. Here is an example Module with 3 fully connected layers, taking 1 value and outputting 2 values:</p> <pre><code>struct Net : torch::nn::Module {\n  torch::nn::Linear fc1, fc2, fc3;\n\n  Net(int64_t dims) : fc1(1, dims), fc2(dims, dims), fc3(dims, 2) {\n    register_module(\"fc1\", fc1);\n    register_module(\"fc2\", fc2);\n    register_module(\"fc3\", fc3);\n  }\n};\n</code></pre> <p>Note: If you want it to be a <code>class</code> instead of a <code>struct</code>, you have to make the inheritance, constructor, and forward function public.</p> <p>This above is the \"C++ way\" of creating a Module, which is best C++ practice. The API allows for the \"Python way\" of initializing and registering submodules:</p> <pre><code>struct Net : torch::nn::Module {\n  torch::nn::Linear fc1{nullptr}, fc2{nullptr}, fc3{nullptr};\n\n  Net(int64_t dims) {\n    fc1 = register_module(\"fc1\", torch::nn::Linear(1, dims));\n    fc2 = register_module(\"fc2\", torch::nn::Linear(dims, dims));\n    fc3 = register_module(\"fc3\", torch::nn::Linear(dims, 2));\n  }\n};\n</code></pre> <p>The submodules are initialized to <code>nullptr</code>, and then assigned to the result of <code>register_module</code> inside the body of the constructor. This is at the cost of an extra constructor call for each submodule for initializing them to <code>nullptr</code>. Unless this is happening frequently, then the cost is pretty minimal. This is because <code>torch::nn::Linear</code> is an \"alias\" for a wrapper class template around a <code>shared_ptr</code>, called <code>torch::nn::ModuleHolder</code>. The real type \"aliased\" by <code>Linear</code> in this case would be ModuleHolder, where LinearImpl is the actual implementation of the Linear module. More details can be found here, but overall this is to simplify the API and make it more similar to how it is done in Python. You can circumvent the use of the ModuleHolder wrapper class (or shared_ptr) by using the actual implementation class, but some features only support the wrapper class such as loading and saving. So there are options for advanced C++ users to be more efficient, while also being easy for users who are less interested in that to use the library. <p>You may have noticed that the features of the linear layer are specified by the int64_t type. This is a signed 64-bit integer. I'm not entirely sure why Linear is using a signed integer to specify its dimensions, because negative dimensions don't make sense. If you try making a linear layer in Python with negative dimensions, you get an error. I think it would make more sense to use an unsigned integer. I couldn't find any information on why this is the case, and many other values in the library use int64_t as well that could be unsigned. My best guess is that this is to be future-proofed, in case they want to use the negative values to mean something in the future. In any case, I can't imagine why you would need more than $2^{32} - 1$ features in a linear layer.</p>"},{"location":"blogpost/Situ/draft/#forward-function","title":"Forward Function","text":"<p>We need to define what happens when we do a forward pass through the network.  We do this by defining the forward function:</p> <pre><code>struct Net : torch::nn::Module {\n  torch::nn::Linear fc1, fc2, fc3;\n\n  Net(int64_t dims) : fc1(1, dims), fc2(dims, dims), fc3(dims, 2) {\n    register_module(\"fc1\", fc1);\n    register_module(\"fc2\", fc2);\n    register_module(\"fc3\", fc3);\n  }\n\n  torch::Tensor forward(torch::Tensor x) {\n    x = torch::relu(fc1(x));\n    x = torch::relu(fc2(x));\n    x = fc3(x);\n    return x;\n  }\n};\n</code></pre> <p>This is pretty much the same as how it is done in Python, which looks pretty nice. We pass x through each layer and applying ReLU on the output of each layer, except for the last layer. We can call each layer like a function because they are ModuleHolders that define <code>operator()</code>, which calls the implementation's forward method. So <code>fc1(x)</code> is equivalent to <code>fc1-&gt;forward(x)</code>. <code>Module</code> doesn't have a virtual function named <code>forward</code>, so we don't use the <code>override</code> keyword and we can name this to something else, but if we want to use this <code>Module</code> in a <code>ModuleHolder</code>, it should be named <code>forward</code> so that it can be called like a function.</p>"},{"location":"blogpost/Situ/draft/#training","title":"Training","text":"<p>This will be a simple example of training Net to learn to output two arbitrary numbers from one.</p> <pre><code>int main() {\n  torch::nn::ModuleHolder&lt;Net&gt; net(10);\n  std::cout &lt;&lt; \"net: \" &lt;&lt; net &lt;&lt; std::endl;\n  torch::optim::SGD optimizer(net-&gt;parameters(), 0.01);\n  torch::Tensor x = torch::rand({1, 1});\n  torch::Tensor y = torch::rand({1, 2});\n  std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"y: \" &lt;&lt; y &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"y_pred: \" &lt;&lt; net(x) &lt;&lt; std::endl;\n  for (size_t i = 0; i &lt; 1000; ++i) {\n    torch::Tensor y_pred = net(x);\n    torch::Tensor loss = torch::mse_loss(y_pred, y);\n    loss.backward();\n    optimizer.step();\n    optimizer.zero_grad();\n  }\n  std::cout &lt;&lt; \"Training finished!\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"y_pred: \" &lt;&lt; net(x) &lt;&lt; std::endl;\n}\n</code></pre> <p>Here's the output:</p> <pre><code>net: Net(\n  (fc1): torch::nn::Linear(in_features=1, out_features=10, bias=true)\n  (fc2): torch::nn::Linear(in_features=10, out_features=10, bias=true)\n  (fc3): torch::nn::Linear(in_features=10, out_features=2, bias=true)\n)\nx:  0.8651\n[ CPUFloatType{1,1} ]\ny:  0.8518  0.9766\n[ CPUFloatType{1,2} ]\ny_pred: -0.1346  0.4346\n[ CPUFloatType{1,2} ]\nTraining finished!\ny_pred:  0.8518  0.9766\n[ CPUFloatType{1,2} ]\n</code></pre> <p>This is straight-forward too. We create a <code>ModuleHolder</code> for our <code>Net</code> so that we can write <code>net(x)</code>, which is completely optional. We could easily have defined <code>net</code> as <code>Net net(10)</code> and just use <code>net.forward(x)</code> instead. We create an optimizer with a learning rate of <code>0.01</code> and give it the parameters of our network. We then create arbitrary data. In the training loop, we compute the loss, propagate it backwards, update the parameters with the optimizer, and zero the gradients. After training is done, we see that the network has learned to output the same values as the target.</p>"},{"location":"blogpost/Situ/draft/#tensors","title":"Tensors","text":"<p>PyTorch works with tensors. In Python, they can have many different types such as floats, doubles, halfs, and many more. It is done in the same way in the C++ API. Tensors are dynamically typed, which is a striking contrast to the C++ philosophy of static typing. This allows for the user to change a tensor's type at runtime, using the <code>Tensor.to(&lt;data type&gt;)</code> method of tensors and modules. As a consequence, the program may perform an illegal operation between tensors with different types, but it will still compile and crash at runtime. This may not be a big deal for developers coming from Python, as they have likely gotten used to this problem. Crashing at runtime due to types is not something C++ developers typically deal with, if at all, so this can be seen as a disaster to some. In my opinion, it can be pretty frustrating to wait for it to compile just for it to crash due to a type error.</p> <p>If you want to iterate over the values of a tensor frequently, dynamic dispatch will significantly slow down the access to the values. Dynamic dispatch is the process of deciding which code to call for a certain tensor data type and number of dimensions [3]. This is like the dynamic dispatch that happens when polymorphism and virtual functions are used. If this is done for every value in a tensor, it can get fairly expensive. The API provides \"accessors\" which can be used to index into the tensor values efficiently. We can perform a quick test:</p> <pre><code>#include \"torch/torch.h\"\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\nusing namespace std::chrono;\nint main() {\n  torch::Tensor x = torch::rand({100, 100});\n  auto x_a = x.accessor&lt;float, 2&gt;();\n  float t1{0}, t2{0};\n\n  auto start = high_resolution_clock::now();\n  for (size_t i = 0; i &lt; 100'000; ++i)\n    for (int64_t j = 0; j &lt; x.size(0); ++j)\n      t1 += x[j][j].item&lt;float&gt;();\n  std::cout &lt;&lt; t1 &lt;&lt; std::endl;\n  auto time_secs = duration_cast&lt;milliseconds&gt;(high_resolution_clock::now() - start);\n  std::cout &lt;&lt; time_secs &lt;&lt; std::endl;\n\n  start = high_resolution_clock::now();\n  for (size_t i = 0; i &lt; 100'000; ++i)\n    for (int64_t j = 0; j &lt; x_a.size(0); ++j)\n      t2 += x_a[j][j];\n  std::cout &lt;&lt; t2 &lt;&lt; std::endl;\n  time_secs = duration_cast&lt;milliseconds&gt;(high_resolution_clock::now() - start);\n  std::cout &lt;&lt; time_secs &lt;&lt; std::endl;\n}\n</code></pre> <p>For the first loop, when we use <code>x[j][j]</code> it returns a 1x1 tensor containing the value. The value must be extracted and converted to a float using <code>Tensor.item&lt;float&gt;()</code>. For the second loop, we use the accessor to index into the tensor values directly. Here's the output:</p> <pre><code>5.43507e+06\n27972ms\n5.43507e+06\n23ms\n</code></pre> <p>The accessor is significantly faster since checks are only done once when the accessor was created [3].</p>"},{"location":"blogpost/Situ/draft/#conclusion","title":"Conclusion","text":"<p>The PyTorch C++ API is not too difficult to use. The developers spent a lot of effort to be extremely easy to use by hiding away templates, memory management, and other C++ features. It is practically a direct port of the Python API, so if you know how to use PyTorch in Python, you can use it in C++ with minimal difficulty. If you are an avid C++ programmer, you may be frustrated at the lack of compile-time type safety with tensors. The documentation has room for improvement, but I suppose the functionality should be the same as the Python interface, so the Python documentation can be used as a reference.</p>"},{"location":"blogpost/Situ/draft/#sources","title":"Sources:","text":"<ol> <li>https://pytorch.org/cppdocs/installing.html</li> <li>https://pytorch.org/tutorials/advanced/cpp_frontend.html</li> <li>https://pytorch.org/cppdocs/notes/tensor_basics.html</li> <li>https://github.com/pytorch/pytorch/</li> <li>https://pytorch.org/tutorials/advanced/cpp_frontend.html</li> <li>https://pytorch.org/cppdocs/index.html</li> </ol>"},{"location":"blogpost/Situ/final/","title":"Review of PyTorch C++ API","text":""},{"location":"blogpost/Situ/final/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Knowledge of using PyTorch in Python</li> <li>Basic C++ knowledge</li> </ul>"},{"location":"blogpost/Situ/final/#introduction","title":"Introduction","text":"<p>PyTorch is a library for Python for machine learning. It is written in C++ and Python is used to interface with the library. This makes it have the performance of C++ while being easy to use. So why use the C++ API? PyTorch gives the following reasons: * The ability to make use of C++ multi-threading, since Python has a global interpreter lock which prevents true multi-threading. * It can be used to integrate with existing C++ code. * Python's low performance is too much of a cost for your application.</p> <p>Of course, You may just prefer writing C++ rather than Python.</p> <p>Note on performance between Python and C++: If most of your program is waiting on PyTorch, then moving from Python to C++ won't make a significant difference in performance. This is because PyTorch is written in C++ with Python bindings, allowing it to be used in Python. As a result, PyTorch function calls in Python are calling C++ compiled code, so PyTorch won't be limited by Python's performance. The only performance gain you will get is from the pure Python code that you may have. If there's a specific part of your program that is taking a long time, then you can move that part to C++ with Python bindings to get a performance boost, rather than moving the entire program to C++.</p> <p>The C++ API is designed to be extremely similar to how PyTorch is used in Python, so that it is straightforward to use. One of the tips that they give is to write the code like you would in Python, while abiding to C++ syntax [2].</p>"},{"location":"blogpost/Situ/final/#installation","title":"Installation","text":"<p>The setup for the library is pretty straightforward if you only want to use the CPU for PyTorch. These instructions worked for me without modification. The installation for GPU support is a lot more involved since the CUDA toolkit from Nvidia is needed to successfully build PyTorch, and there seems to be a problem with the library for the 12.1 version of CUDA.</p> Steps I followed for installing PyTorch with GPU Support Firstly, you need a CUDA-compatible device. A list of CUDA-enabled devices are found here: https://developer.nvidia.com/cuda-gpus  Then, download libtorch from https://pytorch.org/get-started/locally/ I selected `Nightly + Windows + LibTorch + C++/Java + CUDA 12.1` and downloaded the release version of the library.  The `libtorch` folder inside of the downloaded zip file should be moved to a convenient location.  Then I downloaded the corresponding 12.1 version of the CUDA toolkit from https://developer.nvidia.com/cuda-downloads by navigating to \"Archive of Previous CUDA Releases\" at the bottom of the page. When selecting the target platform, my selections were `Windows + x86_64 + 10 + exe (local)`. Downloading and running the installer should install CUDA 12.1 on the system.  Doing `nvcc --version` in the command prompt should show the version of CUDA installed.  This is typically all the steps needed to start building programs with PyTorch, but there is a problem where CMake gives an error stating that it failed to find nvToolsExt. A solution I found from https://discuss.pytorch.org/t/failed-to-find-nvtoolsext/179635/4 is to install the CUDA toolkit version 11.8, which includes the nvToolsExt library. So I installed CUDA 11.8 following the same steps as above, and doing a custom installation for only the Nsight NVTX component under the CUDA category.   After all of these steps, I was able to compile the CUDA-enabled LibTorch library with the MSVC compiler with the following CMakeLists.txt file and console commands:  <pre><code>cmake_minimum_required(VERSION 3.12)\nproject(example)\n\nset(CMAKE_CXX_STANDARD 20)\n\nfind_package(Torch REQUIRED)\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${TORCH_CXX_FLAGS}\")\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example \"${TORCH_LIBRARIES}\")\n\n# The following code block is suggested to be used on Windows.\n# According to https://github.com/pytorch/pytorch/issues/25457,\n# the DLLs need to be copied to avoid memory errors.\nif (MSVC)\n  file(GLOB TORCH_DLLS \"${TORCH_INSTALL_PREFIX}/lib/*.dll\")\n  add_custom_command(TARGET example\n                     POST_BUILD\n                     COMMAND ${CMAKE_COMMAND} -E copy_if_different\n                     ${TORCH_DLLS}\n                     $&lt;TARGET_FILE_DIR:example&gt;)\nendif (MSVC)\n</code></pre>  This CMakelists.txt file is from https://pytorch.org/cppdocs/installing.html  The console commands I used to build the program were (starting in the path where the example.cpp file is located, and assuming the libtorch folder is in the same directory):  <pre><code>mkdir build\ncd build\ncmake -DCMAKE_PREFIX_PATH=\"${CMAKE_CURRENT_SOURCE_DIR}/../libtorch\" ..\ncmake --build . --config Release &amp;&amp; Release\\example.exe\n</code></pre>"},{"location":"blogpost/Situ/final/#documentation","title":"Documentation","text":"<p>The documentation can be found here. There is a significant portion of functions that are missing documentation.</p>"},{"location":"blogpost/Situ/final/#minimal-example","title":"Minimal Example","text":"<p>The installation guide provides a small example to try when getting the library set up. It is a simple program that creates a 2x3 tensor of random numbers between 0 and 1 and prints it to std::cout. The installation guide gives the following example:</p> <pre><code>#include &lt;torch/torch.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n  torch::Tensor tensor = torch::rand({2, 3});\n  std::cout &lt;&lt; tensor &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code> 0.3828  0.0383  0.8342\n 0.3193  0.1213  0.6756\n[ CPUFloatType{2,3} ]\n</code></pre> <p>This is the equivalent Python code:</p> <pre><code>import torch\n\ntensor = torch.rand(2, 3)\nprint(tensor)\n</code></pre> <p>Output:</p> <pre><code>tensor([[0.5879, 0.5029, 0.1522],\n        [0.0165, 0.1526, 0.8701]])\n</code></pre> <p>Aside from the random numbers, the results are pretty similar. If we use a large tensor size, such as [2,3,4], we see the following output:</p> <p>C++ Output:</p> <pre><code>(1,.,.) = \n  0.6969  0.9800  0.9234  0.7233\n  0.3798  0.5593  0.0248  0.4228\n  0.7216  0.3585  0.0960  0.8017\n\n(2,.,.) =\n  0.9224  0.8513  0.3186  0.1017\n  0.5374  0.5361  0.1317  0.0175\n  0.2660  0.0787  0.0405  0.9669\n[ CPUFloatType{2,3,4} ]\n</code></pre> <p>Python Output:</p> <pre><code>tensor([[[0.9271, 0.0307, 0.6839, 0.0347],\n         [0.2656, 0.7255, 0.8338, 0.8732],\n         [0.1196, 0.7630, 0.2806, 0.6407]],\n\n        [[0.9917, 0.8121, 0.7952, 0.1987],\n         [0.9438, 0.6141, 0.3507, 0.5229],\n         [0.8222, 0.0517, 0.3564, 0.0864]]])\n</code></pre> <p>The C++ output includes the index for each 2D slice of the tensor, which can be useful for debugging. You can easily lose track of which slice you're looking at in Python, especially if you printed out a large tensor.</p>"},{"location":"blogpost/Situ/final/#creating-a-module","title":"Creating a Module","text":"<p>A Module is the primary class for defining neural networks in PyTorch. It can hold other Module instances as attributes, and PyTorch will keep track of them as children in a tree structure when registered using <code>register_module</code>. This is useful for saving and loading models, moving models between types and devices, and most importantly for training. Here is an example Module with 3 fully connected layers, taking 1 value and outputting 2 values, with the flexible <code>dims</code> parameter:</p> <pre><code>struct Net : torch::nn::Module {\n  torch::nn::Linear fc1, fc2, fc3;\n\n  Net(int64_t dims) : fc1(1, dims), fc2(dims, dims), fc3(dims, 2) {\n    register_module(\"fc1\", fc1);\n    register_module(\"fc2\", fc2);\n    register_module(\"fc3\", fc3);\n  }\n};\n</code></pre> <p>Note: If you want it to be a <code>class</code> instead of a <code>struct</code>, you have to make the inheritance, constructor, and <code>forward</code> method public (<code>forward</code> will be talked about later).</p> <p>The example above is the \"C++ way\" of defining the constructor for a Module, which is best C++ practice. The member initializer list in the constructor avoids the extra default initialization of the members. The API allows for the \"Python way\" of initializing and registering submodules:</p> <pre><code>struct Net : torch::nn::Module {\n  torch::nn::Linear fc1{nullptr}, fc2{nullptr}, fc3{nullptr};\n\n  Net(int64_t dims) {\n    fc1 = register_module(\"fc1\", torch::nn::Linear(1, dims));\n    fc2 = register_module(\"fc2\", torch::nn::Linear(dims, dims));\n    fc3 = register_module(\"fc3\", torch::nn::Linear(dims, 2));\n  }\n};\n</code></pre> <p>Here is the equivalent Python code for reference:</p> <pre><code>class Net(torch.nn.Module):\n    def __init__(self, dims):\n        super().__init__()\n        # These modules are registered automatically; there is no \"register_module\" method.\n        self.fc1 = torch.nn.Linear(1, dims)\n        self.fc2 = torch.nn.Linear(dims, dims)\n        self.fc3 = torch.nn.Linear(dims, 2)\n</code></pre> <p>The submodules are initialized to <code>nullptr</code>, and then assigned to the result of <code>register_module</code> inside the body of the constructor. This is at the cost of an extra constructor call for each submodule for initializing them to <code>nullptr</code>. Unless this is happening frequently, then the cost is pretty small. This is because <code>torch::nn::Linear</code> is an \"alias\" for a wrapper class template around a <code>shared_ptr</code>, called <code>torch::nn::ModuleHolder</code>, so assignment to the <code>shared_ptr</code> is pretty cheap. The real type \"aliased\" by <code>Linear</code> in this case would be ModuleHolder, where LinearImpl is the actual implementation of the Linear module. More details can be found here, but overall this is to simplify the API and make it more similar to how it is done in Python. You can circumvent the use of the ModuleHolder wrapper class (or shared_ptr) by using the actual implementation class, but some features only support the wrapper class such as loading and saving. So there are options for advanced C++ users to be more efficient, while also being easy for users who are less interested in that to use the library. <p>You may have noticed that the features of the linear layer are specified by the int64_t type. This is a signed 64-bit integer. I'm not entirely sure why Linear is using a signed integer to specify its dimensions, because negative dimensions don't make sense. If you try making a linear layer in Python with negative dimensions, you get an error. I think it would make more sense to use an unsigned integer. I couldn't find any information on why this is the case, and many other values in the library use int64_t as well that could be unsigned. My best guess is that this is to be future-proofed, in case they want to use the negative values to mean something in the future. In any case, I can't imagine why you would need more than $2^{32} - 1$ in or out features in a Linear layer.</p>"},{"location":"blogpost/Situ/final/#forward-function","title":"Forward Function","text":"<p>We need to define what happens when we do a forward pass through the network.  We do this by defining the forward function:</p> <pre><code>struct Net : torch::nn::Module {\n  torch::nn::Linear fc1, fc2, fc3;\n\n  Net(int64_t dims) : fc1(1, dims), fc2(dims, dims), fc3(dims, 2) {\n    register_module(\"fc1\", fc1);\n    register_module(\"fc2\", fc2);\n    register_module(\"fc3\", fc3);\n  }\n\n  torch::Tensor forward(torch::Tensor x) {\n    x = torch::relu(fc1(x));\n    x = torch::relu(fc2(x));\n    return fc3(x);\n  }\n};\n</code></pre> <p>Equivalent Python code:</p> <pre><code>class Net(torch.nn.Module):\n    def __init__(self, dims):\n        super().__init__()\n        self.fc1 = torch.nn.Linear(1, dims)\n        self.fc2 = torch.nn.Linear(dims, dims)\n        self.fc3 = torch.nn.Linear(dims, 2)\n\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        return self.fc3(x)\n</code></pre> <p>The two <code>forward</code> methods look pretty much the same and easy to understand. The C++ <code>forward</code> method takes a copy of the passed in <code>Tensor</code> so we can reuse the variable. We pass x through each layer and apply ReLU on the output of each layer, except for the last layer so that it can output any value. We can call each layer like a function because they are <code>ModuleHolder</code>s, which define <code>operator()</code> that just calls the implementation's forward method. So <code>fc1(x)</code> is equivalent to <code>fc1-&gt;forward(x)</code>. The <code>forward</code> method is not a virtual function of <code>Module</code>, so we don't use the <code>override</code> keyword. If <code>forward</code> is not defined, and <code>operator()</code> is used on a <code>ModuleHolder</code> holding your derived <code>Module</code> class, the code will not compile because it is a function template, and the compiler will see that <code>forward</code> will not be able to be called.</p>"},{"location":"blogpost/Situ/final/#training","title":"Training","text":"<p>Let's try training the model we defined above. We will do a simple example of fitting the model to a single data point. Due to the way the model was defined, the input tensor must be of size Bx1 and the output tensor must be of size Bx2, where B is the batch size (1 in this case because of the single data point).</p> <p>Let's see the Python version first for reference:</p> <pre><code>import torch\n\nclass Net(torch.nn.Module):\n    def __init__(self, dims):\n        super().__init__()\n        self.fc1 = torch.nn.Linear(1, dims)\n        self.fc2 = torch.nn.Linear(dims, dims)\n        self.fc3 = torch.nn.Linear(dims, 2)\n\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        return self.fc3(x)\n\ndevice_type = \"cpu\"\nif torch.cuda.is_available():\n    print(\"CUDA is available, using default CUDA device.\")\n    device_type = \"cuda\"\ndevice = torch.device(device_type)\n\nnet = Net(10)\nprint(\"net: \", net)\n# Create the vanilla stochastic gradient descent optimizer that operates on the net's parameters, with a learning rate of 0.01\noptimizer = torch.optim.SGD(net.parameters(), lr=0.01)\n# Create a random data point on the device we're using\nx = torch.rand(1, 1, device=device)\ny = torch.rand(1, 2, device=device)\nprint(\"x: \", x)\nprint(\"y: \", y)\nnet.to(device) # Move the network to the device\nprint(\"y_pred: \", net(x))\n# Train the network for 1000 iterations\nfor i in range(1000):\n    y_pred = net(x) # Make the prediction\n    loss = torch.nn.functional.mse_loss(y_pred, y) # Compute the loss between the prediction and the actual\n    loss.backward() # Compute the gradients\n    optimizer.step() # Update the parameters based on the gradients\n    optimizer.zero_grad() # Zero the gradients\nprint(\"Training finished!\")\nprint(\"y_pred: \", net(x))\n</code></pre> <p>Now for the C++ code:</p> <pre><code>#include \"torch/torch.h\"\n#include &lt;iostream&gt;\n\nstruct Net : torch::nn::Module {\n  torch::nn::Linear fc1, fc2, fc3;\n\n  Net(int64_t dims) : fc1(1, dims), fc2(dims, dims), fc3(dims, 2) {\n    register_module(\"fc1\", fc1);\n    register_module(\"fc2\", fc2);\n    register_module(\"fc3\", fc3);\n  }\n\n  torch::Tensor forward(torch::Tensor x) {\n    x = torch::relu(fc1(x));\n    x = torch::relu(fc2(x));\n    return fc3(x);\n  }\n};\n\nint main() {\n  std::string device_type = \"cpu\";\n  if (torch::cuda::is_available()) {\n    std::cout &lt;&lt; \"CUDA is available, using default CUDA device.\" &lt;&lt; std::endl;\n    device_type = \"cuda\";\n  }\n  torch::Device device(device_type);\n\n  torch::nn::ModuleHolder&lt;Net&gt; net(10);\n  std::cout &lt;&lt; \"net: \" &lt;&lt; net &lt;&lt; std::endl;\n  torch::optim::SGD optimizer(net-&gt;parameters(), 0.01);\n  torch::Tensor x = torch::rand({1, 1}, device);\n  torch::Tensor y = torch::rand({1, 2}, device);\n  std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"y: \" &lt;&lt; y &lt;&lt; std::endl;\n  net-&gt;to(device);\n  std::cout &lt;&lt; \"y_pred: \" &lt;&lt; net(x) &lt;&lt; std::endl;\n  for (size_t i = 0; i &lt; 1000; ++i) {\n    torch::Tensor y_pred = net(x);\n    torch::Tensor loss = torch::mse_loss(y_pred, y);\n    loss.backward();\n    optimizer.step();\n    optimizer.zero_grad();\n  }\n  std::cout &lt;&lt; \"Training finished!\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"y_pred: \" &lt;&lt; net(x) &lt;&lt; std::endl;\n}\n</code></pre> <p>Here's the output if CUDA is not available:</p> <pre><code>net: Net(\n  (fc1): torch::nn::Linear(in_features=1, out_features=10, bias=true)\n  (fc2): torch::nn::Linear(in_features=10, out_features=10, bias=true)\n  (fc3): torch::nn::Linear(in_features=10, out_features=2, bias=true)\n)\nx:  0.8651\n[ CPUFloatType{1,1} ]\ny:  0.8518  0.9766\n[ CPUFloatType{1,2} ]\ny_pred: -0.1346  0.4346\n[ CPUFloatType{1,2} ]\nTraining finished!\ny_pred:  0.8518  0.9766\n[ CPUFloatType{1,2} ]\n</code></pre> <p>And here's the output if CUDA is available:</p> <pre><code>CUDA is available, using default CUDA device.\nnet: Net(\n  (fc1): torch::nn::Linear(in_features=1, out_features=10, bias=true)\n  (fc2): torch::nn::Linear(in_features=10, out_features=10, bias=true)\n  (fc3): torch::nn::Linear(in_features=10, out_features=2, bias=true)\n)\nx:  0.8651\n[ CUDAFloatType{1,1} ]\ny:  0.8518  0.9766\n[ CUDAFloatType{1,2} ]\ny_pred: -0.1346  0.4346\n[ CUDAFloatType{1,2} ]\nTraining finished!\ny_pred:  0.8518  0.9766\n[ CUDAFloatType{1,2} ]\n</code></pre> <p>This is straight-forward as well. We create a <code>ModuleHolder</code> for our <code>Net</code> so that we can write <code>net(x)</code>, which is completely optional. We could easily have defined <code>net</code> as <code>Net net(10)</code> and just use <code>net.forward(x)</code> instead. We create an optimizer with a learning rate of <code>0.01</code> and give it the parameters of our network. We then create arbitrary data tensors <code>x</code> and <code>y</code>. In the training loop, we compute the loss, propagate it backwards to compute gradients the parameters, update the parameters with the optimizer, and zero the gradients. After training is done, we see that the network has learned to output the same values as <code>y</code> when given <code>x</code>.</p>"},{"location":"blogpost/Situ/final/#how-much-faster-is-cuda-than-the-cpu-operations","title":"How much faster is CUDA than the CPU operations?","text":"<p>I did a quick and dirty test to see how much faster CUDA is than the CPU. I used the same code as above, but I added a timer to see how long it takes to train the network for 1000 iterations. I also added a loop to repeat the training 100 times to get a better average. I used the release version of LibTorch. Here is the code for the comparison:</p> <pre><code>#include \"torch/torch.h\"\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n\nstruct Net : torch::nn::Module {\n  torch::nn::Linear fc1, fc2, fc3;\n\n  Net(int64_t dims) : fc1(1, dims), fc2(dims, dims), fc3(dims, 2) {\n    register_module(\"fc1\", fc1);\n    register_module(\"fc2\", fc2);\n    register_module(\"fc3\", fc3);\n  }\n  torch::Tensor forward(torch::Tensor x) {\n    x = torch::relu(fc1(x));\n    x = torch::relu(fc2(x));\n    x = fc3(x);\n    return x;\n  }\n};\n\nusing namespace std::chrono;\nint main() {\n  torch::Device device(\"cpu\");\n  std::vector&lt;duration&lt;double&gt;&gt; times_cpu;\n  std::vector&lt;duration&lt;double&gt;&gt; times_gpu;\n  const size_t N = 10000;\n  const size_t M = 10;\n  const size_t STEP = N / M;\n  const size_t START = STEP;\n\n  // Store total loss to prevent the compiler from optimizing out the code\n  auto cpu_options = torch::TensorOptions().requires_grad(false);\n  torch::Tensor cpu_loss = torch::zeros({}, cpu_options);\n  auto gpu_options = torch::TensorOptions().requires_grad(false).device(\"cuda\");\n  torch::Tensor gpu_loss = torch::zeros({}, gpu_options);\n\n  // Time how long it takes to train the network on the CPU for different size networks\n  for (size_t n = START; n &lt; N; n += STEP) {\n    if (n % STEP == 0) {\n      std::cout &lt;&lt; n / STEP * M &lt;&lt; \"%\" &lt;&lt; std::endl;\n    }\n    torch::nn::ModuleHolder&lt;Net&gt; net(n);\n    torch::optim::SGD optimizer(net-&gt;parameters(), 0.01);\n    torch::Tensor x = torch::rand({1, 1}, device);\n    torch::Tensor y = torch::rand({1, 2}, device);\n    net-&gt;to(device);\n    auto start = high_resolution_clock::now();\n    for (size_t i = 0; i &lt; 1000; ++i) {\n      torch::Tensor y_pred = net(x);\n      torch::Tensor loss = torch::mse_loss(y_pred, y);\n      loss.backward();\n      optimizer.step();\n      optimizer.zero_grad();\n      cpu_loss += loss;\n    }\n    duration&lt;double&gt; time = high_resolution_clock::now() - start;\n    times_cpu.push_back(time);\n  }\n  std::cout &lt;&lt; \"CPU loss: \" &lt;&lt; cpu_loss &lt;&lt; std::endl;\n\n  // GPU\n  device = torch::Device(\"cuda\");\n  for (size_t n = START; n &lt; N; n += STEP) {\n    if (n % STEP == 0) {\n      std::cout &lt;&lt; n / STEP * M &lt;&lt; \"%\" &lt;&lt; std::endl;\n    }\n    torch::nn::ModuleHolder&lt;Net&gt; net(n);\n    torch::optim::SGD optimizer(net-&gt;parameters(), 0.01);\n    torch::Tensor x = torch::rand({1, 1}, device);\n    torch::Tensor y = torch::rand({1, 2}, device);\n    net-&gt;to(device);\n    auto start = high_resolution_clock::now();\n    for (size_t i = 0; i &lt; 1000; ++i) {\n      torch::Tensor y_pred = net(x);\n      torch::Tensor loss = torch::mse_loss(y_pred, y);\n      loss.backward();\n      optimizer.step();\n      optimizer.zero_grad();\n      gpu_loss += loss;\n    }\n    duration&lt;double&gt; time = high_resolution_clock::now() - start;\n    times_gpu.push_back(time);\n  }\n  std::cout &lt;&lt; \"GPU loss: \" &lt;&lt; gpu_loss &lt;&lt; std::endl;\n\n  // Print results\n  std::cout &lt;&lt; \"CPU:\" &lt;&lt; std::endl;\n  for (auto t : times_cpu) {\n    std::cout &lt;&lt; t.count() &lt;&lt; \" \";\n  }\n  std::cout &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"GPU:\" &lt;&lt; std::endl;\n  for (auto t : times_gpu) {\n    std::cout &lt;&lt; t.count() &lt;&lt; \" \";\n  }\n  std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>And here are the results:</p> <pre><code>10%\n20%\n30%\n40%\n50%\n60%\n70%\n80%\n90%\nCPU loss: 198.905\n[ CPUFloatType{} ]\n10%\n20%\n30%\n40%\n50%\n60%\n70%\n80%\n90%\nGPU loss: 179.096\n[ CUDAFloatType{} ]\nCPU:\n1.41505 7.83082 17.3266 32.5976 51.6532 75.6886 100.701 139.414 177.368\nGPU:\n3.31302 1.31196 2.09196 3.70828 5.55248 7.82177 10.6128 13.7544 17.3604\n</code></pre> <p>Here is a graph of the results: </p> <p>Although there are the possibility of outliers, the general trend and the difference is clear. Performing the operations with CUDA on the is roughly 10 times faster than the CPU for my setup. This is with a NVIDIA GeForce GTX 1650 and an Intel Core i7 9750H. If the model is large, then it is definitely worth using CUDA if possible. Of course, this is an unrealistic example, this model architecture is very basic and it is essentially a single large matrix multiplication, but it does showcase the potential performance gains when using the GPU.</p>"},{"location":"blogpost/Situ/final/#tensors","title":"Tensors","text":"<p>PyTorch works with tensors. A tensor in PyTorch is an n-dimensional array, similar to a NumPy array from the Python library NumPy. They can have many different types such as floats, doubles, halfs, and many more. It is done in the same way in the C++ API. Tensors are dynamically typed, which is a striking contrast to the C++ philosophy of static typing. This allows for the user to change a tensor's type at runtime, using the <code>Tensor.to(&lt;data type&gt;)</code> method of tensors and modules. As a consequence, the program may perform an illegal operation between tensors with different types, but it will still compile and proceed to crash at runtime. This may not be a big deal for developers coming from Python, as they have likely gotten used to this problem. Crashing at runtime due to types is not something C++ developers typically deal with, if at all, so this can be seen as a disaster to some. In my opinion, it can be pretty frustrating to wait for it to compile just for it to crash due to a type error.</p> <p>If you want to iterate over the values of a tensor frequently, dynamic dispatch will significantly slow down the access to the values. Dynamic dispatch is the process of deciding which code to call for a certain tensor data type and number of dimensions [3]. This is like the dynamic dispatch that happens when polymorphism and virtual functions are used. If this is done for every value in a tensor, it can get fairly expensive. The API provides \"accessors\" which can be used to index into the tensor values efficiently. We can perform a quick test on the release version of LibTorch:</p> <pre><code>#include \"torch/torch.h\"\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\nusing namespace std::chrono;\nint main() {\n  torch::Tensor x = torch::rand({100, 100});\n  auto x_a = x.accessor&lt;float, 2&gt;();\n  float t1{0}, t2{0};\n\n  auto start = high_resolution_clock::now();\n  for (size_t i = 0; i &lt; 100'000; ++i)\n    for (int64_t j = 0; j &lt; x.size(0); ++j)\n      t1 += x[j][j].item&lt;float&gt;();\n  auto time_secs = duration_cast&lt;milliseconds&gt;(high_resolution_clock::now() - start);\n  std::cout &lt;&lt; time_secs &lt;&lt; std::endl;\n\n  start = high_resolution_clock::now();\n  for (size_t i = 0; i &lt; 100'000; ++i)\n    for (int64_t j = 0; j &lt; x_a.size(0); ++j)\n      t2 += x_a[j][j];\n  time_secs = duration_cast&lt;milliseconds&gt;(high_resolution_clock::now() - start);\n  std::cout &lt;&lt; time_secs &lt;&lt; std::endl;\n  std::cout &lt;&lt; t1 == t2 &lt;&lt; std::endl; // Prevent compiler from optimizing out the loops\n}\n</code></pre> <p>For the first loop, when we use <code>x[j][j]</code> it returns a 1x1 tensor containing the value. The value must be extracted and converted to a float using <code>Tensor.item&lt;float&gt;()</code>. For the second loop, we use the accessor to index into the tensor values directly. Here's the output:</p> <pre><code>27972ms\n23ms\n1\n</code></pre> <p>The accessor is significantly faster since checks are only done once when the accessor was created [3].</p>"},{"location":"blogpost/Situ/final/#conclusion","title":"Conclusion","text":"<p>The PyTorch C++ API is not too difficult to use. The developers spent a lot of effort to be extremely easy to use by hiding away templates, memory management, and other C++ features. It is practically a direct port of the Python API, so if you know how to use PyTorch in Python, you can use it in C++ with minimal difficulty. If you are an avid C++ programmer, you may be frustrated at the lack of compile-time type safety with tensors. The documentation has room for improvement, but I suppose the functionality should be the same as the Python interface, so the Python documentation can be used as a reference.</p>"},{"location":"blogpost/Situ/final/#sources","title":"Sources:","text":"<ol> <li>https://pytorch.org/cppdocs/installing.html</li> <li>https://pytorch.org/tutorials/advanced/cpp_frontend.html</li> <li>https://pytorch.org/cppdocs/notes/tensor_basics.html</li> <li>https://github.com/pytorch/pytorch/</li> <li>https://pytorch.org/tutorials/advanced/cpp_frontend.html</li> <li>https://pytorch.org/cppdocs/index.html</li> </ol>"},{"location":"blogpost/Thamminana/final/","title":"Blog Post for Logging in C++","text":"<p>author: Aman Dhruva Thamminana</p>"},{"location":"blogpost/Thamminana/final/#introduction-what-is-logging","title":"Introduction: What is Logging?","text":"<p>Whether you are one is just staring of in their programming journey or a seasoned programmer,  you would have used print statements to debug your code. Logging is very similar to print states of code but with more tools to help better understand the state of the program. Logging can be a very useful tool to level up one;'s programming skills.</p> <p>In simple terms logging is the act of  recording events, actions, or states that occur during the execution of a program.</p> <p>Let's look into understanding the basics of logging in C++ and looking into spdlog and glog libraries.</p>"},{"location":"blogpost/Thamminana/final/#back-to-basics-why-is-logging-important","title":"Back to Basics:  Why is Logging Important?","text":"<p>Logging helps us understand what is happening to a program under the hood. This can be very crutial especially at scale like when working on a large code base or when running high and long computing programs. Understading this information can allow us to create error free, efficient and robust code. </p> <p>Logging has become an indispensable standard in the software industry. In real-world many applications in  ios, android, and web and software platforms themselves use logging to record information about their operations.  . These detailed records enable developers to understand the context of issues, replicate scenarios, and create fixes.</p>"},{"location":"blogpost/Thamminana/final/#how-logging-differs-from-print-statements","title":"How Logging Differs from Print Statements?","text":"<p>Print statements can be used as a simpler version of logging allowing the programer to display several states of the program. Unlike print statements logging provides several syntatical levels of capturing information. </p> <p>Although it is upto the library to provide these levels, some of the common levels are: - Debug: Information that is critical to debug an application. - Info: Informational messages that highlight the progress of the application. - Warning: Indicates a potential problem that is not terminal to the application. - Error: Indicates a serious error that may prevent the application from continuing to run.</p> <p>Logging also provides the ability to log to different outputs like files, console, etc. This can be useful when running a program on a remote locations.</p>"},{"location":"blogpost/Thamminana/final/#spdlog","title":"spdlog \ud83d\udca8 \ud83d\udca8","text":"<p>spdlog is a very popular logging library for C++. It is a header only library built to be fast and efficient. </p> <p>to install in macos I have run these steps</p> <pre><code>brew install spdlog\n</code></pre> <p>to add it to cmake</p> <pre><code>find_package(glog REQUIRED)\n\nadd_executable(CSE_491_Capstone_Blog_Draft main.cpp)\ntarget_link_libraries(CSE_491_Capstone_Blog_Draft glog::glog)\n</code></pre> <p>and to get started with spdlog in your cpp project</p> <pre><code>#include &lt;spdlog/spdlog.h&gt;\n</code></pre> <p>Here is a simple code snippet to get started with spdlog</p> <pre><code>#include &lt;spdlog/spdlog.h&gt;\n\nvoid sampleFunction() {\n    // Initialize spdlog\n    auto logger = spdlog::default_logger();\n\n    // Set log level (equivalent to controlling INFO, WARNING, ERROR, FATAL in glog)\n    logger-&gt;set_level(spdlog::level::trace); // This will allow all levels of logging\n\n    // Log messages\n    SPDLOG_INFO(\"This is an informational message.\");\n    SPDLOG_WARN(\"This is a warning message.\");\n    SPDLOG_ERROR(\"This is an error message.\");\n    SPDLOG_CRITICAL(\"This is a fatal error message. The program will exit.\");\n\n    // In spdlog, there's no need for explicit shutdown like in Google Logging.\n    // It will automatically flush and shutdown on program exit.\n}\n</code></pre> <p>which will output</p> <pre><code>\n[2023-11-20 23:43:14.334] [info] [spdlog_main.cpp:12] This is an informational message.\n[2023-11-20 23:43:14.335] [warning] [spdlog_main.cpp:13] This is a warning message.\n[2023-11-20 23:43:14.335] [error] [spdlog_main.cpp:14] This is an error message.\n[2023-11-20 23:43:14.335] [critical] [spdlog_main.cpp:15] This is a fatal error message. The program will exit.\n</code></pre> <p>just more colorful and pretty. </p>"},{"location":"blogpost/Thamminana/final/#named-logging","title":"Named Logging","text":"<p>spdlog allows you to create multiple loggers with different names. This can be useful when you want to log different parts of your application to different files or streams.</p> <pre><code>#include \"spdlog/spdlog.h\"\n#include \"spdlog/sinks/stdout_color_sinks.h\"\n\nvoid stdout_example()\n{\n  // create a color multi-threaded logger\n  auto console = spdlog::stdout_color_mt(\"console\");\n  auto err_logger = spdlog::stderr_color_mt(\"stderr\");\n  spdlog::get(\"console\")-&gt;info(\"loggers can be retrieved from a global registry using the spdlog::get(logger_name)\");\n  spdlog::get(\"stderr\")-&gt;info(\"loggers can be retrieved from a global registry using the spdlog::get(logger_name)\");\n}\n</code></pre> <p>which outputs</p> <pre><code>[2023-11-20 23:47:38.197] [console] [info] loggers can be retrieved from a global registry using the spdlog::get(logger_name)\n[2023-11-20 23:47:38.198] [stderr] [info] loggers can be retrieved from a global registry using the spdlog::get(logger_name)\n</code></pre> <p>Here is an example for logging to a file</p> <pre><code>\n#include &lt;iostream&gt;\n\n#include \"spdlog/spdlog.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\nvoid basic_logfile_example()\n{\n  try\n  {\n    auto logger = spdlog::basic_logger_mt(\"basic_logger\", \"logs/basic-log.txt\");\n  }\n  catch (const spdlog::spdlog_ex &amp;ex)\n  {\n    std::cout &lt;&lt; \"Log init failed: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n  }\n}\n\n</code></pre> <p>more advanced logging can also be done with spdlog. </p> <pre><code>#include \"spdlog/sinks/rotating_file_sink.h\"\nvoid rotating_example()\n{\n    // Create a file rotating logger with 5 MB size max and 3 rotated files\n    auto max_size = 1048576 * 5;\n    auto max_files = 3;\n    auto logger = spdlog::rotating_logger_mt(\"some_logger_name\", \"logs/rotating.txt\", max_size, max_files);\n}\n</code></pre> <p>This demonstrates the creation of a rotating file logger using the spdlog library in C++. It configures a logger named \"some_logger_name\" to write to \"logs/rotating.txt\", with a maximum file size of 5 MB and a limit of 3 rotated files.</p> <pre><code>#include \"spdlog/sinks/daily_file_sink.h\"\nvoid daily_example()\n{\n    // Create a daily logger - a new file is created every day at 2:30 am\n    auto logger = spdlog::daily_logger_mt(\"daily_logger\", \"logs/daily.txt\", 2, 30);\n}\n</code></pre> <p>and ability to log trace and flush periodically</p> <pre><code>spdlog::enable_backtrace(32); \n\nfor(int i = 0; i &lt; 100; i++)\n{\n  spdlog::debug(\"Backtrace message {}\", i); \n}\n// if some error happened\nspdlog::dump_backtrace(); \n\nspdlog::flush_every(std::chrono::seconds(3));\n</code></pre> <p>These are some of the basic features of spdlog. There are a many more features that can be found in the documentation.</p>"},{"location":"blogpost/Thamminana/final/#glog","title":"glog (\ud83d\udd35\ud83d\udd34\ud83d\udfe0\ud83d\udfe2)","text":"<p>The Google Logging Library (glog) is a robust and efficient logging library for C++ applications developed by Google.  It is designed for ease of use and high performance, making it a popular choice among developers.</p> <p>to install in macos I have run these steps</p> <pre><code>brew install glog\n</code></pre> <p>to add it to cmake</p> <pre><code>find_package(glog REQUIRED)\n\nadd_executable(CSE_491_Capstone_Blog_Draft main.cpp)\ntarget_link_libraries(CSE_491_Capstone_Blog_Draft glog::glog)\n</code></pre> <p>and to get started with glog in your cpp project</p> <pre><code>#include &lt;glog/logging.h&gt;\n</code></pre> <p>Here is a simple code snippet to get started with glog</p> <pre><code>#include &lt;glog/logging.h&gt;\n\nvoid samplefunction() {\n  // Initialize Google Logging\n  google::InitGoogleLogging(\"Aman's Blogpost\");\n\n  // Set log destination to console (stderr).\n  google::LogToStderr();\n\n  // Log messages\n  LOG(INFO) &lt;&lt; \"This is an informational message.\";\n  LOG(WARNING) &lt;&lt; \"This is a warning message.\";\n  LOG(ERROR) &lt;&lt; \"This is an error message.\";\n  LOG(FATAL) &lt;&lt; \"This is a fatal error message. The program will exit.\";\n\n\n  // Clean up and shutdown Google Logging\n  google::ShutdownGoogleLogging();\n\n}\n</code></pre> <p>which will output</p> <pre><code>I20231016 23:59:25.775111 3685077760 main.cpp:18] This is an informational message.\nW20231016 23:59:25.775573 3685077760 main.cpp:19] This is a warning message.\nE20231016 23:59:25.775576 3685077760 main.cpp:20] This is an error message.\nE20231016 23:59:25.775578 3685077760 main.cpp:24] Encountered  errors.\n\nProcess finished with exit code 0\n</code></pre> <p>to break down the code snippet above</p> <pre><code>I20231016 23:59:25.775111 3685077760 main.cpp:18]\n</code></pre> <ul> <li>I: INFO</li> <li>20231016: Date</li> <li>23:59:25.775111: Time</li> <li>3685077760: Thread ID (PID )</li> <li>main.cpp:18: File name and line number</li> <li>contents of the log message itself</li> </ul>"},{"location":"blogpost/Thamminana/final/#conditional-logging","title":"Conditional Logging","text":"<pre><code>#include &lt;glog/logging.h&gt;\n\nvoid PerformTask(int value) {\n    // Log a message if the input value is greater than 10.\n    LOG_IF(INFO, value &gt; 10) &lt;&lt; \"Value is greater than 10: \" &lt;&lt; value;\n\n    // Log a message if the input value is even.\n    LOG_IF(WARNING, value % 2 == 0) &lt;&lt; \"Value is even: \" &lt;&lt; value;\n}\n\nint main(int argc, char* argv[]) {\n    // Initialize glog. This should be called once in your program.\n    google::InitGoogleLogging(argv[0]);\n\n    int value1 = 7;\n    int value2 = 12;\n\n    // Call PerformTask with different values.\n    PerformTask(value1);\n    PerformTask(value2);\n\n    // Clean up and shutdown glog.\n    google::ShutdownGoogleLogging();\n\n    return 0;\n}\n</code></pre> <p>which does not output value. (strange) but can conditionally output immediate string messages.</p> <p>here is another example</p> <pre><code>#include &lt;glog/logging.h&gt;\n\nvoid ConditionalLoggingExample(int value) {\n  LOG_IF(INFO, value &gt; 10) &lt;&lt; \"Logging an informational message (condition met).\";\n  LOG_IF(INFO, value &lt;= 10) &lt;&lt; \"Logging an informational message (condition not met).\";\n\n  int verbosity_level = 2;\n  VLOG_IF(verbosity_level, value &gt; 10) &lt;&lt; \"Verbose log message (condition met).\";\n  VLOG_IF(verbosity_level, value &lt;= 10) &lt;&lt; \"Verbose log message (condition not met).\";\n}\n\nint main(int argc, char* argv[]) {\n  google::InitGoogleLogging(argv[0]);\n\n  // Set log destination to console (stderr).\n  google::LogToStderr();\n\n  int value = 15;\n  ConditionalLoggingExample(value);\n\n  google::ShutdownGoogleLogging();\n  return 0;\n}\n</code></pre> <p>which outputs</p> <pre><code>I20231018 00:18:04.219352 3685077760 main.cpp:4] Logging an informational message (condition met).\nI20231018 00:18:04.219790 3685077760 main.cpp:4] Logging an informational message (condition met).\nI20231018 00:18:04.219794 3685077760 main.cpp:8] Verbose log message (condition met).\n</code></pre> <p>There are a many more macros...</p>"},{"location":"blogpost/Thamminana/final/#log_every_n","title":"<code>LOG_EVERY_N</code>","text":"<p>The LOG_EVERY_N macro allows you to log a message every N occurrences. This can be helpful when you want to log messages periodically or at specific intervals. </p> <pre><code>void samplefunction() {\n    LOG_EVERY_N(INFO, 5) &lt;&lt; \"Logging every 5th call of samplefunction.\";\n}\n</code></pre>"},{"location":"blogpost/Thamminana/final/#log_first_n","title":"<code>LOG_FIRST_N</code>","text":"<p>LOG_IF_EVERY_N combines conditional and periodic logging. It logs a message every N occurrences only if a specific condition is met.</p> <pre><code>void samplefunction() {\n    LOG_IF_EVERY_N(INFO, value &gt; 10, 5) &lt;&lt; \"Logging every 5th call of samplefunction if value &gt; 10.\";\n}\n</code></pre>"},{"location":"blogpost/Thamminana/final/#log_first_n_1","title":"<code>LOG_FIRST_N</code>","text":"<p>LOG_FIRST_N allows you to log a message only for the first N occurrences.</p> <pre><code>void samplefunction() {\n    LOG_FIRST_N(INFO, 5) &lt;&lt; \"Logging only the first 5 calls of samplefunction.\";\n}\n</code></pre>"},{"location":"blogpost/Thamminana/final/#log_every_t","title":"<code>LOG_EVERY_T</code>","text":"<p>LOG_EVERY_T enables you to log a message every T seconds. This is beneficial when you want to log periodic updates </p> <pre><code>void samplefunction() {\n    LOG_EVERY_T(INFO, 5) &lt;&lt; \"Logging every 5 seconds.\";\n}\n</code></pre>"},{"location":"blogpost/Thamminana/final/#check","title":"<code>CHECK</code>","text":"<p>The CHECK macro verifies a condition and logs a FATAL message if the condition is false</p> <pre><code>void samplefunction() {\n    CHECK(value &gt; 10) &lt;&lt; \"Value is not greater than 10.\";\n}\n</code></pre> <p> A number of these macros can also be called with D[MACRO] allowing to only run macros in debug mode and not in release.</p>"},{"location":"blogpost/Thamminana/final/#good-practices-for-logging","title":"Good Practices for Logging","text":"<p>from my research I have found a few good practices for logging.</p> <ul> <li>Choosing appropriate log levels and verbosity level for each log message.</li> <li>Ability to structure log messages appropriately.</li> <li>Gather and store initial context information of the systems.</li> <li>be cautious of logging sensitive information like credientials.</li> </ul>"},{"location":"blogpost/Thamminana/final/#conclusion","title":"Conclusion","text":"<p>In the course of exploring logging libraries like spdlog and glog, I've encountered a lot of features and practices that have significantly enhanced  my understanding of effective logging in C++. As I continue to develop my own logging system, I have started to incorporate some of these features and practices.</p> <p>Moving beyond simple print statements, logging can be a very useful tool to level up one's programming skills.</p> <p>References: - https://github.com/gabime/spdlog - https://github.com/google/glog</p>"},{"location":"blogpost/VanDam/draft/","title":"Raylib with Emscripten exploration","text":""},{"location":"blogpost/VanDam/draft/#author-jayson-van-dam","title":"Author: Jayson Van Dam","text":""},{"location":"blogpost/VanDam/draft/#overview","title":"Overview","text":"<p>My goal with this blog post is to get Raylib's Arkanoid example working in a web browser using the Emscripten compiler to compile C++ source code into WebAssembly. I will be following this guide to install both Emscripten and Raylib on Windows.</p>"},{"location":"blogpost/VanDam/draft/#emscripten-windows-installation-steps","title":"Emscripten Windows installation steps","text":"<ol> <li>First, be sure that Python and Git are both installed on the system.</li> <li>Download the Emscripten SDK as a zip file from https://github.com/emscripten-core/emsdk/archive/refs/heads/main.zip</li> <li>Open the zip file (with 7-zip or another archiving tool), then go into the <code>emsdk-main</code> directory. Extract the contents of this directory to <code>C:\\emsdk\\</code></li> <li>Open Command Prompt, then run <code>cd C:\\emsdk\\</code></li> <li>Run <code>emsdk.bat install latest</code></li> <li>Run <code>emsdk.bat activate latest</code></li> <li>Run <code>emsdk_env.bat</code></li> <li>You should now be able to run <code>emcc --version</code>. It should give output similar to this:     <code>emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 3.1.47 (431685f05c67f0424c11473cc16798b9587bb536)     Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt)     This is free and open source software under the MIT license.     There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></li> <li>From now on, if you want to compile with Emscripten, then go to <code>C:\\emsdk</code> in File Explorer and run <code>emcmdprompt.bat</code>.</li> </ol>"},{"location":"blogpost/VanDam/draft/#difficulty-of-raylib-installation","title":"Difficulty of Raylib installation","text":"<p>Raylib seems a bit more challenging to install. At first, I tried to run <code>pacman -S mingw-w64-x86_64-raylib</code> (as suggested in the Working on Windows wiki page), but this did not seem to work at first.</p> <p>Second, I tried downloading the Raylib installer at https://github.com/raysan5/raylib/releases/download/4.5.0/raylib_installer_v4.5.mingw.64bit.exe. This seemed to work better and installed Raylib at <code>C:\\raylib</code>.</p> <p>Then, I read a bit deeper and found that the instructions say that:     \"Before compiling your game, raylib library must be recompiled for HTML5,     generating <code>libraylib.a</code>.\"</p> <p>I got a few compilation errors before when trying to compile a game, so this makes much more sense. I used the instructions for \"2.2 Using Makefile\", which seemed to recompile raylib correctly.</p> <p>This is a screenshot of where I got the \"Using Makefile\" instructions for compiling the Raylib library:</p> <p></p> <p>When compiling the Arkanoid example game with <code>mingw32-make PLATFORM=PLATFORM_WEB -B -e</code>, it failed at first with this error message:     <code>C:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find ../../../raylib/src/libraylib.a: No such file or directory</code></p> <p>I thought that changing the raylib path would be much easier when compiling on the command line. I ran</p> <pre><code>emcc -o arkanoid.html arkanoid.cpp -Os -Wall C:\\raylib\\raylib\\src\\libraylib.a -I. -IC:\\raylib\\raylib\\src -L. -LC:\\raylib\\raylib\\src -s USE_GLFW=3 --shell-file C:\\raylib\\raylib\\src\\shell.html -DPLATFORM_WEB\n</code></pre> <p>and got this error message:     <code>arkanoid.cpp:119:28: error: non-constant-expression cannot be narrowed from type 'int' to 'float' in initializer list       [-Wc++11-narrowing]         119 |     brickSize = (Vector2){ GetScreenWidth()/BRICKS_PER_LINE, 40 };</code></p> <p>For assistance with this error, I looked to the Using raylib with Cpp page. This is a screenshot of the relevant part of the guide I looked at:</p> <p></p> <p>Since I changed the <code>arkanoid.c</code> example to <code>arkanoid.cpp</code>, I need to replace any instances of structure initialization with brace initialization. For these, I usually just needed to remove the parentheses around the type, so this C code from line 119:  <code>brickSize = (Vector2){ GetScreenWidth()/BRICKS_PER_LINE, 40 };</code>  would be converted into this C++ code:  <code>brickSize = Vector2{ static_cast&lt;float&gt;(GetScreenWidth()/BRICKS_PER_LINE), 40 };</code> </p> <p>How to compile the Arkanoid example: 1. Open File Explorer, launch <code>C:\\emsdk\\emcmdprompt.bat</code> 1. Change directory into <code>\\path\\to\\source\\</code> 1. Run this command:     <code>emcc -o arkanoid.html arkanoid.cpp -Os -Wall C:\\raylib\\raylib\\src\\libraylib.a -I. -IC:\\raylib\\raylib\\src -L. -LC:\\raylib\\raylib\\src -s USE_GLFW=3 --shell-file C:\\raylib\\raylib\\src\\shell.html -DPLATFORM_WEB</code></p> <p>How to test the Arkanoid example: 1. Change directory into <code>\\path\\to\\source\\</code> 1. Launch the web server with <code>python -m http.server 8080</code> 1. Visit <code>http://localhost:8080</code> in a web browser</p>"},{"location":"blogpost/VanDam/draft/#experience-getting-functions-and-classes-working","title":"Experience getting functions and classes working","text":"<p>As stated above, I did have to change the <code>brickSize</code> initialization in order to compile <code>arkanoid.cpp</code> correctly. I did not have to change any other code for the functionality to work, but there were also a few compiler warnings:</p> <pre><code>arkanoid.cpp:62:26: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n62  | static Player player = { 0 };\n    |                          ^\n    |                          {}\narkanoid.cpp:63:22: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n63  | static Ball ball = { 0 };\n    |                      ^\n    |                      {}\narkanoid.cpp:64:58: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n64  | static Brick brick[LINES_OF_BRICKS][BRICKS_PER_LINE] = { 0 };\n    |                                                          ^\n    |                                                          {}\narkanoid.cpp:64:58: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n64  | static Brick brick[LINES_OF_BRICKS][BRICKS_PER_LINE] = { 0 };\n    |                                                          ^\n    |                                                          {}\narkanoid.cpp:64:58: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n64  | static Brick brick[LINES_OF_BRICKS][BRICKS_PER_LINE] = { 0 };\n    |                                                          ^\n    |                                                          {}\n</code></pre> <p>To get rid of these compiler warnings, I changed lines 62-64 of <code>arkanoid.cpp</code> to include curly braces around the initializations: </p> <pre><code>static Player player = { {0} };\nstatic Ball ball = { {0} };\nstatic Brick brick[LINES_OF_BRICKS][BRICKS_PER_LINE] = { { { { 0 } } } };\n</code></pre>"},{"location":"blogpost/VanDam/draft/#difficulty-of-integration-and-making-changes","title":"Difficulty of integration and making changes","text":"<p>I think that Raylib should be relatively easy to integrate and make changes with. Its website mentions instructions for compiling on the command line, with Makefiles, and with CMake. Therefore, I could see Raylib being introduced into many different types of applications and many types of build systems.</p> <p>I noticed that the provided example Arkanoid code only allowed for movement with the arrow keys. I found that the <code>IsKeyDown()</code> function is being used inside <code>UpdateGame()</code> to check for user input. Adding more checks for <code>IsKeyDown(KEY_A)</code> and <code>IsKeyDown(KEY_D)</code> was very easy, so I could see that making code changes is relatively easy with Raylib.</p>"},{"location":"blogpost/VanDam/draft/#when-i-would-recommend-using-raylib","title":"When I would recommend using Raylib","text":"<p>The most obvious use case for using Raylib would be someone who knows how to use C or C++ and wants to develop a video game with a simple game engine. I could see this being ideal for a game jam, where a game would need to be quickly developed and iterated upon, and developers are typically encouraged to make their games able to run in a web browser. Since Raylib can be compiled with Emscripten, it can be run in any web browser that supports WebAssembly, which includes all modern browsers.</p>"},{"location":"blogpost/VanDam/draft/#tips-for-new-raylib-users","title":"Tips for new Raylib users","text":"<p>The biggest tip I would give to new Raylib users would be to plan your build system ahead of time. I tried to start this blog post by following many different tutorials, and none of them gave me the exact instructions to set up Raylib with Emscripten specifically. Raylib supports many different platforms, but as shown from my experience, it's challenging to get it working perfectly the first time.</p>"},{"location":"blogpost/VanDam/final/","title":"Raylib with Emscripten exploration","text":""},{"location":"blogpost/VanDam/final/#author-jayson-van-dam","title":"Author: Jayson Van Dam","text":""},{"location":"blogpost/VanDam/final/#overview","title":"Overview","text":"<p>My goal with this blog post is to get Raylib's Arkanoid example working in a web browser using the Emscripten compiler to compile C++ source code into WebAssembly. I will be following this guide to install both Emscripten and Raylib on Windows.</p>"},{"location":"blogpost/VanDam/final/#emscripten-windows-installation-steps","title":"Emscripten Windows installation steps","text":"<ol> <li>First, be sure that Python and Git are both installed on the system.</li> <li>Download the Emscripten SDK as a zip file from https://github.com/emscripten-core/emsdk/archive/refs/heads/main.zip</li> <li>Open the zip file (with 7-zip or another archiving tool), then go into the <code>emsdk-main</code> directory. Extract the contents of this directory to <code>C:\\emsdk\\</code></li> <li>Open Command Prompt, then run <code>cd C:\\emsdk\\</code></li> <li>Run <code>emsdk.bat install latest</code></li> <li>Run <code>emsdk.bat activate latest</code></li> <li>Run <code>emsdk_env.bat</code></li> <li>You should now be able to run <code>emcc --version</code>. It should give output similar to this:     <code>emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 3.1.47 (431685f05c67f0424c11473cc16798b9587bb536)     Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt)     This is free and open source software under the MIT license.     There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></li> <li>From now on, if you want to compile with Emscripten, then go to <code>C:\\emsdk</code> in File Explorer and run <code>emcmdprompt.bat</code>.</li> </ol>"},{"location":"blogpost/VanDam/final/#difficulty-of-raylib-installation","title":"Difficulty of Raylib installation","text":"<p>Raylib seems a bit more challenging to install. At first, I tried to run <code>pacman -S mingw-w64-x86_64-raylib</code> (as suggested in the Working on Windows wiki page), but this did not seem to work at first.</p> <p>Second, I tried downloading the Raylib installer at https://github.com/raysan5/raylib/releases/download/4.5.0/raylib_installer_v4.5.mingw.64bit.exe. This seemed to work better and installed Raylib at <code>C:\\raylib</code>.</p> <p>Then, I read a bit deeper and found that the instructions say that:     \"Before compiling your game, raylib library must be recompiled for HTML5,     generating <code>libraylib.a</code>.\"</p> <p>I got a few compilation errors before when trying to compile a game, so this makes much more sense. I used the instructions for \"2.2 Using Makefile\", which seemed to recompile raylib correctly.</p> <p>This is a screenshot of where I got the \"Using Makefile\" instructions for compiling the Raylib library:</p> <p></p> <p>When compiling the Arkanoid example game with <code>mingw32-make PLATFORM=PLATFORM_WEB -B -e</code>, it failed at first with this error message:     <code>C:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find ../../../raylib/src/libraylib.a: No such file or directory</code></p> <p>I thought that changing the raylib path would be much easier when compiling on the command line. I ran</p> <pre><code>emcc -o arkanoid.html arkanoid.cpp -Os -Wall C:\\raylib\\raylib\\src\\libraylib.a -I. -IC:\\raylib\\raylib\\src -L. -LC:\\raylib\\raylib\\src -s USE_GLFW=3 --shell-file C:\\raylib\\raylib\\src\\shell.html -DPLATFORM_WEB\n</code></pre> <p>and got this error message:     <code>arkanoid.cpp:119:28: error: non-constant-expression cannot be narrowed from type 'int' to 'float' in initializer list       [-Wc++11-narrowing]         119 |     brickSize = (Vector2){ GetScreenWidth()/BRICKS_PER_LINE, 40 };</code></p> <p>For assistance with this error, I looked to the Using raylib with Cpp page. This is a screenshot of the relevant part of the guide I looked at:</p> <p></p> <p>Since I changed the <code>arkanoid.c</code> example to <code>arkanoid.cpp</code>, I need to replace any instances of structure initialization with brace initialization. For these, I usually just needed to remove the parentheses around the type, so this C code from line 119:  <code>brickSize = (Vector2){ GetScreenWidth()/BRICKS_PER_LINE, 40 };</code>  would be converted into this C++ code:  <code>brickSize = Vector2{ static_cast&lt;float&gt;(GetScreenWidth()/BRICKS_PER_LINE), 40 };</code> </p> <p>How to compile the Arkanoid example: 1. Open File Explorer, launch <code>C:\\emsdk\\emcmdprompt.bat</code> 1. Change directory into <code>\\path\\to\\source\\</code> 1. Run this command:     <code>emcc -o arkanoid.html arkanoid.cpp -Os -Wall C:\\raylib\\raylib\\src\\libraylib.a -I. -IC:\\raylib\\raylib\\src -L. -LC:\\raylib\\raylib\\src -s USE_GLFW=3 --shell-file C:\\raylib\\raylib\\src\\shell.html -DPLATFORM_WEB</code></p> <p>How to test the Arkanoid example: 1. Change directory into <code>\\path\\to\\source\\</code> 1. Launch the web server with <code>python -m http.server 8080</code> 1. Visit <code>http://localhost:8080</code> in a web browser</p>"},{"location":"blogpost/VanDam/final/#experience-getting-functions-and-classes-working","title":"Experience getting functions and classes working","text":"<p>As stated above, I did have to change the <code>brickSize</code> initialization in order to compile <code>arkanoid.cpp</code> correctly. I did not have to change any other code for the functionality to work, but there were also a few compiler warnings:</p> <pre><code>arkanoid.cpp:62:26: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n62  | static Player player = { 0 };\n    |                          ^\n    |                          {}\narkanoid.cpp:63:22: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n63  | static Ball ball = { 0 };\n    |                      ^\n    |                      {}\narkanoid.cpp:64:58: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n64  | static Brick brick[LINES_OF_BRICKS][BRICKS_PER_LINE] = { 0 };\n    |                                                          ^\n    |                                                          {}\narkanoid.cpp:64:58: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n64  | static Brick brick[LINES_OF_BRICKS][BRICKS_PER_LINE] = { 0 };\n    |                                                          ^\n    |                                                          {}\narkanoid.cpp:64:58: warning: suggest braces around initialization of subobject [-Wmissing-braces]\n64  | static Brick brick[LINES_OF_BRICKS][BRICKS_PER_LINE] = { 0 };\n    |                                                          ^\n    |                                                          {}\n</code></pre> <p>To get rid of these compiler warnings, I changed lines 62-64 of <code>arkanoid.cpp</code> to include curly braces around the initializations: </p> <pre><code>static Player player = { {0} };\nstatic Ball ball = { {0} };\nstatic Brick brick[LINES_OF_BRICKS][BRICKS_PER_LINE] = { { { { 0 } } } };\n</code></pre>"},{"location":"blogpost/VanDam/final/#difficulty-of-integration-and-making-changes","title":"Difficulty of integration and making changes","text":"<p>I think that Raylib should be relatively easy to integrate and make changes with. Its website mentions instructions for compiling on the command line, with Makefiles, and with CMake. Therefore, I could see Raylib being introduced into many different types of applications and many types of build systems.</p> <p>I noticed that the provided example Arkanoid code only allowed for movement with the arrow keys. I found that the <code>IsKeyDown()</code> function is being used inside <code>UpdateGame()</code> to check for user input. Adding more checks for <code>IsKeyDown(KEY_A)</code> and <code>IsKeyDown(KEY_D)</code> was very easy, so I could see that making code changes is relatively easy with Raylib.</p>"},{"location":"blogpost/VanDam/final/#when-i-would-recommend-using-raylib","title":"When I would recommend using Raylib","text":"<p>The most obvious use case for using Raylib would be someone who knows how to use C or C++ and wants to develop a video game with a simple game engine. I could see this being ideal for a game jam, where a game would need to be quickly developed and iterated upon, and developers are typically encouraged to make their games able to run in a web browser. Since Raylib can be compiled with Emscripten, it can be run in any web browser that supports WebAssembly, which includes all modern browsers.</p>"},{"location":"blogpost/VanDam/final/#tips-for-new-raylib-users","title":"Tips for new Raylib users","text":"<p>The biggest tip I would give to new Raylib users would be to plan your build system ahead of time. I tried to start this blog post by following many different tutorials, and none of them gave me the exact instructions to set up Raylib with Emscripten specifically. Raylib supports many different platforms, but as shown from my experience, it's challenging to get it working perfectly the first time.</p>"},{"location":"blogpost/Villalpando/final/","title":"Final","text":"<p>When you have a large collection of similar objects, you usually store them. You store your groceries in the fridge, your clothes in the closet, and your valuables in safes. The same concept applies to programming. In C++, when you have multiple variables or objects, you store them in what we call, Containers. </p>"},{"location":"blogpost/Villalpando/final/#in-c-there-are-3-main-types-of-containers","title":"In C++, there are 3 main types of containers:","text":"<ol> <li> <p>Sequence Containers</p> </li> <li> <p>Associative Containers</p> </li> <li> <p>Unordered Associative Containers</p> </li> </ol> <p>This blogpost will conduct a somewhat deep-dive on Sequence Containers and their applications in the C++ programming language.</p>"},{"location":"blogpost/Villalpando/final/#what-are-sequence-containers","title":"What are Sequence Containers?","text":"<p>According to cppreference.com, \u201cSequence containers implement data  structures which can be accessed sequentially.\u201d.</p> <p>Sequence Containers, hence the name, have an emphasis on the fact that objects within this data  structure can be accessed and stored in a sequential manner. This means that objects are stored one after another, and that when accessing these objects that you stored, you can do that in the same way in which you stored them.</p> <p>Let\u2019s see how this looks in code, specifically with vectors.</p> <pre><code>std::vector&lt;int&gt; myVector; \n\nmyVector.push_back(1); // [1] \nmyVector.push_back(2); // [1, 2] \nmyVector.push_back(3); // [1, 2, 3] \nmyVector.push_back(4); // [1, 2, 3, 4]\n\n</code></pre> <p>Here, we create a vector called, myVector and store 4 elements sequentially in this vector.</p> <ul> <li> <p>The vector starts out as empty, []</p> </li> <li> <p>When we .push_back 1 upon the vector, the vector is now [1]</p> </li> <li> <p>When we .push_back 2 upon the vector, the vector is now [1, 2]</p> </li> <li> <p>When we .push_back 3 upon the vector, the vector is now [1, 2, 3]</p> </li> <li> <p>When we .push_back 4 upon the vector, the vector is now [1, 2, 3, 4]</p> </li> </ul> <p>This is what is meant by sequential storage. We can also access these elements sequentially.</p> <pre><code>std::cout &lt;&lt; myVector[2];\nOutput: 3\n</code></pre> <p>By putting myVector[2], we sequentially access the third element in the vector. The reason that we also put [2] and not [3] for the third element is because C++ works on a zero-based index, meaning that indexing starts at 0. </p>"},{"location":"blogpost/Villalpando/final/#what-are-the-different-types-of-sequence-containers","title":"What are the different types of Sequence Containers?","text":"<p>We have the following:</p> <pre><code>1. Std::vector\n2. Std::deque\n3. Std::list\n4. Std::forward_list\n5. Std::array\n</code></pre> <p>These are the 5 main sequence containers in C++. For this blog post, I want to conduct a deep dive into what exactly a <code>std::deque</code> and a <code>std::forward_list</code> are. In addition, I would like to compare and contrast both.</p>"},{"location":"blogpost/Villalpando/final/#stddeque","title":"std::deque","text":"<p><code>std::deque</code> short for double-ended queue, is a container that allows for insertion and deletion at the beginning and the end of the queue. </p> <p>Usually, deques are a fixed size, so if you are trying to push elements onto a deque past its size then you\u2019ll have to create a new deque. </p>"},{"location":"blogpost/Villalpando/final/#a-deque-performs-as-follows","title":"A deque performs as follows:","text":"<ul> <li>Insertion &amp; Deletion (at either end): O(1)</li> <li>Insertion &amp;  Deletion O(n)</li> </ul> <p>Deques are a great data structure to use if you need really speedy insertion &amp; deletions due to the nature of a queue. </p> <p>However, they can tend to use a lot of memory due the design of the deque.</p>"},{"location":"blogpost/Villalpando/final/#stdforward_list","title":"std::forward_list","text":"<p><code>std::forward_list</code> is a container that uses singly linked lists, but, compared to std::list forward_lists are more space efficent. </p>"},{"location":"blogpost/Villalpando/final/#a-forward-list-performs-as-follows","title":"A forward list performs as follows:","text":"<ul> <li>Insertion &amp; Deletion (at the front): O(1)</li> <li>Insertion &amp; Deletion: O(n)</li> </ul> <p>Forward lists are very memory efficient, so the best use case for them is when you are most concerned about memory. </p> <p>Be careful, as forward lists will not be a good data  structure to use if you need to directly access memory or do a lot of insertion/deletion.</p>"},{"location":"blogpost/Villalpando/final/#comparing-contrasting-stddeque-and-stdforward_list","title":"Comparing &amp; contrasting <code>std::deque</code> and  <code>std::forward_list</code>","text":"<p>A forward list is much more memory efficient than a deque because deques manage multiple arrays. But, a deque can do much more than a forward list. It has the ability to do bidirectional traversal and random access unlike forward lists.</p> <p>Both data structures do decent at insertion and deletion. While deques are really good at working from both ends, forward lists (hence the word forward at the beginning) are more efficient with insertion &amp; deletion at the front. </p> <p>To summarize, I would recommend using deques if you aren\u2019t worried about memory, want something similar to a vector. I would also recommend to use forward_lists if you are super concerned about space and don\u2019t need a lot of functionality with the data structure.</p>"},{"location":"blogpost/Villalpando/final/#associative-containers","title":"Associative Containers","text":"<p>Associative containers automatically sort elements following a specific order and are mainly used for searching and sorting operations. These include <code>set</code>, <code>map</code>, <code>multiset</code>, and <code>multimap</code>.</p>"},{"location":"blogpost/Villalpando/final/#set","title":"Set","text":"<ul> <li>Description: A collection of unique elements, sorted by their values.</li> <li>Use Case: Ideal for maintaining a collection of unique items with fast retrieval.</li> </ul>"},{"location":"blogpost/Villalpando/final/#example","title":"Example:","text":"<pre><code>#include &lt;set&gt;\nstd::set&lt;int&gt; s = {3, 1, 4, 1, 5};\ns.insert(2); // Adds 2 to the set\n</code></pre>"},{"location":"blogpost/Villalpando/final/#map","title":"Map","text":"<ul> <li>Description: A collection of key-value pairs, sorted by keys, where each key is unique.</li> <li>Use Case: Useful for associating values with keys (like a dictionary).</li> </ul>"},{"location":"blogpost/Villalpando/final/#example_1","title":"Example:","text":"<pre><code>#include &lt;map&gt;\nstd::map&lt;std::string, int&gt; age = {{\"Alice\", 30}, {\"Bob\", 25}};\nage[\"Charlie\"] = 28; // Adds a new key-value pair\n</code></pre>"},{"location":"blogpost/Villalpando/final/#unordered-associative-containers","title":"Unordered Associative Containers","text":"<p>Unordered associative containers store elements in no particular order and provide faster operations compared to ordered associative containers. They include <code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, and <code>unordered_multimap</code>.</p>"},{"location":"blogpost/Villalpando/final/#unordered-set","title":"Unordered Set","text":"<ul> <li>Description: Similar to set, but uses a hash table for storage, providing faster access.</li> <li>Use Case: Best for situations where order doesn't matter, but fast access and uniqueness of elements are important.</li> </ul>"},{"location":"blogpost/Villalpando/final/#example_2","title":"Example:","text":"<pre><code>#include &lt;unordered_set&gt;\nstd::unordered_set&lt;int&gt; us = {4, 1, 2, 3, 4};\nus.insert(5); // Adds 5 to the set\n</code></pre>"},{"location":"blogpost/Villalpando/final/#unordered-map","title":"Unordered Map","text":"<ul> <li>Description: Similar to map, but uses a hash table, allowing for faster access.</li> <li>Use Case: Ideal when you need a key-value storage with fast access and order is not a concern.</li> </ul>"},{"location":"blogpost/Villalpando/final/#example_3","title":"Example:","text":"<pre><code>#include &lt;unordered_map&gt;\nstd::unordered_map&lt;std::string, int&gt; um = {{\"Alice\", 30}, {\"Bob\", 25}};\num[\"Charlie\"] = 28; // Adds a new key-value pair\n</code></pre>"},{"location":"blogpost/Villalpando/final/#conclusion","title":"Conclusion","text":"<p>Choosing the right container in C++ depends on the specific requirements of your application. Sequence containers like <code>vector</code> and <code>deque</code> are great for ordered data and offer fast access. Associative containers such as <code>set</code> and <code>map</code> provide sorted storage and efficient lookup. Unordered associative containers, including <code>unordered_set</code> and <code>unordered_map</code>, offer the fastest operations where order is not important. Understanding these containers and their use cases is crucial for efficient and effective C++ programming.</p>"},{"location":"blogpost/Villalpando/final/#detailed-comparisons-of-container-types","title":"Detailed Comparisons of Container Types","text":""},{"location":"blogpost/Villalpando/final/#sequence-vs-associative-vs-unordered-associative-containers","title":"Sequence vs Associative vs Unordered Associative Containers","text":"<ul> <li>Sequence Containers: Maintain the order of insertion. Examples include <code>vector</code>, <code>deque</code>, <code>list</code>, <code>forward_list</code>, and <code>array</code>. Best for scenarios where order matters and you need fast access based on position.</li> <li>Associative Containers: Automatically sort elements and are ideal for sorted data management. Includes <code>set</code>, <code>map</code>, <code>multiset</code>, and <code>multimap</code>. Use these when you need efficient search, insertion, and deletion operations.</li> <li>Unordered Associative Containers: Store elements in a hash table, offering faster operations. Includes <code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, and <code>unordered_multimap</code>. Choose these for faster access where element order is not a concern.</li> </ul>"},{"location":"blogpost/Villalpando/final/#other-sequence-containers","title":"Other Sequence Containers","text":""},{"location":"blogpost/Villalpando/final/#list","title":"List","text":"<ul> <li>Description: Doubly-linked list allowing insertion and deletion from anywhere in the container.</li> <li>Use Case: Ideal when you need frequent insertions and deletions from anywhere in the list.</li> </ul>"},{"location":"blogpost/Villalpando/final/#example_4","title":"Example:","text":"<pre><code>#include &lt;list&gt;\nstd::list&lt;int&gt; lst = {1, 2, 3};\nlst.push_front(0); // Insert at the beginning\nlst.push_back(4); // Insert at the end\n</code></pre>"},{"location":"blogpost/Villalpando/final/#array","title":"Array","text":"<ul> <li>Description: Static size array offering fast fixed-size operations.</li> <li>Use Case: Best when you have a fixed number of elements and need fast access by index.</li> </ul>"},{"location":"blogpost/Villalpando/final/#example_5","title":"Example:","text":"<pre><code>#include &lt;array&gt;\nstd::array&lt;int, 5&gt; arr = {1, 2, 3, 4, 5};\nstd::cout &lt;&lt; arr[3]; // Accessing the fourth element\n</code></pre>"},{"location":"blogpost/Villalpando/final/#practical-situations-for-different-containers","title":"Practical Situations for Different Containers","text":"<ul> <li>Vectors for Dynamic Arrays: Use <code>vector</code> when you need a dynamic array with the ability to resize and provide random access.</li> <li>Sets for Unique Sorted Elements: Choose <code>set</code> when managing a collection of unique items that need to be in sorted order.</li> <li>Unordered Maps for Fast Key-Value Access: Opt for <code>unordered_map</code> when you require a key-value pair storage with fast access, and the order is not a priority.</li> </ul>"},{"location":"blogpost/Villalpando/final/#in-depth-c-references","title":"In-Depth C++ References","text":"<ul> <li>cppreference.com: A detailed resource for understanding the implementations and nuances of various container  classes.</li> <li>C++ Primer (5th Edition) by Stanley B. Lippman: This book provides a comprehensive introduction to C++ with a focus on modern practices.</li> <li>Effective STL by Scott Meyers: Offers specific guidance on the effective use of the STL, including containers and algorithms.</li> </ul>"},{"location":"blogpost/Villalpando/final/#take-away","title":"Take Away","text":"<p>The choice of container in C++ should be guided by the specific needs of your application. Whether you require ordered data management, efficient sorting and searching, or fast access without the concern for order, there is a container designed for your use case.</p>"},{"location":"Core%20Project/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace clogged Tools for debug-logging that can be easily controlled. <ul> <li>class Logger Logger class with colors and team names. </li> </ul> </li> <li>namespace cse491 A base class interface for all agent types. <ul> <li>class AgentBase </li> <li>struct CellType Simple data structure to hold info about a TYPE of cell in the world. </li> <li>class CoreObject </li> <li>class Entity </li> <li>class GridPosition Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. </li> <li>class InterfaceBase </li> <li>class ItemBase </li> <li>struct Property </li> <li>struct PropertyBase </li> <li>class WorldBase </li> <li>class WorldGrid A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. </li> <li>struct is_any_map Type trait to determine if we are working with any type of map. </li> <li>struct is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; </li> <li>struct is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; </li> <li>struct is_vector Type trait to determine if we are working with a vector. </li> <li>struct is_vector&lt; std::vector&lt; T &gt; &gt; </li> </ul> </li> <li>namespace std </li> <li>namespace worldlang A base class for all World modules. </li> </ul>"},{"location":"Core%20Project/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir core <ul> <li>file AgentBase.hpp </li> <li>file CoreObject.hpp </li> <li>file Data.hpp </li> <li>file EasyLogging.hpp </li> <li>file Entity.cpp </li> <li>file Entity.hpp </li> <li>file GridPosition.hpp </li> <li>file InterfaceBase.hpp </li> <li>file ItemBase.hpp </li> <li>file Property.hpp </li> <li>file Serialize.hpp </li> <li>file WorldBase.hpp </li> <li>file WorldGrid.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"Core%20Project/namespaceclogged/","title":"Namespace clogged","text":"<p>Namespace List &gt; clogged</p> <p>Tools for debug-logging that can be easily controlled. More...</p>"},{"location":"Core%20Project/namespaceclogged/#classes","title":"Classes","text":"Type Name class Logger Logger class with colors and team names."},{"location":"Core%20Project/namespaceclogged/#public-types","title":"Public Types","text":"Type Name enum Color Colors for logging. enum LogLevel Log levels for logging. enum Team Teams Names for logging."},{"location":"Core%20Project/namespaceclogged/#public-attributes","title":"Public Attributes","text":"Type Name const LogLevel LOGLEVEL   = = LogLevel::DEBUGLevel of logging @TODO: Change this to be a flag in the CMakeLists.txt."},{"location":"Core%20Project/namespaceclogged/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: ALPHA </p>"},{"location":"Core%20Project/namespaceclogged/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Core%20Project/namespaceclogged/#enum-color","title":"enum Color","text":"<pre><code>enum clogged::Color {\n    RESET = 0,\n    BLUE = 34,\n    GREEN = 32,\n    RED = 31\n};\n</code></pre>"},{"location":"Core%20Project/namespaceclogged/#enum-loglevel","title":"enum LogLevel","text":"<pre><code>enum clogged::LogLevel {\n    DEBUG,\n    INFO,\n    WARNING,\n    ERR,\n    NA\n};\n</code></pre>"},{"location":"Core%20Project/namespaceclogged/#enum-team","title":"enum Team","text":"<pre><code>enum clogged::Team {\n    TEAM_1,\n    TEAM_2,\n    TEAM_3,\n    TEAM_4,\n    TEAM_5,\n    TEAM_6,\n    TEAM_7,\n    TEAM_8,\n    TEAM_9,\n    GENERAL,\n    NA\n};\n</code></pre>"},{"location":"Core%20Project/namespaceclogged/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Core%20Project/namespaceclogged/#variable-loglevel","title":"variable LOGLEVEL","text":"<pre><code>const LogLevel LOGLEVEL;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/EasyLogging.hpp</code></p>"},{"location":"Core%20Project/classclogged_1_1_logger/","title":"Class clogged::Logger","text":"<p>ClassList &gt; clogged &gt; Logger</p> <p>Logger class with colors and team names.More...</p> <ul> <li><code>#include &lt;EasyLogging.hpp&gt;</code></li> </ul>"},{"location":"Core%20Project/classclogged_1_1_logger/#public-functions","title":"Public Functions","text":"Type Name Logger &amp; operator&lt;&lt; (Team team) Sets the Team name for the current log. Logger &amp; operator&lt;&lt; (LogLevel logLevel) sets the log level for the current log Logger &amp; operator&lt;&lt; (Color color) colors of the log Logger &amp; operator&lt;&lt; (std::ostream &amp;(*)(std::ostream &amp;) manipulator) Manipulator for endl so that we can reset the values when a team is done logging. Logger &amp; operator&lt;&lt; (const T &amp; value) Aye I used a template."},{"location":"Core%20Project/classclogged_1_1_logger/#public-static-functions","title":"Public Static Functions","text":"Type Name Logger &amp; Log ()  Logger &amp; Log (T &amp;&amp; arg1, EXTRA_Ts &amp;&amp;... extra_args)  std::ostream &amp; endl (std::ostream &amp; os) Custom endl to reset the values."},{"location":"Core%20Project/classclogged_1_1_logger/#detailed-description","title":"Detailed Description","text":"<p>Not a fan of this practice But would prefer not to use parenthesis </p> <p>Author:</p> <p>@amantham20 @chatGPT</p> <p>I was about to name this clogged.</p> <p>This is a custom logger class that can be used to log messages to the console. </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator","title":"function operator&lt;&lt;","text":"<p>Sets the Team name for the current log. </p> <pre><code>inline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    Team team\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>team</code> name of the team </li> </ul> <p>Returns:</p> <p>Logger&amp; </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator_1","title":"function operator&lt;&lt;","text":"<p>sets the log level for the current log </p> <pre><code>inline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    LogLevel logLevel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>logLevel</code> Level/Type of the log </li> </ul> <p>Returns:</p> <p>Logger&amp; </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator_2","title":"function operator&lt;&lt;","text":"<p>colors of the log </p> <pre><code>inline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    Color color\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>color</code> </li> </ul> <p>Returns:</p> <p>Logger&amp; </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator_3","title":"function operator&lt;&lt;","text":"<p>Manipulator for endl so that we can reset the values when a team is done logging. </p> <pre><code>inline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    std::ostream &amp;(*)(std::ostream &amp;) manipulator\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>manipulator</code> </li> </ul> <p>Returns:</p> <p>Logger&amp; </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-operator_4","title":"function operator&lt;&lt;","text":"<p>Aye I used a template. </p> <pre><code>template&lt;typename T typename T&gt;\ninline Logger &amp; clogged::Logger::operator&lt;&lt; (\n    const T &amp; value\n) \n</code></pre> <p>Function to log the value</p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>value</code> </li> </ul> <p>Returns:</p> <p>Logger&amp;</p> <p>@TODO: Might have to change this so that we only break a team log when a new team is set. aka ensure that logger &lt;&lt; Team::TEAM_1 &lt;&lt; \"Hello\" &lt;&lt; \"World\" &lt;&lt; endl; works in one line with one team print </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Core%20Project/classclogged_1_1_logger/#function-log-12","title":"function Log [1/2]","text":"<pre><code>static inline Logger &amp; clogged::Logger::Log () \n</code></pre> <p>Only instance of the logger once Changes requested from Dr.@ofria</p> <p>Authors:</p> <p>@mercere99 </p> <p>Returns:</p> <p>a unique Logger instance </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-log-22","title":"function Log [2/2]","text":"<pre><code>template&lt;typename T typename T, typename... EXTRA_Ts&gt;\nstatic inline Logger &amp; clogged::Logger::Log (\n    T &amp;&amp; arg1,\n    EXTRA_Ts &amp;&amp;... extra_args\n) \n</code></pre> <p>Only instance of the logger once Changes requested from Dr.@ofria</p> <p>Authors:</p> <p>@mercere99 </p> <p>Parameters:</p> <ul> <li><code>arg1</code> Set of values that you want to have logged. </li> </ul> <p>Returns:</p> <p>Unique Logger instance </p>"},{"location":"Core%20Project/classclogged_1_1_logger/#function-endl","title":"function endl","text":"<p>Custom endl to reset the values. </p> <pre><code>static inline std::ostream &amp; clogged::Logger::endl (\n    std::ostream &amp; os\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> </li> </ul> <p>Returns:</p> <p>std::ostream&amp; </p> <p>The documentation for this class was generated from the following file <code>source/core/EasyLogging.hpp</code></p>"},{"location":"Core%20Project/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>A base class interface for all agent types. More...</p>"},{"location":"Core%20Project/namespacecse491/#classes","title":"Classes","text":"Type Name class AgentBase struct CellType Simple data structure to hold info about a TYPE of cell in the world. class CoreObject class Entity class GridPosition Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. class InterfaceBase class ItemBase struct Property &lt;typename T&gt; struct PropertyBase class WorldBase class WorldGrid A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. struct is_any_map &lt;typename T&gt;Type trait to determine if we are working with any type of map. struct is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; &lt;typename KEY_T, typename VALUE_T&gt; struct is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; &lt;typename KEY_T, typename VALUE_T&gt; struct is_vector &lt;typename T&gt;Type trait to determine if we are working with a vector. struct is_vector&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt;"},{"location":"Core%20Project/namespacecse491/#public-types","title":"Public Types","text":"Type Name enum PropertyType Common types of properties in network serialization. enum State States that an agent can be in. enum WorldType Enum for World types in network serialization. typedef std::map&lt; size_t, std::unique_ptr&lt; AgentBase &gt; &gt; agent_map_t Maps of agent IDs to agent pointers. typedef std::map&lt; size_t, std::unique_ptr&lt; ItemBase &gt; &gt; item_map_t Maps of item IDs to item pointers. typedef std::vector&lt; CellType &gt; type_options_t Available CellTypes will be passed around as a vector of options."},{"location":"Core%20Project/namespacecse491/#public-static-functions","title":"Public Static Functions","text":"Type Name T DeserializeAs (std::istream &amp; is) Helper function to deserialize and return a specified type. void DeserializeFunction (std::istream &amp; is, std::function&lt; void(T)&gt; set_fun) Helper function to deserialize a member variables from a function. void DeserializeValue (std::istream &amp; is, T &amp; var) Helper function to deserialize a single member variable. void DeserializeValue_Map (std::istream &amp;, T &amp;)  void DeserializeValue_Map (std::istream &amp; is, MAP_T &amp; var) Helper specialty function to deserialize a unordered_map member variable. void DeserializeValue_Vector (std::istream &amp; is, std::vector&lt; T &gt; &amp; var) Helper specialty function to deserialize a vector-based member variable. void SerializeValue (std::ostream &amp; os, const T &amp; var) Helper function to serialize a single member variable. void SerializeValue_Map (std::ostream &amp; os, const T &amp; var) Helper specialty function to serialize a unordered_map member variable. void SerializeValue_Vector (std::ostream &amp; os, const std::vector&lt; T &gt; &amp; var) Helper specialty function to serialize a vector-based member variable."},{"location":"Core%20Project/namespacecse491/#detailed-description","title":"Detailed Description","text":"<p>A simple 2D Grid container.</p> <p>Tools to simplify serializing classes.</p> <p>A class to maintain arbitrary data and facilitate its use.</p> <p>A base class interface for all non-agent item types.</p> <p>A base class for all player-interface types.</p> <p>A mechanism of identifying a grid cell, as well as a position within the cell.</p> <p>A base class for all items or agents that can exist on the grid.</p> <p>Set of types used throughout the codebase.</p> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: ALPHA </p>"},{"location":"Core%20Project/namespacecse491/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Core%20Project/namespacecse491/#enum-propertytype","title":"enum PropertyType","text":"<pre><code>enum cse491::PropertyType {\n    t_double,\n    t_int,\n    t_char,\n    t_string,\n    t_position,\n    t_bool,\n    t_other\n};\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#enum-state","title":"enum State","text":"<pre><code>enum cse491::State {\n    Healthy,\n    Taking_Damage,\n    Dying,\n    Deceased\n};\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#enum-worldtype","title":"enum WorldType","text":"<pre><code>enum cse491::WorldType {\n    w_maze,\n    w_second,\n    w_generative,\n    w_manual\n};\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#typedef-agent_map_t","title":"typedef agent_map_t","text":"<pre><code>using agent_map_t =  std::map&lt;size_t, std::unique_ptr&lt;AgentBase&gt; &gt;;\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#typedef-item_map_t","title":"typedef item_map_t","text":"<pre><code>using item_map_t =  std::map&lt;size_t, std::unique_ptr&lt;ItemBase&gt; &gt;;\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#typedef-type_options_t","title":"typedef type_options_t","text":"<pre><code>using type_options_t =  std::vector&lt;CellType&gt;;\n</code></pre>"},{"location":"Core%20Project/namespacecse491/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Core%20Project/namespacecse491/#function-deserializeas","title":"function DeserializeAs","text":"<p>Helper function to deserialize and return a specified type. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic T cse491::DeserializeAs (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Input stream to write from. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-deserializefunction","title":"function DeserializeFunction","text":"<p>Helper function to deserialize a member variables from a function. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::DeserializeFunction (\n    std::istream &amp; is,\n    std::function&lt; void(T)&gt; set_fun\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Input stream to write from. </li> <li><code>var</code> Variable to serialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-deserializevalue","title":"function DeserializeValue","text":"<p>Helper function to deserialize a single member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::DeserializeValue (\n    std::istream &amp; is,\n    T &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Input stream to write from. </li> <li><code>var</code> Variable to deserialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-deserializevalue_map","title":"function DeserializeValue_Map","text":"<pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::DeserializeValue_Map (\n    std::istream &amp;,\n    T &amp;\n) \n</code></pre>"},{"location":"Core%20Project/namespacecse491/#function-deserializevalue_map_1","title":"function DeserializeValue_Map","text":"<p>Helper specialty function to deserialize a unordered_map member variable. </p> <pre><code>template&lt;typename MAP_T typename MAP_T&gt;\nstatic void cse491::DeserializeValue_Map (\n    std::istream &amp; is,\n    MAP_T &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> Input stream to read from. </li> <li><code>var</code> Variable to deserialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-deserializevalue_vector","title":"function DeserializeValue_Vector","text":"<p>Helper specialty function to deserialize a vector-based member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::DeserializeValue_Vector (\n    std::istream &amp; is,\n    std::vector&lt; T &gt; &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Input stream to read from. </li> <li><code>var</code> Variable to deserialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-serializevalue","title":"function SerializeValue","text":"<p>Helper function to serialize a single member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::SerializeValue (\n    std::ostream &amp; os,\n    const T &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to write to. </li> <li><code>var</code> Variable to serialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-serializevalue_map","title":"function SerializeValue_Map","text":"<p>Helper specialty function to serialize a unordered_map member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::SerializeValue_Map (\n    std::ostream &amp; os,\n    const T &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to write to. </li> <li><code>var</code> Variable to serialize. </li> </ul>"},{"location":"Core%20Project/namespacecse491/#function-serializevalue_vector","title":"function SerializeValue_Vector","text":"<p>Helper specialty function to serialize a vector-based member variable. </p> <pre><code>template&lt;typename T typename T&gt;\nstatic void cse491::SerializeValue_Vector (\n    std::ostream &amp; os,\n    const std::vector&lt; T &gt; &amp; var\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to write to. </li> <li><code>var</code> Variable to serialize. </li> </ul> <p>The documentation for this class was generated from the following file <code>source/core/AgentBase.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/","title":"Class cse491::AgentBase","text":"<p>ClassList &gt; cse491 &gt; AgentBase</p> <p>Inherits the following classes: cse491::Entity</p> <p>Inherited by the following classes: cse491::InterfaceBase</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#public-functions","title":"Public Functions","text":"Type Name virtual AgentBase &amp; AddAction (const std::string &amp; action_name, size_t action_id) Provide a new action that this agent can take. AgentBase (size_t id, const std::string &amp; name) Default value upon initialization. virtual void Deserialize_impl (std::istream &amp; is) overrideDeserialize item-specific values and call Entity 's Deserialize_impl. size_t GetActionID (const std::string &amp; action_name) constReturn an action ID if that action exists, otherwise return zero. int GetActionResult () constRetrieve the result of the most recent action. State GetAgentState () Get the current state of the Agent. virtual GridPosition GetNextPosition () Allow derived agents to provide an arbitrary next position for the world to move the agent to. virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. bool HasAction (const std::string &amp; action_name) constTest if agent already has a specified action. virtual bool Initialize () Run AFTER the world configures the agent, for additional tests or setup. virtual bool IsAgent () override constIs Entity an autonomous agent? virtual void Notify (const std::string &amp;, const std::string &amp;=\"none\") Send a notification to this agent, typically from the world. virtual size_t SelectAction (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) Decide the next action for this agent to perform; should be overridden! virtual void Serialize_impl (std::ostream &amp; os) override constSerialize item-specific values and call Entity 's Serialize_impl. void SetActionResult (int result) Update the result from the most recent action. void TakeDamage (cse491::AgentBase &amp; agent) If the agent is in State::Taking_Damage, decrease the health by the damage factor once per timestep. void UpdateAgentState (cse491::AgentBase &amp; agent) Updates an Agent's state depending on health. void storeActionMap (std::string name)  ~AgentBase () = default"},{"location":"Core%20Project/classcse491_1_1_agent_base/#public-functions-inherited-from-cse491entity","title":"Public Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Entity &amp; AddItem (size_t id)  Entity &amp; AddItem (Entity &amp; item)  virtual void Deserialize_impl (std::istream &amp; is) overrideSerialize entity-specific values. Entity (size_t id, const std::string &amp; name)  Entity (const Entity &amp;) = delete Entity (Entity &amp;&amp;) = default size_t GetGridID () const size_t GetID () const std::vector&lt; size_t &gt; GetInventory () const const std::string &amp; GetName () const size_t GetNumProperties () constHow many properties does this entity have? GridPosition GetPosition () const const T &amp; GetProperty (const std::string &amp; name) constReturn the current value of the specified property. property_map_t &amp; GetPropertyMap () return the property map for the entity PropertyType GetPropertyType (const std::string &amp; name) const WorldBase &amp; GetWorld () const bool HasItem (size_t id) constInventory Management. bool HasProperty (const std::string &amp; name) constDoes this agent have a property with the specified name? bool HasWorld () const virtual bool IsAgent () constIs Entity an autonomous agent? virtual bool IsInterface () constIs Entity an interface for a human? virtual bool IsItem () constIs Entity an item? bool IsOnGrid (size_t in_grid_id) const Entity &amp; RemoveItem (size_t id)  Entity &amp; RemoveItem (Entity &amp; item)  Entity &amp; RemoveProperty (const std::string &amp; name) Completely remove a property from an Entity . virtual void Serialize_impl (std::ostream &amp; os) override constSerialize entity-specific values. Entity &amp; SetName (const std::string in_name)  Entity &amp; SetPosition (GridPosition in_pos, size_t grid_id=0)  Entity &amp; SetPosition (double x, double y)  Entity &amp; SetProperties () Allow for setting multiple properties at once. Entity &amp; SetProperties (const std::string &amp; name, VALUE_T &amp;&amp; value, EXTRA_Ts &amp;&amp;... extras)  Entity &amp; SetProperty (const std::string &amp; name, const T &amp; value) Change the value of the specified property (will create if needed) virtual Entity &amp; SetWorld (WorldBase &amp; in_world)  Entity &amp; operator= (const Entity &amp;) = delete Entity &amp; operator= (Entity &amp;&amp;) = delete virtual ~Entity () = default"},{"location":"Core%20Project/classcse491_1_1_agent_base/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-types-inherited-from-cse491entity","title":"Protected Types inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name typedef std::unordered_map&lt; std::string, std::unique_ptr&lt; PropertyBase &gt; &gt; property_map_t Every entity can have a simple set of properties (with values) associated with it."},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-attributes","title":"Protected Attributes","text":"Type Name int action Action that agent is currently performing. std::unordered_map&lt; std::string, size_t &gt; action_map Map of names to action ids. int action_result   = = 0Usually a one (success) or zero (failure). State agent_state   = = Healthy"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-attributes-inherited-from-cse491entity","title":"Protected Attributes inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name size_t grid_id   = = 0Which grid is this entity on? size_t id   = = 0Unique ID for this entity (0 is used for \"no ID\") std::vector&lt; size_t &gt; inventory What entity ids are held by this entity? std::string name   = = \"\"Name for this entity (E.g., \"Player 1\" or \"+2 Sword\") GridPosition position Where on the grid is this entity? property_map_t property_map"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-functions-inherited-from-cse491entity","title":"Protected Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Property&lt; T &gt; &amp; AsProperty (const std::string &amp; name) const"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_agent_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-addaction","title":"function AddAction","text":"<pre><code>inline virtual AgentBase &amp; cse491::AgentBase::AddAction (\n    const std::string &amp; action_name,\n    size_t action_id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-agentbase","title":"function AgentBase","text":"<pre><code>inline cse491::AgentBase::AgentBase (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Deserialize item-specific values and call Entity 's Deserialize_impl.</p> <pre><code>inline virtual void cse491::AgentBase::Deserialize_impl (\n    std::istream &amp; is\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> istream to read contents from. </li> </ul> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-getactionid","title":"function GetActionID","text":"<pre><code>inline size_t cse491::AgentBase::GetActionID (\n    const std::string &amp; action_name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-getactionresult","title":"function GetActionResult","text":"<pre><code>inline int cse491::AgentBase::GetActionResult () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-getagentstate","title":"function GetAgentState","text":"<p>Get the current state of the Agent. </p> <pre><code>inline State cse491::AgentBase::GetAgentState () \n</code></pre> <p>Returns:</p> <p>State enum of agent_state </p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-getnextposition","title":"function GetNextPosition","text":"<pre><code>inline virtual GridPosition cse491::AgentBase::GetNextPosition () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::AgentBase::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-hasaction","title":"function HasAction","text":"<pre><code>inline bool cse491::AgentBase::HasAction (\n    const std::string &amp; action_name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-initialize","title":"function Initialize","text":"<p>Run AFTER the world configures the agent, for additional tests or setup. </p> <pre><code>inline virtual bool cse491::AgentBase::Initialize () \n</code></pre> <p>Returns:</p> <p>Was the initialization successful? </p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-isagent","title":"function IsAgent","text":"<pre><code>inline virtual bool cse491::AgentBase::IsAgent () override const\n</code></pre> <p>Implements cse491::Entity::IsAgent</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-notify","title":"function Notify","text":"<p>Send a notification to this agent, typically from the world. </p> <pre><code>inline virtual void cse491::AgentBase::Notify (\n    const std::string &amp;,\n    const std::string &amp;=\"none\"\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>message</code> Contents of the notification </li> <li><code>msg_type</code> Category of message, such as \"item_alert\", \"damage\", or \"enemy\" This function is useful to notify users of events in the world, such as them taking damage, finding an item, etc. The message type can potentially also provide information to an autonomous agent assuming we come up with a standard list of types. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-selectaction","title":"function SelectAction","text":"<p>Decide the next action for this agent to perform; should be overridden! </p> <pre><code>inline virtual size_t cse491::AgentBase::SelectAction (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The agent is provided with the current WorldGrid </li> </ul> <p>Returns:</p> <p>ID associated with the action to perform; (zero is always \"no action\") </p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Serialize item-specific values and call Entity 's Serialize_impl.</p> <pre><code>inline virtual void cse491::AgentBase::Serialize_impl (\n    std::ostream &amp; os\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream to write contents to. </li> </ul> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-setactionresult","title":"function SetActionResult","text":"<pre><code>inline void cse491::AgentBase::SetActionResult (\n    int result\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-takedamage","title":"function TakeDamage","text":"<pre><code>inline void cse491::AgentBase::TakeDamage (\n    cse491::AgentBase &amp; agent\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-updateagentstate","title":"function UpdateAgentState","text":"<p>Updates an Agent's state depending on health. </p> <pre><code>inline void cse491::AgentBase::UpdateAgentState (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent whose state to update If the agent's health is between Max_health and 3 -&gt; Healthy If the agent's health is between 0 and 3 -&gt; Dying If the agent is Taking_Damage -&gt; Taking_Damage If the agent is at 0 or below -&gt; Dead </li> </ul> <p>See also: TakeDamage </p> <p>Returns:</p> <p>None </p>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-storeactionmap","title":"function storeActionMap","text":"<pre><code>inline void cse491::AgentBase::storeActionMap (\n    std::string name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#function-agentbase_1","title":"function ~AgentBase","text":"<pre><code>cse491::AgentBase::~AgentBase () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_agent_base/#variable-action","title":"variable action","text":"<pre><code>int action;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#variable-action_map","title":"variable action_map","text":"<pre><code>std::unordered_map&lt;std::string, size_t&gt; action_map;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#variable-action_result","title":"variable action_result","text":"<pre><code>int action_result;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_agent_base/#variable-agent_state","title":"variable agent_state","text":"<pre><code>State agent_state;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/AgentBase.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1_cell_type/","title":"Struct cse491::CellType","text":"<p>ClassList &gt; cse491 &gt; CellType</p> <p>Simple data structure to hold info about a TYPE of cell in the world. </p> <ul> <li><code>#include &lt;Data.hpp&gt;</code></li> </ul>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-attributes","title":"Public Attributes","text":"Type Name std::string desc Full description of what this type of cell is. std::string name Unique name for this type of cell (e.g., \"wall\", \"tree\", \"moon\") std::set&lt; std::string &gt; properties   = {}Set of properties for this cell type. char symbol Symbol for text representations (files or interface)"},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr char CELL_WALL   = = \"wall\" constexpr char CELL_WATER   = = \"water\""},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-functions","title":"Public Functions","text":"Type Name bool HasProperty (const std::string &amp; property) constChecks if the given property is set on this CellType . CellType &amp; RemoveProperty (const std::string &amp; property) Removes the specifed property from this CellType . CellType &amp; SetProperty (const std::string &amp; property) Adds the specifed property to this CellType ."},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-desc","title":"variable desc","text":"<pre><code>std::string desc;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-name","title":"variable name","text":"<pre><code>std::string name;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-properties","title":"variable properties","text":"<pre><code>std::set&lt;std::string&gt; properties;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-symbol","title":"variable symbol","text":"<pre><code>char symbol;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-cell_wall","title":"variable CELL_WALL","text":"<pre><code>constexpr char CELL_WALL[];\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#variable-cell_water","title":"variable CELL_WATER","text":"<pre><code>constexpr char CELL_WATER[];\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_cell_type/#function-hasproperty","title":"function HasProperty","text":"<pre><code>inline bool cse491::CellType::HasProperty (\n    const std::string &amp; property\n) const\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#function-removeproperty","title":"function RemoveProperty","text":"<pre><code>inline CellType &amp; cse491::CellType::RemoveProperty (\n    const std::string &amp; property\n) \n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_cell_type/#function-setproperty","title":"function SetProperty","text":"<pre><code>inline CellType &amp; cse491::CellType::SetProperty (\n    const std::string &amp; property\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/Data.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_core_object/","title":"Class cse491::CoreObject","text":"<p>ClassList &gt; cse491 &gt; CoreObject</p> <p>Inherited by the following classes: cse491::Entity,  cse491::GridPosition,  cse491::PropertyBase,  cse491::WorldGrid</p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#public-functions","title":"Public Functions","text":"Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_core_object/#protected-functions","title":"Protected Functions","text":"Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_core_object/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_core_object/#function-deserialize-12","title":"function Deserialize [1/2]","text":"<p>Restore the state of this object, extracting it from the provided stream. </p> <pre><code>inline void cse491::CoreObject::Deserialize (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>input_stream</code> The istream with full details about this object. This function takes in an istream that was previously written using the paired Serialize() function and restores the associated class. It should stop loading when all data is finished; this may be signalled by the \":::END\" directive. The stream should end ready for the next extraction. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-deserialize-22","title":"function Deserialize [2/2]","text":"<p>A version of Deserialize that accepts a filename to read this object from. </p> <pre><code>inline bool cse491::CoreObject::Deserialize (\n    std::string filename\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> The name of the file to open to load this object from. </li> </ul> <p>Returns:</p> <p>Success (true/false) </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-gettypename","title":"function GetTypeName","text":"<p>Access the derived name for this type. </p> <pre><code>inline std::string cse491::CoreObject::GetTypeName () const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-serialize-12","title":"function Serialize [1/2]","text":"<p>Store the current state of this object for later extraction. </p> <pre><code>inline void cse491::CoreObject::Serialize (\n    std::ostream &amp; os\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_stream</code> An ostream that the required information should be stored in. A derived class is required to store all information about itself in Serialize() and clearly note the end of storage to simplify de-serializing the data. This function will automatic add a start line that reads \":::START\" followed by the typename, and an end line with \":::END\" followed by the typename again. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-serialize-22","title":"function Serialize [2/2]","text":"<p>A version of Serialize that accepts a filename for saving just this object. </p> <pre><code>inline bool cse491::CoreObject::Serialize (\n    std::string filename\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> The name of the file to create for storing this object. </li> </ul> <p>Returns:</p> <p>Success (true/false) </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-operator","title":"function operator&lt;=&gt;","text":"<pre><code>auto cse491::CoreObject::operator&lt;=&gt; (\n    const CoreObject &amp;\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-coreobject","title":"function ~CoreObject","text":"<pre><code>inline virtual cse491::CoreObject::~CoreObject () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_core_object/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_core_object/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Override to restore the state of this object from the provided stream. </p> <pre><code>virtual void cse491::CoreObject::Deserialize_impl (\n    std::istream &amp;\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>input_stream</code> The istream with full details about this object. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-enddeserialize","title":"function EndDeserialize","text":"<p>Set up end of the deserialization for this class (does type checking) </p> <pre><code>inline bool cse491::CoreObject::EndDeserialize (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> Input stream to deserialize from. </li> </ul> <p>Returns:</p> <p>success (true/false) </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-endserialize","title":"function EndSerialize","text":"<p>Set up end of the serialization for this class (allows checking later) </p> <pre><code>inline void cse491::CoreObject::EndSerialize (\n    std::ostream &amp; os\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to Serialize into. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>virtual std::string cse491::CoreObject::GetTypeName_impl () const = 0\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Override to store the current state of this object for later extraction. </p> <pre><code>virtual void cse491::CoreObject::Serialize_impl (\n    std::ostream &amp;\n) const = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_stream</code> An ostream that the required information should be stored in. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-startdeserialize","title":"function StartDeserialize","text":"<p>Set up beginning of the deserialization for this class (does type checking) </p> <pre><code>inline bool cse491::CoreObject::StartDeserialize (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> Input stream to deserialize from. </li> </ul> <p>Returns:</p> <p>success (true/false) </p>"},{"location":"Core%20Project/classcse491_1_1_core_object/#function-startserialize","title":"function StartSerialize","text":"<p>Set up beginning of the serialization for this class (allows checking later) </p> <pre><code>inline void cse491::CoreObject::StartSerialize (\n    std::ostream &amp; os\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Output stream to Serialize into. </li> </ul> <p>The documentation for this class was generated from the following file <code>source/core/CoreObject.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_entity/","title":"Class cse491::Entity","text":"<p>ClassList &gt; cse491 &gt; Entity</p> <p>Inherits the following classes: cse491::CoreObject</p> <p>Inherited by the following classes: cse491::AgentBase,  cse491::ItemBase</p>"},{"location":"Core%20Project/classcse491_1_1_entity/#public-functions","title":"Public Functions","text":"Type Name Entity &amp; AddItem (size_t id)  Entity &amp; AddItem (Entity &amp; item)  virtual void Deserialize_impl (std::istream &amp; is) overrideSerialize entity-specific values. Entity (size_t id, const std::string &amp; name)  Entity (const Entity &amp;) = delete Entity (Entity &amp;&amp;) = default size_t GetGridID () const size_t GetID () const std::vector&lt; size_t &gt; GetInventory () const const std::string &amp; GetName () const size_t GetNumProperties () constHow many properties does this entity have? GridPosition GetPosition () const const T &amp; GetProperty (const std::string &amp; name) constReturn the current value of the specified property. property_map_t &amp; GetPropertyMap () return the property map for the entity PropertyType GetPropertyType (const std::string &amp; name) const WorldBase &amp; GetWorld () const bool HasItem (size_t id) constInventory Management. bool HasProperty (const std::string &amp; name) constDoes this agent have a property with the specified name? bool HasWorld () const virtual bool IsAgent () constIs Entity an autonomous agent? virtual bool IsInterface () constIs Entity an interface for a human? virtual bool IsItem () constIs Entity an item? bool IsOnGrid (size_t in_grid_id) const Entity &amp; RemoveItem (size_t id)  Entity &amp; RemoveItem (Entity &amp; item)  Entity &amp; RemoveProperty (const std::string &amp; name) Completely remove a property from an Entity . virtual void Serialize_impl (std::ostream &amp; os) override constSerialize entity-specific values. Entity &amp; SetName (const std::string in_name)  Entity &amp; SetPosition (GridPosition in_pos, size_t grid_id=0)  Entity &amp; SetPosition (double x, double y)  Entity &amp; SetProperties () Allow for setting multiple properties at once. Entity &amp; SetProperties (const std::string &amp; name, VALUE_T &amp;&amp; value, EXTRA_Ts &amp;&amp;... extras)  Entity &amp; SetProperty (const std::string &amp; name, const T &amp; value) Change the value of the specified property (will create if needed) virtual Entity &amp; SetWorld (WorldBase &amp; in_world)  Entity &amp; operator= (const Entity &amp;) = delete Entity &amp; operator= (Entity &amp;&amp;) = delete virtual ~Entity () = default"},{"location":"Core%20Project/classcse491_1_1_entity/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-types","title":"Protected Types","text":"Type Name typedef std::unordered_map&lt; std::string, std::unique_ptr&lt; PropertyBase &gt; &gt; property_map_t Every entity can have a simple set of properties (with values) associated with it."},{"location":"Core%20Project/classcse491_1_1_entity/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t grid_id   = = 0Which grid is this entity on? size_t id   = = 0Unique ID for this entity (0 is used for \"no ID\") std::vector&lt; size_t &gt; inventory What entity ids are held by this entity? std::string name   = = \"\"Name for this entity (E.g., \"Player 1\" or \"+2 Sword\") GridPosition position Where on the grid is this entity? property_map_t property_map"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-functions","title":"Protected Functions","text":"Type Name Property&lt; T &gt; &amp; AsProperty (const std::string &amp; name) const"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_entity/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_entity/#function-additem-12","title":"function AddItem [1/2]","text":"<pre><code>Entity &amp; cse491::Entity::AddItem (\n    size_t id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-additem-22","title":"function AddItem [2/2]","text":"<pre><code>inline Entity &amp; cse491::Entity::AddItem (\n    Entity &amp; item\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Serialize entity-specific values. </p> <pre><code>inline virtual void cse491::Entity::Deserialize_impl (\n    std::istream &amp; is\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream to write contents to. </li> </ul> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-entity-13","title":"function Entity [1/3]","text":"<pre><code>inline cse491::Entity::Entity (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-entity-23","title":"function Entity [2/3]","text":"<pre><code>cse491::Entity::Entity (\n    const Entity &amp;\n) = delete\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-entity-33","title":"function Entity [3/3]","text":"<pre><code>cse491::Entity::Entity (\n    Entity &amp;&amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getgridid","title":"function GetGridID","text":"<pre><code>inline size_t cse491::Entity::GetGridID () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getid","title":"function GetID","text":"<pre><code>inline size_t cse491::Entity::GetID () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getinventory","title":"function GetInventory","text":"<pre><code>inline std::vector&lt; size_t &gt; cse491::Entity::GetInventory () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getname","title":"function GetName","text":"<pre><code>inline const std::string &amp; cse491::Entity::GetName () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getnumproperties","title":"function GetNumProperties","text":"<pre><code>inline size_t cse491::Entity::GetNumProperties () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getposition","title":"function GetPosition","text":"<pre><code>inline GridPosition cse491::Entity::GetPosition () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getproperty","title":"function GetProperty","text":"<pre><code>template&lt;typename T typename T&gt;\ninline const T &amp; cse491::Entity::GetProperty (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getpropertymap","title":"function GetPropertyMap","text":"<pre><code>inline property_map_t &amp; cse491::Entity::GetPropertyMap () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getpropertytype","title":"function GetPropertyType","text":"<pre><code>inline PropertyType cse491::Entity::GetPropertyType (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-getworld","title":"function GetWorld","text":"<pre><code>inline WorldBase &amp; cse491::Entity::GetWorld () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-hasitem","title":"function HasItem","text":"<pre><code>inline bool cse491::Entity::HasItem (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-hasproperty","title":"function HasProperty","text":"<pre><code>inline bool cse491::Entity::HasProperty (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-hasworld","title":"function HasWorld","text":"<pre><code>inline bool cse491::Entity::HasWorld () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-isagent","title":"function IsAgent","text":"<pre><code>inline virtual bool cse491::Entity::IsAgent () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-isinterface","title":"function IsInterface","text":"<pre><code>inline virtual bool cse491::Entity::IsInterface () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-isitem","title":"function IsItem","text":"<pre><code>inline virtual bool cse491::Entity::IsItem () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-isongrid","title":"function IsOnGrid","text":"<pre><code>inline bool cse491::Entity::IsOnGrid (\n    size_t in_grid_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-removeitem-12","title":"function RemoveItem [1/2]","text":"<pre><code>Entity &amp; cse491::Entity::RemoveItem (\n    size_t id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-removeitem-22","title":"function RemoveItem [2/2]","text":"<pre><code>inline Entity &amp; cse491::Entity::RemoveItem (\n    Entity &amp; item\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-removeproperty","title":"function RemoveProperty","text":"<pre><code>inline Entity &amp; cse491::Entity::RemoveProperty (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Serialize entity-specific values. </p> <pre><code>inline virtual void cse491::Entity::Serialize_impl (\n    std::ostream &amp; os\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream to write contents to. </li> </ul> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setname","title":"function SetName","text":"<pre><code>inline Entity &amp; cse491::Entity::SetName (\n    const std::string in_name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setposition-12","title":"function SetPosition [1/2]","text":"<pre><code>Entity &amp; cse491::Entity::SetPosition (\n    GridPosition in_pos,\n    size_t grid_id=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setposition-22","title":"function SetPosition [2/2]","text":"<pre><code>inline Entity &amp; cse491::Entity::SetPosition (\n    double x,\n    double y\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setproperties-12","title":"function SetProperties [1/2]","text":"<pre><code>inline Entity &amp; cse491::Entity::SetProperties () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setproperties-22","title":"function SetProperties [2/2]","text":"<pre><code>template&lt;typename VALUE_T typename VALUE_T, typename... EXTRA_Ts&gt;\ninline Entity &amp; cse491::Entity::SetProperties (\n    const std::string &amp; name,\n    VALUE_T &amp;&amp; value,\n    EXTRA_Ts &amp;&amp;... extras\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setproperty","title":"function SetProperty","text":"<pre><code>template&lt;typename T typename T&gt;\ninline Entity &amp; cse491::Entity::SetProperty (\n    const std::string &amp; name,\n    const T &amp; value\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-setworld","title":"function SetWorld","text":"<pre><code>inline virtual Entity &amp; cse491::Entity::SetWorld (\n    WorldBase &amp; in_world\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-operator","title":"function operator=","text":"<pre><code>Entity &amp; cse491::Entity::operator= (\n    const Entity &amp;\n) = delete\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-operator_1","title":"function operator=","text":"<pre><code>Entity &amp; cse491::Entity::operator= (\n    Entity &amp;&amp;\n) = delete\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#function-entity","title":"function ~Entity","text":"<pre><code>virtual cse491::Entity::~Entity () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_entity/#typedef-property_map_t","title":"typedef property_map_t","text":"<pre><code>using property_map_t =  std::unordered_map&lt;std::string, std::unique_ptr&lt;PropertyBase&gt; &gt;;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_entity/#variable-grid_id","title":"variable grid_id","text":"<pre><code>size_t grid_id;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-id","title":"variable id","text":"<pre><code>size_t id;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-inventory","title":"variable inventory","text":"<pre><code>std::vector&lt;size_t&gt; inventory;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-name","title":"variable name","text":"<pre><code>std::string name;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-position","title":"variable position","text":"<pre><code>GridPosition position;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#variable-property_map","title":"variable property_map","text":"<pre><code>property_map_t property_map;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_entity/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_entity/#function-asproperty","title":"function AsProperty","text":"<pre><code>template&lt;typename T typename T&gt;\ninline Property &lt; T &gt; &amp; cse491::Entity::AsProperty (\n    const std::string &amp; name\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/Entity.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/","title":"Class cse491::GridPosition","text":"<p>ClassList &gt; cse491 &gt; GridPosition</p> <p>Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. </p> <ul> <li><code>#include &lt;GridPosition.hpp&gt;</code></li> </ul> <p>Inherits the following classes: cse491::CoreObject</p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-functions","title":"Public Functions","text":"Type Name GridPosition Above (double dist=1.0) constReturn a grid position above this one (by default, directly above) GridPosition Below (double dist=1.0) constReturn a grid position below this one (by default, directly below) size_t CellX () const size_t CellY () const virtual void Deserialize_impl (std::istream &amp;) overrideOverride to restore the state of this object from the provided stream. double Distance (GridPosition pos2) const GridPosition &amp; FromStream (std::istream &amp; ss)  GridPosition &amp; FromString (std::string in_str)  GridPosition GetOffset (double offset_x, double offset_y) constReturn a the GridPosition at the requested offset. virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. double GetX () const double GetY () const GridPosition () = default GridPosition (double x, double y)  GridPosition (const std::string &amp; str)  GridPosition (const GridPosition &amp;) = default bool IsInvalid () const bool IsNear (GridPosition pos2, double max_dist=1.0) const bool IsValid () const double MDistance (GridPosition pos2) constManhattan distance between grid positions. GridPosition &amp; MakeInvalid () Make this grid position invalid, by setting both coords to \"not-a-number\". virtual void Serialize_impl (std::ostream &amp;) override constOverride to store the current state of this object for later extraction. GridPosition &amp; Set (double in_x, double in_y)  GridPosition &amp; SetX (double in)  GridPosition &amp; SetY (double in)  GridPosition &amp; Shift (double shift_x, double shift_y)  GridPosition ToLeft (double dist=1.0) constReturn a grid position to the left of this one (by default, directly left) GridPosition ToRight (double dist=1.0) constReturn a grid position to the right of this one (by default, directly right) std::string ToString () const GridPosition operator+ (GridPosition in) constAdd together two grid positions and return the result. GridPosition &amp; operator+= (const GridPosition &amp; in)  GridPosition &amp; operator-= (const GridPosition &amp; in)  auto operator&lt;=&gt; (const GridPosition &amp;) constEnable all comparison operators (==, !=, &lt;, &lt;=, &gt;, &gt;=) GridPosition &amp; operator= (const GridPosition &amp;) = default ~GridPosition () = default"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-static-functions","title":"Public Static Functions","text":"Type Name const GridPosition &amp; Invalid ()"},{"location":"Core%20Project/classcse491_1_1_grid_position/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-above","title":"function Above","text":"<pre><code>inline GridPosition cse491::GridPosition::Above (\n    double dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-below","title":"function Below","text":"<pre><code>inline GridPosition cse491::GridPosition::Below (\n    double dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-cellx","title":"function CellX","text":"<pre><code>inline size_t cse491::GridPosition::CellX () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-celly","title":"function CellY","text":"<pre><code>inline size_t cse491::GridPosition::CellY () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Override to restore the state of this object from the provided stream. </p> <pre><code>inline virtual void cse491::GridPosition::Deserialize_impl (\n    std::istream &amp;\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>input_stream</code> The istream with full details about this object. </li> </ul> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-distance","title":"function Distance","text":"<pre><code>inline double cse491::GridPosition::Distance (\n    GridPosition pos2\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-fromstream","title":"function FromStream","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::FromStream (\n    std::istream &amp; ss\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-fromstring","title":"function FromString","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::FromString (\n    std::string in_str\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-getoffset","title":"function GetOffset","text":"<pre><code>inline GridPosition cse491::GridPosition::GetOffset (\n    double offset_x,\n    double offset_y\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::GridPosition::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-getx","title":"function GetX","text":"<pre><code>inline double cse491::GridPosition::GetX () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gety","title":"function GetY","text":"<pre><code>inline double cse491::GridPosition::GetY () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition-14","title":"function GridPosition [1/4]","text":"<pre><code>cse491::GridPosition::GridPosition () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition-24","title":"function GridPosition [2/4]","text":"<pre><code>inline cse491::GridPosition::GridPosition (\n    double x,\n    double y\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition-34","title":"function GridPosition [3/4]","text":"<pre><code>inline cse491::GridPosition::GridPosition (\n    const std::string &amp; str\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition-44","title":"function GridPosition [4/4]","text":"<pre><code>cse491::GridPosition::GridPosition (\n    const GridPosition &amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-isinvalid","title":"function IsInvalid","text":"<pre><code>inline bool cse491::GridPosition::IsInvalid () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-isnear","title":"function IsNear","text":"<pre><code>inline bool cse491::GridPosition::IsNear (\n    GridPosition pos2,\n    double max_dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-isvalid","title":"function IsValid","text":"<pre><code>inline bool cse491::GridPosition::IsValid () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-mdistance","title":"function MDistance","text":"<p>Manhattan distance between grid positions. </p> <pre><code>inline double cse491::GridPosition::MDistance (\n    GridPosition pos2\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos2</code> Position to compare to </li> </ul> <p>Returns:</p> <p>Manhattan distance </p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-makeinvalid","title":"function MakeInvalid","text":"<p>Make this grid position invalid, by setting both coords to \"not-a-number\". </p> <pre><code>inline GridPosition &amp; cse491::GridPosition::MakeInvalid () \n</code></pre> <p>Returns:</p> <p>This object. </p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Override to store the current state of this object for later extraction. </p> <pre><code>inline virtual void cse491::GridPosition::Serialize_impl (\n    std::ostream &amp;\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_stream</code> An ostream that the required information should be stored in. </li> </ul> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-set","title":"function Set","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::Set (\n    double in_x,\n    double in_y\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-setx","title":"function SetX","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::SetX (\n    double in\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-sety","title":"function SetY","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::SetY (\n    double in\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-shift","title":"function Shift","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::Shift (\n    double shift_x,\n    double shift_y\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-toleft","title":"function ToLeft","text":"<pre><code>inline GridPosition cse491::GridPosition::ToLeft (\n    double dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-toright","title":"function ToRight","text":"<pre><code>inline GridPosition cse491::GridPosition::ToRight (\n    double dist=1.0\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-tostring","title":"function ToString","text":"<pre><code>inline std::string cse491::GridPosition::ToString () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator","title":"function operator+","text":"<pre><code>inline GridPosition cse491::GridPosition::operator+ (\n    GridPosition in\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator_1","title":"function operator+=","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::operator+= (\n    const GridPosition &amp; in\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator-","title":"function operator-=","text":"<pre><code>inline GridPosition &amp; cse491::GridPosition::operator-= (\n    const GridPosition &amp; in\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator_2","title":"function operator&lt;=&gt;","text":"<pre><code>auto cse491::GridPosition::operator&lt;=&gt; (\n    const GridPosition &amp;\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-operator_3","title":"function operator=","text":"<pre><code>GridPosition &amp; cse491::GridPosition::operator= (\n    const GridPosition &amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-gridposition","title":"function ~GridPosition","text":"<pre><code>cse491::GridPosition::~GridPosition () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_grid_position/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_grid_position/#function-invalid","title":"function Invalid","text":"<pre><code>static inline const GridPosition &amp; cse491::GridPosition::Invalid () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/GridPosition.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_interface_base/","title":"Class cse491::InterfaceBase","text":"<p>ClassList &gt; cse491 &gt; InterfaceBase</p> <p>Inherits the following classes: cse491::AgentBase</p>"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions","title":"Public Functions","text":"Type Name InterfaceBase (size_t id, const std::string &amp; name)  virtual bool IsInterface () override constIs Entity an interface for a human? ~InterfaceBase () = default"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions-inherited-from-cse491agentbase","title":"Public Functions inherited from cse491::AgentBase","text":"<p>See cse491::AgentBase</p> Type Name virtual AgentBase &amp; AddAction (const std::string &amp; action_name, size_t action_id) Provide a new action that this agent can take. AgentBase (size_t id, const std::string &amp; name) Default value upon initialization. virtual void Deserialize_impl (std::istream &amp; is) overrideDeserialize item-specific values and call Entity 's Deserialize_impl. size_t GetActionID (const std::string &amp; action_name) constReturn an action ID if that action exists, otherwise return zero. int GetActionResult () constRetrieve the result of the most recent action. State GetAgentState () Get the current state of the Agent. virtual GridPosition GetNextPosition () Allow derived agents to provide an arbitrary next position for the world to move the agent to. virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. bool HasAction (const std::string &amp; action_name) constTest if agent already has a specified action. virtual bool Initialize () Run AFTER the world configures the agent, for additional tests or setup. virtual bool IsAgent () override constIs Entity an autonomous agent? virtual void Notify (const std::string &amp;, const std::string &amp;=\"none\") Send a notification to this agent, typically from the world. virtual size_t SelectAction (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) Decide the next action for this agent to perform; should be overridden! virtual void Serialize_impl (std::ostream &amp; os) override constSerialize item-specific values and call Entity 's Serialize_impl. void SetActionResult (int result) Update the result from the most recent action. void TakeDamage (cse491::AgentBase &amp; agent) If the agent is in State::Taking_Damage, decrease the health by the damage factor once per timestep. void UpdateAgentState (cse491::AgentBase &amp; agent) Updates an Agent's state depending on health. void storeActionMap (std::string name)  ~AgentBase () = default"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions-inherited-from-cse491entity","title":"Public Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Entity &amp; AddItem (size_t id)  Entity &amp; AddItem (Entity &amp; item)  virtual void Deserialize_impl (std::istream &amp; is) overrideSerialize entity-specific values. Entity (size_t id, const std::string &amp; name)  Entity (const Entity &amp;) = delete Entity (Entity &amp;&amp;) = default size_t GetGridID () const size_t GetID () const std::vector&lt; size_t &gt; GetInventory () const const std::string &amp; GetName () const size_t GetNumProperties () constHow many properties does this entity have? GridPosition GetPosition () const const T &amp; GetProperty (const std::string &amp; name) constReturn the current value of the specified property. property_map_t &amp; GetPropertyMap () return the property map for the entity PropertyType GetPropertyType (const std::string &amp; name) const WorldBase &amp; GetWorld () const bool HasItem (size_t id) constInventory Management. bool HasProperty (const std::string &amp; name) constDoes this agent have a property with the specified name? bool HasWorld () const virtual bool IsAgent () constIs Entity an autonomous agent? virtual bool IsInterface () constIs Entity an interface for a human? virtual bool IsItem () constIs Entity an item? bool IsOnGrid (size_t in_grid_id) const Entity &amp; RemoveItem (size_t id)  Entity &amp; RemoveItem (Entity &amp; item)  Entity &amp; RemoveProperty (const std::string &amp; name) Completely remove a property from an Entity . virtual void Serialize_impl (std::ostream &amp; os) override constSerialize entity-specific values. Entity &amp; SetName (const std::string in_name)  Entity &amp; SetPosition (GridPosition in_pos, size_t grid_id=0)  Entity &amp; SetPosition (double x, double y)  Entity &amp; SetProperties () Allow for setting multiple properties at once. Entity &amp; SetProperties (const std::string &amp; name, VALUE_T &amp;&amp; value, EXTRA_Ts &amp;&amp;... extras)  Entity &amp; SetProperty (const std::string &amp; name, const T &amp; value) Change the value of the specified property (will create if needed) virtual Entity &amp; SetWorld (WorldBase &amp; in_world)  Entity &amp; operator= (const Entity &amp;) = delete Entity &amp; operator= (Entity &amp;&amp;) = delete virtual ~Entity () = default"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-types-inherited-from-cse491entity","title":"Protected Types inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name typedef std::unordered_map&lt; std::string, std::unique_ptr&lt; PropertyBase &gt; &gt; property_map_t Every entity can have a simple set of properties (with values) associated with it."},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-attributes-inherited-from-cse491agentbase","title":"Protected Attributes inherited from cse491::AgentBase","text":"<p>See cse491::AgentBase</p> Type Name int action Action that agent is currently performing. std::unordered_map&lt; std::string, size_t &gt; action_map Map of names to action ids. int action_result   = = 0Usually a one (success) or zero (failure). State agent_state   = = Healthy"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-attributes-inherited-from-cse491entity","title":"Protected Attributes inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name size_t grid_id   = = 0Which grid is this entity on? size_t id   = = 0Unique ID for this entity (0 is used for \"no ID\") std::vector&lt; size_t &gt; inventory What entity ids are held by this entity? std::string name   = = \"\"Name for this entity (E.g., \"Player 1\" or \"+2 Sword\") GridPosition position Where on the grid is this entity? property_map_t property_map"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-functions-inherited-from-cse491entity","title":"Protected Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Property&lt; T &gt; &amp; AsProperty (const std::string &amp; name) const"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-static-functions","title":"Protected Static Functions","text":"Type Name void exitCleanup ()"},{"location":"Core%20Project/classcse491_1_1_interface_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_interface_base/#function-interfacebase","title":"function InterfaceBase","text":"<pre><code>inline cse491::InterfaceBase::InterfaceBase (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_interface_base/#function-isinterface","title":"function IsInterface","text":"<pre><code>inline virtual bool cse491::InterfaceBase::IsInterface () override const\n</code></pre> <p>Implements cse491::Entity::IsInterface</p>"},{"location":"Core%20Project/classcse491_1_1_interface_base/#function-interfacebase_1","title":"function ~InterfaceBase","text":"<pre><code>cse491::InterfaceBase::~InterfaceBase () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_interface_base/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_interface_base/#function-exitcleanup","title":"function exitCleanup","text":"<pre><code>static inline void cse491::InterfaceBase::exitCleanup () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/InterfaceBase.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_item_base/","title":"Class cse491::ItemBase","text":"<p>ClassList &gt; cse491 &gt; ItemBase</p> <p>Inherits the following classes: cse491::Entity</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#public-functions","title":"Public Functions","text":"Type Name virtual void Deserialize_impl (std::istream &amp; is) overrideDeserialize item-specific values and call Entity 's Deserialize_impl. size_t GetOwnerID () const virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. virtual bool IsItem () override constIs Entity an item? bool IsOnGrid () const bool IsOnGrid (size_t grid_id) const bool IsOwned () const bool IsOwnedBy (size_t entity_id) const bool IsOwnedByAgent () const bool IsOwnedByAgent (size_t agent_id) const bool IsOwnedByItem () const bool IsOwnedByItem (size_t item_id) const ItemBase (size_t id, const std::string &amp; name)  virtual void Serialize_impl (std::ostream &amp; os) override constSerialize item-specific values and call Entity 's Serialize_impl. ItemBase &amp; SetGrid (size_t grid_id=0)  ItemBase &amp; SetOwner (const Entity &amp; owner) Identify the entity (item or agent) that now owns this item. ItemBase &amp; SetUnowned ()  ~ItemBase () = default"},{"location":"Core%20Project/classcse491_1_1_item_base/#public-functions-inherited-from-cse491entity","title":"Public Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Entity &amp; AddItem (size_t id)  Entity &amp; AddItem (Entity &amp; item)  virtual void Deserialize_impl (std::istream &amp; is) overrideSerialize entity-specific values. Entity (size_t id, const std::string &amp; name)  Entity (const Entity &amp;) = delete Entity (Entity &amp;&amp;) = default size_t GetGridID () const size_t GetID () const std::vector&lt; size_t &gt; GetInventory () const const std::string &amp; GetName () const size_t GetNumProperties () constHow many properties does this entity have? GridPosition GetPosition () const const T &amp; GetProperty (const std::string &amp; name) constReturn the current value of the specified property. property_map_t &amp; GetPropertyMap () return the property map for the entity PropertyType GetPropertyType (const std::string &amp; name) const WorldBase &amp; GetWorld () const bool HasItem (size_t id) constInventory Management. bool HasProperty (const std::string &amp; name) constDoes this agent have a property with the specified name? bool HasWorld () const virtual bool IsAgent () constIs Entity an autonomous agent? virtual bool IsInterface () constIs Entity an interface for a human? virtual bool IsItem () constIs Entity an item? bool IsOnGrid (size_t in_grid_id) const Entity &amp; RemoveItem (size_t id)  Entity &amp; RemoveItem (Entity &amp; item)  Entity &amp; RemoveProperty (const std::string &amp; name) Completely remove a property from an Entity . virtual void Serialize_impl (std::ostream &amp; os) override constSerialize entity-specific values. Entity &amp; SetName (const std::string in_name)  Entity &amp; SetPosition (GridPosition in_pos, size_t grid_id=0)  Entity &amp; SetPosition (double x, double y)  Entity &amp; SetProperties () Allow for setting multiple properties at once. Entity &amp; SetProperties (const std::string &amp; name, VALUE_T &amp;&amp; value, EXTRA_Ts &amp;&amp;... extras)  Entity &amp; SetProperty (const std::string &amp; name, const T &amp; value) Change the value of the specified property (will create if needed) virtual Entity &amp; SetWorld (WorldBase &amp; in_world)  Entity &amp; operator= (const Entity &amp;) = delete Entity &amp; operator= (Entity &amp;&amp;) = delete virtual ~Entity () = default"},{"location":"Core%20Project/classcse491_1_1_item_base/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-types","title":"Protected Types","text":"Type Name enum OwnerType"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-types-inherited-from-cse491entity","title":"Protected Types inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name typedef std::unordered_map&lt; std::string, std::unique_ptr&lt; PropertyBase &gt; &gt; property_map_t Every entity can have a simple set of properties (with values) associated with it."},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t owner_id   = = 0 OwnerType owner_type   = = OwnerType::NONE"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-attributes-inherited-from-cse491entity","title":"Protected Attributes inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name size_t grid_id   = = 0Which grid is this entity on? size_t id   = = 0Unique ID for this entity (0 is used for \"no ID\") std::vector&lt; size_t &gt; inventory What entity ids are held by this entity? std::string name   = = \"\"Name for this entity (E.g., \"Player 1\" or \"+2 Sword\") GridPosition position Where on the grid is this entity? property_map_t property_map"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-functions-inherited-from-cse491entity","title":"Protected Functions inherited from cse491::Entity","text":"<p>See cse491::Entity</p> Type Name Property&lt; T &gt; &amp; AsProperty (const std::string &amp; name) const"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_item_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_item_base/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Deserialize item-specific values and call Entity 's Deserialize_impl.</p> <pre><code>inline virtual void cse491::ItemBase::Deserialize_impl (\n    std::istream &amp; is\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> istream to read contents from. </li> </ul> <p>Implements cse491::Entity::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-getownerid","title":"function GetOwnerID","text":"<pre><code>inline size_t cse491::ItemBase::GetOwnerID () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::ItemBase::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isitem","title":"function IsItem","text":"<pre><code>inline virtual bool cse491::ItemBase::IsItem () override const\n</code></pre> <p>Implements cse491::Entity::IsItem</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isongrid-12","title":"function IsOnGrid [1/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOnGrid () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isongrid-22","title":"function IsOnGrid [2/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOnGrid (\n    size_t grid_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isowned","title":"function IsOwned","text":"<pre><code>inline bool cse491::ItemBase::IsOwned () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedby","title":"function IsOwnedBy","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedBy (\n    size_t entity_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedbyagent-12","title":"function IsOwnedByAgent [1/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedByAgent () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedbyagent-22","title":"function IsOwnedByAgent [2/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedByAgent (\n    size_t agent_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedbyitem-12","title":"function IsOwnedByItem [1/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedByItem () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-isownedbyitem-22","title":"function IsOwnedByItem [2/2]","text":"<pre><code>inline bool cse491::ItemBase::IsOwnedByItem (\n    size_t item_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-itembase","title":"function ItemBase","text":"<pre><code>inline cse491::ItemBase::ItemBase (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Serialize item-specific values and call Entity 's Serialize_impl.</p> <pre><code>inline virtual void cse491::ItemBase::Serialize_impl (\n    std::ostream &amp; os\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream to write contents to. </li> </ul> <p>Implements cse491::Entity::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-setgrid","title":"function SetGrid","text":"<pre><code>inline ItemBase &amp; cse491::ItemBase::SetGrid (\n    size_t grid_id=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-setowner","title":"function SetOwner","text":"<p>Identify the entity (item or agent) that now owns this item. </p> <pre><code>inline ItemBase &amp; cse491::ItemBase::SetOwner (\n    const Entity &amp; owner\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>owner</code> The new owning entity. </li> </ul> <p>Returns:</p> <p>A reference to this item. </p>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-setunowned","title":"function SetUnowned","text":"<pre><code>inline ItemBase &amp; cse491::ItemBase::SetUnowned () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#function-itembase_1","title":"function ~ItemBase","text":"<pre><code>cse491::ItemBase::~ItemBase () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_item_base/#enum-ownertype","title":"enum OwnerType","text":"<pre><code>enum cse491::ItemBase::OwnerType {\n    NONE = 0,\n    GRID,\n    ITEM,\n    AGENT\n};\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_item_base/#variable-owner_id","title":"variable owner_id","text":"<pre><code>size_t owner_id;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_item_base/#variable-owner_type","title":"variable owner_type","text":"<pre><code>OwnerType owner_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/ItemBase.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1_property/","title":"Struct cse491::Property","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; cse491 &gt; Property</p> <p>Inherits the following classes: cse491::PropertyBase</p>"},{"location":"Core%20Project/structcse491_1_1_property/#public-attributes","title":"Public Attributes","text":"Type Name T value"},{"location":"Core%20Project/structcse491_1_1_property/#public-functions","title":"Public Functions","text":"Type Name virtual void Deserialize_impl (std::istream &amp;) overrideOverride to restore the state of this object from the provided stream. virtual PropertyType GetType () override const virtual std::string GetTypeName () override const virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. Property (const T &amp; in)  Property (T &amp;&amp; in)  virtual void Serialize_impl (std::ostream &amp;) override constOverride to store the current state of this object for later extraction. virtual char ToChar () override const virtual double ToDouble () override const virtual GridPosition ToGridPosition () override const virtual int ToInt () override const virtual std::string ToString () override const"},{"location":"Core%20Project/structcse491_1_1_property/#public-functions-inherited-from-cse491propertybase","title":"Public Functions inherited from cse491::PropertyBase","text":"<p>See cse491::PropertyBase</p> Type Name virtual PropertyType GetType () const = 0 virtual std::string GetTypeName () const = 0 virtual char ToChar () const = 0 virtual double ToDouble () const = 0 virtual GridPosition ToGridPosition () const = 0 virtual int ToInt () const = 0 virtual std::string ToString () const = 0 virtual ~PropertyBase ()"},{"location":"Core%20Project/structcse491_1_1_property/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/structcse491_1_1_property/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/structcse491_1_1_property/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_property/#variable-value","title":"variable value","text":"<pre><code>T value;\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_property/#function-deserialize_impl","title":"function Deserialize_impl","text":"<p>Override to restore the state of this object from the provided stream. </p> <pre><code>inline virtual void cse491::Property::Deserialize_impl (\n    std::istream &amp;\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>input_stream</code> The istream with full details about this object. </li> </ul> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-gettype","title":"function GetType","text":"<pre><code>inline virtual PropertyType cse491::Property::GetType () override const\n</code></pre> <p>Implements cse491::PropertyBase::GetType</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-gettypename","title":"function GetTypeName","text":"<pre><code>inline virtual std::string cse491::Property::GetTypeName () override const\n</code></pre> <p>Implements cse491::PropertyBase::GetTypeName</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::Property::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-property-12","title":"function Property [1/2]","text":"<pre><code>inline cse491::Property::Property (\n    const T &amp; in\n) \n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property/#function-property-22","title":"function Property [2/2]","text":"<pre><code>inline cse491::Property::Property (\n    T &amp;&amp; in\n) \n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property/#function-serialize_impl","title":"function Serialize_impl","text":"<p>Override to store the current state of this object for later extraction. </p> <pre><code>inline virtual void cse491::Property::Serialize_impl (\n    std::ostream &amp;\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>output_stream</code> An ostream that the required information should be stored in. </li> </ul> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-tochar","title":"function ToChar","text":"<pre><code>inline virtual char cse491::Property::ToChar () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToChar</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-todouble","title":"function ToDouble","text":"<pre><code>inline virtual double cse491::Property::ToDouble () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToDouble</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-togridposition","title":"function ToGridPosition","text":"<pre><code>inline virtual GridPosition cse491::Property::ToGridPosition () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToGridPosition</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-toint","title":"function ToInt","text":"<pre><code>inline virtual int cse491::Property::ToInt () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToInt</p>"},{"location":"Core%20Project/structcse491_1_1_property/#function-tostring","title":"function ToString","text":"<pre><code>inline virtual std::string cse491::Property::ToString () override const\n</code></pre> <p>Implements cse491::PropertyBase::ToString</p> <p>The documentation for this class was generated from the following file <code>source/core/Property.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1_property_base/","title":"Struct cse491::PropertyBase","text":"<p>ClassList &gt; cse491 &gt; PropertyBase</p> <p>Inherits the following classes: cse491::CoreObject</p> <p>Inherited by the following classes: cse491::Property</p>"},{"location":"Core%20Project/structcse491_1_1_property_base/#public-functions","title":"Public Functions","text":"Type Name virtual PropertyType GetType () const = 0 virtual std::string GetTypeName () const = 0 virtual char ToChar () const = 0 virtual double ToDouble () const = 0 virtual GridPosition ToGridPosition () const = 0 virtual int ToInt () const = 0 virtual std::string ToString () const = 0 virtual ~PropertyBase ()"},{"location":"Core%20Project/structcse491_1_1_property_base/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/structcse491_1_1_property_base/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/structcse491_1_1_property_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/structcse491_1_1_property_base/#function-gettype","title":"function GetType","text":"<pre><code>virtual PropertyType cse491::PropertyBase::GetType () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-gettypename","title":"function GetTypeName","text":"<pre><code>virtual std::string cse491::PropertyBase::GetTypeName () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-tochar","title":"function ToChar","text":"<pre><code>virtual char cse491::PropertyBase::ToChar () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-todouble","title":"function ToDouble","text":"<pre><code>virtual double cse491::PropertyBase::ToDouble () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-togridposition","title":"function ToGridPosition","text":"<pre><code>virtual GridPosition cse491::PropertyBase::ToGridPosition () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-toint","title":"function ToInt","text":"<pre><code>virtual int cse491::PropertyBase::ToInt () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-tostring","title":"function ToString","text":"<pre><code>virtual std::string cse491::PropertyBase::ToString () const = 0\n</code></pre>"},{"location":"Core%20Project/structcse491_1_1_property_base/#function-propertybase","title":"function ~PropertyBase","text":"<pre><code>inline virtual cse491::PropertyBase::~PropertyBase () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/Property.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_world_base/","title":"Class cse491::WorldBase","text":"<p>ClassList &gt; cse491 &gt; WorldBase</p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-attributes","title":"Public Attributes","text":"Type Name netWorth::ClientManager * client_manager   = = nullptrServer manager for world if used. netWorth::ServerManager * server_manager   = = nullptr"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t npos   = = static_cast&lt;size_t&gt;(-1)"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-functions","title":"Public Functions","text":"Type Name AgentBase &amp; AddAgent (std::string agent_name=\"None\", PROPERTY_Ts... properties) Build a new agent of the specified type. AgentBase &amp; AddConfiguredAgent (std::unique_ptr&lt; AgentBase &gt; agent_ptr) Add an already-created agent. ItemBase &amp; AddItem (std::unique_ptr&lt; ItemBase &gt; item_ptr) Add a new, already-built item. ItemBase &amp; AddItem (std::string item_name=\"None\", PROPERTY_Ts... properties) Build a new item and add it. WorldBase &amp; AddItemToGrid (size_t item_id, GridPosition pos, size_t grid_id=0)  void CollectData ()  virtual void ConfigAgent (AgentBase &amp;) constClient manager for world if used. void Deserialize (std::istream &amp; is, netWorth::ClientManager * manager) Deserialize world, agents, and items from istream. void DeserializeAgentSet (std::istream &amp; is, netWorth::ClientManager * manager) Add deserialized agents to world with a manager. void DeserializeItemSet (std::istream &amp; is) Add deserialized items to world. virtual int DoAction (AgentBase &amp; agent, size_t action_id) = 0Central function for an agent to take any action. virtual std::vector&lt; size_t &gt; FindAgentsAt (GridPosition pos, size_t grid_id=0) constLookup IDs for all agents at a given grid position. virtual std::vector&lt; size_t &gt; FindAgentsNear (GridPosition pos, double dist=1.0, size_t grid_id=0) constLookup IDs for all agents near a given grid position. virtual std::vector&lt; size_t &gt; FindItemsAt (GridPosition pos, size_t grid_id=0) constLookup IDs for all items at a given grid position. virtual std::vector&lt; size_t &gt; FindItemsNear (GridPosition pos, double dist=1.0, size_t grid_id=0) constLookup IDs for all items near a given grid position. AgentBase &amp; GetAgent (size_t id) Return a reference to an agent with a given ID. size_t GetAgentID (const std::string &amp; name) Return the ID of an agent with a given name. size_t GetCellTypeID (const std::string &amp; name) constReturn the ID associated with the cell type name. const std::string &amp; GetCellTypeName (size_t id) const char GetCellTypeSymbol (size_t id) const const type_options_t &amp; GetCellTypes () const virtual WorldGrid &amp; GetGrid () Return an editable version of the current grid for this world (main_grid by default) virtual WorldGrid &amp; GetGrid (size_t grid_id)  virtual const WorldGrid &amp; GetGrid () constReturn a const grid for this world (main_grid by default) virtual const WorldGrid &amp; GetGrid (size_t grid_id) const ItemBase &amp; GetItem (size_t id) Return a reference to an agent with a given ID. size_t GetItemID (const std::string &amp; name) Return the ID of an item with a given name. size_t GetNumAgents () constGet the total number of AGENT entities. size_t GetNumItems () constGet the total number of NON-agent entities. double GetRandom () Return a uniform random value between 0.0 and 1.0. double GetRandom (double max) Return a uniform random value between 0.0 and max. double GetRandom (double min, double max) Return a uniform random value between min and max. double GetRandomNormal () Return a gaussian random value with mean 0.0 and sd 1.0. double GetRandomNormal (double mean, double sd=1.0) Return a gaussian random value with provided mean and sd. virtual bool GetRunOver () constDetermine if the run has ended. unsigned int GetSeed () constGet the seed used to initialize this RNG. bool HasAgent (size_t id) constDoes an agent with the provided ID exist? bool HasItem (size_t id) constDoes an item with the provided ID exist? virtual bool IsTraversable (const AgentBase &amp;, cse491::GridPosition) constDetermine if this tile can be walked on, defaults to every tile is walkable. WorldBase &amp; RemoveAgent (size_t agent_id) Remove an agent from the agent map. WorldBase &amp; RemoveAgent (std::string agent_name=\"None\") Remove an agent from the agent map by name. WorldBase &amp; RemoveItem (size_t item_id) Remove an item from the item map. WorldBase &amp; RemoveItem (std::string item_name) Remove an item from the item map by name. virtual void Reset ()  virtual void Run () Run all agents repeatedly until an end condition is met. virtual void RunAgents () Step through each agent giving them a chance to take an action. virtual void RunClient (netWorth::ClientManager * manager) Run, but for client-side. virtual void RunClientAgents () RunAgents, but with extra features for client-side. virtual void RunServer (netWorth::ServerManager * manager) Run, but for server-side. virtual void RunServerAgents () RunAgents, but with extra features for server-side. void Serialize (std::ostream &amp; os) Serialize world, agents, and items into ostream. void SerializeAgentSet (std::ostream &amp; os) Serialize agent data into an ostream. void SerializeItemSet (std::ostream &amp; os) Serialize item data into an ostream. virtual void SetWorldRunning (bool running) Set if world is running or not for concurrency purposes. virtual void UpdateWorld () UpdateWorld() is run after every agent has a turn. Override this function to manage background events for a world. WorldBase (unsigned int seed=0)  virtual ~WorldBase () = default"},{"location":"Core%20Project/classcse491_1_1_world_base/#protected-attributes","title":"Protected Attributes","text":"Type Name std::string action The action that the agent is currently performing. agent_map_t agent_map Map of IDs to pointers to agent entities. std::shared_ptr&lt; DataCollection::AgentReceiver &gt; agent_receiver std::unordered_map&lt; size_t, WorldGrid &gt; grids Derived worlds may choose to have more than one grid. item_map_t item_map Map of IDs to pointers to non-agent entities. size_t last_entity_id   = = 0The last Entity ID used; increment at each creation. WorldGrid &amp; main_grid Main grid for this world; shortcut to <code>grids[\"main\"]</code> __ std::normal_distribution norm_dist Normal distribution; mean 0, std 1. std::mt19937 random_gen Random number generator. bool run_over   = = falseShould the run end? unsigned int seed Seed used for generator. type_options_t type_options Vector of types of cells in grids for this world. std::uniform_real_distribution uni_dist Uniform distribution of doubles, 0 to 1. bool world_running   = = trueIs the world currently running?"},{"location":"Core%20Project/classcse491_1_1_world_base/#protected-functions","title":"Protected Functions","text":"Type Name size_t AddCellType (const std::string &amp; name, const std::string &amp; desc=\"\", char symbol='\\0') Add a new type of cell to this world. virtual void ConfigAgent (AgentBase &amp;)  size_t NextEntityID () Helper function to set the next entity id."},{"location":"Core%20Project/classcse491_1_1_world_base/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-client_manager","title":"variable client_manager","text":"<pre><code>netWorth::ClientManager* client_manager;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-server_manager","title":"variable server_manager","text":"<pre><code>netWorth::ServerManager* server_manager;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-npos","title":"variable npos","text":"<pre><code>constexpr size_t npos;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#function-addagent","title":"function AddAgent","text":"<p>Build a new agent of the specified type. </p> <pre><code>template&lt;typename AGENT_T typename AGENT_T, typename... PROPERTY_Ts&gt;\ninline AgentBase &amp; cse491::WorldBase::AddAgent (\n    std::string agent_name=\"None\",\n    PROPERTY_Ts... properties\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>AGENT_T</code> The type of agent to build </li> <li><code>PROPERTY_Ts</code> Types for any properties to set at creation (automatic) </li> </ul> <p>Parameters:</p> <ul> <li><code>agent_name</code> The name of this agent </li> <li><code>properties</code> Name/value pairs for any properties set at creation </li> </ul> <p>Returns:</p> <p>A reference to the newly created agent </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-addconfiguredagent","title":"function AddConfiguredAgent","text":"<pre><code>inline AgentBase &amp; cse491::WorldBase::AddConfiguredAgent (\n    std::unique_ptr&lt; AgentBase &gt; agent_ptr\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-additem-12","title":"function AddItem [1/2]","text":"<p>Add a new, already-built item. </p> <pre><code>inline ItemBase &amp; cse491::WorldBase::AddItem (\n    std::unique_ptr&lt; ItemBase &gt; item_ptr\n) \n</code></pre> <p>Returns:</p> <p>A reference to the newly created item </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-additem-22","title":"function AddItem [2/2]","text":"<p>Build a new item and add it. </p> <pre><code>template&lt;typename ITEM_T typename ITEM_T, typename... PROPERTY_Ts&gt;\ninline ItemBase &amp; cse491::WorldBase::AddItem (\n    std::string item_name=\"None\",\n    PROPERTY_Ts... properties\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>PROPERTY_Ts</code> Types for any properties to set at creation (automatic) </li> </ul> <p>Parameters:</p> <ul> <li><code>item_name</code> The name of this item </li> <li><code>properties</code> Name/value pairs for any properties set at creation </li> </ul> <p>Returns:</p> <p>A reference to the newly created item </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-additemtogrid","title":"function AddItemToGrid","text":"<pre><code>inline WorldBase &amp; cse491::WorldBase::AddItemToGrid (\n    size_t item_id,\n    GridPosition pos,\n    size_t grid_id=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-collectdata","title":"function CollectData","text":"<pre><code>inline void cse491::WorldBase::CollectData () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-configagent-12","title":"function ConfigAgent [1/2]","text":"<p>Client manager for world if used. </p> <pre><code>inline virtual void cse491::WorldBase::ConfigAgent (\n    AgentBase &amp;\n) const\n</code></pre> <p>Helper function that is run whenever a new agent is created. </p> <p>Note:</p> <p>Override this function to provide agents with actions or other setup. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-deserialize","title":"function Deserialize","text":"<p>Deserialize world, agents, and items from istream. </p> <pre><code>inline void cse491::WorldBase::Deserialize (\n    std::istream &amp; is,\n    netWorth::ClientManager * manager\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>manager</code> ClientManager for ControlledAgents </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-deserializeagentset","title":"function DeserializeAgentSet","text":"<p>Add deserialized agents to world with a manager. </p> <pre><code>inline void cse491::WorldBase::DeserializeAgentSet (\n    std::istream &amp; is,\n    netWorth::ClientManager * manager\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>is</code> istream </li> <li><code>manager</code> ClientManager which manages ControlledAgents </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-deserializeitemset","title":"function DeserializeItemSet","text":"<p>Add deserialized items to world. </p> <pre><code>inline void cse491::WorldBase::DeserializeItemSet (\n    std::istream &amp; is\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>istream</code> </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-doaction","title":"function DoAction","text":"<p>Central function for an agent to take any action. </p> <pre><code>virtual int cse491::WorldBase::DoAction (\n    AgentBase &amp; agent,\n    size_t action_id\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The specific agent taking the action </li> <li><code>action</code> The id of the action to take </li> </ul> <p>Returns:</p> <p>The result of this action (usually 0/1 to indicate success) </p> <p>Note:</p> <p>Thus function must be overridden in any derived world. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-findagentsat","title":"function FindAgentsAt","text":"<p>Lookup IDs for all agents at a given grid position. </p> <pre><code>inline virtual std::vector&lt; size_t &gt; cse491::WorldBase::FindAgentsAt (\n    GridPosition pos,\n    size_t grid_id=0\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> Grid position to look up. </li> </ul> <p>Returns:</p> <p>A vector of agent IDs at the target position. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-findagentsnear","title":"function FindAgentsNear","text":"<p>Lookup IDs for all agents near a given grid position. </p> <pre><code>inline virtual std::vector&lt; size_t &gt; cse491::WorldBase::FindAgentsNear (\n    GridPosition pos,\n    double dist=1.0,\n    size_t grid_id=0\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> Grid position to look up. </li> <li><code>dist</code> Maximum distance away from pos for an agent to be included. </li> </ul> <p>Returns:</p> <p>A vector of agent IDs within dist of the target position. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-finditemsat","title":"function FindItemsAt","text":"<p>Lookup IDs for all items at a given grid position. </p> <pre><code>inline virtual std::vector&lt; size_t &gt; cse491::WorldBase::FindItemsAt (\n    GridPosition pos,\n    size_t grid_id=0\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> Grid position to look up. </li> <li><code>grid_id</code> ID of grid we are examining (default: main grid) </li> </ul> <p>Returns:</p> <p>A vector of item IDs at the target position. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-finditemsnear","title":"function FindItemsNear","text":"<p>Lookup IDs for all items near a given grid position. </p> <pre><code>inline virtual std::vector&lt; size_t &gt; cse491::WorldBase::FindItemsNear (\n    GridPosition pos,\n    double dist=1.0,\n    size_t grid_id=0\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> Grid position to look up. </li> <li><code>dist</code> Maximum distance away from pos for an item to be included. </li> </ul> <p>Returns:</p> <p>A vector of item IDs within dist of the target position. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getagent","title":"function GetAgent","text":"<pre><code>inline AgentBase &amp; cse491::WorldBase::GetAgent (\n    size_t id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getagentid","title":"function GetAgentID","text":"<pre><code>inline size_t cse491::WorldBase::GetAgentID (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getcelltypeid","title":"function GetCellTypeID","text":"<p>Return the ID associated with the cell type name. </p> <pre><code>inline size_t cse491::WorldBase::GetCellTypeID (\n    const std::string &amp; name\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> The unique name of the cell type </li> </ul> <p>Returns:</p> <p>The unique ID of the cell type (or 0 if it doesn't exist.) </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getcelltypename","title":"function GetCellTypeName","text":"<pre><code>inline const std::string &amp; cse491::WorldBase::GetCellTypeName (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getcelltypesymbol","title":"function GetCellTypeSymbol","text":"<pre><code>inline char cse491::WorldBase::GetCellTypeSymbol (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getcelltypes","title":"function GetCellTypes","text":"<pre><code>inline const type_options_t &amp; cse491::WorldBase::GetCellTypes () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getgrid-14","title":"function GetGrid [1/4]","text":"<pre><code>inline virtual WorldGrid &amp; cse491::WorldBase::GetGrid () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getgrid-24","title":"function GetGrid [2/4]","text":"<pre><code>inline virtual WorldGrid &amp; cse491::WorldBase::GetGrid (\n    size_t grid_id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getgrid-34","title":"function GetGrid [3/4]","text":"<pre><code>inline virtual const WorldGrid &amp; cse491::WorldBase::GetGrid () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getgrid-44","title":"function GetGrid [4/4]","text":"<pre><code>inline virtual const WorldGrid &amp; cse491::WorldBase::GetGrid (\n    size_t grid_id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getitem","title":"function GetItem","text":"<pre><code>inline ItemBase &amp; cse491::WorldBase::GetItem (\n    size_t id\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getitemid","title":"function GetItemID","text":"<pre><code>inline size_t cse491::WorldBase::GetItemID (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getnumagents","title":"function GetNumAgents","text":"<pre><code>inline size_t cse491::WorldBase::GetNumAgents () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getnumitems","title":"function GetNumItems","text":"<pre><code>inline size_t cse491::WorldBase::GetNumItems () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandom-13","title":"function GetRandom [1/3]","text":"<pre><code>inline double cse491::WorldBase::GetRandom () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandom-23","title":"function GetRandom [2/3]","text":"<pre><code>inline double cse491::WorldBase::GetRandom (\n    double max\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandom-33","title":"function GetRandom [3/3]","text":"<pre><code>inline double cse491::WorldBase::GetRandom (\n    double min,\n    double max\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandomnormal-12","title":"function GetRandomNormal [1/2]","text":"<pre><code>inline double cse491::WorldBase::GetRandomNormal () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrandomnormal-22","title":"function GetRandomNormal [2/2]","text":"<pre><code>inline double cse491::WorldBase::GetRandomNormal (\n    double mean,\n    double sd=1.0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getrunover","title":"function GetRunOver","text":"<pre><code>inline virtual bool cse491::WorldBase::GetRunOver () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-getseed","title":"function GetSeed","text":"<pre><code>inline unsigned int cse491::WorldBase::GetSeed () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-hasagent","title":"function HasAgent","text":"<pre><code>inline bool cse491::WorldBase::HasAgent (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-hasitem","title":"function HasItem","text":"<pre><code>inline bool cse491::WorldBase::HasItem (\n    size_t id\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-istraversable","title":"function IsTraversable","text":"<p>Determine if this tile can be walked on, defaults to every tile is walkable. </p> <pre><code>inline virtual bool cse491::WorldBase::IsTraversable (\n    const AgentBase &amp;,\n    cse491::GridPosition\n) const\n</code></pre> <p>Author:</p> <p>@mdkdoc15 </p> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position we are checking </li> </ul> <p>Returns:</p> <p>If an agent should be allowed on this square </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-removeagent-12","title":"function RemoveAgent [1/2]","text":"<p>Remove an agent from the agent map. </p> <pre><code>inline WorldBase &amp; cse491::WorldBase::RemoveAgent (\n    size_t agent_id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent_id</code> The unique ID this agent </li> </ul> <p>Returns:</p> <p>A reference to this world. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-removeagent-22","title":"function RemoveAgent [2/2]","text":"<p>Remove an agent from the agent map by name. </p> <pre><code>inline WorldBase &amp; cse491::WorldBase::RemoveAgent (\n    std::string agent_name=\"None\"\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent_name</code> The name of this agent </li> </ul> <p>Returns:</p> <p>This world </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-removeitem-12","title":"function RemoveItem [1/2]","text":"<p>Remove an item from the item map. </p> <pre><code>inline WorldBase &amp; cse491::WorldBase::RemoveItem (\n    size_t item_id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>item_id</code> The unique ID this item </li> </ul> <p>Returns:</p> <p>A reference to this world. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-removeitem-22","title":"function RemoveItem [2/2]","text":"<p>Remove an item from the item map by name. </p> <pre><code>inline WorldBase &amp; cse491::WorldBase::RemoveItem (\n    std::string item_name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>item_id</code> The ID of this item </li> </ul> <p>Returns:</p> <p>This world </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-reset","title":"function Reset","text":"<pre><code>inline virtual void cse491::WorldBase::Reset () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-run","title":"function Run","text":"<pre><code>inline virtual void cse491::WorldBase::Run () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runagents","title":"function RunAgents","text":"<p>Step through each agent giving them a chance to take an action. </p> <pre><code>inline virtual void cse491::WorldBase::RunAgents () \n</code></pre> <p>Note:</p> <p>Override this function if you want to control which grid the agents receive. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runclient","title":"function RunClient","text":"<pre><code>inline virtual void cse491::WorldBase::RunClient (\n    netWorth::ClientManager * manager\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runclientagents","title":"function RunClientAgents","text":"<p>RunAgents, but with extra features for client-side. </p> <pre><code>inline virtual void cse491::WorldBase::RunClientAgents () \n</code></pre> <p>Note:</p> <p>Override this function if you want to control which grid the agents receive. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runserver","title":"function RunServer","text":"<pre><code>inline virtual void cse491::WorldBase::RunServer (\n    netWorth::ServerManager * manager\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-runserveragents","title":"function RunServerAgents","text":"<p>RunAgents, but with extra features for server-side. </p> <pre><code>inline virtual void cse491::WorldBase::RunServerAgents () \n</code></pre> <p>Note:</p> <p>Override this function if you want to control which grid the agents receive. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-serialize","title":"function Serialize","text":"<p>Serialize world, agents, and items into ostream. </p> <pre><code>inline void cse491::WorldBase::Serialize (\n    std::ostream &amp; os\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-serializeagentset","title":"function SerializeAgentSet","text":"<p>Serialize agent data into an ostream. </p> <pre><code>inline void cse491::WorldBase::SerializeAgentSet (\n    std::ostream &amp; os\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-serializeitemset","title":"function SerializeItemSet","text":"<p>Serialize item data into an ostream. </p> <pre><code>inline void cse491::WorldBase::SerializeItemSet (\n    std::ostream &amp; os\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> ostream </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-setworldrunning","title":"function SetWorldRunning","text":"<pre><code>inline virtual void cse491::WorldBase::SetWorldRunning (\n    bool running\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-updateworld","title":"function UpdateWorld","text":"<pre><code>inline virtual void cse491::WorldBase::UpdateWorld () \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-worldbase","title":"function WorldBase","text":"<pre><code>inline cse491::WorldBase::WorldBase (\n    unsigned int seed=0\n) \n</code></pre> <p>Initializes world with cell types and random generator </p> <p>Parameters:</p> <ul> <li><code>seed</code> Seed used for RNG. Use 0 for a non-deterministic result. </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-worldbase_1","title":"function ~WorldBase","text":"<pre><code>virtual cse491::WorldBase::~WorldBase () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-action","title":"variable action","text":"<pre><code>std::string action;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-agent_map","title":"variable agent_map","text":"<pre><code>agent_map_t agent_map;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-agent_receiver","title":"variable agent_receiver","text":"<pre><code>std::shared_ptr&lt;DataCollection::AgentReceiver&gt; agent_receiver;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-grids","title":"variable grids","text":"<pre><code>std::unordered_map&lt;size_t, WorldGrid&gt; grids;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-item_map","title":"variable item_map","text":"<pre><code>item_map_t item_map;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-last_entity_id","title":"variable last_entity_id","text":"<pre><code>size_t last_entity_id;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-main_grid","title":"variable main_grid","text":"<pre><code>WorldGrid&amp; main_grid;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-norm_dist","title":"variable norm_dist","text":"<pre><code>std::normal_distribution norm_dist;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-random_gen","title":"variable random_gen","text":"<pre><code>std::mt19937 random_gen;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-run_over","title":"variable run_over","text":"<pre><code>bool run_over;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-seed","title":"variable seed","text":"<pre><code>unsigned int seed;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-type_options","title":"variable type_options","text":"<pre><code>type_options_t type_options;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-uni_dist","title":"variable uni_dist","text":"<pre><code>std::uniform_real_distribution uni_dist;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#variable-world_running","title":"variable world_running","text":"<pre><code>bool world_running;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_base/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_base/#function-addcelltype","title":"function AddCellType","text":"<p>Add a new type of cell to this world. </p> <pre><code>inline size_t cse491::WorldBase::AddCellType (\n    const std::string &amp; name,\n    const std::string &amp; desc=\"\",\n    char symbol='\\0'\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> A unique name for this cell type </li> <li><code>desc</code> A longer description of the cell type </li> <li><code>symbol</code> An (optional) unique symbol for text IO (files, command line) </li> </ul> <p>Returns:</p> <p>A unique ID associated with this cell type (position in type_options vector) </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-configagent-22","title":"function ConfigAgent [2/2]","text":"<pre><code>inline virtual void cse491::WorldBase::ConfigAgent (\n    AgentBase &amp;\n) \n</code></pre> <p>Helper function that is run whenever a new agent is created. </p> <p>Note:</p> <p>Override this function to provide agents with actions or other setup. </p>"},{"location":"Core%20Project/classcse491_1_1_world_base/#function-nextentityid","title":"function NextEntityID","text":"<pre><code>inline size_t cse491::WorldBase::NextEntityID () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/WorldBase.hpp</code></p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/","title":"Class cse491::WorldGrid","text":"<p>ClassList &gt; cse491 &gt; WorldGrid</p> <p>A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. More...</p> <ul> <li><code>#include &lt;CoreObject.hpp&gt;</code></li> </ul> <p>Inherits the following classes: cse491::CoreObject</p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#public-functions","title":"Public Functions","text":"Type Name size_t At (size_t x, size_t y) const size_t &amp; At (size_t x, size_t y)  size_t At (GridPosition p) const size_t &amp; At (GridPosition p)  size_t GetHeight () const size_t GetNumCells () const size_t GetWidth () const bool IsValid (double x, double y) constTest if specific coordinates are in range for this GridWorld. bool IsValid (GridPosition pos) constTest if a GridPosition is in range for this GridWorld. void Read (std::istream &amp; is, const type_options_t &amp; types)  bool Read (std::string filename, const type_options_t &amp; types) Helper function to specify a file name to read the grid state from. void Resize (size_t new_width, size_t new_height, size_t default_type=0)  WorldGrid () = default WorldGrid (size_t width, size_t height, size_t default_type=0)  WorldGrid (const WorldGrid &amp;) = default WorldGrid (WorldGrid &amp;&amp;) = default void Write (std::ostream &amp; os, const type_options_t &amp; types) constWrite out a human-readable version of the current WorldGrid . bool Write (std::string filename, const type_options_t &amp; types) constHelper function to specify a file name to write the grid state to. WorldGrid &amp; operator= (const WorldGrid &amp;) = default WorldGrid &amp; operator= (WorldGrid &amp;&amp;) = default size_t operator[] (GridPosition p) const size_t &amp; operator[] (GridPosition p)"},{"location":"Core%20Project/classcse491_1_1_world_grid/#public-functions-inherited-from-cse491coreobject","title":"Public Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name void Deserialize (std::istream &amp; is) Restore the state of this object, extracting it from the provided stream. bool Deserialize (std::string filename) A version of Deserialize that accepts a filename to read this object from. std::string GetTypeName () constAccess the derived name for this type. void Serialize (std::ostream &amp; os) constStore the current state of this object for later extraction. bool Serialize (std::string filename) constA version of Serialize that accepts a filename for saving just this object. auto operator&lt;=&gt; (const CoreObject &amp;) const virtual ~CoreObject ()"},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; size_t &gt; cells All cells, grouped by full rows, top to bottom. size_t height   = = 0Number of rows of cells in the grid. size_t width   = = 0Number of cells in each row of the grid."},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-functions","title":"Protected Functions","text":"Type Name virtual void Deserialize_impl (std::istream &amp; is) overrideRead the state of the grid out of the provided stream. virtual std::string GetTypeName_impl () override constOverride to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp; os) override constWrite the current state of this grid into the provided stream. size_t ToIndex (size_t x, size_t y) constConvert an X and a Y value to the index in the vector."},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-functions-inherited-from-cse491coreobject","title":"Protected Functions inherited from cse491::CoreObject","text":"<p>See cse491::CoreObject</p> Type Name virtual void Deserialize_impl (std::istream &amp;) = 0Override to restore the state of this object from the provided stream. bool EndDeserialize (std::istream &amp; is) Set up end of the deserialization for this class (does type checking) void EndSerialize (std::ostream &amp; os) constSet up end of the serialization for this class (allows checking later) virtual std::string GetTypeName_impl () const = 0Override to allow access the derived name for this type. virtual void Serialize_impl (std::ostream &amp;) const = 0Override to store the current state of this object for later extraction. bool StartDeserialize (std::istream &amp; is) Set up beginning of the deserialization for this class (does type checking) void StartSerialize (std::ostream &amp; os) constSet up beginning of the serialization for this class (allows checking later)"},{"location":"Core%20Project/classcse491_1_1_world_grid/#detailed-description","title":"Detailed Description","text":"<p>Represents a 2D grid of cells. This class provides utilities to manage, access, and modify cells within a grid. </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-at-14","title":"function At [1/4]","text":"<pre><code>inline size_t cse491::WorldGrid::At (\n    size_t x,\n    size_t y\n) const\n</code></pre> <p>Returns:</p> <p>The grid state at the provided x and y coordinates </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-at-24","title":"function At [2/4]","text":"<pre><code>inline size_t &amp; cse491::WorldGrid::At (\n    size_t x,\n    size_t y\n) \n</code></pre> <p>Returns:</p> <p>A reference to the grid state at the provided x and y coordinates </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-at-34","title":"function At [3/4]","text":"<pre><code>inline size_t cse491::WorldGrid::At (\n    GridPosition p\n) const\n</code></pre> <p>Returns:</p> <p>The state at a given GridPosition. </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-at-44","title":"function At [4/4]","text":"<pre><code>inline size_t &amp; cse491::WorldGrid::At (\n    GridPosition p\n) \n</code></pre> <p>Returns:</p> <p>A reference to the state at a given GridPosition. </p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-getheight","title":"function GetHeight","text":"<pre><code>inline size_t cse491::WorldGrid::GetHeight () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-getnumcells","title":"function GetNumCells","text":"<pre><code>inline size_t cse491::WorldGrid::GetNumCells () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-getwidth","title":"function GetWidth","text":"<pre><code>inline size_t cse491::WorldGrid::GetWidth () const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-isvalid-12","title":"function IsValid [1/2]","text":"<pre><code>inline bool cse491::WorldGrid::IsValid (\n    double x,\n    double y\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-isvalid-22","title":"function IsValid [2/2]","text":"<pre><code>inline bool cse491::WorldGrid::IsValid (\n    GridPosition pos\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-read-12","title":"function Read [1/2]","text":"<pre><code>inline void cse491::WorldGrid::Read (\n    std::istream &amp; is,\n    const type_options_t &amp; types\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-read-22","title":"function Read [2/2]","text":"<pre><code>inline bool cse491::WorldGrid::Read (\n    std::string filename,\n    const type_options_t &amp; types\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-resize","title":"function Resize","text":"<pre><code>inline void cse491::WorldGrid::Resize (\n    size_t new_width,\n    size_t new_height,\n    size_t default_type=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-worldgrid-14","title":"function WorldGrid [1/4]","text":"<pre><code>cse491::WorldGrid::WorldGrid () = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-worldgrid-24","title":"function WorldGrid [2/4]","text":"<pre><code>inline cse491::WorldGrid::WorldGrid (\n    size_t width,\n    size_t height,\n    size_t default_type=0\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-worldgrid-34","title":"function WorldGrid [3/4]","text":"<pre><code>cse491::WorldGrid::WorldGrid (\n    const WorldGrid &amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-worldgrid-44","title":"function WorldGrid [4/4]","text":"<pre><code>cse491::WorldGrid::WorldGrid (\n    WorldGrid &amp;&amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-write-12","title":"function Write [1/2]","text":"<p>Write out a human-readable version of the current WorldGrid .</p> <pre><code>inline void cse491::WorldGrid::Write (\n    std::ostream &amp; os,\n    const type_options_t &amp; types\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> Stream to write to </li> <li><code>types</code> A vector of CellTypes for symbol identification </li> </ul>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-write-22","title":"function Write [2/2]","text":"<pre><code>inline bool cse491::WorldGrid::Write (\n    std::string filename,\n    const type_options_t &amp; types\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-operator","title":"function operator=","text":"<pre><code>WorldGrid &amp; cse491::WorldGrid::operator= (\n    const WorldGrid &amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-operator_1","title":"function operator=","text":"<pre><code>WorldGrid &amp; cse491::WorldGrid::operator= (\n    WorldGrid &amp;&amp;\n) = default\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-operator_2","title":"function operator[]","text":"<pre><code>inline size_t cse491::WorldGrid::operator[] (\n    GridPosition p\n) const\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-operator_3","title":"function operator[]","text":"<pre><code>inline size_t &amp; cse491::WorldGrid::operator[] (\n    GridPosition p\n) \n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_grid/#variable-cells","title":"variable cells","text":"<pre><code>std::vector&lt;size_t&gt; cells;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#variable-height","title":"variable height","text":"<pre><code>size_t height;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#variable-width","title":"variable width","text":"<pre><code>size_t width;\n</code></pre>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-deserialize_impl","title":"function Deserialize_impl","text":"<pre><code>inline virtual void cse491::WorldGrid::Deserialize_impl (\n    std::istream &amp; is\n) override\n</code></pre> <p>Implements cse491::CoreObject::Deserialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-gettypename_impl","title":"function GetTypeName_impl","text":"<p>Override to allow access the derived name for this type. </p> <pre><code>inline virtual std::string cse491::WorldGrid::GetTypeName_impl () override const\n</code></pre> <p>Returns:</p> <p>A unique typename, ideally the exact name for this class (with scope) This member function will be helpful for serialization and debugging. It should return a fully scoped typename, such as \"cse491::WorldGrid\". </p> <p>Implements cse491::CoreObject::GetTypeName_impl</p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-serialize_impl","title":"function Serialize_impl","text":"<pre><code>inline virtual void cse491::WorldGrid::Serialize_impl (\n    std::ostream &amp; os\n) override const\n</code></pre> <p>Implements cse491::CoreObject::Serialize_impl</p>"},{"location":"Core%20Project/classcse491_1_1_world_grid/#function-toindex","title":"function ToIndex","text":"<pre><code>inline size_t cse491::WorldGrid::ToIndex (\n    size_t x,\n    size_t y\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/WorldGrid.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__any__map/","title":"Struct cse491::is_any_map","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; cse491 &gt; is_any_map</p> <p>Type trait to determine if we are working with any type of map. </p> <ul> <li><code>#include &lt;Serialize.hpp&gt;</code></li> </ul> <p>Inherits the following classes: false_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__any__map_3_01std_1_1map_3_01_k_e_y___t_00_01_v_a_l_u_e___t_01_4_01_4/","title":"Struct cse491::is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt;","text":"<p>template &lt;typename KEY_T typename KEY_T, typename VALUE_T typename VALUE_T&gt;</p> <p>ClassList &gt; cse491 &gt; is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt;</p> <p>Inherits the following classes: true_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__any__map_3_01std_1_1unordered__map_3_01_k_e_y___t_00_01_v_a_l_u_e___t_01_4_01_4/","title":"Struct cse491::is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt;","text":"<p>template &lt;typename KEY_T typename KEY_T, typename VALUE_T typename VALUE_T&gt;</p> <p>ClassList &gt; cse491 &gt; is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt;</p> <p>Inherits the following classes: true_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__vector/","title":"Struct cse491::is_vector","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; cse491 &gt; is_vector</p> <p>Type trait to determine if we are working with a vector. </p> <ul> <li><code>#include &lt;Serialize.hpp&gt;</code></li> </ul> <p>Inherits the following classes: false_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/structcse491_1_1is__vector_3_01std_1_1vector_3_01_t_01_4_01_4/","title":"Struct cse491::is_vector&lt; std::vector&lt; T &gt; &gt;","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; cse491 &gt; is_vector&lt; std::vector&lt; T &gt; &gt;</p> <p>Inherits the following classes: true_type</p> <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Core%20Project/namespaceworldlang/","title":"Namespace worldlang","text":"<p>Namespace List &gt; worldlang</p> <p>A base class for all World modules. More...</p>"},{"location":"Core%20Project/namespaceworldlang/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: ALPHA </p> <p>The documentation for this class was generated from the following file <code>source/core/WorldBase.hpp</code></p>"},{"location":"Core%20Project/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Core%20Project/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir core <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Core%20Project/dir_0d27ce74e9bd514c31e1d63efab6b388/","title":"Dir source/core","text":"<p>FileList &gt; core</p>"},{"location":"Core%20Project/dir_0d27ce74e9bd514c31e1d63efab6b388/#files","title":"Files","text":"Type Name file AgentBase.hpp file CoreObject.hpp file Data.hpp file EasyLogging.hpp file Entity.cpp file Entity.hpp file GridPosition.hpp file InterfaceBase.hpp file ItemBase.hpp file Property.hpp file Serialize.hpp file WorldBase.hpp file WorldGrid.hpp <p>The documentation for this class was generated from the following file <code>source/core/</code></p>"},{"location":"Core%20Project/_agent_base_8hpp/","title":"File AgentBase.hpp","text":"<p>FileList &gt; core &gt; AgentBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"../DataCollection/AgentData.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"Entity.hpp\"</code></li> <li><code>#include \"GridPosition.hpp\"</code></li> <li><code>#include \"WorldGrid.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_agent_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_agent_base_8hpp/#classes","title":"Classes","text":"Type Name class AgentBase <p>The documentation for this class was generated from the following file <code>source/core/AgentBase.hpp</code></p>"},{"location":"Core%20Project/_agent_base_8hpp_source/","title":"File AgentBase.hpp","text":"<p>File List &gt; core &gt; AgentBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;utility&gt;\n\n#include \"../DataCollection/AgentData.hpp\"\n#include \"Data.hpp\"\n#include \"Entity.hpp\"\n#include \"GridPosition.hpp\"\n#include \"WorldGrid.hpp\"\n\nnamespace cse491 {\n\nenum State  \n{\n  Healthy,\n  Taking_Damage,\n  Dying,\n  Deceased\n};\n\nclass AgentBase : public Entity {\nprotected:\n  std::unordered_map&lt;std::string, size_t&gt; action_map;  \n  int action;             \n  int action_result = 0;  \n\n  State agent_state = Healthy;  \n\npublic:\n  AgentBase(size_t id, const std::string &amp;name) : Entity(id, name) {}\n  ~AgentBase() = default;  // Already virtual from Entity\n\n  // -- World Interactions --\n\n  virtual bool Initialize() { return true; }\n\n  // -- Entity Overrides --\n\n  bool IsAgent() const override { return true; }\n\n  // -- Agent Interaction --\n\n  State GetAgentState() { return agent_state; }\n\n  void UpdateAgentState(cse491::AgentBase &amp;agent) {\n    if (agent.HasProperty(\"Health\")) {\n      if (agent.GetProperty&lt;int&gt;(\"Health\") &lt;= agent.GetProperty&lt;int&gt;(\"Max_Health\") &amp;&amp;\n          agent.GetProperty&lt;int&gt;(\"Health\") &gt; 3) {\n        agent.agent_state = Healthy;\n      } else if (agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 3 &amp;&amp; agent.GetProperty&lt;int&gt;(\"Health\") &gt; 0) {\n        agent.agent_state = Dying;\n      } else if (agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 0) {\n        agent.agent_state = Deceased;\n      }\n    }\n    if (agent.HasProperty(\"Taking_Damage\")) {\n      if (agent.GetProperty&lt;bool&gt;(\"Taking_Damage\") == true) {\n        agent.agent_state = Taking_Damage;\n      }\n    }\n  }\n\n  void TakeDamage(cse491::AgentBase &amp;agent) {\n    agent.SetProperty&lt;int&gt;(\n        \"Health\", agent.GetProperty&lt;int&gt;(\"Health\") - agent.GetProperty&lt;int&gt;(\"Taking_Damage\"));\n    UpdateAgentState(agent);\n  }\n\n  // -- Action management --\n\n  [[nodiscard]] bool HasAction(const std::string &amp;action_name) const {\n    return action_map.count(action_name);\n  }\n\n  [[nodiscard]] size_t GetActionID(const std::string &amp;action_name) const {\n    auto it = action_map.find(action_name);\n    if (it == action_map.end()) return 0;\n    return it-&gt;second;\n  }\n\n  void storeActionMap(std::string name) {\n    DataCollection::AgentData data(name);\n    data.StoreAction(action_map);\n  }\n\n  [[nodiscard]] virtual GridPosition GetNextPosition() { return Entity::GetPosition(); }\n\n  virtual AgentBase &amp;AddAction(const std::string &amp;action_name, size_t action_id) {\n    assert(!HasAction(action_name));  // Cannot add existing action name.\n    action_map[action_name] = action_id;\n    return *this;\n  }\n\n  [[nodiscard]] virtual size_t SelectAction([[maybe_unused]] const WorldGrid &amp;grid,\n                                            [[maybe_unused]] const type_options_t &amp;type_options,\n                                            [[maybe_unused]] const item_map_t &amp;item_map,\n                                            [[maybe_unused]] const agent_map_t &amp;agent_map) {\n    return 0;\n  }\n\n  [[nodiscard]] int GetActionResult() const { return action_result; }\n\n  void SetActionResult(int result) { action_result = result; }\n\n  virtual void Notify(const std::string &amp; /*message*/, const std::string &amp; /*msg_type*/ = \"none\") {}\n\n  std::string GetTypeName_impl() const override { return \"cse491::AgentBase\"; }\n\n  void Serialize_impl(std::ostream &amp;os) const override {\n    Entity::Serialize_impl(os);\n    SerializeValue(os, action_map);\n    SerializeValue(os, action);\n    SerializeValue(os, action_result);\n    SerializeValue(os, agent_state);\n  }\n\n  void Deserialize_impl(std::istream &amp;is) override {\n    Entity::Deserialize_impl(is);\n    DeserializeValue(is, action_map);\n    DeserializeValue(is, action);\n    DeserializeValue(is, action_result);\n    DeserializeValue(is, agent_state);\n  }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_core_object_8hpp/","title":"File CoreObject.hpp","text":"<p>FileList &gt; core &gt; CoreObject.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"Serialize.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_core_object_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_core_object_8hpp/#classes","title":"Classes","text":"Type Name class CoreObject"},{"location":"Core%20Project/_core_object_8hpp/#macros","title":"Macros","text":"Type Name define EXPERIMENTAL_CLASS  __attribute__((annotate(\"experimental_class\"))) define EXPERIMENTAL_FUNCTION  __attribute__((annotate(\"experimental_function\")))A common interface class for core objects that sets up required functionality."},{"location":"Core%20Project/_core_object_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Core%20Project/_core_object_8hpp/#define-experimental_class","title":"define EXPERIMENTAL_CLASS","text":"<pre><code>#define EXPERIMENTAL_CLASS __attribute__((annotate(\"experimental_class\")))\n</code></pre>"},{"location":"Core%20Project/_core_object_8hpp/#define-experimental_function","title":"define EXPERIMENTAL_FUNCTION","text":"<p>A common interface class for core objects that sets up required functionality. </p> <pre><code>#define EXPERIMENTAL_FUNCTION __attribute__((annotate(\"experimental_function\")))\n</code></pre> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: ALPHA</p> <p>This CoreObject class builds an interface for all of the core object, ensuring that they can be properly serialized.</p> <p>Derived classes must implement: GetTypeName_impl() - Return the qualified type name. Serialize_impl(std::ostream &amp;) - Store the object in a stream. Deserialize_impl(std::istream &amp;) - Restore the object from a stream. </p> <p>Author:</p> <p>@amantham20 uses as attribute to mark experimental classes and functions </p> <p>The documentation for this class was generated from the following file <code>source/core/CoreObject.hpp</code></p>"},{"location":"Core%20Project/_core_object_8hpp_source/","title":"File CoreObject.hpp","text":"<p>File List &gt; core &gt; CoreObject.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\n#include \"Serialize.hpp\"\n\n#ifndef NDEBUG\n#define EXPERIMENTAL_FUNCTION __attribute__((annotate(\"experimental_function\")))\n#define EXPERIMENTAL_CLASS __attribute__((annotate(\"experimental_class\")))\n\n#else // NDEBUG *not* set, so debug mode.\n#define EXPERIMENTAL_CLASS                       \\\n  __attribute__((annotate(\"experimental_class\"), \\\n                 warning(\"This is an experimental class and should be used with caution.\")))\n#define EXPERIMENTAL_FUNCTION                                              \\\n  __attribute__((annotate(\"experimental_function\"),                        \\\n                 warning(\"This is an experimental function and should be \" \\\n                         \"used with caution.\")))\n#endif\n\nnamespace cse491 {\n\nclass CoreObject {\nprotected:\n  // -- Required functionality in all core classes --\n  // These functions are core functionality that must be implemented in all derived\n  // classes.  They will enable the public interface to behave correctly.\n\n  virtual std::string GetTypeName_impl() const = 0;\n\n  virtual void Serialize_impl(std::ostream &amp;) const = 0;\n\n  virtual void Deserialize_impl(std::istream &amp;) = 0;\n\n  // -- Helper functions --\n  // The functions below can be used in derived classes to implement above functionality.\n\n  void StartSerialize(std::ostream &amp;os) const { os &lt;&lt; \":::START \" &lt;&lt; GetTypeName() &lt;&lt; \"\\n\"; }\n\n  void EndSerialize(std::ostream &amp;os) const { os &lt;&lt; \":::END \" &lt;&lt; GetTypeName() &lt;&lt; \"\\n\"; }\n\n  bool StartDeserialize(std::istream &amp;is) {\n    std::string line;\n    std::getline(is, line);\n    std::string expected = \":::START \" + GetTypeName();\n    if (line != expected) {\n      std::cerr &lt;&lt; \"Deserialization error.  Expected: \" &lt;&lt; expected &lt;&lt; \"...Found: \" &lt;&lt; line;\n      return false;\n    }\n    return true;\n  }\n\n  bool EndDeserialize(std::istream &amp;is) {\n    std::string line;\n    std::getline(is, line);\n    std::string expected = \":::END \" + GetTypeName();\n    if (line != expected) {\n      std::cerr &lt;&lt; \"Deserialization error.  Expected: \" &lt;&lt; expected &lt;&lt; \"...Found: \" &lt;&lt; line;\n      return false;\n    }\n    return true;\n  }\n\n\npublic:\n  virtual ~CoreObject() {}\n\n  auto operator&lt;=&gt;(const CoreObject &amp;) const = default;\n\n  std::string GetTypeName() const { return GetTypeName_impl(); }\n\n  void Serialize(std::ostream &amp;os) const {\n    StartSerialize(os);\n    Serialize_impl(os);\n    EndSerialize(os);\n  }\n\n  void Deserialize(std::istream &amp;is) {\n    StartDeserialize(is);\n    Deserialize_impl(is);\n    EndDeserialize(is);\n  }\n\n  bool Serialize(std::string filename) const {\n    std::ofstream os(filename);\n    if (!os.is_open()) {\n      std::cerr &lt;&lt; \"Could not open file '\" &lt;&lt; filename &lt;&lt; \"' for Serialize().\" &lt;&lt; std::endl;\n      return false;\n    }\n    Serialize(os);\n    return true;\n  }\n\n  bool Deserialize(std::string filename) {\n    std::ifstream is(filename);\n    if (!is.is_open()) {\n      std::cerr &lt;&lt; \"Could not open file '\" &lt;&lt; filename &lt;&lt; \"' for Serialize().\" &lt;&lt; std::endl;\n      return false;\n    }\n    Deserialize(is);\n    return true;\n  }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_data_8hpp/","title":"File Data.hpp","text":"<p>FileList &gt; core &gt; Data.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Core%20Project/_data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_data_8hpp/#classes","title":"Classes","text":"Type Name struct CellType Simple data structure to hold info about a TYPE of cell in the world. <p>The documentation for this class was generated from the following file <code>source/core/Data.hpp</code></p>"},{"location":"Core%20Project/_data_8hpp_source/","title":"File Data.hpp","text":"<p>File List &gt; core &gt; Data.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace cse491 {\n\nstruct CellType {\n  std::string name;  \n  std::string desc;  \n  char symbol;       \n  std::set&lt;std::string&gt; properties{};  \n\n  CellType&amp; SetProperty(const std::string&amp; property) {\n    properties.insert(property);\n    return *this;\n  }\n\n  CellType&amp; RemoveProperty(const std::string&amp; property) {\n    properties.erase(property);\n    return *this;\n  }\n\n  bool HasProperty(const std::string&amp; property) const { return properties.count(property); }\n\n  constexpr static char CELL_WALL[] = \"wall\";\n  constexpr static char CELL_WATER[] = \"water\";\n};\n\nusing type_options_t = std::vector&lt;CellType&gt;;\n\nclass ItemBase;\nusing item_map_t = std::map&lt;size_t, std::unique_ptr&lt;ItemBase&gt;&gt;;\n\nclass AgentBase;\nusing agent_map_t = std::map&lt;size_t, std::unique_ptr&lt;AgentBase&gt;&gt;;\n\nenum class PropertyType { t_double, t_int, t_char, t_string, t_position, t_bool, t_other };\n\nenum class WorldType { w_maze, w_second, w_generative, w_manual };\n\n}  // namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_easy_logging_8hpp/","title":"File EasyLogging.hpp","text":"<p>FileList &gt; core &gt; EasyLogging.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"Core%20Project/_easy_logging_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace clogged Tools for debug-logging that can be easily controlled."},{"location":"Core%20Project/_easy_logging_8hpp/#classes","title":"Classes","text":"Type Name class Logger Logger class with colors and team names."},{"location":"Core%20Project/_easy_logging_8hpp/#macros","title":"Macros","text":"Type Name define LOGLINE  \"File: \" &lt;&lt; __FILE__ &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"Ensure that we only log when NDEBUG flg is not set. define LOG_FNC  \"Function: \" &lt;&lt; __func__ &lt;&lt; \" \" define LOG_RELLINE  \"File: \" &lt;&lt; RELATIVE_PATH(__FILE__) &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\" define RELATIVE_PATH (file)"},{"location":"Core%20Project/_easy_logging_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Core%20Project/_easy_logging_8hpp/#define-logline","title":"define LOGLINE","text":"<pre><code>#define LOGLINE \"File: \" &lt;&lt; __FILE__ &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"\n</code></pre>"},{"location":"Core%20Project/_easy_logging_8hpp/#define-log_fnc","title":"define LOG_FNC","text":"<pre><code>#define LOG_FNC \"Function: \" &lt;&lt; __func__ &lt;&lt; \" \"\n</code></pre>"},{"location":"Core%20Project/_easy_logging_8hpp/#define-log_relline","title":"define LOG_RELLINE","text":"<pre><code>#define LOG_RELLINE \"File: \" &lt;&lt; RELATIVE_PATH(__FILE__) &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"\n</code></pre>"},{"location":"Core%20Project/_easy_logging_8hpp/#define-relative_path","title":"define RELATIVE_PATH","text":"<pre><code>#define RELATIVE_PATH (\n    file\n) (std::string(file).find_last_of(\"/\\\\\") != std::string::npos                \\\n       ? std::string(file).substr(std::string(file).find_last_of(\"/\\\\\") + 1) \\\n       : std::string(file))\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/core/EasyLogging.hpp</code></p>"},{"location":"Core%20Project/_easy_logging_8hpp_source/","title":"File EasyLogging.hpp","text":"<p>File List &gt; core &gt; EasyLogging.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n\nnamespace clogged {\n\nenum class LogLevel { DEBUG, INFO, WARNING, ERR, NA };\n\nenum class Team {\n  TEAM_1,\n  TEAM_2,\n  TEAM_3,\n  TEAM_4,\n  TEAM_5,\n  TEAM_6,\n  TEAM_7,\n  TEAM_8,\n  TEAM_9,\n  GENERAL,\n  NA\n};\n\nenum class Color { RESET = 0, BLUE = 34, GREEN = 32, RED = 31 };\n\nconst LogLevel LOGLEVEL = LogLevel::DEBUG;\n\n#ifndef NDEBUG\n\n#define LOGLINE \"File: \" &lt;&lt; __FILE__ &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"\n\n#define RELATIVE_PATH(file)                                                  \\\n  (std::string(file).find_last_of(\"/\\\\\") != std::string::npos                \\\n       ? std::string(file).substr(std::string(file).find_last_of(\"/\\\\\") + 1) \\\n       : std::string(file))\n\n#define LOG_RELLINE \"File: \" &lt;&lt; RELATIVE_PATH(__FILE__) &lt;&lt; \"::-&gt;::Line(\" &lt;&lt; __LINE__ &lt;&lt; \")\"\n\n#define LOG_FNC \"Function: \" &lt;&lt; __func__ &lt;&lt; \" \"\n\n\nclass Logger {\npublic:\n  Logger &amp;operator&lt;&lt;(Team team) {\n    currentTeam = team;\n    metaPrinted = false;\n    //         std::cout &lt;&lt; endl; //TODO: Might have to enable this so that we\n    //         can have same line logging when endl is not used\n    return *this;\n  }\n\n  Logger &amp;operator&lt;&lt;(LogLevel logLevel) {\n    currentLogLevel = logLevel;\n    metaPrinted = false;\n    return *this;\n  }\n\n  Logger &amp;operator&lt;&lt;(Color color) {\n    currentColor = color;\n    return *this;\n  }\n\n  Logger &amp;operator&lt;&lt;(std::ostream &amp;(*manipulator)(std::ostream &amp;)) {\n    typedef std::ostream &amp;(*EndlManipulator)(std::ostream &amp;);\n\n    // Compare the function pointers\n    if (manipulator == static_cast&lt;EndlManipulator&gt;(std::endl) || manipulator == endl) {\n      // Handle std::endl here\n      currentTeam = Team::NA;\n      currentLogLevel = LogLevel::DEBUG;\n      currentColor = Color::RESET;\n\n      std::cout &lt;&lt; std::endl;\n\n      metaPrinted = false;\n    }\n\n    return *this;\n  }\n\n  template &lt;typename T&gt;\n  Logger &amp;operator&lt;&lt;(const T &amp;value) {\n    // TODO: Define when to log by loglevel comparison. Goal is to send it in as\n    // a flag in the CMakeLists.txt\n    if (currentLogLevel &gt;= LOGLEVEL) {\n      // added additional flag in case one wants to compile without colors (or)\n      // if the terminal does not support colors\n#ifndef D_ANSI_COLOR_CODES\n      std::string colorStart = \"\\033[\" + std::to_string(static_cast&lt;int&gt;(currentColor)) + \"m\";\n      std::string colorEnd = \"\\033[0m\";\n#else\n      std::string colorStart = \"\";\n      std::string colorEnd = \"\";\n#endif\n      std::ostringstream logMessage;\n      logMessage &lt;&lt; colorStart;\n      if (!metaPrinted) {\n        logMessage &lt;&lt; teamToString(currentTeam) &lt;&lt; logToString(currentLogLevel);\n        metaPrinted = true;\n      }\n\n      logMessage &lt;&lt; value &lt;&lt; colorEnd;\n      std::cout &lt;&lt; logMessage.str();  // &lt;&lt; std::endl;  //TODO: Might have to\n                                      // make enable this so that we can have\n                                      // same line logging when endl is not used\n    }\n\n    return *this;\n  }\n\n  static Logger &amp;Log() {\n    static Logger instance;  // Guaranteed to be initialized only once.\n    return instance;\n  }\n\n  template &lt;typename T, typename... EXTRA_Ts&gt;\n  static Logger &amp;Log(T &amp;&amp;arg1, EXTRA_Ts &amp;&amp;...extra_args) {\n    Log() &lt;&lt; std::forward&lt;T&gt;(arg1);            // Log the first argument.\n    if constexpr (sizeof...(EXTRA_Ts) == 0) {  // No arguments left.\n      return Log() &lt;&lt; Logger::endl;            // Trigger a flush.\n    } else {\n      return Log(std::forward&lt;EXTRA_Ts&gt;(extra_args)...);  // Log remaining arguments.\n    }\n  }\n\n  static std::ostream &amp;endl(std::ostream &amp;os) {\n    Log() &lt;&lt; std::endl;  // Call the custom Logger::endl to reset values\n    return os;\n  }\n\nprivate:\n  Team currentTeam = Team::NA;\n\n  LogLevel currentLogLevel = LogLevel::DEBUG;\n\n  Color currentColor = Color::RESET;\n\n  bool metaPrinted = false;\n\n  std::map&lt;Team, std::string&gt; teamToStringMap = {\n      {Team::TEAM_1, \"Team 1\"},  {Team::TEAM_2, \"Team 2\"}, {Team::TEAM_3, \"Team 3\"},\n      {Team::TEAM_4, \"Team 4\"},  {Team::TEAM_5, \"Team 5\"}, {Team::TEAM_6, \"Team 6\"},\n      {Team::TEAM_7, \"Team 7\"},  {Team::TEAM_8, \"Team 8\"}, {Team::TEAM_9, \"Team 9\"},\n      {Team::GENERAL, \"General\"}};\n\n  std::string teamToString(Team team) {\n    auto it = teamToStringMap.find(team);\n    if (it != teamToStringMap.end()) {\n      return \"[\" + it-&gt;second + \"]\";\n    }\n\n    return \"\";\n  }\n\n  std::string logToString(LogLevel logLevel) {\n    if (logLevel == LogLevel::DEBUG) {\n      return \"(DEBUG) \";\n    } else if (logLevel == LogLevel::INFO) {\n      return \"(INFO) \";\n    } else if (logLevel == LogLevel::WARNING) {\n      return \"(WARNING) \";\n    } else if (logLevel == LogLevel::ERR) {\n      return \"(ERROR) \";\n    } else {\n      return \"\";\n    }\n  }\n};\n\n#else\n\n#define LOGLINE \"\"\n#define LOG_RELLINE \"\"\n#define LOG_FNC \"\"\n\n// #define log Log()\n\nclass Logger {\npublic:\n  template &lt;typename T&gt;\n  Logger &amp;operator&lt;&lt;(const T &amp; /*value*/) {\n    return *this;\n  }\n\n  Logger &amp;operator&lt;&lt;(std::ostream &amp;(* /*manipulator*/)(std::ostream &amp;)) { return *this; }\n\n  static std::ostream &amp;endl(std::ostream &amp;os) { return os; }\n\n  static Logger &amp;Log() {\n    static Logger instance;  // Guaranteed to be initialized only once.\n    return instance;\n  }\n};\n\n// Logger Logger::log;\n#endif\n\n}  // namespace clogged\n\n</code></pre>"},{"location":"Core%20Project/_entity_8cpp/","title":"File Entity.cpp","text":"<p>FileList &gt; core &gt; Entity.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Entity.hpp\"</code></li> <li><code>#include \"WorldBase.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_entity_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types. <p>The documentation for this class was generated from the following file <code>source/core/Entity.cpp</code></p>"},{"location":"Core%20Project/_entity_8cpp_source/","title":"File Entity.cpp","text":"<p>File List &gt; core &gt; Entity.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#include \"Entity.hpp\"\n#include \"WorldBase.hpp\"\n\nnamespace cse491 {\n\n  Entity &amp; Entity::SetPosition(GridPosition in_pos, size_t grid_id) {\n    position = in_pos;\n    if (IsItem()) {\n      auto &amp; item = static_cast&lt;ItemBase&amp;&gt;(*this);\n      item.SetGrid(grid_id);\n    }\n    return *this;\n  }\n\n  Entity &amp; Entity::AddItem(size_t id) {\n    assert(!HasItem(id));\n    inventory.push_back(id);\n    world_ptr-&gt;GetItem(id).SetOwner(*this);\n    return *this;\n  }\n\n  Entity &amp; Entity::RemoveItem(size_t id) {\n    assert(HasItem(id));\n    inventory.erase(std::find(inventory.begin(), inventory.end(), id));\n    world_ptr-&gt;GetItem(id).SetUnowned();\n    return *this;\n  }\n\n}\n\n</code></pre>"},{"location":"Core%20Project/_entity_8hpp/","title":"File Entity.hpp","text":"<p>FileList &gt; core &gt; Entity.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;istream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"CoreObject.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"GridPosition.hpp\"</code></li> <li><code>#include \"Property.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_entity_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_entity_8hpp/#classes","title":"Classes","text":"Type Name class Entity <p>The documentation for this class was generated from the following file <code>source/core/Entity.hpp</code></p>"},{"location":"Core%20Project/_entity_8hpp_source/","title":"File Entity.hpp","text":"<p>File List &gt; core &gt; Entity.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;istream&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"CoreObject.hpp\"\n#include \"Data.hpp\"\n#include \"GridPosition.hpp\"\n#include \"Property.hpp\"\n\nnamespace cse491 {\n\nclass WorldBase;\n\nclass Entity : public CoreObject {\nprivate:\n  WorldBase *world_ptr = nullptr;  \n\nprotected:\n  size_t id = 0;          \n  std::string name = \"\";  \n\n  size_t grid_id = 0;     \n  GridPosition position;  \n\n  std::vector&lt;size_t&gt; inventory; \n\n  using property_map_t = std::unordered_map&lt;std::string, std::unique_ptr&lt;PropertyBase&gt;&gt;;\n  property_map_t property_map;\n\n  // -- Helper Functions --\n\n  template &lt;typename T&gt;\n  Property&lt;T&gt; &amp;AsProperty(const std::string &amp;name) const {\n    assert(HasProperty(name));\n    PropertyBase *raw_ptr = property_map.at(name).get();\n    assert(dynamic_cast&lt;Property&lt;T&gt; *&gt;(raw_ptr));\n    auto property_ptr = static_cast&lt;Property&lt;T&gt; *&gt;(raw_ptr);\n    return *property_ptr;\n  }\n\npublic:\n  Entity(size_t id, const std::string &amp;name) : id(id), name(name) {}\n  Entity(const Entity &amp;) = delete;  // Entities must be unique and shouldn't be copied.\n  Entity(Entity &amp;&amp;) = default;\n  virtual ~Entity() = default;\n\n  Entity &amp;operator=(const Entity &amp;) = delete;  // Entities must be unique and shouldn't be copied.\n  Entity &amp;operator=(Entity &amp;&amp;) = delete;       // Entities should never have IDs change.\n\n  // -- Accessors --\n  [[nodiscard]] size_t GetID() const { return id; }\n  [[nodiscard]] const std::string &amp;GetName() const { return name; }\n  [[nodiscard]] GridPosition GetPosition() const { return position; }\n  [[nodiscard]] WorldBase &amp;GetWorld() const {\n    assert(world_ptr);\n    return *world_ptr;\n  }\n  [[nodiscard]] size_t GetGridID() const { return grid_id; }\n  [[nodiscard]] bool IsOnGrid(size_t in_grid_id) const { return grid_id == in_grid_id; }\n\n  [[nodiscard]] bool HasWorld() const { return world_ptr != nullptr; }\n  Entity &amp;SetName(const std::string in_name) {\n    name = in_name;\n    return *this;\n  }\n  Entity &amp;SetPosition(GridPosition in_pos, size_t grid_id = 0);\n  Entity &amp;SetPosition(double x, double y) {\n    position = GridPosition{x, y};\n    return *this;\n  }\n  virtual Entity &amp;SetWorld(WorldBase &amp;in_world) {\n    world_ptr = &amp;in_world;\n    return *this;\n  }\n\n  virtual bool IsAgent() const { return false; }      \n  virtual bool IsItem() const { return false; }       \n  virtual bool IsInterface() const { return false; }  \n\n  // -- Property Management --\n\n  [[nodiscard]] bool HasProperty(const std::string &amp;name) const { return property_map.count(name); }\n\n  [[nodiscard]] size_t GetNumProperties() const { return property_map.size(); }\n\n  template &lt;typename T = double&gt;\n  [[nodiscard]] const T &amp;GetProperty(const std::string &amp;name) const {\n    assert(HasProperty(name));  // Break if property does not already exist.\n    return AsProperty&lt;T&gt;(name).value;\n  }\n\n  [[nodiscard]] PropertyType GetPropertyType(const std::string &amp;name) const {\n    auto it = property_map.find(name);\n    if (it == property_map.end()) return PropertyType::t_other;\n    return it-&gt;second-&gt;GetType();\n  }\n\n  template &lt;typename T&gt;\n  Entity &amp;SetProperty(const std::string &amp;name, const T &amp;value) {\n    if (HasProperty(name)) {\n      AsProperty&lt;T&gt;(name).value = value;\n    } else {\n      property_map[name] = std::make_unique&lt;Property&lt;T&gt;&gt;(value);\n    }\n    return *this;\n  }\n\n  Entity &amp;SetProperties() { return *this; }\n\n  template &lt;typename VALUE_T, typename... EXTRA_Ts&gt;\n  Entity &amp;SetProperties(const std::string &amp;name, VALUE_T &amp;&amp;value, EXTRA_Ts &amp;&amp;...extras) {\n    SetProperty(name, std::forward&lt;VALUE_T&gt;(value));          // Set the first property...\n    return SetProperties(std::forward&lt;EXTRA_Ts&gt;(extras)...);  // And any additional properties...\n  }\n\n  Entity &amp;RemoveProperty(const std::string &amp;name) {\n    property_map.erase(name);\n    return *this;\n  }\n\n  property_map_t &amp;GetPropertyMap() {\n    return property_map;\n  }\n\n  bool HasItem(size_t id) const {\n    return std::find(inventory.begin(), inventory.end(), id) != inventory.end();\n  }\n\n  Entity &amp;AddItem(size_t id);\n  Entity &amp;AddItem(Entity &amp;item) { return AddItem(item.GetID()); }\n\n  Entity &amp;RemoveItem(size_t id);\n  Entity &amp;RemoveItem(Entity &amp;item) { return RemoveItem(item.GetID()); }\n\n  void Serialize_impl(std::ostream &amp;os) const override {\n    SerializeValue(os, id);\n    SerializeValue(os, name);\n    SerializeValue(os, grid_id);\n    SerializeValue(os, position);\n    SerializeValue(os, inventory);\n\n    SerializeValue(os, property_map.size());\n    for (const auto &amp; [name, ptr] : property_map) {\n      SerializeValue(os, name);\n      SerializeValue(os, ptr-&gt;GetType());\n      SerializeValue(os, ptr-&gt;ToString());\n    }\n  }\n\n  void Deserialize_impl(std::istream &amp;is) override {\n    DeserializeValue(is, id);\n    DeserializeValue(is, name);\n    DeserializeValue(is, grid_id);\n    DeserializeValue(is, position);\n    DeserializeValue(is, inventory);\n\n    size_t num_properties = 0;\n    property_map.clear();\n    std::string name;\n    PropertyType type;\n    DeserializeValue(is, num_properties);\n    for (size_t i = 0; i &lt; num_properties; ++i) {\n      DeserializeValue(is, name);\n      DeserializeValue(is, type);\n      switch (type) {\n        using enum PropertyType;\n      case t_char:     SetProperty(name, DeserializeAs&lt;char&gt;(is));         break;\n      case t_double:   SetProperty(name, DeserializeAs&lt;double&gt;(is));       break;\n      case t_int:      SetProperty(name, DeserializeAs&lt;int&gt;(is));          break;\n      case t_bool:     SetProperty(name, DeserializeAs&lt;bool&gt;(is));          break;\n      case t_string:   SetProperty(name, DeserializeAs&lt;std::string&gt;(is));  break;\n      case t_position: SetProperty(name, DeserializeAs&lt;GridPosition&gt;(is)); break;\n      case t_other:\n        std::cerr &lt;&lt; \"Warning: Cannot deserialize property'\" &lt;&lt; name &lt;&lt; \"'.\" &lt;&lt; std::endl;\n        std::string tmp_str;\n        std::getline(is, tmp_str, '\\n');\n        std::cerr &lt;&lt; \"  Data for that property: \\\"\" &lt;&lt; tmp_str &lt;&lt; \"\\\".\" &lt;&lt; std::endl;\n      }\n    }\n  }\n\n  [[nodiscard]] std::vector&lt;size_t&gt; GetInventory() const { return inventory; }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_grid_position_8hpp/","title":"File GridPosition.hpp","text":"<p>FileList &gt; core &gt; GridPosition.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;compare&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"CoreObject.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_grid_position_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_grid_position_8hpp/#classes","title":"Classes","text":"Type Name class GridPosition Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. <p>The documentation for this class was generated from the following file <code>source/core/GridPosition.hpp</code></p>"},{"location":"Core%20Project/_grid_position_8hpp_source/","title":"File GridPosition.hpp","text":"<p>File List &gt; core &gt; GridPosition.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;    // For sqrt and std::nan()\n#include &lt;compare&gt;  // For operator&lt;=&gt;\n#include &lt;cstddef&gt;  // For size_t\n#include &lt;sstream&gt;  // For std::stringstream\n#include &lt;string&gt;\n\n#include \"CoreObject.hpp\"\n\nnamespace cse491 {\n\nclass GridPosition : public CoreObject {\nprivate:\n  double x = 0.0;\n  double y = 0.0;\n\npublic:\n  GridPosition() = default;\n  GridPosition(double x, double y) : x(x), y(y) {}\n  GridPosition(const std::string &amp; str) { FromString(str); }\n  GridPosition(const GridPosition &amp;) = default;\n\n  ~GridPosition() = default;\n\n  GridPosition &amp;operator=(const GridPosition &amp;) = default;\n\n  // -- Accessors --\n\n  [[nodiscard]] double GetX() const { return x; }\n  [[nodiscard]] double GetY() const { return y; }\n  [[nodiscard]] size_t CellX() const { return static_cast&lt;size_t&gt;(x); }\n  [[nodiscard]] size_t CellY() const { return static_cast&lt;size_t&gt;(y); }\n\n  auto operator&lt;=&gt;(const GridPosition &amp;) const = default;\n\n  [[nodiscard]] bool IsInvalid() const { return std::isnan(x) || std::isnan(y); }\n  [[nodiscard]] bool IsValid() const { return !IsInvalid(); }\n\n  // -- Modifiers --\n\n  GridPosition &amp;Set(double in_x, double in_y) {\n    x = in_x;\n    y = in_y;\n    return *this;\n  }\n  GridPosition &amp;SetX(double in) { x = in; return *this; }\n  GridPosition &amp;SetY(double in) { y = in; return *this; }\n\n  GridPosition &amp;Shift(double shift_x, double shift_y) {\n    x += shift_x;\n    y += shift_y;\n    return *this;\n  }\n\n  GridPosition &amp;operator+=(const GridPosition &amp;in) { return Shift(in.x, in.y); }\n  GridPosition &amp;operator-=(const GridPosition &amp;in) { return Shift(-in.x, -in.y); }\n\n  GridPosition &amp;MakeInvalid() {\n    x = y = std::nan(\"NAN(0)\");\n    return *this;\n  }\n\n  // A static function to request an invalid grid position.\n  static const GridPosition &amp; Invalid() {\n    static GridPosition invalid_pos(std::nan(\"NAN(0)\"), std::nan(\"NAN(0)\"));\n    return invalid_pos;\n  }\n\n  // -- Const Operations --\n\n  [[nodiscard]] GridPosition GetOffset(double offset_x, double offset_y) const {\n    return GridPosition{x + offset_x, y + offset_y};\n  }\n\n  [[nodiscard]] GridPosition Above(double dist = 1.0) const { return GetOffset(0.0, -dist); }\n\n  [[nodiscard]] GridPosition Below(double dist = 1.0) const { return GetOffset(0.0, dist); }\n\n  [[nodiscard]] GridPosition ToLeft(double dist = 1.0) const { return GetOffset(-dist, 0.0); }\n\n  [[nodiscard]] GridPosition ToRight(double dist = 1.0) const { return GetOffset(dist, 0.0); }\n\n  [[nodiscard]] GridPosition operator+(GridPosition in) const { return GetOffset(in.x, in.y); }\n\n  [[nodiscard]] double Distance(GridPosition pos2) const {\n    const double dist1 = x - pos2.x;\n    const double dist2 = y - pos2.y;\n    return sqrt(dist1 * dist1 + dist2 * dist2);\n  }\n\n  [[nodiscard]] double MDistance(GridPosition pos2) const {\n    const double dist1 = x - pos2.x;\n    const double dist2 = y - pos2.y;\n    return abs(dist1) + abs(dist2);\n  }\n\n  [[nodiscard]] bool IsNear(GridPosition pos2, double max_dist = 1.0) const {\n    const double dist1 = x - pos2.x;\n    const double dist2 = y - pos2.y;\n    return (dist1 * dist1 + dist2 * dist2) &lt;= (max_dist * max_dist);\n  }\n\n  [[nodiscard]] std::string ToString() const {\n    std::stringstream ss;\n    ss &lt;&lt; '(' &lt;&lt; x &lt;&lt; ',' &lt;&lt; y &lt;&lt; ')';\n    return ss.str();\n  }\n\n  GridPosition &amp; FromStream(std::istream &amp; ss) {\n    // Format should be \"(x,y)\" with values filled in.\n    // Any deviation from this format produces an undefined position.\n    char c = '\\0';    \n    ss &gt;&gt; c;\n    if (c != '(') return MakeInvalid();\n    ss &gt;&gt; x;\n    ss &gt;&gt; c;\n    if (c != ',') return MakeInvalid();\n    ss &gt;&gt; y;\n    ss &gt;&gt; c;\n    if (c != ')') return MakeInvalid();\n\n    return *this;\n  }\n\n  GridPosition &amp; FromString(std::string in_str) {\n    // Format should be \"(x,y)\" with values filled in.\n    // Any deviation from this format produces an undefined position.\n    std::stringstream ss(in_str);\n    return FromStream(ss); \n  }\n\n\n  // --- CoreObject Functionality ---\n  std::string GetTypeName_impl() const override { return \"cse491::GridPosition\"; }\n\n  void Serialize_impl(std::ostream &amp; os) const override {\n    SerializeValue(os, x);\n    SerializeValue(os, y);\n  };\n\n  void Deserialize_impl(std::istream &amp; is) override {\n    DeserializeValue(is, x);\n    DeserializeValue(is, y);\n  };\n\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_interface_base_8hpp/","title":"File InterfaceBase.hpp","text":"<p>FileList &gt; core &gt; InterfaceBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"../DataCollection/DataManager.hpp\"</code></li> <li><code>#include \"AgentBase.hpp\"</code></li> <li><code>#include \"ItemBase.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_interface_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_interface_base_8hpp/#classes","title":"Classes","text":"Type Name class InterfaceBase <p>The documentation for this class was generated from the following file <code>source/core/InterfaceBase.hpp</code></p>"},{"location":"Core%20Project/_interface_base_8hpp_source/","title":"File InterfaceBase.hpp","text":"<p>File List &gt; core &gt; InterfaceBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;string&gt;\n\n#include \"../DataCollection/DataManager.hpp\"\n#include \"AgentBase.hpp\"\n#include \"ItemBase.hpp\"\n\nnamespace cse491 {\n\nclass InterfaceBase : public AgentBase {\nprotected:\n  static void exitCleanup() {\n    DataCollection::DataManager::GetInstance().WriteToJson();\n    exit(0);\n  }\n\npublic:\n  InterfaceBase(size_t id, const std::string&amp; name) : AgentBase(id, name) {}\n  ~InterfaceBase() = default;  // Already virtual from Entity\n\n  // -- Entity Overrides --\n\n  bool IsInterface() const override { return true; }\n\n  // -- AgentBase overrides --\n  //\n  // Multiple functions defined as virtual in AgentBase can also be overridden from\n  // custom Interfaces.  Specific available function to override include:\n\n  // bool Initialize() { return true; }\n  //\n  // Initialize is run AFTER the world configures the interface with actions, etc, allowing\n  // for additional setup, such as targeted buttons.\n\n  // size_t SelectAction([[maybe_unused]] const WorldGrid &amp; grid) { return 0; }\n  //\n  // SelectAction is run when the world is given the player an opportunity to choose\n  // and action to perform. The interface will be provided with the current WorldGrid\n  // Return the ID associated with the action to perform; (zero is always \"no action\")\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_item_base_8hpp/","title":"File ItemBase.hpp","text":"<p>FileList &gt; core &gt; ItemBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"Entity.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_item_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_item_base_8hpp/#classes","title":"Classes","text":"Type Name class ItemBase <p>The documentation for this class was generated from the following file <code>source/core/ItemBase.hpp</code></p>"},{"location":"Core%20Project/_item_base_8hpp_source/","title":"File ItemBase.hpp","text":"<p>File List &gt; core &gt; ItemBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\n#include \"Data.hpp\"\n#include \"Entity.hpp\"\n\nnamespace cse491 {\n\nclass ItemBase : public Entity {\nprotected:\n  enum OwnerType { NONE = 0, GRID, ITEM, AGENT };\n  OwnerType owner_type = OwnerType::NONE;\n  size_t owner_id = 0;\n\npublic:\n  ItemBase(size_t id, const std::string &amp;name) : Entity(id, name) {}\n  ~ItemBase() = default;  // Already virtual from Entity\n\n  // -- Entity Overrides --\n\n  bool IsItem() const override { return true; }\n\n  // -- Ownership Info --\n  [[nodiscard]] bool IsOnGrid() const { return owner_type == OwnerType::GRID; }\n  [[nodiscard]] bool IsOwnedByItem() const { return owner_type == OwnerType::ITEM; }\n  [[nodiscard]] bool IsOwnedByAgent() const { return owner_type == OwnerType::AGENT; }\n  [[nodiscard]] bool IsOwned() const { return IsOwnedByItem() || IsOwnedByAgent(); }\n  [[nodiscard]] bool IsOnGrid(size_t grid_id) const { return IsOnGrid() &amp;&amp; owner_id == grid_id; }\n  [[nodiscard]] bool IsOwnedByItem(size_t item_id) const {\n    return IsOwnedByItem() &amp;&amp; owner_id == item_id;\n  }\n  [[nodiscard]] bool IsOwnedByAgent(size_t agent_id) const {\n    return IsOwnedByAgent() &amp;&amp; owner_id == agent_id;\n  }\n  [[nodiscard]] bool IsOwnedBy(size_t entity_id) const {\n    return IsOwned() &amp;&amp; owner_id == entity_id;\n  }\n  [[nodiscard]] size_t GetOwnerID() const { return owner_id; }\n\n  ItemBase &amp;SetOwner(const Entity &amp;owner) {\n    if (owner.IsItem())\n      owner_type = OwnerType::ITEM;\n    else if (owner.IsAgent())\n      owner_type = OwnerType::AGENT;\n    else\n      owner_type = OwnerType::NONE;  // Error?\n    owner_id = owner.GetID();\n    position.MakeInvalid();\n    return *this;\n  }\n\n  ItemBase &amp;SetGrid(size_t grid_id = 0) {\n    owner_type = OwnerType::GRID;\n    owner_id = grid_id;\n    return *this;\n  }\n  ItemBase &amp;SetUnowned() {\n    owner_type = OwnerType::NONE;\n    return *this;\n  }\n\n  std::string GetTypeName_impl() const override { return \"cse491::ItemBase\"; }\n\n  void Serialize_impl(std::ostream &amp;os) const override {\n    Entity::Serialize_impl(os);\n    SerializeValue(os, owner_type);\n    SerializeValue(os, owner_id);\n  }\n\n  void Deserialize_impl(std::istream &amp;is) override {\n    Entity::Deserialize_impl(is);\n    DeserializeValue(is, owner_type);\n    DeserializeValue(is, owner_id);\n  }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_property_8hpp/","title":"File Property.hpp","text":"<p>FileList &gt; core &gt; Property.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"CoreObject.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"GridPosition.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_property_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_property_8hpp/#classes","title":"Classes","text":"Type Name struct Property &lt;typename T&gt; struct PropertyBase <p>The documentation for this class was generated from the following file <code>source/core/Property.hpp</code></p>"},{"location":"Core%20Project/_property_8hpp_source/","title":"File Property.hpp","text":"<p>File List &gt; core &gt; Property.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n\n#include \"CoreObject.hpp\"\n#include \"Data.hpp\"\n#include \"GridPosition.hpp\"\n\nnamespace cse491 {\n\nstruct PropertyBase : public CoreObject {\n  virtual ~PropertyBase() {}\n  virtual PropertyType GetType() const = 0;\n  virtual std::string GetTypeName() const = 0;\n  virtual std::string ToString() const = 0;\n  virtual char ToChar() const = 0;\n  virtual double ToDouble() const = 0;\n  virtual int ToInt() const = 0;\n  virtual GridPosition ToGridPosition() const = 0;\n};\n\n// For the moment, properties can be char, int, double, string, or GridPosition\ntemplate &lt;typename T&gt;\nstruct Property : public PropertyBase {\n  T value;\n  Property(const T &amp;in) : value(in) {}\n  Property(T &amp;&amp;in) : value(in) {}\n\n  PropertyType GetType() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return PropertyType::t_char;\n    if constexpr (std::is_same&lt;T, int&gt;())          return PropertyType::t_int;\n    if constexpr (std::is_same&lt;T, bool&gt;())         return PropertyType::t_bool;\n    if constexpr (std::is_same&lt;T, double&gt;())       return PropertyType::t_double;\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return PropertyType::t_string;\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return PropertyType::t_position;\n    return PropertyType::t_other;\n  }\n\n  std::string GetTypeName() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return \"char\";\n    if constexpr (std::is_same&lt;T, int&gt;())          return \"int\";\n    if constexpr (std::is_same&lt;T, bool&gt;())         return \"bool\";\n    if constexpr (std::is_same&lt;T, double&gt;())       return \"double\";\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return \"string\";\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return \"GridPosition\";\n    return \"unknown\";\n  }\n\n  std::string ToString() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return std::string(1, value);\n    if constexpr (std::is_same&lt;T, int&gt;())          return std::to_string(value);\n    if constexpr (std::is_same&lt;T, double&gt;())       return std::to_string(value);\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return value;\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return value.ToString();\n    return \"unknown\";\n  }\n\n  char ToChar() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return value;\n    if constexpr (std::is_same&lt;T, int&gt;())          return static_cast&lt;char&gt;(value);\n    if constexpr (std::is_same&lt;T, double&gt;())       return static_cast&lt;char&gt;(value);\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return value.size() ? value[0] : '\\0';\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return '\\0'; // No conversion.\n    return '\\0';\n  }\n\n  double ToDouble() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return static_cast&lt;double&gt;(value);\n    if constexpr (std::is_same&lt;T, int&gt;())          return static_cast&lt;double&gt;(value);\n    if constexpr (std::is_same&lt;T, double&gt;())       return value;\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return std::stod(value);\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return std::nan(\"nan\"); // No conversion.\n    return std::nan(\"nan\");\n  }\n\n  int ToInt() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return static_cast&lt;int&gt;(value);\n    if constexpr (std::is_same&lt;T, int&gt;())          return value;\n    if constexpr (std::is_same&lt;T, double&gt;())       return static_cast&lt;int&gt;(value);\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return std::stoi(value);\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return 0; // No conversion.\n    return 0;\n  }\n\n  GridPosition ToGridPosition() const override {\n    if constexpr (std::is_same&lt;T, char&gt;())         return GridPosition::Invalid();\n    if constexpr (std::is_same&lt;T, int&gt;())          return GridPosition::Invalid();\n    if constexpr (std::is_same&lt;T, double&gt;())       return GridPosition::Invalid();\n    if constexpr (std::is_same&lt;T, std::string&gt;())  return GridPosition(value);\n    if constexpr (std::is_same&lt;T, GridPosition&gt;()) return value;\n    return GridPosition::Invalid();\n  }\n\n  // --- CoreObject Functionality ---\n  std::string GetTypeName_impl() const override {\n    return std::string(\"cse491::Property&lt;\") + GetTypeName() + \"&gt;\";\n  }\n\n  void Serialize_impl(std::ostream &amp; os) const override {\n    SerializeValue(os, value);\n  };\n\n  void Deserialize_impl(std::istream &amp; is) override {\n    DeserializeValue(is, value);\n  };\n};\n\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_serialize_8hpp/","title":"File Serialize.hpp","text":"<p>FileList &gt; core &gt; Serialize.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Core%20Project/_serialize_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_serialize_8hpp/#classes","title":"Classes","text":"Type Name struct is_any_map &lt;typename T&gt;Type trait to determine if we are working with any type of map. struct is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; &lt;typename KEY_T, typename VALUE_T&gt; struct is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; &lt;typename KEY_T, typename VALUE_T&gt; struct is_vector &lt;typename T&gt;Type trait to determine if we are working with a vector. struct is_vector&lt; std::vector&lt; T &gt; &gt; &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>source/core/Serialize.hpp</code></p>"},{"location":"Core%20Project/_serialize_8hpp_source/","title":"File Serialize.hpp","text":"<p>File List &gt; core &gt; Serialize.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nnamespace cse491 {\n\n// --- Pre-declarations of Functions ---\ntemplate &lt;typename T&gt; static void SerializeValue_Vector(std::ostream &amp;, const std::vector&lt;T&gt; &amp;);\ntemplate &lt;typename T&gt; static void SerializeValue_Map(std::ostream &amp;, const T &amp;);\ntemplate &lt;typename T&gt; static void DeserializeValue_Vector(std::istream &amp;, std::vector&lt;T&gt; &amp;);\ntemplate &lt;typename T&gt; static void DeserializeValue_Map(std::istream &amp;, T &amp;);\n\n\n// --- Type Traits ---\n\ntemplate &lt;typename T&gt; struct is_vector : std::false_type {};\ntemplate &lt;typename T&gt; struct is_vector&lt;std::vector&lt;T&gt;&gt; : std::true_type {};\n\ntemplate &lt;typename T&gt;\nstruct is_any_map : std::false_type {};\ntemplate &lt;typename KEY_T, typename VALUE_T&gt;\nstruct is_any_map&lt;std::map&lt;KEY_T, VALUE_T&gt;&gt; : std::true_type {};\ntemplate &lt;typename KEY_T, typename VALUE_T&gt;\nstruct is_any_map&lt;std::unordered_map&lt;KEY_T, VALUE_T&gt;&gt; : std::true_type {};\n\ntemplate &lt;typename STREAM_T, typename OBJ_T&gt;\nconcept CanStreamTo = requires(STREAM_T &amp; stream, OBJ_T value) {\n  { stream &lt;&lt; value } -&gt; std::convertible_to&lt;std::ostream&amp;&gt;;\n};\n\ntemplate &lt;typename STREAM_T, typename OBJ_T&gt;\nconcept CanStreamFrom = requires(STREAM_T &amp; stream, OBJ_T value) {\n  { stream &gt;&gt; value } -&gt; std::convertible_to&lt;std::istream&amp;&gt;;\n};\n\ntemplate &lt;typename OBJ_T&gt;\nconcept HasSerialize = requires(OBJ_T value) {\n  { value.Serialize(std::cout) } -&gt; std::same_as&lt;void&gt;;\n};\n\ntemplate &lt;typename OBJ_T&gt;\nconcept HasDeserialize = requires(OBJ_T value) {\n  { value.Deserialize(std::cin) } -&gt; std::same_as&lt;void&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstatic void SerializeValue(std::ostream &amp; os, const T &amp; var) {\n  if constexpr (std::is_enum&lt;T&gt;()) {\n    os &lt;&lt; static_cast&lt;int&gt;(var) &lt;&lt; std::endl;\n  } else if constexpr (is_vector&lt;T&gt;()) {\n    SerializeValue_Vector(os, var);\n  } else if constexpr (is_any_map&lt;T&gt;()) {\n    SerializeValue_Map(os, var);\n  } else if constexpr (HasSerialize&lt;T&gt;) {\n    var.Serialize(os);\n  } else if constexpr (CanStreamTo&lt;std::stringstream, T&gt;) {\n    os &lt;&lt; var &lt;&lt; '\\n';\n  } else {\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic void SerializeValue_Vector(std::ostream &amp; os, const std::vector&lt;T&gt; &amp; var) {\n  SerializeValue(os, var.size());\n  for (const auto &amp; x : var) {\n    SerializeValue(os, x);\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic void SerializeValue_Map(std::ostream &amp; os, const T &amp; var) {\n  SerializeValue(os, var.size());\n  for (const auto &amp; [key, value] : var) {\n    SerializeValue(os, key);\n    SerializeValue(os, value);\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic void DeserializeValue(std::istream &amp; is, T &amp; var) {\n  static_assert(!std::is_const&lt;T&gt;(), \"Cannot deserialize const variables.\");\n\n  // If we are loading a string, load it directly.\n  if constexpr (std::is_same&lt;std::decay_t&lt;T&gt;, std::string&gt;()) {\n    std::getline(is, var, '\\n');\n  } else if constexpr (is_vector&lt;T&gt;()) {\n    DeserializeValue_Vector(is, var);\n  } else if constexpr (is_any_map&lt;T&gt;()) {\n    DeserializeValue_Map(is, var);\n  } else if constexpr (HasDeserialize&lt;T&gt;) {\n    var.Deserialize(is);\n  } else {\n    // @CAO: This can be streamlined to use only the original is, and based on type.\n    //       For example, \"is &lt;&lt; var\" followed by \"is.peek()\" to make sure we have a\n    //       newline, and then \"is.ignore()\" to skip the newline.\n    std::string str;\n    std::getline(is, str, '\\n');\n    std::stringstream ss(str);\n    if constexpr (std::is_enum&lt;T&gt;()) { // enums must be converted properly.\n      int enum_val;\n      ss &gt;&gt; enum_val;\n      var = static_cast&lt;T&gt;(enum_val);\n    } else if constexpr (CanStreamFrom&lt;std::stringstream, T&gt;) {\n      ss &gt;&gt; var;\n    } else if constexpr (std::is_pointer&lt;T&gt;()) {\n      std::cerr &lt;&lt; \"Warning: Attempting to deserialize pointer.\" &lt;&lt; std::endl;\n    } else { \n      // Finally, ignore this value?  Most likely a pointer.\n      std::cerr &lt;&lt; \"Warning: Attempting to deserialize unknown type.\" &lt;&lt; std::endl;\n    }\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic void DeserializeFunction(std::istream &amp; is, std::function&lt;void(T)&gt; set_fun) {\n  std::string str;\n  std::getline(is, str, '\\n');\n  if constexpr (std::is_same&lt;std::decay_t&lt;T&gt;, std::string&gt;()) {\n    set_fun(str);\n  } else if constexpr (std::is_same&lt;std::decay_t&lt;T&gt;, int&gt;()) {\n    set_fun(stoi(str));\n  } else if constexpr (std::is_same&lt;std::decay_t&lt;T&gt;, double&gt;()) {\n    set_fun(stod(str));\n  } else {\n    T var;\n    std::stringstream ss(str);\n    ss &gt;&gt; var;\n    set_fun(var);\n  }\n}\n\ntemplate &lt;typename T&gt;\nstatic T DeserializeAs(std::istream &amp; is) {\n  T value;\n  DeserializeValue(is, value);\n  return value;\n}\n\ntemplate &lt;typename T&gt;\nstatic void DeserializeValue_Vector(std::istream &amp; is, std::vector&lt;T&gt; &amp; var) {\n  DeserializeFunction&lt;size_t&gt;(is, [&amp;var](size_t in_size){ var.resize(in_size); } );\n  for (auto &amp; x : var) {\n    DeserializeValue(is, x);\n  }\n}\n\ntemplate &lt;typename MAP_T&gt;\nstatic void DeserializeValue_Map(std::istream &amp; is, MAP_T &amp; var) {\n  size_t map_size = 0;\n  typename MAP_T::key_type key;\n  typename MAP_T::mapped_type value;\n  DeserializeValue(is, map_size);\n  for (size_t i = 0; i &lt; map_size; ++i) {\n    DeserializeValue(is, key);\n    DeserializeValue(is, value);\n    var[key] = value;\n  }\n}\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_world_base_8hpp/","title":"File WorldBase.hpp","text":"<p>FileList &gt; core &gt; WorldBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../DataCollection/AgentReciever.hpp\"</code></li> <li><code>#include \"AgentBase.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"DataCollection/DataManager.hpp\"</code></li> <li><code>#include \"Interfaces/NetWorth/client/ClientInterface.hpp\"</code></li> <li><code>#include \"Interfaces/NetWorth/client/ClientManager.hpp\"</code></li> <li><code>#include \"Interfaces/NetWorth/client/ControlledAgent.hpp\"</code></li> <li><code>#include \"Interfaces/NetWorth/server/ServerManager.hpp\"</code></li> <li><code>#include \"ItemBase.hpp\"</code></li> <li><code>#include \"WorldGrid.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_world_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types. namespace worldlang A base class for all World modules."},{"location":"Core%20Project/_world_base_8hpp/#classes","title":"Classes","text":"Type Name class WorldBase <p>The documentation for this class was generated from the following file <code>source/core/WorldBase.hpp</code></p>"},{"location":"Core%20Project/_world_base_8hpp_source/","title":"File WorldBase.hpp","text":"<p>File List &gt; core &gt; WorldBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;memory&gt;\n#include &lt;queue&gt;\n#include &lt;random&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"../DataCollection/AgentReciever.hpp\"\n#include \"AgentBase.hpp\"\n#include \"Data.hpp\"\n#include \"DataCollection/DataManager.hpp\"\n#include \"Interfaces/NetWorth/client/ClientInterface.hpp\"\n#include \"Interfaces/NetWorth/client/ClientManager.hpp\"\n#include \"Interfaces/NetWorth/client/ControlledAgent.hpp\"\n#include \"Interfaces/NetWorth/server/ServerManager.hpp\"\n#include \"ItemBase.hpp\"\n#include \"WorldGrid.hpp\"\n\n// Forward declaration\nnamespace worldlang {\nclass ProgramExecutor;\n}\n\nnamespace cse491 {\nclass DataReceiver;\n\nclass WorldBase {\npublic:\n  static constexpr size_t npos = static_cast&lt;size_t&gt;(-1);\n  netWorth::ServerManager *server_manager = nullptr;  \n  netWorth::ClientManager *client_manager = nullptr;  \n\n  virtual void ConfigAgent(AgentBase &amp; /* agent */) const {}\n\nprotected:\n  std::unordered_map&lt;size_t, WorldGrid&gt; grids;\n\n  WorldGrid &amp;main_grid;         \n  type_options_t type_options;  \n\n  item_map_t item_map;        \n  agent_map_t agent_map;      \n  size_t last_entity_id = 0;  \n\n  bool run_over = false;      \n  bool world_running = true;  \n\n  std::string action;  \n  std::shared_ptr&lt;DataCollection::AgentReceiver&gt; agent_receiver;\n\n  unsigned int seed;                          \n  std::mt19937 random_gen;                    \n  std::uniform_real_distribution&lt;&gt; uni_dist;  \n  std::normal_distribution&lt;&gt; norm_dist;       \n\n  size_t NextEntityID() { return ++last_entity_id; }\n\n  virtual void ConfigAgent(AgentBase &amp; /* agent */) {}\n\n  size_t AddCellType(const std::string &amp;name, const std::string &amp;desc = \"\", char symbol = '\\0') {\n    type_options.push_back(CellType{name, desc, symbol});\n    return type_options.size() - 1;\n  }\n\npublic:\n  WorldBase(unsigned int seed = 0) : grids(), main_grid(grids[0]), seed(seed) {\n    // The first cell type (ID 0) should be reserved for errors or empty spots in a grid.\n    AddCellType(\"Unknown\", \"This is an invalid cell type and should not be reachable.\");\n\n    // Initialize the random number generator.\n    if (seed == 0) {\n      std::random_device rd;  // An expensive \"true\" random number generator.\n      seed = rd();            // Change the seed to a random value.\n    }\n    random_gen.seed(seed);\n  }\n\n  virtual ~WorldBase() = default;\n\n  virtual void Reset() {\n    item_map.clear();\n    agent_map.clear();\n    last_entity_id = 0;\n    run_over = false;\n  }\n\n  // -- Accessors --\n\n  [[nodiscard]] size_t GetNumItems() const { return item_map.size(); }\n\n  [[nodiscard]] size_t GetNumAgents() const { return agent_map.size(); }\n\n  [[nodiscard]] bool HasItem(size_t id) const { return item_map.count(id); }\n\n  [[nodiscard]] bool HasAgent(size_t id) const { return agent_map.count(id); }\n\n  [[nodiscard]] ItemBase &amp;GetItem(size_t id) {\n    assert(HasItem(id));\n    return *item_map[id];\n  }\n\n  [[nodiscard]] AgentBase &amp;GetAgent(size_t id) {\n    assert(HasAgent(id));\n    return *agent_map[id];\n  }\n\n  [[nodiscard]] size_t GetItemID(const std::string &amp;name) {\n    for (auto &amp;[id, ptr] : item_map) {\n      if (ptr-&gt;GetName() == name) return id;\n    }\n    return npos;\n  }\n\n  [[nodiscard]] size_t GetAgentID(const std::string &amp;name) {\n    for (auto &amp;[id, ptr] : agent_map) {\n      if (ptr-&gt;GetName() == name) return id;\n    }\n    return npos;\n  }\n\n  virtual WorldGrid &amp;GetGrid() { return main_grid; }\n  virtual WorldGrid &amp;GetGrid(size_t grid_id) { return grids[grid_id]; }\n\n  virtual const WorldGrid &amp;GetGrid() const { return main_grid; }\n  virtual const WorldGrid &amp;GetGrid(size_t grid_id) const { return grids.at(grid_id); }\n\n  virtual bool GetRunOver() const { return run_over; }\n\n  // -- Random Number Generation --\n\n  unsigned int GetSeed() const { return seed; }\n\n  double GetRandom() { return uni_dist(random_gen); }\n\n  double GetRandom(double max) { return GetRandom() * max; }\n\n  double GetRandom(double min, double max) {\n    assert(max &gt; min);\n    return min + GetRandom(max - min);\n  }\n\n  double GetRandomNormal() { return norm_dist(random_gen); }\n\n  double GetRandomNormal(double mean, double sd = 1.0) {\n    assert(sd &gt; 0);\n    return mean + norm_dist(random_gen) * sd;\n  }\n\n  // -- Agent Management --\n\n  AgentBase &amp;AddConfiguredAgent(std::unique_ptr&lt;AgentBase&gt; agent_ptr) {\n    std::mutex agent_map_lock;\n    agent_map_lock.lock();\n    agent_ptr-&gt;SetWorld(*this);\n    if (agent_ptr-&gt;Initialize() == false) {\n      std::cerr &lt;&lt; \"Failed to initialize agent '\" &lt;&lt; agent_ptr-&gt;GetName() &lt;&lt; \"'.\" &lt;&lt; std::endl;\n    }\n    AgentBase &amp; agentReturn = *agent_map[agent_ptr-&gt;GetID()];\n    agent_map[agent_ptr-&gt;GetID()] = std::move(agent_ptr);\n    agent_map_lock.unlock();\n    return agentReturn;\n  }\n\n\n  template &lt;typename AGENT_T, typename... PROPERTY_Ts&gt;\n  AgentBase &amp;AddAgent(std::string agent_name = \"None\", PROPERTY_Ts... properties) {\n    std::mutex agent_map_lock;\n    agent_map_lock.lock();\n    const size_t agent_id = NextEntityID();\n    auto agent_ptr = std::make_unique&lt;AGENT_T&gt;(agent_id, agent_name);\n    agent_ptr-&gt;SetWorld(*this);\n    agent_ptr-&gt;SetProperties(std::forward&lt;PROPERTY_Ts&gt;(properties)...);\n    ConfigAgent(*agent_ptr);\n    if (agent_ptr-&gt;Initialize() == false) {\n      std::cerr &lt;&lt; \"Failed to initialize agent '\" &lt;&lt; agent_name &lt;&lt; \"'.\" &lt;&lt; std::endl;\n    }\n    agent_map[agent_id] = std::move(agent_ptr);\n    AgentBase &amp;agentReturn = *agent_map[agent_id];\n    agent_map_lock.unlock();\n    return agentReturn;\n  }\n\n  ItemBase &amp;AddItem(std::unique_ptr&lt;ItemBase&gt; item_ptr) {\n    assert(item_ptr);                // item_ptr must not be null.\n    assert(item_ptr-&gt;GetID() != 0);  // item_ptr must have had a non-zero ID assigned.\n    item_ptr-&gt;SetWorld(*this);\n    size_t item_id = item_ptr-&gt;GetID();\n    item_map[item_id] = std::move(item_ptr);\n    return *item_map[item_id];\n  }\n\n  template &lt;typename ITEM_T = ItemBase, typename... PROPERTY_Ts&gt;\n  ItemBase &amp;AddItem(std::string item_name = \"None\", PROPERTY_Ts... properties) {\n    auto item_ptr = std::make_unique&lt;ITEM_T&gt;(NextEntityID(), item_name);\n    item_ptr-&gt;SetProperties(std::forward&lt;PROPERTY_Ts&gt;(properties)...);\n    return AddItem(std::move(item_ptr));\n  }\n\n  WorldBase &amp;RemoveAgent(size_t agent_id) {\n    agent_map.erase(agent_id);\n    return *this;\n  }\n\n  WorldBase &amp;RemoveItem(size_t item_id) {\n    item_map.erase(item_id);\n    return *this;\n  }\n\n  WorldBase &amp;RemoveAgent(std::string agent_name = \"None\") {\n    assert(agent_name != \"Interface\");  // We are not allowed to remove interfaces.\n    return RemoveAgent(GetAgentID(agent_name));\n  }\n\n  WorldBase &amp;RemoveItem(std::string item_name) { return RemoveItem(GetItemID(item_name)); }\n\n  WorldBase &amp;AddItemToGrid(size_t item_id, GridPosition pos, size_t grid_id = 0) {\n    item_map[item_id]-&gt;SetPosition(pos, grid_id);\n    return *this;\n  }\n\n  // -- Action Management --\n\n  virtual int DoAction(AgentBase &amp;agent, size_t action_id) = 0;\n\n  virtual void RunAgents() {\n    for (auto &amp;[id, agent_ptr] : agent_map) {\n      size_t action_id = agent_ptr-&gt;SelectAction(main_grid, type_options, item_map, agent_map);\n      agent_ptr-&gt;storeActionMap(agent_ptr-&gt;GetName());\n      int result = DoAction(*agent_ptr, action_id);\n      agent_ptr-&gt;SetActionResult(result);\n    }\n  }\n\n  virtual void RunClientAgents() {\n    for (auto &amp;[id, agent_ptr] : agent_map) {\n      size_t action_id = agent_ptr-&gt;SelectAction(main_grid, type_options, item_map, agent_map);\n      agent_ptr-&gt;storeActionMap(agent_ptr-&gt;GetName());\n      int result = DoAction(*agent_ptr, action_id);\n      agent_ptr-&gt;SetActionResult(result);\n    }\n\n    // Deserialize agents\n    std::string data = client_manager-&gt;getSerializedAgents();\n    if (data.substr(0, 18) == \":::START agent_set\") {\n      std::istringstream is(data);\n      DeserializeAgentSet(is, client_manager);\n    }\n  }\n\n  virtual void RunServerAgents() {\n    std::set&lt;size_t&gt; to_delete;\n\n    for (auto &amp;[id, agent_ptr] : agent_map) {\n      // wait until clients have connected to run\n      while (!server_manager-&gt;hasAgentsPresent() || !world_running) {\n      }\n\n      // select action and send to client\n      size_t action_id = agent_ptr-&gt;SelectAction(main_grid, type_options, item_map, agent_map);\n      server_manager-&gt;writeToActionMap(id, action_id);\n      agent_ptr-&gt;storeActionMap(agent_ptr-&gt;GetName());\n      int result = DoAction(*agent_ptr, action_id);\n      agent_ptr-&gt;SetActionResult(result);\n\n      // mark agent for deletion if client disconnects\n      if (action_id == 9999) to_delete.insert(id);\n    }\n\n    // delete agents\n    for (size_t id : to_delete) {\n      RemoveAgent(id);\n    }\n\n    // send updates to client for deleted agents\n    if (!to_delete.empty()) {\n      std::ostringstream os;\n      SerializeAgentSet(os);\n      std::string data = os.str();\n      server_manager-&gt;setSerializedAgents(data);\n      server_manager-&gt;setNewAgent(true);\n      server_manager-&gt;sendGameUpdates();\n    }\n  }\n\n  void CollectData() {\n    for (const auto &amp;[id, agent_ptr] : agent_map) {\n      DataCollection::DataManager::GetInstance().GetAgentReceiver().StoreData(\n          agent_ptr-&gt;GetName(), agent_ptr-&gt;GetPosition(), agent_ptr-&gt;GetActionResult());\n    }\n  }\n\n  virtual void UpdateWorld() {}\n\n  virtual void Run() {\n    run_over = false;\n    while (!run_over) {\n      RunAgents();\n      CollectData();\n      UpdateWorld();\n    }\n  }\n\n  virtual void RunClient(netWorth::ClientManager *manager) {\n    run_over = false;\n    client_manager = manager;\n    while (!run_over) {\n      if (world_running) {\n        RunClientAgents();\n        CollectData();\n        UpdateWorld();\n      }\n    }\n  }\n\n  virtual void RunServer(netWorth::ServerManager *manager) {\n    run_over = false;\n    server_manager = manager;\n    while (!run_over) {\n      if (world_running) {\n        RunServerAgents();\n        CollectData();\n        UpdateWorld();\n      }\n    }\n  }\n\n  virtual void SetWorldRunning(bool running) { world_running = running; }\n\n  // CellType management.\n\n  // Return a const vector of all of the possible cell types.\n  [[nodiscard]] const type_options_t &amp;GetCellTypes() const { return type_options; }\n\n  [[nodiscard]] size_t GetCellTypeID(const std::string &amp;name) const {\n    for (size_t i = 1; i &lt; type_options.size(); ++i) {\n      if (type_options[i].name == name) return i;\n    }\n    return 0;\n  }\n\n  [[nodiscard]] const std::string &amp;GetCellTypeName(size_t id) const {\n    if (id &gt;= type_options.size()) return type_options[0].name;\n    return type_options[id].name;\n  }\n\n  [[nodiscard]] char GetCellTypeSymbol(size_t id) const {\n    if (id &gt;= type_options.size()) return type_options[0].symbol;\n    return type_options[id].symbol;\n  }\n\n  // -- Grid Analysis Helpers --\n\n  [[nodiscard]] virtual std::vector&lt;size_t&gt; FindItemsAt(GridPosition pos,\n                                                        size_t grid_id = 0) const {\n    std::vector&lt;size_t&gt; item_ids;\n    for (const auto &amp;[id, item_ptr] : item_map) {\n      if (item_ptr-&gt;IsOnGrid(grid_id) &amp;&amp; item_ptr-&gt;GetPosition() == pos) item_ids.push_back(id);\n    }\n    return item_ids;\n  }\n\n  [[nodiscard]] virtual std::vector&lt;size_t&gt; FindAgentsAt(GridPosition pos,\n                                                         size_t grid_id = 0) const {\n    std::vector&lt;size_t&gt; agent_ids;\n    for (const auto &amp;[id, agent_ptr] : agent_map) {\n      if (agent_ptr-&gt;IsOnGrid(grid_id) &amp;&amp; agent_ptr-&gt;GetPosition() == pos) agent_ids.push_back(id);\n    }\n    return agent_ids;\n  }\n\n  [[nodiscard]] virtual std::vector&lt;size_t&gt; FindItemsNear(GridPosition pos, double dist = 1.0,\n                                                          size_t grid_id = 0) const {\n    std::vector&lt;size_t&gt; item_ids;\n    for (const auto &amp;[id, item_ptr] : item_map) {\n      if (item_ptr-&gt;IsOnGrid(grid_id) &amp;&amp; item_ptr-&gt;GetPosition().IsNear(pos, dist)) {\n        item_ids.push_back(id);\n      }\n    }\n    return item_ids;\n  }\n\n  [[nodiscard]] virtual std::vector&lt;size_t&gt; FindAgentsNear(GridPosition pos, double dist = 1.0,\n                                                           size_t grid_id = 0) const {\n    std::vector&lt;size_t&gt; agent_ids;\n    for (const auto &amp;[id, agent_ptr] : agent_map) {\n      if (agent_ptr-&gt;IsOnGrid(grid_id) &amp;&amp; agent_ptr-&gt;GetPosition().IsNear(pos, dist)) {\n        agent_ids.push_back(id);\n      }\n    }\n    return agent_ids;\n  }\n\n  [[nodiscard]] virtual bool IsTraversable(const AgentBase &amp; /*agent*/,\n                                           cse491::GridPosition /*pos*/) const {\n    return true;\n  }\n\n  // -- Network Serialization and Deserialization --\n\n  void SerializeAgentSet(std::ostream &amp;os) {\n    os &lt;&lt; \":::START agent_set\\n\";\n    SerializeValue(os, agent_map.size());\n\n    for (const auto &amp;[agent_id, agent_ptr] : agent_map) {\n      SerializeValue(os, *agent_ptr);\n    }\n    os &lt;&lt; \":::END agent_set\\n\";\n  }\n\n  void DeserializeAgentSet(std::istream &amp;is, netWorth::ClientManager *manager) {\n    // find beginning of agent_set serialization\n    std::string read;\n    std::getline(is, read, '\\n');\n    if (read != \":::START agent_set\") {\n      std::cerr &lt;&lt; \"Could not find start of agent_set serialization\" &lt;&lt; std::endl;\n      return;\n    }\n\n    size_t client_id = manager-&gt;getClientID();\n\n    // Remove all agents other than the interface\n    std::vector&lt;size_t&gt; to_delete;\n    for (auto &amp; [agent_id, agent_ptr] : agent_map) {\n      if (agent_id != client_id) to_delete.push_back(agent_id);\n    }\n\n    for (size_t agent_id : to_delete) {\n      RemoveAgent(agent_id);\n    }\n\n    // reset last_entity_id; start from the beginning\n    last_entity_id = 0;\n\n    // Load the number of agents saved.\n    size_t server_last_entity_id = DeserializeAs&lt;size_t&gt;(is);\n\n    // client id NOT in agent map yet if ID = 0\n    // append to end of set\n    if (client_id == 0) client_id = server_last_entity_id;\n\n    // Load back in all agents.\n    for (size_t i = 0; i &lt; server_last_entity_id; i++) {\n      // First, check to see if we've hit the end of the agent_set\n      // Because we are looking at last entity id (and not total size), we may have\n      //  gaps in our agent_set\n      auto tmp_pos = is.tellg();\n      std::getline(is, read, '\\n');\n      if(read == \":::END agent_set\"){\n        if(last_entity_id &lt; client_id) last_entity_id = client_id;\n        return;\n      }\n      else is.seekg(tmp_pos);\n      auto agent_ptr = std::make_unique&lt;netWorth::ControlledAgent&gt;(0, \"temp\");\n      DeserializeValue(is, *agent_ptr);\n      agent_ptr-&gt;SetProperty(\"manager\", manager);\n\n      if (agent_ptr-&gt;GetID() &gt;= last_entity_id) last_entity_id = agent_ptr-&gt;GetID();\n\n      // If this agent is the client interface, skip it (we already have it).\n      if (agent_ptr-&gt;GetID() == client_id) { continue; }\n\n      AddConfiguredAgent(std::move(agent_ptr));\n    }\n\n    // find end of agent_set deserialization\n    std::getline(is, read, '\\n');\n    if (read != \":::END agent_set\") {\n      std::cerr &lt;&lt; \"Could not find end of agent_set serialization\" &lt;&lt; std::endl;\n      return;\n    }\n  }\n\n  void SerializeItemSet(std::ostream &amp;os) {\n    os &lt;&lt; \":::START item_set\\n\";\n    SerializeValue(os, item_map.size());\n\n    for (const auto &amp;item : item_map) {\n      item.second-&gt;Serialize(os);\n    }\n    os &lt;&lt; \":::END item_set\\n\";\n  }\n\n  void DeserializeItemSet(std::istream &amp;is) {\n    // find beginning of item_set serialization\n    std::string read;\n    std::getline(is, read, '\\n');\n    if (read != \":::START item_set\") {\n      std::cerr &lt;&lt; \"Could not find start of item_set serialization\" &lt;&lt; std::endl;\n      return;\n    }\n\n    // how many items?\n    size_t size;\n    DeserializeValue(is, size);\n\n    // read each item\n    for (size_t i = 0; i &lt; size; i++) {\n      auto item = std::make_unique&lt;ItemBase&gt;(agent_map.size() + i, \"\");\n      DeserializeValue(is, *item);\n      AddItem(std::move(item));\n    }\n\n    // find end of item_set serialization\n    std::getline(is, read, '\\n');\n    if (read != \":::END item_set\") {\n      std::cerr &lt;&lt; \"Could not find end of item_set serialization\" &lt;&lt; std::endl;\n      return;\n    }\n  }\n\n  void Serialize(std::ostream &amp;os) {\n    main_grid.Serialize(os);\n    SerializeAgentSet(os);\n    SerializeItemSet(os);\n  }\n\n  void Deserialize(std::istream &amp;is, netWorth::ClientManager *manager) {\n    main_grid.Deserialize(is);\n    DeserializeAgentSet(is, manager);\n    DeserializeItemSet(is);\n  }\n\n  // Needs access to most things here so this is easiest way to do so\n  friend worldlang::ProgramExecutor;\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/_world_grid_8hpp/","title":"File WorldGrid.hpp","text":"<p>FileList &gt; core &gt; WorldGrid.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"CoreObject.hpp\"</code></li> <li><code>#include \"Data.hpp\"</code></li> <li><code>#include \"GridPosition.hpp\"</code></li> </ul>"},{"location":"Core%20Project/_world_grid_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A base class interface for all agent types."},{"location":"Core%20Project/_world_grid_8hpp/#classes","title":"Classes","text":"Type Name class WorldGrid A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. <p>The documentation for this class was generated from the following file <code>source/core/WorldGrid.hpp</code></p>"},{"location":"Core%20Project/_world_grid_8hpp_source/","title":"File WorldGrid.hpp","text":"<p>File List &gt; core &gt; WorldGrid.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"CoreObject.hpp\"\n#include \"Data.hpp\"\n#include \"GridPosition.hpp\"\n\nnamespace cse491 {\n\nclass WorldGrid : public CoreObject {\nprotected:\n  size_t width = 0;           \n  size_t height = 0;          \n  std::vector&lt;size_t&gt; cells;  \n\n  // -- Helper functions --\n\n  [[nodiscard]] inline size_t ToIndex(size_t x, size_t y) const { return x + y * width; }\n\n  // -- Serialize and Deserialize functions --\n  // Mechanisms to efficiently save and load the exact state of the grid.\n  // File format is width and height followed by all\n  // values in the grid on each line thereafter.\n\n  std::string GetTypeName_impl() const override { return \"cse491::WorldGrid\"; }\n\n  void Serialize_impl(std::ostream &amp;os) const override {\n    SerializeValue(os, width);\n    SerializeValue(os, height);\n    for (size_t state : cells) SerializeValue(os, state);\n  }\n\n  void Deserialize_impl(std::istream &amp;is) override {\n    DeserializeValue(is, width);\n    DeserializeValue(is, height);\n    cells.resize(width * height);\n    for (size_t &amp;state : cells) DeserializeValue(is, state);\n  }\n\npublic:\n  WorldGrid() = default;\n  WorldGrid(size_t width, size_t height, size_t default_type = 0)\n      : width(width), height(height), cells(width * height, default_type) {}\n  WorldGrid(const WorldGrid &amp;) = default;\n  WorldGrid(WorldGrid &amp;&amp;) = default;\n\n  WorldGrid &amp;operator=(const WorldGrid &amp;) = default;\n  WorldGrid &amp;operator=(WorldGrid &amp;&amp;) = default;\n\n  // -- Accessors --\n  [[nodiscard]] size_t GetWidth() const { return width; }\n  [[nodiscard]] size_t GetHeight() const { return height; }\n  [[nodiscard]] size_t GetNumCells() const { return cells.size(); }\n\n  [[nodiscard]] bool IsValid(double x, double y) const {\n    return x &gt;= 0.0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0.0 &amp;&amp; y &lt; height;\n  }\n\n  [[nodiscard]] bool IsValid(GridPosition pos) const { return IsValid(pos.GetX(), pos.GetY()); }\n\n  [[nodiscard]] size_t At(size_t x, size_t y) const {\n    assert(IsValid(x, y));\n    return cells[ToIndex(x, y)];\n  }\n\n  [[nodiscard]] size_t &amp;At(size_t x, size_t y) {\n    assert(IsValid(x, y));\n    return cells[ToIndex(x, y)];\n  }\n\n  [[nodiscard]] size_t At(GridPosition p) const { return At(p.CellX(), p.CellY()); }\n\n  [[nodiscard]] size_t &amp;At(GridPosition p) { return At(p.CellX(), p.CellY()); }\n\n  [[nodiscard]] size_t operator[](GridPosition p) const { return At(p); }\n  [[nodiscard]] size_t &amp;operator[](GridPosition p) { return At(p); }\n\n  // Size adjustments.\n  void Resize(size_t new_width, size_t new_height, size_t default_type = 0) {\n    // Create a new vector of the correct size.\n    std::vector&lt;size_t&gt; new_cells(new_width * new_height, default_type);\n\n    // Copy the overlapping portions of the two grids.\n    size_t min_width = std::min(width, new_width);\n    size_t min_height = std::min(height, new_height);\n    for (size_t x = 0; x &lt; min_width; ++x) {\n      for (size_t y = 0; y &lt; min_height; ++y) {\n        new_cells[x + y * new_width] = cells[ToIndex(x, y)];\n      }\n    }\n\n    // Swap the new grid in; let the old grid be deallocated in its place.\n    std::swap(cells, new_cells);\n    width = new_width;\n    height = new_height;\n  }\n\n  // -- Read and Write functions --\n  // These are the same idea as Save and Load, but they are human readable, but they\n  // also require that each state has been assigned a unique character symbol.\n\n  void Write(std::ostream &amp;os, const type_options_t &amp;types) const {\n    size_t cell_id = 0;\n    for (size_t y = 0; y &lt; height; ++y) {\n      for (size_t x = 0; x &lt; width; ++x) {\n        os &lt;&lt; types[cells[cell_id++]].symbol;\n      }\n      os &lt;&lt; '\\n';\n    }\n    os.flush();\n  }\n\n  bool Write(std::string filename, const type_options_t &amp;types) const {\n    std::ofstream os(filename);\n    if (!os.is_open()) {\n      std::cerr &lt;&lt; \"Could not open file '\" &lt;&lt; filename &lt;&lt; \"' to write grid.\" &lt;&lt; std::endl;\n      return false;\n    }\n    Write(os, types);\n    return true;\n  }\n\n  void Read(std::istream &amp;is, const type_options_t &amp;types) {\n    // Build a symbol chart for conversions back.\n    std::unordered_map&lt;char, size_t&gt; symbol_map;\n    for (size_t i = 0; i &lt; types.size(); ++i) {\n      symbol_map[types[i].symbol] = i;\n    }\n\n    // Load the file into memory.\n    std::vector&lt;std::string&gt; char_grid;\n    std::string line;\n    width = 0;\n    while (std::getline(is, line)) {\n      char_grid.push_back(line);\n      if (line.size() &gt; width) width = line.size();\n    }\n    height = char_grid.size();\n\n    // Convert each symbol to the appropriate value.\n    cells.resize(width * height);\n    size_t cell_id = 0;\n    for (size_t y = 0; y &lt; height; ++y) {\n      for (size_t x = 0; x &lt; width; ++x) {\n        // Use the cell values provided, or zero if a cell position is missing.\n        cells[cell_id++] = (x &lt; char_grid[y].size()) ? symbol_map[char_grid[y][x]] : 0;\n      }\n    }\n  }\n\n  bool Read(std::string filename, const type_options_t &amp;types) {\n    std::ifstream is(filename);\n    if (!is.is_open()) {\n      std::cerr &lt;&lt; \"Could not open file '\" &lt;&lt; filename &lt;&lt; \"' to write grid.\" &lt;&lt; std::endl;\n      return false;\n    }\n    Read(is, types);\n    return true;\n  }\n};\n\n}  // End of namespace cse491\n\n</code></pre>"},{"location":"Core%20Project/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace clogged Tools for debug-logging that can be easily controlled. </li> <li>namespace cse491 A base class interface for all agent types. </li> <li>namespace std </li> <li>namespace worldlang A base class for all World modules. </li> </ul>"},{"location":"Core%20Project/classes/","title":"Class Index","text":""},{"location":"Core%20Project/classes/#a","title":"a","text":"<ul> <li>AgentBase (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#c","title":"c","text":"<ul> <li>CellType (cse491)</li> <li>CoreObject (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#e","title":"e","text":"<ul> <li>Entity (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#g","title":"g","text":"<ul> <li>GridPosition (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#i","title":"i","text":"<ul> <li>InterfaceBase (cse491)</li> <li>is_any_map (cse491)</li> <li>is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; (cse491)</li> <li>is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; (cse491)</li> <li>is_vector (cse491)</li> <li>is_vector&lt; std::vector&lt; T &gt; &gt; (cse491)</li> <li>ItemBase (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#l","title":"l","text":"<ul> <li>Logger (clogged)</li> </ul>"},{"location":"Core%20Project/classes/#p","title":"p","text":"<ul> <li>Property (cse491)</li> <li>PropertyBase (cse491)</li> </ul>"},{"location":"Core%20Project/classes/#w","title":"w","text":"<ul> <li>WorldBase (cse491)</li> <li>WorldGrid (cse491)</li> </ul>"},{"location":"Core%20Project/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class clogged::Logger Logger class with colors and team names.</li> <li>class cse491::CoreObject <ul> <li>class cse491::Entity <ul> <li>class cse491::AgentBase <ul> <li>class cse491::InterfaceBase </li> </ul> </li> <li>class cse491::ItemBase </li> </ul> </li> <li>class cse491::GridPosition Represents a position within a 2D grid of cells. This class provides utilities to manage a position in 2D space. The position is stored as floating-point values (to allow for smooth motion through a grid), but is easily converted to size_t for grid-cell identification. </li> <li>struct cse491::PropertyBase <ul> <li>struct cse491::Property </li> </ul> </li> <li>class cse491::WorldGrid A common interface class for core objects that sets up required functionality. This class ensures that objects can be serialized (saved), deserialized (restored) and provides helper functions. </li> </ul> </li> <li>class cse491::WorldBase </li> <li>struct cse491::CellType Simple data structure to hold info about a TYPE of cell in the world. </li> <li>class false_type <ul> <li>struct cse491::is_any_map Type trait to determine if we are working with any type of map. </li> <li>struct cse491::is_vector Type trait to determine if we are working with a vector. </li> </ul> </li> <li>class true_type <ul> <li>struct cse491::is_any_map&lt; std::map&lt; KEY_T, VALUE_T &gt; &gt; </li> <li>struct cse491::is_any_map&lt; std::unordered_map&lt; KEY_T, VALUE_T &gt; &gt; </li> <li>struct cse491::is_vector&lt; std::vector&lt; T &gt; &gt; </li> </ul> </li> </ul>"},{"location":"Core%20Project/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Core%20Project/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Core%20Project/class_members/","title":"Class Members","text":""},{"location":"Core%20Project/class_members/#a","title":"a","text":"<ul> <li>AddAction (cse491::AgentBase)</li> <li>AgentBase (cse491::AgentBase)</li> <li>action (cse491::AgentBase, cse491::WorldBase)</li> <li>action_map (cse491::AgentBase)</li> <li>action_result (cse491::AgentBase)</li> <li>agent_state (cse491::AgentBase)</li> <li>AddItem (cse491::Entity, cse491::WorldBase)</li> <li>AsProperty (cse491::Entity)</li> <li>Above (cse491::GridPosition)</li> <li>AddAgent (cse491::WorldBase)</li> <li>AddCellType (cse491::WorldBase)</li> <li>AddConfiguredAgent (cse491::WorldBase)</li> <li>AddItemToGrid (cse491::WorldBase)</li> <li>agent_map (cse491::WorldBase)</li> <li>agent_receiver (cse491::WorldBase)</li> <li>At (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#b","title":"b","text":"<ul> <li>Below (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_members/#c","title":"c","text":"<ul> <li>currentColor (clogged::Logger)</li> <li>currentLogLevel (clogged::Logger)</li> <li>currentTeam (clogged::Logger)</li> <li>CELL_WALL (cse491::CellType)</li> <li>CELL_WATER (cse491::CellType)</li> <li>CellX (cse491::GridPosition)</li> <li>CellY (cse491::GridPosition)</li> <li>CollectData (cse491::WorldBase)</li> <li>ConfigAgent (cse491::WorldBase)</li> <li>client_manager (cse491::WorldBase)</li> <li>cells (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#d","title":"d","text":"<ul> <li>Deserialize_impl (cse491::AgentBase, cse491::CoreObject, cse491::Entity, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>desc (cse491::CellType)</li> <li>Deserialize (cse491::CoreObject, cse491::WorldBase)</li> <li>Distance (cse491::GridPosition)</li> <li>DeserializeAgentSet (cse491::WorldBase)</li> <li>DeserializeItemSet (cse491::WorldBase)</li> <li>DoAction (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#e","title":"e","text":"<ul> <li>endl (clogged::Logger)</li> <li>EndDeserialize (cse491::CoreObject)</li> <li>EndSerialize (cse491::CoreObject)</li> <li>Entity (cse491::Entity)</li> <li>exitCleanup (cse491::InterfaceBase)</li> </ul>"},{"location":"Core%20Project/class_members/#f","title":"f","text":"<ul> <li>FromStream (cse491::GridPosition)</li> <li>FromString (cse491::GridPosition)</li> <li>FindAgentsAt (cse491::WorldBase)</li> <li>FindAgentsNear (cse491::WorldBase)</li> <li>FindItemsAt (cse491::WorldBase)</li> <li>FindItemsNear (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#g","title":"g","text":"<ul> <li>GetActionID (cse491::AgentBase)</li> <li>GetActionResult (cse491::AgentBase)</li> <li>GetAgentState (cse491::AgentBase)</li> <li>GetNextPosition (cse491::AgentBase)</li> <li>GetTypeName_impl (cse491::AgentBase, cse491::CoreObject, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>GetTypeName (cse491::CoreObject, cse491::Property, cse491::PropertyBase)</li> <li>GetGridID (cse491::Entity)</li> <li>GetID (cse491::Entity)</li> <li>GetInventory (cse491::Entity)</li> <li>GetName (cse491::Entity)</li> <li>GetNumProperties (cse491::Entity)</li> <li>GetPosition (cse491::Entity)</li> <li>GetProperty (cse491::Entity)</li> <li>GetPropertyMap (cse491::Entity)</li> <li>GetPropertyType (cse491::Entity)</li> <li>GetWorld (cse491::Entity)</li> <li>grid_id (cse491::Entity)</li> <li>GetOffset (cse491::GridPosition)</li> <li>GetX (cse491::GridPosition)</li> <li>GetY (cse491::GridPosition)</li> <li>GridPosition (cse491::GridPosition)</li> <li>GetOwnerID (cse491::ItemBase)</li> <li>GetType (cse491::Property, cse491::PropertyBase)</li> <li>GetAgent (cse491::WorldBase)</li> <li>GetAgentID (cse491::WorldBase)</li> <li>GetCellTypeID (cse491::WorldBase)</li> <li>GetCellTypeName (cse491::WorldBase)</li> <li>GetCellTypeSymbol (cse491::WorldBase)</li> <li>GetCellTypes (cse491::WorldBase)</li> <li>GetGrid (cse491::WorldBase)</li> <li>GetItem (cse491::WorldBase)</li> <li>GetItemID (cse491::WorldBase)</li> <li>GetNumAgents (cse491::WorldBase)</li> <li>GetNumItems (cse491::WorldBase)</li> <li>GetRandom (cse491::WorldBase)</li> <li>GetRandomNormal (cse491::WorldBase)</li> <li>GetRunOver (cse491::WorldBase)</li> <li>GetSeed (cse491::WorldBase)</li> <li>grids (cse491::WorldBase)</li> <li>GetHeight (cse491::WorldGrid)</li> <li>GetNumCells (cse491::WorldGrid)</li> <li>GetWidth (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#h","title":"h","text":"<ul> <li>HasAction (cse491::AgentBase)</li> <li>HasProperty (cse491::CellType, cse491::Entity)</li> <li>HasItem (cse491::Entity, cse491::WorldBase)</li> <li>HasWorld (cse491::Entity)</li> <li>HasAgent (cse491::WorldBase)</li> <li>height (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#i","title":"i","text":"<ul> <li>Initialize (cse491::AgentBase)</li> <li>IsAgent (cse491::AgentBase, cse491::Entity)</li> <li>IsInterface (cse491::Entity, cse491::InterfaceBase)</li> <li>IsItem (cse491::Entity, cse491::ItemBase)</li> <li>IsOnGrid (cse491::Entity, cse491::ItemBase)</li> <li>id (cse491::Entity)</li> <li>inventory (cse491::Entity)</li> <li>Invalid (cse491::GridPosition)</li> <li>IsInvalid (cse491::GridPosition)</li> <li>IsNear (cse491::GridPosition)</li> <li>IsValid (cse491::GridPosition, cse491::WorldGrid)</li> <li>InterfaceBase (cse491::InterfaceBase)</li> <li>IsOwned (cse491::ItemBase)</li> <li>IsOwnedBy (cse491::ItemBase)</li> <li>IsOwnedByAgent (cse491::ItemBase)</li> <li>IsOwnedByItem (cse491::ItemBase)</li> <li>ItemBase (cse491::ItemBase)</li> <li>IsTraversable (cse491::WorldBase)</li> <li>item_map (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#l","title":"l","text":"<ul> <li>Log (clogged::Logger)</li> <li>logToString (clogged::Logger)</li> <li>last_entity_id (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#m","title":"m","text":"<ul> <li>metaPrinted (clogged::Logger)</li> <li>MDistance (cse491::GridPosition)</li> <li>MakeInvalid (cse491::GridPosition)</li> <li>main_grid (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#n","title":"n","text":"<ul> <li>Notify (cse491::AgentBase)</li> <li>name (cse491::CellType, cse491::Entity)</li> <li>NextEntityID (cse491::WorldBase)</li> <li>norm_dist (cse491::WorldBase)</li> <li>npos (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (clogged::Logger)</li> <li>operator&lt;=&gt; (cse491::CoreObject, cse491::GridPosition)</li> <li>operator= (cse491::Entity, cse491::GridPosition, cse491::WorldGrid)</li> <li>operator+ (cse491::GridPosition)</li> <li>operator+= (cse491::GridPosition)</li> <li>operator-= (cse491::GridPosition)</li> <li>OwnerType (cse491::ItemBase)</li> <li>owner_id (cse491::ItemBase)</li> <li>owner_type (cse491::ItemBase)</li> <li>operator[] (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#p","title":"p","text":"<ul> <li>properties (cse491::CellType)</li> <li>position (cse491::Entity)</li> <li>property_map (cse491::Entity)</li> <li>property_map_t (cse491::Entity)</li> <li>Property (cse491::Property)</li> </ul>"},{"location":"Core%20Project/class_members/#r","title":"r","text":"<ul> <li>RemoveProperty (cse491::CellType, cse491::Entity)</li> <li>RemoveItem (cse491::Entity, cse491::WorldBase)</li> <li>RemoveAgent (cse491::WorldBase)</li> <li>Reset (cse491::WorldBase)</li> <li>Run (cse491::WorldBase)</li> <li>RunAgents (cse491::WorldBase)</li> <li>RunClient (cse491::WorldBase)</li> <li>RunClientAgents (cse491::WorldBase)</li> <li>RunServer (cse491::WorldBase)</li> <li>RunServerAgents (cse491::WorldBase)</li> <li>random_gen (cse491::WorldBase)</li> <li>run_over (cse491::WorldBase)</li> <li>Read (cse491::WorldGrid)</li> <li>Resize (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#s","title":"s","text":"<ul> <li>SelectAction (cse491::AgentBase)</li> <li>Serialize_impl (cse491::AgentBase, cse491::CoreObject, cse491::Entity, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>SetActionResult (cse491::AgentBase)</li> <li>storeActionMap (cse491::AgentBase)</li> <li>SetProperty (cse491::CellType, cse491::Entity)</li> <li>symbol (cse491::CellType)</li> <li>Serialize (cse491::CoreObject, cse491::WorldBase)</li> <li>StartDeserialize (cse491::CoreObject)</li> <li>StartSerialize (cse491::CoreObject)</li> <li>SetName (cse491::Entity)</li> <li>SetPosition (cse491::Entity)</li> <li>SetProperties (cse491::Entity)</li> <li>SetWorld (cse491::Entity)</li> <li>Set (cse491::GridPosition)</li> <li>SetX (cse491::GridPosition)</li> <li>SetY (cse491::GridPosition)</li> <li>Shift (cse491::GridPosition)</li> <li>SetGrid (cse491::ItemBase)</li> <li>SetOwner (cse491::ItemBase)</li> <li>SetUnowned (cse491::ItemBase)</li> <li>SerializeAgentSet (cse491::WorldBase)</li> <li>SerializeItemSet (cse491::WorldBase)</li> <li>SetWorldRunning (cse491::WorldBase)</li> <li>seed (cse491::WorldBase)</li> <li>server_manager (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#t","title":"t","text":"<ul> <li>teamToString (clogged::Logger)</li> <li>teamToStringMap (clogged::Logger)</li> <li>TakeDamage (cse491::AgentBase)</li> <li>ToLeft (cse491::GridPosition)</li> <li>ToRight (cse491::GridPosition)</li> <li>ToString (cse491::GridPosition, cse491::Property, cse491::PropertyBase)</li> <li>ToChar (cse491::Property, cse491::PropertyBase)</li> <li>ToDouble (cse491::Property, cse491::PropertyBase)</li> <li>ToGridPosition (cse491::Property, cse491::PropertyBase)</li> <li>ToInt (cse491::Property, cse491::PropertyBase)</li> <li>type_options (cse491::WorldBase)</li> <li>ToIndex (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#u","title":"u","text":"<ul> <li>UpdateAgentState (cse491::AgentBase)</li> <li>UpdateWorld (cse491::WorldBase)</li> <li>uni_dist (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_members/#v","title":"v","text":"<ul> <li>value (cse491::Property)</li> </ul>"},{"location":"Core%20Project/class_members/#w","title":"w","text":"<ul> <li>world_ptr (cse491::Entity)</li> <li>WorldBase (cse491::WorldBase)</li> <li>world_running (cse491::WorldBase)</li> <li>WorldGrid (cse491::WorldGrid)</li> <li>Write (cse491::WorldGrid)</li> <li>width (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_members/#x","title":"x","text":"<ul> <li>x (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_members/#y","title":"y","text":"<ul> <li>y (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_members/#_1","title":"~","text":"<ul> <li>~AgentBase (cse491::AgentBase)</li> <li>~CoreObject (cse491::CoreObject)</li> <li>~Entity (cse491::Entity)</li> <li>~GridPosition (cse491::GridPosition)</li> <li>~InterfaceBase (cse491::InterfaceBase)</li> <li>~ItemBase (cse491::ItemBase)</li> <li>~PropertyBase (cse491::PropertyBase)</li> <li>~WorldBase (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Core%20Project/class_member_functions/#a","title":"a","text":"<ul> <li>AddAction (cse491::AgentBase)</li> <li>AgentBase (cse491::AgentBase)</li> <li>AddItem (cse491::Entity, cse491::WorldBase)</li> <li>AsProperty (cse491::Entity)</li> <li>Above (cse491::GridPosition)</li> <li>AddAgent (cse491::WorldBase)</li> <li>AddCellType (cse491::WorldBase)</li> <li>AddConfiguredAgent (cse491::WorldBase)</li> <li>AddItemToGrid (cse491::WorldBase)</li> <li>At (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#b","title":"b","text":"<ul> <li>Below (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#c","title":"c","text":"<ul> <li>CellX (cse491::GridPosition)</li> <li>CellY (cse491::GridPosition)</li> <li>CollectData (cse491::WorldBase)</li> <li>ConfigAgent (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#d","title":"d","text":"<ul> <li>Deserialize_impl (cse491::AgentBase, cse491::CoreObject, cse491::Entity, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>Deserialize (cse491::CoreObject, cse491::WorldBase)</li> <li>Distance (cse491::GridPosition)</li> <li>DeserializeAgentSet (cse491::WorldBase)</li> <li>DeserializeItemSet (cse491::WorldBase)</li> <li>DoAction (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#e","title":"e","text":"<ul> <li>endl (clogged::Logger)</li> <li>EndDeserialize (cse491::CoreObject)</li> <li>EndSerialize (cse491::CoreObject)</li> <li>Entity (cse491::Entity)</li> <li>exitCleanup (cse491::InterfaceBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#f","title":"f","text":"<ul> <li>FromStream (cse491::GridPosition)</li> <li>FromString (cse491::GridPosition)</li> <li>FindAgentsAt (cse491::WorldBase)</li> <li>FindAgentsNear (cse491::WorldBase)</li> <li>FindItemsAt (cse491::WorldBase)</li> <li>FindItemsNear (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#g","title":"g","text":"<ul> <li>GetActionID (cse491::AgentBase)</li> <li>GetActionResult (cse491::AgentBase)</li> <li>GetAgentState (cse491::AgentBase)</li> <li>GetNextPosition (cse491::AgentBase)</li> <li>GetTypeName_impl (cse491::AgentBase, cse491::CoreObject, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>GetTypeName (cse491::CoreObject, cse491::Property, cse491::PropertyBase)</li> <li>GetGridID (cse491::Entity)</li> <li>GetID (cse491::Entity)</li> <li>GetInventory (cse491::Entity)</li> <li>GetName (cse491::Entity)</li> <li>GetNumProperties (cse491::Entity)</li> <li>GetPosition (cse491::Entity)</li> <li>GetProperty (cse491::Entity)</li> <li>GetPropertyMap (cse491::Entity)</li> <li>GetPropertyType (cse491::Entity)</li> <li>GetWorld (cse491::Entity)</li> <li>GetOffset (cse491::GridPosition)</li> <li>GetX (cse491::GridPosition)</li> <li>GetY (cse491::GridPosition)</li> <li>GridPosition (cse491::GridPosition)</li> <li>GetOwnerID (cse491::ItemBase)</li> <li>GetType (cse491::Property, cse491::PropertyBase)</li> <li>GetAgent (cse491::WorldBase)</li> <li>GetAgentID (cse491::WorldBase)</li> <li>GetCellTypeID (cse491::WorldBase)</li> <li>GetCellTypeName (cse491::WorldBase)</li> <li>GetCellTypeSymbol (cse491::WorldBase)</li> <li>GetCellTypes (cse491::WorldBase)</li> <li>GetGrid (cse491::WorldBase)</li> <li>GetItem (cse491::WorldBase)</li> <li>GetItemID (cse491::WorldBase)</li> <li>GetNumAgents (cse491::WorldBase)</li> <li>GetNumItems (cse491::WorldBase)</li> <li>GetRandom (cse491::WorldBase)</li> <li>GetRandomNormal (cse491::WorldBase)</li> <li>GetRunOver (cse491::WorldBase)</li> <li>GetSeed (cse491::WorldBase)</li> <li>GetHeight (cse491::WorldGrid)</li> <li>GetNumCells (cse491::WorldGrid)</li> <li>GetWidth (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#h","title":"h","text":"<ul> <li>HasAction (cse491::AgentBase)</li> <li>HasProperty (cse491::CellType, cse491::Entity)</li> <li>HasItem (cse491::Entity, cse491::WorldBase)</li> <li>HasWorld (cse491::Entity)</li> <li>HasAgent (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (cse491::AgentBase)</li> <li>IsAgent (cse491::AgentBase, cse491::Entity)</li> <li>IsInterface (cse491::Entity, cse491::InterfaceBase)</li> <li>IsItem (cse491::Entity, cse491::ItemBase)</li> <li>IsOnGrid (cse491::Entity, cse491::ItemBase)</li> <li>Invalid (cse491::GridPosition)</li> <li>IsInvalid (cse491::GridPosition)</li> <li>IsNear (cse491::GridPosition)</li> <li>IsValid (cse491::GridPosition, cse491::WorldGrid)</li> <li>InterfaceBase (cse491::InterfaceBase)</li> <li>IsOwned (cse491::ItemBase)</li> <li>IsOwnedBy (cse491::ItemBase)</li> <li>IsOwnedByAgent (cse491::ItemBase)</li> <li>IsOwnedByItem (cse491::ItemBase)</li> <li>ItemBase (cse491::ItemBase)</li> <li>IsTraversable (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#l","title":"l","text":"<ul> <li>Log (clogged::Logger)</li> <li>logToString (clogged::Logger)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#m","title":"m","text":"<ul> <li>MDistance (cse491::GridPosition)</li> <li>MakeInvalid (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#n","title":"n","text":"<ul> <li>Notify (cse491::AgentBase)</li> <li>NextEntityID (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (clogged::Logger)</li> <li>operator&lt;=&gt; (cse491::CoreObject, cse491::GridPosition)</li> <li>operator= (cse491::Entity, cse491::GridPosition, cse491::WorldGrid)</li> <li>operator+ (cse491::GridPosition)</li> <li>operator+= (cse491::GridPosition)</li> <li>operator-= (cse491::GridPosition)</li> <li>operator[] (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#p","title":"p","text":"<ul> <li>Property (cse491::Property)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#r","title":"r","text":"<ul> <li>RemoveProperty (cse491::CellType, cse491::Entity)</li> <li>RemoveItem (cse491::Entity, cse491::WorldBase)</li> <li>RemoveAgent (cse491::WorldBase)</li> <li>Reset (cse491::WorldBase)</li> <li>Run (cse491::WorldBase)</li> <li>RunAgents (cse491::WorldBase)</li> <li>RunClient (cse491::WorldBase)</li> <li>RunClientAgents (cse491::WorldBase)</li> <li>RunServer (cse491::WorldBase)</li> <li>RunServerAgents (cse491::WorldBase)</li> <li>Read (cse491::WorldGrid)</li> <li>Resize (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (cse491::AgentBase)</li> <li>Serialize_impl (cse491::AgentBase, cse491::CoreObject, cse491::Entity, cse491::GridPosition, cse491::ItemBase, cse491::Property, cse491::WorldGrid)</li> <li>SetActionResult (cse491::AgentBase)</li> <li>storeActionMap (cse491::AgentBase)</li> <li>SetProperty (cse491::CellType, cse491::Entity)</li> <li>Serialize (cse491::CoreObject, cse491::WorldBase)</li> <li>StartDeserialize (cse491::CoreObject)</li> <li>StartSerialize (cse491::CoreObject)</li> <li>SetName (cse491::Entity)</li> <li>SetPosition (cse491::Entity)</li> <li>SetProperties (cse491::Entity)</li> <li>SetWorld (cse491::Entity)</li> <li>Set (cse491::GridPosition)</li> <li>SetX (cse491::GridPosition)</li> <li>SetY (cse491::GridPosition)</li> <li>Shift (cse491::GridPosition)</li> <li>SetGrid (cse491::ItemBase)</li> <li>SetOwner (cse491::ItemBase)</li> <li>SetUnowned (cse491::ItemBase)</li> <li>SerializeAgentSet (cse491::WorldBase)</li> <li>SerializeItemSet (cse491::WorldBase)</li> <li>SetWorldRunning (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#t","title":"t","text":"<ul> <li>teamToString (clogged::Logger)</li> <li>TakeDamage (cse491::AgentBase)</li> <li>ToLeft (cse491::GridPosition)</li> <li>ToRight (cse491::GridPosition)</li> <li>ToString (cse491::GridPosition, cse491::Property, cse491::PropertyBase)</li> <li>ToChar (cse491::Property, cse491::PropertyBase)</li> <li>ToDouble (cse491::Property, cse491::PropertyBase)</li> <li>ToGridPosition (cse491::Property, cse491::PropertyBase)</li> <li>ToInt (cse491::Property, cse491::PropertyBase)</li> <li>ToIndex (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#u","title":"u","text":"<ul> <li>UpdateAgentState (cse491::AgentBase)</li> <li>UpdateWorld (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#w","title":"w","text":"<ul> <li>WorldBase (cse491::WorldBase)</li> <li>WorldGrid (cse491::WorldGrid)</li> <li>Write (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_functions/#_1","title":"~","text":"<ul> <li>~AgentBase (cse491::AgentBase)</li> <li>~CoreObject (cse491::CoreObject)</li> <li>~Entity (cse491::Entity)</li> <li>~GridPosition (cse491::GridPosition)</li> <li>~InterfaceBase (cse491::InterfaceBase)</li> <li>~ItemBase (cse491::ItemBase)</li> <li>~PropertyBase (cse491::PropertyBase)</li> <li>~WorldBase (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Core%20Project/class_member_variables/#a","title":"a","text":"<ul> <li>action (cse491::AgentBase, cse491::WorldBase)</li> <li>action_map (cse491::AgentBase)</li> <li>action_result (cse491::AgentBase)</li> <li>agent_state (cse491::AgentBase)</li> <li>agent_map (cse491::WorldBase)</li> <li>agent_receiver (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#c","title":"c","text":"<ul> <li>currentColor (clogged::Logger)</li> <li>currentLogLevel (clogged::Logger)</li> <li>currentTeam (clogged::Logger)</li> <li>CELL_WALL (cse491::CellType)</li> <li>CELL_WATER (cse491::CellType)</li> <li>client_manager (cse491::WorldBase)</li> <li>cells (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#d","title":"d","text":"<ul> <li>desc (cse491::CellType)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#g","title":"g","text":"<ul> <li>grid_id (cse491::Entity)</li> <li>grids (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#h","title":"h","text":"<ul> <li>height (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#i","title":"i","text":"<ul> <li>id (cse491::Entity)</li> <li>inventory (cse491::Entity)</li> <li>item_map (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#l","title":"l","text":"<ul> <li>last_entity_id (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#m","title":"m","text":"<ul> <li>metaPrinted (clogged::Logger)</li> <li>main_grid (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#n","title":"n","text":"<ul> <li>name (cse491::CellType, cse491::Entity)</li> <li>norm_dist (cse491::WorldBase)</li> <li>npos (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#o","title":"o","text":"<ul> <li>owner_id (cse491::ItemBase)</li> <li>owner_type (cse491::ItemBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#p","title":"p","text":"<ul> <li>properties (cse491::CellType)</li> <li>position (cse491::Entity)</li> <li>property_map (cse491::Entity)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#r","title":"r","text":"<ul> <li>random_gen (cse491::WorldBase)</li> <li>run_over (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#s","title":"s","text":"<ul> <li>symbol (cse491::CellType)</li> <li>seed (cse491::WorldBase)</li> <li>server_manager (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#t","title":"t","text":"<ul> <li>teamToStringMap (clogged::Logger)</li> <li>type_options (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#u","title":"u","text":"<ul> <li>uni_dist (cse491::WorldBase)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#v","title":"v","text":"<ul> <li>value (cse491::Property)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#w","title":"w","text":"<ul> <li>world_ptr (cse491::Entity)</li> <li>world_running (cse491::WorldBase)</li> <li>width (cse491::WorldGrid)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#x","title":"x","text":"<ul> <li>x (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_member_variables/#y","title":"y","text":"<ul> <li>y (cse491::GridPosition)</li> </ul>"},{"location":"Core%20Project/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"Core%20Project/class_member_typedefs/#p","title":"p","text":"<ul> <li>property_map_t (cse491::Entity)</li> </ul>"},{"location":"Core%20Project/class_member_enums/","title":"Class Member Enums","text":""},{"location":"Core%20Project/class_member_enums/#o","title":"o","text":"<ul> <li>OwnerType (cse491::ItemBase)</li> </ul>"},{"location":"Core%20Project/namespace_members/","title":"Namespace Members","text":""},{"location":"Core%20Project/namespace_members/#a","title":"a","text":"<ul> <li>agent_map_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#c","title":"c","text":"<ul> <li>Color (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_members/#d","title":"d","text":"<ul> <li>DeserializeAs (cse491)</li> <li>DeserializeFunction (cse491)</li> <li>DeserializeValue (cse491)</li> <li>DeserializeValue_Map (cse491)</li> <li>DeserializeValue_Vector (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#i","title":"i","text":"<ul> <li>item_map_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#l","title":"l","text":"<ul> <li>LOGLEVEL (clogged)</li> <li>LogLevel (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_members/#p","title":"p","text":"<ul> <li>PropertyType (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#s","title":"s","text":"<ul> <li>SerializeValue (cse491)</li> <li>SerializeValue_Map (cse491)</li> <li>SerializeValue_Vector (cse491)</li> <li>State (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#t","title":"t","text":"<ul> <li>Team (clogged)</li> <li>type_options_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_members/#w","title":"w","text":"<ul> <li>WorldType (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"Core%20Project/namespace_member_functions/#d","title":"d","text":"<ul> <li>DeserializeAs (cse491)</li> <li>DeserializeFunction (cse491)</li> <li>DeserializeValue (cse491)</li> <li>DeserializeValue_Map (cse491)</li> <li>DeserializeValue_Vector (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_functions/#s","title":"s","text":"<ul> <li>SerializeValue (cse491)</li> <li>SerializeValue_Map (cse491)</li> <li>SerializeValue_Vector (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"Core%20Project/namespace_member_variables/#l","title":"l","text":"<ul> <li>LOGLEVEL (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"Core%20Project/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>agent_map_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>item_map_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>type_options_t (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"Core%20Project/namespace_member_enums/#c","title":"c","text":"<ul> <li>Color (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#l","title":"l","text":"<ul> <li>LogLevel (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#p","title":"p","text":"<ul> <li>PropertyType (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#s","title":"s","text":"<ul> <li>State (cse491)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#t","title":"t","text":"<ul> <li>Team (clogged)</li> </ul>"},{"location":"Core%20Project/namespace_member_enums/#w","title":"w","text":"<ul> <li>WorldType (cse491)</li> </ul>"},{"location":"Core%20Project/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Core%20Project/macros/","title":"Macros","text":""},{"location":"Core%20Project/macros/#e","title":"e","text":"<ul> <li>EXPERIMENTAL_CLASS (CoreObject.hpp)</li> <li>EXPERIMENTAL_FUNCTION (CoreObject.hpp)</li> </ul>"},{"location":"Core%20Project/macros/#l","title":"l","text":"<ul> <li>LOGLINE (EasyLogging.hpp)</li> <li>LOG_FNC (EasyLogging.hpp)</li> <li>LOG_RELLINE (EasyLogging.hpp)</li> </ul>"},{"location":"Core%20Project/macros/#r","title":"r","text":"<ul> <li>RELATIVE_PATH (EasyLogging.hpp)</li> </ul>"},{"location":"Core%20Project/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Core%20Project/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cse491 An Agent that will walk back and forth along a row or column. <ul> <li>class PacingAgent </li> </ul> </li> <li>namespace walle <ul> <li>class AStarAgent </li> <li>struct AStarAgentData </li> <li>class AgentFactory </li> <li>class Alerter </li> <li>struct BaseAgentData </li> <li>struct CompareNodes Custom comparison function for priority queue. </li> <li>struct Node Node class to hold information about positions for A* search. </li> <li>struct PacingAgentData </li> <li>class PathAgent </li> <li>struct PathAgentData </li> <li>class RandomAgent </li> <li>class TrackingAgent </li> <li>struct TrackingAgentData </li> </ul> </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Agents <ul> <li>file AStarAgent.hpp AStar Agent Class. </li> <li>file AgentFactory.hpp A factory class that abstracts away the initialization of adding an agent to a world. </li> <li>file AgentLibary.hpp </li> <li>file PacingAgent.hpp </li> <li>file PathAgent.cpp Path Agent Class. </li> <li>file PathAgent.hpp </li> <li>file RandomAgent.hpp An Agent that will move around using random actions. </li> <li>file TrackingAgent.hpp Agent that switches between user-defined custom movement pattern and tracking a given agent. </li> </ul> </li> </ul> </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>An Agent that will walk back and forth along a row or column. More...</p>"},{"location":"Agent%20Library%28Group%201%29/namespacecse491/#classes","title":"Classes","text":"Type Name class PacingAgent"},{"location":"Agent%20Library%28Group%201%29/namespacecse491/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>The documentation for this class was generated from the following file <code>source/Agents/PacingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/","title":"Class cse491::PacingAgent","text":"<p>ClassList &gt; cse491 &gt; PacingAgent</p> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#public-functions","title":"Public Functions","text":"Type Name bool GetVertical () constReturns the vertical member variable. bool Initialize () overrideThis agent needs a specific set of actions to function. PacingAgent (size_t id, const std::string &amp; name)  size_t SelectAction (const WorldGrid &amp;, const type_options_t &amp;, const item_map_t &amp;, const agent_map_t &amp;) overrideChoose the action to take a step in the appropriate direction. PacingAgent &amp; SetVertical (bool vert)  ~PacingAgent () = default"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name bool reverse   = = falseIs this agent on their way back? (up/left?) bool vertical   = = trueIs this agent moving down&amp;up? False = right&amp;left."},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-getvertical","title":"function GetVertical","text":"<pre><code>inline bool cse491::PacingAgent::GetVertical () const\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool cse491::PacingAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-pacingagent","title":"function PacingAgent","text":"<pre><code>inline cse491::PacingAgent::PacingAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cse491::PacingAgent::SelectAction (\n    const WorldGrid &amp;,\n    const type_options_t &amp;,\n    const item_map_t &amp;,\n    const agent_map_t &amp;\n) override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-setvertical","title":"function SetVertical","text":"<pre><code>inline PacingAgent &amp; cse491::PacingAgent::SetVertical (\n    bool vert\n) \n</code></pre> <p>Setter for vertical param </p> <p>Parameters:</p> <ul> <li><code>vert</code> what vertical should be </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#function-pacingagent_1","title":"function ~PacingAgent","text":"<pre><code>cse491::PacingAgent::~PacingAgent () = default\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#variable-reverse","title":"variable reverse","text":"<pre><code>bool reverse;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classcse491_1_1_pacing_agent/#variable-vertical","title":"variable vertical","text":"<pre><code>bool vertical;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/PacingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/","title":"Namespace walle","text":"<p>Namespace List &gt; walle</p>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#classes","title":"Classes","text":"Type Name class AStarAgent struct AStarAgentData class AgentFactory class Alerter struct BaseAgentData struct CompareNodes Custom comparison function for priority queue. struct Node Node class to hold information about positions for A* search. struct PacingAgentData class PathAgent struct PathAgentData class RandomAgent class TrackingAgent struct TrackingAgentData"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#public-types","title":"Public Types","text":"Type Name enum TrackingState"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#public-functions","title":"Public Functions","text":"Type Name T &amp; DownCastAgent (cse491::Entity &amp; entity) Helper function for simplifying downcasting entities that have been added to the world. std::vector&lt; cse491::GridPosition &gt; GetShortestPath (const cse491::GridPosition &amp; start, const cse491::GridPosition &amp; end, const cse491::WorldBase &amp; world, const cse491::AgentBase &amp; agent) Uses A* to return a list of grid positions. std::vector&lt; cse491::GridPosition &gt; StrToOffsets (std::string_view commands)"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#enum-trackingstate","title":"enum TrackingState","text":"<pre><code>enum walle::TrackingState {\n    RETURNING_TO_START,\n    TRACKING,\n    PATROLLING\n};\n</code></pre> <p>Used to keep track of what action we are currently taking </p>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#function-downcastagent","title":"function DownCastAgent","text":"<pre><code>template&lt;typename T typename T&gt;\nT &amp; walle::DownCastAgent (\n    cse491::Entity &amp; entity\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#function-getshortestpath","title":"function GetShortestPath","text":"<p>Uses A* to return a list of grid positions. </p> <pre><code>inline std::vector&lt; cse491::GridPosition &gt; walle::GetShortestPath (\n    const cse491::GridPosition &amp; start,\n    const cse491::GridPosition &amp; end,\n    const cse491::WorldBase &amp; world,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Author:</p> <p>@mdkdoc15 </p> <p>Parameters:</p> <ul> <li><code>start</code> Starting position for search </li> <li><code>end</code> Ending position for the search </li> </ul> <p>Returns:</p> <p>vector of A* path from start to end, empty vector if no path exists </p>"},{"location":"Agent%20Library%28Group%201%29/namespacewalle/#function-strtooffsets","title":"function StrToOffsets","text":"<pre><code>inline std::vector&lt; cse491::GridPosition &gt; walle::StrToOffsets (\n    std::string_view commands\n) \n</code></pre> <p>Converts a string to a sequence of offsets</p> <p>This convenience method takes a string with a special formatting that allows one to specify a sequence of whitespace-separated inputs in linear directions. The format is [steps[*]]&lt;direction&gt; where <code>steps</code> is a positive integer and optional (assumed to be 1 by default) star <code>*</code> represents scaling the movement by <code>steps</code>. Optional, but cannot be used if <code>steps</code> is not provided if the star is not present, then <code>steps</code> individual offsets are created in the direction <code>direction</code> <code>direction</code> is a cardinal direction with the following logical mapping: n: north s: south e: east w: west x: stay put Example: \"n w 3e 10*s 5*w x\" should create the sequence of offsets {0, -1}, {-1, 0}, {1, 0}, {1, 0}, {1, 0}, {0, 10}, {-5, 0}, {0, 0} </p> <p>Parameters:</p> <ul> <li><code>commands</code> string in a format of sequential directions </li> </ul> <p>Note:</p> <p>throws an <code>std::invalid_argument</code> when input string is poorly formatted </p> <p>Note:</p> <p>this includes when a negative integer is passed as <code>steps</code>. If a zero is used, treated as the default (one) </p> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/","title":"Class walle::AStarAgent","text":"<p>ClassList &gt; walle &gt; AStarAgent</p> <p>More...</p> <ul> <li><code>#include &lt;AStarAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#public-functions","title":"Public Functions","text":"Type Name AStarAgent (size_t id, const std::string &amp; name) Constructor for creating a new AStarAgent object. cse491::GridPosition GetGoalPosition () constgets the goal position and returns it cse491::GridPosition GetNextPosition () overrideGet the next position to move to. int GetPathLength () const int GetRecalculateValue () const bool Initialize () overrideThis agent needs a specific set of actions to function. void RecalculatePath () Update the path to go to goal position. size_t SelectAction (const cse491::WorldGrid &amp;, const cse491::type_options_t &amp;, const cse491::item_map_t &amp;, const cse491::agent_map_t &amp;) overrideChoose the action to take a step in the appropriate direction. void SetGoalPosition (const double x, const double y) Set where the agent should head towards. void SetGoalPosition (const cse491::GridPosition gp) Set where the agent should head towards. void SetRecalculate (const int recalculate) Set how many moves should occur before recalculating path A lower number will react faster to updates in the world but will call A* search more often. ~AStarAgent () = default"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#detailed-description","title":"Detailed Description","text":"<p>Class that describes a AStarAgent class </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-astaragent","title":"function AStarAgent","text":"<p>Constructor for creating a new AStarAgent object.</p> <pre><code>inline walle::AStarAgent::AStarAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> id of the agent </li> <li><code>name</code> name of the agent </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-getgoalposition","title":"function GetGoalPosition","text":"<p>gets the goal position and returns it </p> <pre><code>inline cse491::GridPosition walle::AStarAgent::GetGoalPosition () const\n</code></pre> <p>Returns:</p> <p>goal_position member variable </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-getnextposition","title":"function GetNextPosition","text":"<p>Get the next position to move to. </p> <pre><code>inline cse491::GridPosition walle::AStarAgent::GetNextPosition () override\n</code></pre> <p>Returns:</p> <p>GridPosition to move to </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-getpathlength","title":"function GetPathLength","text":"<pre><code>inline int walle::AStarAgent::GetPathLength () const\n</code></pre> <p>Gets the size of the current path </p> <p>Returns:</p> <p>length of path </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-getrecalculatevalue","title":"function GetRecalculateValue","text":"<pre><code>inline int walle::AStarAgent::GetRecalculateValue () const\n</code></pre> <p>Returns the recalculate value </p> <p>Returns:</p> <p>recalculated value </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool walle::AStarAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-recalculatepath","title":"function RecalculatePath","text":"<pre><code>inline void walle::AStarAgent::RecalculatePath () \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t walle::AStarAgent::SelectAction (\n    const cse491::WorldGrid &amp;,\n    const cse491::type_options_t &amp;,\n    const cse491::item_map_t &amp;,\n    const cse491::agent_map_t &amp;\n) override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-setgoalposition-12","title":"function SetGoalPosition [1/2]","text":"<p>Set where the agent should head towards. </p> <pre><code>inline void walle::AStarAgent::SetGoalPosition (\n    const double x,\n    const double y\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>x</code> x-coordinate of the goal position </li> <li><code>y</code> y-coordinate of the goal position </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-setgoalposition-22","title":"function SetGoalPosition [2/2]","text":"<p>Set where the agent should head towards. </p> <pre><code>inline void walle::AStarAgent::SetGoalPosition (\n    const cse491::GridPosition gp\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>gp</code> position agent should go towards </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-setrecalculate","title":"function SetRecalculate","text":"<p>Set how many moves should occur before recalculating path A lower number will react faster to updates in the world but will call A* search more often. </p> <pre><code>inline void walle::AStarAgent::SetRecalculate (\n    const int recalculate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>recalculate</code> How often path should be recalculated </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_a_star_agent/#function-astaragent_1","title":"function ~AStarAgent","text":"<pre><code>walle::AStarAgent::~AStarAgent () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AStarAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/","title":"Struct walle::AStarAgentData","text":"<p>ClassList &gt; walle &gt; AStarAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherits the following classes: walle::BaseAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name cse491::GridPosition goal_pos The final position in the world that the AStarAgent is travelling to. int recalculate_after_x_turns   = = 5Number of steps after which the shortest path is recalculated."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#public-attributes-inherited-from-wallebaseagentdata","title":"Public Attributes inherited from walle::BaseAgentData","text":"<p>See walle::BaseAgentData</p> Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for an AStarAgent </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#variable-goal_pos","title":"variable goal_pos","text":"<pre><code>cse491::GridPosition goal_pos;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_a_star_agent_data/#variable-recalculate_after_x_turns","title":"variable recalculate_after_x_turns","text":"<pre><code>int recalculate_after_x_turns;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/","title":"Class walle::AgentFactory","text":"<p>ClassList &gt; walle &gt; AgentFactory</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#public-functions","title":"Public Functions","text":"Type Name AStarAgent &amp; AddAStarAgent (const AStarAgentData &amp; agent_data)  cse491::PacingAgent &amp; AddPacingAgent (const PacingAgentData &amp; agent_data)  PathAgent &amp; AddPathAgent (const PathAgentData &amp; agent_data)  TrackingAgent &amp; AddTrackingAgent (const TrackingAgentData &amp; agent_data)  AgentFactory () = deleteThe world to create Agents in. AgentFactory (cse491::WorldBase &amp; world)"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-addastaragent","title":"function AddAStarAgent","text":"<pre><code>AStarAgent &amp; walle::AgentFactory::AddAStarAgent (\n    const AStarAgentData &amp; agent_data\n) \n</code></pre> <p>Add an AStarAgent to the world </p> <p>Parameters:</p> <ul> <li><code>agent_data</code> data for agent we want to create </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-addpacingagent","title":"function AddPacingAgent","text":"<pre><code>cse491::PacingAgent &amp; walle::AgentFactory::AddPacingAgent (\n    const PacingAgentData &amp; agent_data\n) \n</code></pre> <p>Add a PacingAgent to the world </p> <p>Parameters:</p> <ul> <li><code>agent_data</code> data for agent we want to create </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-addpathagent","title":"function AddPathAgent","text":"<pre><code>PathAgent &amp; walle::AgentFactory::AddPathAgent (\n    const PathAgentData &amp; agent_data\n) \n</code></pre> <p>Add a PathAgent to the world </p> <p>Parameters:</p> <ul> <li><code>agent_data</code> data for agent we want to create </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-addtrackingagent","title":"function AddTrackingAgent","text":"<pre><code>TrackingAgent &amp; walle::AgentFactory::AddTrackingAgent (\n    const TrackingAgentData &amp; agent_data\n) \n</code></pre> <p>Add a TrackingAgent to the world </p> <p>Parameters:</p> <ul> <li><code>agent_data</code> data for agent we want to create </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-agentfactory-12","title":"function AgentFactory [1/2]","text":"<pre><code>walle::AgentFactory::AgentFactory () = delete\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_agent_factory/#function-agentfactory-22","title":"function AgentFactory [2/2]","text":"<pre><code>inline explicit walle::AgentFactory::AgentFactory (\n    cse491::WorldBase &amp; world\n) \n</code></pre> <p>Constructor for AgentFactory </p> <p>Parameters:</p> <ul> <li><code>world</code> we are adding agents too </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/","title":"Class walle::Alerter","text":"<p>ClassList &gt; walle &gt; Alerter</p> <p>More...</p> <ul> <li><code>#include &lt;TrackingAgent.hpp&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#public-functions","title":"Public Functions","text":"Type Name void AddAgent (size_t id)  void AlertAllTrackingAgents (size_t caller_id)  Alerter () = delete Alerter (cse491::WorldBase * world_ptr)  Alerter (cse491::WorldBase * world_ptr, size_t id)  std::unordered_set&lt; size_t &gt; const &amp; GetNetworkSet () constReturns an immutable reference to the Alerter 's set of agents it knows about. void RemoveAgent (size_t id)"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#detailed-description","title":"Detailed Description","text":"<p>A single Alerter is responsible for forcefully changing the state of all trackers in its network to TrackingState::TRACKING when a single TrackingAgent in the set of trackers comes into range of its goal_pos </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-addagent","title":"function AddAgent","text":"<pre><code>void walle::Alerter::AddAgent (\n    size_t id\n) \n</code></pre> <p>Adds a TrackingAgent to the network </p> <p>Parameters:</p> <ul> <li><code>id</code> id of agent to be added </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-alertalltrackingagents","title":"function AlertAllTrackingAgents","text":"<pre><code>void walle::Alerter::AlertAllTrackingAgents (\n    size_t caller_id\n) \n</code></pre> <p>Uses UpdateState to focus all trackers onto their goal_pos regardless of the distance away </p> <p>Parameters:</p> <ul> <li><code>caller_id</code> the original id of the agent that came into range of its goal_pos; does not need to be updated </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-alerter-13","title":"function Alerter [1/3]","text":"<pre><code>walle::Alerter::Alerter () = delete\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-alerter-23","title":"function Alerter [2/3]","text":"<pre><code>explicit walle::Alerter::Alerter (\n    cse491::WorldBase * world_ptr\n) \n</code></pre> <p>Alerter constructor (only knows its world and has no agents in its network) </p> <p>Parameters:</p> <ul> <li><code>world_ptr</code> the world this alerter is associated with </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-alerter-33","title":"function Alerter [3/3]","text":"<pre><code>walle::Alerter::Alerter (\n    cse491::WorldBase * world_ptr,\n    size_t id\n) \n</code></pre> <p>Alerter constructor (adds the TrackingAgent with that id to the alerter network) </p> <p>Parameters:</p> <ul> <li><code>id</code> id of agent to be added </li> <li><code>world_ptr</code> the world this alerter is associated with </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-getnetworkset","title":"function GetNetworkSet","text":"<pre><code>inline std::unordered_set&lt; size_t &gt; const &amp; walle::Alerter::GetNetworkSet () const\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_alerter/#function-removeagent","title":"function RemoveAgent","text":"<pre><code>void walle::Alerter::RemoveAgent (\n    size_t id\n) \n</code></pre> <p>Removes a TrackingAgent to the network </p> <p>Parameters:</p> <ul> <li><code>id</code> id of agent to be removed </li> </ul> <p>Note:</p> <p>no assertions here since we may want to allow the TrackingAgent to join another network later if it's not being destructed </p> <p>The documentation for this class was generated from the following file <code>source/Agents/TrackingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/","title":"Struct walle::BaseAgentData","text":"<p>ClassList &gt; walle &gt; BaseAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: walle::AStarAgentData,  walle::PacingAgentData,  walle::PathAgentData,  walle::TrackingAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for AgentBase </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#variable-name","title":"variable name","text":"<pre><code>std::string name;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#variable-position","title":"variable position","text":"<pre><code>cse491::GridPosition position;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_base_agent_data/#variable-symbol","title":"variable symbol","text":"<pre><code>char symbol;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/","title":"Struct walle::CompareNodes","text":"<p>ClassList &gt; walle &gt; CompareNodes</p> <p>Custom comparison function for priority queue. More...</p> <ul> <li><code>#include &lt;AgentLibary.hpp&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/#public-functions","title":"Public Functions","text":"Type Name bool operator() (const std::shared_ptr&lt; walle::Node &gt; &amp; a, const std::shared_ptr&lt; walle::Node &gt; &amp; b) const"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/#detailed-description","title":"Detailed Description","text":"<p>Returns:</p> <p>if a has a greater total cost than b </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_compare_nodes/#function-operator","title":"function operator()","text":"<pre><code>inline bool walle::CompareNodes::operator() (\n    const std::shared_ptr&lt; walle::Node &gt; &amp; a,\n    const std::shared_ptr&lt; walle::Node &gt; &amp; b\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentLibary.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/","title":"Struct walle::Node","text":"<p>ClassList &gt; walle &gt; Node</p> <p>Node class to hold information about positions for A* search.</p> <ul> <li><code>#include &lt;AgentLibary.hpp&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#public-attributes","title":"Public Attributes","text":"Type Name double g Cost from start to current node. double h Heuristic (estimated cost from current node to goal) std::shared_ptr&lt; Node &gt; parent How we got to this node (Used to construct final path) cse491::GridPosition position Where node is located."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#public-functions","title":"Public Functions","text":"Type Name Node (const cse491::GridPosition &amp; position, double g, double h, std::shared_ptr&lt; Node &gt; parent)  double f () constCalculate the total cost (f) of the node."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#variable-g","title":"variable g","text":"<pre><code>double g;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#variable-h","title":"variable h","text":"<pre><code>double h;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#variable-parent","title":"variable parent","text":"<pre><code>std::shared_ptr&lt;Node&gt; parent;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#variable-position","title":"variable position","text":"<pre><code>cse491::GridPosition position;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#function-node","title":"function Node","text":"<pre><code>inline walle::Node::Node (\n    const cse491::GridPosition &amp; position,\n    double g,\n    double h,\n    std::shared_ptr&lt; Node &gt; parent\n) \n</code></pre> <p>Constructor for a node </p> <p>Parameters:</p> <ul> <li><code>position</code> location on grid of this node </li> <li><code>g</code> actual distance to get from start to this node </li> <li><code>h</code> heuristic guess for distance from this node to end location </li> <li><code>parent</code> Used to construct path back at end </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_node/#function-f","title":"function f","text":"<p>Calculate the total cost (f) of the node. </p> <pre><code>inline double walle::Node::f () const\n</code></pre> <p>Returns:</p> <p>sum of actual distance and heuristic distance </p> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentLibary.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/","title":"Struct walle::PacingAgentData","text":"<p>ClassList &gt; walle &gt; PacingAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherits the following classes: walle::BaseAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name bool vertical   = = falseWhether the PacingAgent is moving up and down (vertical) or left and right(!vertical)"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#public-attributes-inherited-from-wallebaseagentdata","title":"Public Attributes inherited from walle::BaseAgentData","text":"<p>See walle::BaseAgentData</p> Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for a PacingAgent </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_pacing_agent_data/#variable-vertical","title":"variable vertical","text":"<pre><code>bool vertical;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/","title":"Class walle::PathAgent","text":"<p>ClassList &gt; walle &gt; PathAgent</p> <p>More...</p> <ul> <li><code>#include &lt;PathAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#public-functions","title":"Public Functions","text":"Type Name cse491::GridPosition CalcNextPos () const void DecrementIndex ()  int GetIndex () constGet the index. cse491::GridPosition GetNextPosition () override std::vector&lt; cse491::GridPosition &gt; const &amp; GetPath () constGet the Path. void IncrementIndex ()  bool Initialize () override PathAgent () = delete PathAgent (size_t id, std::string const &amp; name)  PathAgent (size_t id, std::string const &amp; name, std::vector&lt; cse491::GridPosition &gt; offsets)  PathAgent (size_t id, std::string const &amp; name, std::string_view commands)  PathAgent &amp; ResetIndex () Reset the index to 0. size_t SelectAction (cse491::WorldGrid const &amp;, cse491::type_options_t const &amp;, cse491::item_map_t const &amp;, cse491::agent_map_t const &amp;) override PathAgent &amp; SetPath (std::vector&lt; cse491::GridPosition &gt; offsets, size_t start_index=0)  PathAgent &amp; SetPath (std::string_view commands, size_t start_index=0)  virtual cse491::GridPosition UpdateAndGetNextPos (bool increment)  ~PathAgent () override"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name int index_   = = 0Current index into offsets_. std::vector&lt; cse491::GridPosition &gt; offsets_"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#detailed-description","title":"Detailed Description","text":"<p>Agent that has a user-defined custom movement pattern Passed a sequence of to be sequentially applied as the agent is updated </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-calcnextpos","title":"function CalcNextPos","text":"<pre><code>cse491::GridPosition walle::PathAgent::CalcNextPos () const\n</code></pre> <p>Retrieves the position of the agent after applying the current offset </p> <p>Returns:</p> <p>next position of the agent </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-decrementindex","title":"function DecrementIndex","text":"<pre><code>void walle::PathAgent::DecrementIndex () \n</code></pre> <p>Decrements the index into the offsets sequence </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-getindex","title":"function GetIndex","text":"<p>Get the index. </p> <pre><code>int walle::PathAgent::GetIndex () const\n</code></pre> <p>Returns:</p> <p>int index</p> <p>Retrieves which step the agent is on </p> <p>Returns:</p> <p>the current index into the offsets </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-getnextposition","title":"function GetNextPosition","text":"<pre><code>cse491::GridPosition walle::PathAgent::GetNextPosition () override\n</code></pre> <p>Overrides AgentBase GetNextPosition to retrieve the calculated next position </p> <p>Returns:</p> <p>next position to move the path agent in </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-getpath","title":"function GetPath","text":"<p>Get the Path. </p> <pre><code>std::vector&lt; cse491::GridPosition &gt; const &amp; walle::PathAgent::GetPath () const\n</code></pre> <p>Returns:</p> <p>vector of GridPositions</p> <p>Returns an immutable reference to this agent's current path </p> <p>Returns:</p> <p>sequence of offsets </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-incrementindex","title":"function IncrementIndex","text":"<pre><code>void walle::PathAgent::IncrementIndex () \n</code></pre> <p>Increments the index into the offsets sequence </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-initialize","title":"function Initialize","text":"<pre><code>bool walle::PathAgent::Initialize () override\n</code></pre> <p>Checks that the agent is able to move arbitrarily Verifies that it can currently index into a valid offset </p> <p>Returns:</p> <p>true if so; false otherwise </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent-14","title":"function PathAgent [1/4]","text":"<pre><code>walle::PathAgent::PathAgent () = delete\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent-24","title":"function PathAgent [2/4]","text":"<pre><code>walle::PathAgent::PathAgent (\n    size_t id,\n    std::string const &amp; name\n) \n</code></pre> <p>Constructor (agent default) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> </ul> <p>Note:</p> <p>When this constructor is called, the agent must still be assigned a path before a call to Initialize </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent-34","title":"function PathAgent [3/4]","text":"<pre><code>walle::PathAgent::PathAgent (\n    size_t id,\n    std::string const &amp; name,\n    std::vector&lt; cse491::GridPosition &gt; offsets\n) \n</code></pre> <p>Constructor (vector) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> <li><code>offsets</code> collection of offsets to move the agent </li> </ul> <p>Attention:</p> <p>The sequence of offsets must not be empty </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent-44","title":"function PathAgent [4/4]","text":"<pre><code>walle::PathAgent::PathAgent (\n    size_t id,\n    std::string const &amp; name,\n    std::string_view commands\n) \n</code></pre> <p>Constructor (string) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> <li><code>commands</code> sequence of commands to be interpreted as offsets </li> </ul> <p>Attention:</p> <p>The sequence of offsets must not be empty </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-resetindex","title":"function ResetIndex","text":"<p>Reset the index to 0. </p> <pre><code>inline PathAgent &amp; walle::PathAgent::ResetIndex () \n</code></pre> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>size_t walle::PathAgent::SelectAction (\n    cse491::WorldGrid const &amp;,\n    cse491::type_options_t const &amp;,\n    cse491::item_map_t const &amp;,\n    cse491::agent_map_t const &amp;\n) override\n</code></pre> <p>Tells world to </p> <p>Returns:</p> <p>whether the update succeeded </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-setpath-12","title":"function SetPath [1/2]","text":"<pre><code>PathAgent &amp; walle::PathAgent::SetPath (\n    std::vector&lt; cse491::GridPosition &gt; offsets,\n    size_t start_index=0\n) \n</code></pre> <p>Assigns the offsets_member to a new series of offsets </p> <p>Parameters:</p> <ul> <li><code>offsets</code> collection of grid positions used as the new offsets </li> <li><code>start_index</code> which offset to start indexing into (beginning by default) </li> </ul> <p>Returns:</p> <p>self </p> <p>Attention:</p> <p>throws an <code>std::invalid_argument</code> when an invalid start index is provided </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-setpath-22","title":"function SetPath [2/2]","text":"<pre><code>PathAgent &amp; walle::PathAgent::SetPath (\n    std::string_view commands,\n    size_t start_index=0\n) \n</code></pre> <p>Assigns the offsets_ member to a new series of offsets, taking a command string </p> <p>Parameters:</p> <ul> <li><code>commands</code> formatted string of commands used as offsets </li> <li><code>start_index</code> which command to begin indexing into (first command by default) </li> </ul> <p>Returns:</p> <p>self </p> <p>Attention:</p> <p>throws an <code>std::invalid_argument</code> when mis-formatted commands an invalid index is provided </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-updateandgetnextpos","title":"function UpdateAndGetNextPos","text":"<pre><code>virtual cse491::GridPosition walle::PathAgent::UpdateAndGetNextPos (\n    bool increment\n) \n</code></pre> <p>Convenience method Applies the current offset to calculate the next position and then adjusts the index </p> <p>Parameters:</p> <ul> <li><code>increment</code> decides whether to move in the forward or backward direction to allow for complex pathing </li> </ul> <p>Returns:</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#function-pathagent","title":"function ~PathAgent","text":"<pre><code>walle::PathAgent::~PathAgent () override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#variable-index_","title":"variable index_","text":"<pre><code>int index_;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_path_agent/#variable-offsets_","title":"variable offsets_","text":"<pre><code>std::vector&lt;cse491::GridPosition&gt; offsets_;\n</code></pre> <p>Collection of ways to offset the Agent's position </p> <p>Attention:</p> <p>This is a not a sequence of direct coordinates on the WorldGrid, but a series of offsets </p> <p>The documentation for this class was generated from the following file <code>source/Agents/PathAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/","title":"Struct walle::PathAgentData","text":"<p>ClassList &gt; walle &gt; PathAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherits the following classes: walle::BaseAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name int index Starting index into the vector of GridPositions. std::string string_path String representation of the path traveled (e.g. \"n s e w\" for north south east west) std::vector&lt; cse491::GridPosition &gt; vector_path Set of grid positions that are applied to the agent's position during one step (constructed from string_path)"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#public-attributes-inherited-from-wallebaseagentdata","title":"Public Attributes inherited from walle::BaseAgentData","text":"<p>See walle::BaseAgentData</p> Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for a PathAgent </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#variable-index","title":"variable index","text":"<pre><code>int index;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#variable-string_path","title":"variable string_path","text":"<pre><code>std::string string_path;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_path_agent_data/#variable-vector_path","title":"variable vector_path","text":"<pre><code>std::vector&lt;cse491::GridPosition&gt; vector_path;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/","title":"Class walle::RandomAgent","text":"<p>ClassList &gt; walle &gt; RandomAgent</p> <p>More...</p> <ul> <li><code>#include &lt;RandomAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#public-functions","title":"Public Functions","text":"Type Name void CalculateRandom (double multiplier) Function to calculate the random direction. bool GetMoving () constGet the Moving object. double GetRandom () constGet the Random object. bool Initialize () overrideThis agent needs a specific set of actions to function. RandomAgent (size_t id, const std::string &amp; name) Is the agent moving? size_t SelectAction (const cse491::WorldGrid &amp;, const cse491::type_options_t &amp;, const cse491::item_map_t &amp;, const cse491::agent_map_t &amp;) overrideChoose the action to take a step in the random direction. void SetDirection (double direction) Set the Direction object. void SetMoving (bool move) Set the Moving object. ~RandomAgent () = default"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#detailed-description","title":"Detailed Description","text":"<p>Class for the Random Agent </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-calculaterandom","title":"function CalculateRandom","text":"<p>Function to calculate the random direction. </p> <pre><code>inline void walle::RandomAgent::CalculateRandom (\n    double multiplier\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>multiplier</code> double: random multiplier </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-getmoving","title":"function GetMoving","text":"<p>Get the Moving object. </p> <pre><code>inline bool walle::RandomAgent::GetMoving () const\n</code></pre> <p>Returns:</p> <p>true </p> <p>Returns:</p> <p>false </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-getrandom","title":"function GetRandom","text":"<p>Get the Random object. </p> <pre><code>inline double walle::RandomAgent::GetRandom () const\n</code></pre> <p>Returns:</p> <p>double random member variable </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool walle::RandomAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-randomagent","title":"function RandomAgent","text":"<p>Is the agent moving? </p> <pre><code>inline walle::RandomAgent::RandomAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Construct a new Random Agent object </p> <p>Parameters:</p> <ul> <li><code>id</code> id of the agent </li> <li><code>name</code> name of the agent </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t walle::RandomAgent::SelectAction (\n    const cse491::WorldGrid &amp;,\n    const cse491::type_options_t &amp;,\n    const cse491::item_map_t &amp;,\n    const cse491::agent_map_t &amp;\n) override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-setdirection","title":"function SetDirection","text":"<p>Set the Direction object. </p> <pre><code>inline void walle::RandomAgent::SetDirection (\n    double direction\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>direction</code> direction to set </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-setmoving","title":"function SetMoving","text":"<p>Set the Moving object. </p> <pre><code>inline void walle::RandomAgent::SetMoving (\n    bool move\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>move</code> move to set </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_random_agent/#function-randomagent_1","title":"function ~RandomAgent","text":"<pre><code>walle::RandomAgent::~RandomAgent () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/RandomAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/","title":"Class walle::TrackingAgent","text":"<p>ClassList &gt; walle &gt; TrackingAgent</p> <p>More...</p> <ul> <li><code>#include &lt;TrackingAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: AgentBase</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#public-functions","title":"Public Functions","text":"Type Name void AddToAlerter (std::shared_ptr&lt; Alerter &gt; alerter)  void CallAlerter (size_t agent_id) Tells the alerter to notify all other tracking agents in network. std::shared_ptr&lt; Alerter &gt; GetAlerter () const cse491::GridPosition GetNextPosition () override std::vector&lt; cse491::GridPosition &gt; const &amp; GetPath () const TrackingState GetState ()  cse491::Entity const * GetTarget () const double GetTrackingDistance () const bool Initialize () override void MakeAlerter () Creates an alerter network and adds this tracking agent to it. void RemoveFromAlerter ()  size_t SelectAction (cse491::WorldGrid const &amp; grid, cse491::type_options_t const &amp; type, cse491::item_map_t const &amp; item_set, cse491::agent_map_t const &amp; agent_set) overrideUpdates the internal state of the TrackingAgent and calls the internal agent's select action method. size_t SelectInnerAction (PathAgent &amp; agent, cse491::WorldGrid const &amp; grid, cse491::type_options_t const &amp; type, cse491::item_map_t const &amp; item_set, cse491::agent_map_t const &amp; agent_set) Select action for PathAgent inner type. size_t SelectInnerAction (AStarAgent &amp; agent, cse491::WorldGrid const &amp; grid, cse491::type_options_t const &amp; type, cse491::item_map_t const &amp; item_set, cse491::agent_map_t const &amp; agent_set) Select action for AStarAgent inner type. TrackingAgent &amp; SetPath (std::vector&lt; cse491::GridPosition &gt; offsets)  TrackingAgent &amp; SetPath (std::string_view offsets)  TrackingAgent &amp; SetStartPosition (cse491::GridPosition pos)  TrackingAgent &amp; SetStartPosition (double x, double y)  TrackingAgent &amp; SetTarget (Entity * agent)  TrackingAgent &amp; SetTrackingDistance (double dist)  TrackingAgent &amp; SetWorld (cse491::WorldBase &amp; in_world) override TrackingAgent () = delete TrackingAgent (size_t id, std::string const &amp; name)  TrackingAgent (size_t id, std::string const &amp; name, std::vector&lt; cse491::GridPosition &gt; &amp;&amp; offsets, std::shared_ptr&lt; Alerter &gt; &amp;&amp; alerter=nullptr)  TrackingAgent (size_t id, std::string const &amp; name, std::string_view commands, std::shared_ptr&lt; Alerter &gt; &amp;&amp; alerter=nullptr)  void UpdateState (bool alerting=true)  ~TrackingAgent () override"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#detailed-description","title":"Detailed Description","text":"<p>Agent that switches between user-defined custom movement pattern and tracking a given agent </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-addtoalerter","title":"function AddToAlerter","text":"<pre><code>inline void walle::TrackingAgent::AddToAlerter (\n    std::shared_ptr&lt; Alerter &gt; alerter\n) \n</code></pre> <p>Adds this tracking agent to an already-existing alerter network </p> <p>Parameters:</p> <ul> <li><code>alerter</code> alerter that this agent should be associated with </li> </ul> <p>Note:</p> <p>alerter must not be null </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-callalerter","title":"function CallAlerter","text":"<pre><code>inline void walle::TrackingAgent::CallAlerter (\n    size_t agent_id\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-getalerter","title":"function GetAlerter","text":"<pre><code>inline std::shared_ptr&lt; Alerter &gt; walle::TrackingAgent::GetAlerter () const\n</code></pre> <p>Used to expand the alerter network by adding other tracking agents to it </p> <p>Returns:</p> <p>a copy of this tracking agent's alerter </p> <p>Note:</p> <p>it's expected that this function is used when calling AddToAlerter on a different tracking agent </p> <p>Note:</p> <p>may be null </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-getnextposition","title":"function GetNextPosition","text":"<pre><code>inline cse491::GridPosition walle::TrackingAgent::GetNextPosition () override\n</code></pre> <p>Overrides the AgentBase getter to retrieve the next calculated position </p> <p>Returns:</p> <p>inner PathAgent's next position </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-getpath","title":"function GetPath","text":"<pre><code>inline std::vector&lt; cse491::GridPosition &gt; const &amp; walle::TrackingAgent::GetPath () const\n</code></pre> <p>Returns an immutable reference to this agent's current path </p> <p>Returns:</p> <p>sequence of offsets </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-getstate","title":"function GetState","text":"<pre><code>inline TrackingState walle::TrackingAgent::GetState () \n</code></pre> <p>Retrieves the current internal state of the Tracking Agent </p> <p>Returns:</p> <p>current state </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-gettarget","title":"function GetTarget","text":"<pre><code>inline cse491::Entity const * walle::TrackingAgent::GetTarget () const\n</code></pre> <p>Returns an immutable pointer to this agent's target </p> <p>Returns:</p> <p>ptr to entity </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-gettrackingdistance","title":"function GetTrackingDistance","text":"<pre><code>inline double walle::TrackingAgent::GetTrackingDistance () const\n</code></pre> <p>Get the distance around this tracker that it surveys </p> <p>Returns:</p> <p>tracking distance </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-initialize","title":"function Initialize","text":"<pre><code>inline bool walle::TrackingAgent::Initialize () override\n</code></pre> <p>Ensure that the TrackingAgent's internal PathAgent is correctly initialized Verifies that it can currently index into a valid offset </p> <p>Returns:</p> <p>true if so; false otherwise </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-makealerter","title":"function MakeAlerter","text":"<pre><code>inline void walle::TrackingAgent::MakeAlerter () \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-removefromalerter","title":"function RemoveFromAlerter","text":"<pre><code>inline void walle::TrackingAgent::RemoveFromAlerter () \n</code></pre> <p>Removes this tracking agent from it's own tracking network </p> <p>Note:</p> <p>called from the TrackingAgent destructor </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t walle::TrackingAgent::SelectAction (\n    cse491::WorldGrid const &amp; grid,\n    cse491::type_options_t const &amp; type,\n    cse491::item_map_t const &amp; item_set,\n    cse491::agent_map_t const &amp; agent_set\n) override\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-selectinneraction-12","title":"function SelectInnerAction [1/2]","text":"<pre><code>inline size_t walle::TrackingAgent::SelectInnerAction (\n    PathAgent &amp; agent,\n    cse491::WorldGrid const &amp; grid,\n    cse491::type_options_t const &amp; type,\n    cse491::item_map_t const &amp; item_set,\n    cse491::agent_map_t const &amp; agent_set\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-selectinneraction-22","title":"function SelectInnerAction [2/2]","text":"<pre><code>inline size_t walle::TrackingAgent::SelectInnerAction (\n    AStarAgent &amp; agent,\n    cse491::WorldGrid const &amp; grid,\n    cse491::type_options_t const &amp; type,\n    cse491::item_map_t const &amp; item_set,\n    cse491::agent_map_t const &amp; agent_set\n) \n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setpath-12","title":"function SetPath [1/2]","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetPath (\n    std::vector&lt; cse491::GridPosition &gt; offsets\n) \n</code></pre> <p>Sets the patrolling path of the TrackingAgent </p> <p>Parameters:</p> <ul> <li><code>offsets</code> grid position offsets creating the path </li> </ul> <p>Returns:</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setpath-22","title":"function SetPath [2/2]","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetPath (\n    std::string_view offsets\n) \n</code></pre> <p>Sets the patrolling path of the TrackingAgent </p> <p>Parameters:</p> <ul> <li><code>offsets</code> grid position offsets creating the path </li> </ul> <p>Returns:</p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setstartposition-12","title":"function SetStartPosition [1/2]","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetStartPosition (\n    cse491::GridPosition pos\n) \n</code></pre> <p>Set where this agent \"patrol area\" starts </p> <p>Parameters:</p> <ul> <li><code>gp</code> grid position of position </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setstartposition-22","title":"function SetStartPosition [2/2]","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetStartPosition (\n    double x,\n    double y\n) \n</code></pre> <p>Set where this agent \"patrol area\" starts </p> <p>Parameters:</p> <ul> <li><code>x</code> x-coordinate of start pos </li> <li><code>y</code> y-coordinate of start pos </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-settarget","title":"function SetTarget","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetTarget (\n    Entity * agent\n) \n</code></pre> <p>Set which agent we are following </p> <p>Parameters:</p> <ul> <li><code>agent</code> we want to track </li> </ul> <p>Returns:</p> <p>self </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-settrackingdistance","title":"function SetTrackingDistance","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetTrackingDistance (\n    double dist\n) \n</code></pre> <p>Set how close goal_pos has to be to start tracking </p> <p>Parameters:</p> <ul> <li><code>dist</code> to start tracking at </li> </ul> <p>Returns:</p> <p>calling object </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-setworld","title":"function SetWorld","text":"<pre><code>inline TrackingAgent &amp; walle::TrackingAgent::SetWorld (\n    cse491::WorldBase &amp; in_world\n) override\n</code></pre> <p>Set both the world for the current agent and the agents it is a part of </p> <p>Parameters:</p> <ul> <li><code>in_world</code> new world to associate the agent with </li> </ul> <p>Returns:</p> <p>calling agent </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent-14","title":"function TrackingAgent [1/4]","text":"<pre><code>walle::TrackingAgent::TrackingAgent () = delete\n</code></pre> <p>Delete default constructor </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent-24","title":"function TrackingAgent [2/4]","text":"<pre><code>inline walle::TrackingAgent::TrackingAgent (\n    size_t id,\n    std::string const &amp; name\n) \n</code></pre> <p>Constructor (default) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent-34","title":"function TrackingAgent [3/4]","text":"<pre><code>inline walle::TrackingAgent::TrackingAgent (\n    size_t id,\n    std::string const &amp; name,\n    std::vector&lt; cse491::GridPosition &gt; &amp;&amp; offsets,\n    std::shared_ptr&lt; Alerter &gt; &amp;&amp; alerter=nullptr\n) \n</code></pre> <p>Constructor (vector) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> <li><code>offsets</code> collection of offsets to move the agent </li> <li><code>alerter</code> alerter network to add agent to </li> </ul> <p>Attention:</p> <p>The sequence of offsets must not be empty </p> <p>Attention:</p> <p>alerter should be a nullptr if this tracker is not part of any group of tracking agents </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent-44","title":"function TrackingAgent [4/4]","text":"<pre><code>inline walle::TrackingAgent::TrackingAgent (\n    size_t id,\n    std::string const &amp; name,\n    std::string_view commands,\n    std::shared_ptr&lt; Alerter &gt; &amp;&amp; alerter=nullptr\n) \n</code></pre> <p>Constructor (string view) </p> <p>Parameters:</p> <ul> <li><code>id</code> unique agent id </li> <li><code>name</code> name of path agent </li> <li><code>commands</code> sequence of commands to be interpreted as offsets </li> <li><code>alerter</code> alerter network to add agent to </li> </ul> <p>Attention:</p> <p>The sequence of offsets must not be empty </p> <p>Attention:</p> <p>alerter should be a nullptr if this tracker is not part of any group of tracking agents </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-updatestate","title":"function UpdateState","text":"<pre><code>inline void walle::TrackingAgent::UpdateState (\n    bool alerting=true\n) \n</code></pre> <p>Handles focusing the agent onto a goal_pos, returning it to its original location, and patrolling </p> <p>Parameters:</p> <ul> <li><code>alerting</code> determines whether this agent should alert all other TrackingAgents in its network when its goal_pos comes into range </li> </ul> <p>Note:</p> <p>the inner variant type will be AStarAgent when tracking OR returning to a location, but PathAgent when patrolling </p>"},{"location":"Agent%20Library%28Group%201%29/classwalle_1_1_tracking_agent/#function-trackingagent","title":"function ~TrackingAgent","text":"<pre><code>inline walle::TrackingAgent::~TrackingAgent () override\n</code></pre> <p>Destructor </p> <p>The documentation for this class was generated from the following file <code>source/Agents/TrackingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/","title":"Struct walle::TrackingAgentData","text":"<p>ClassList &gt; walle &gt; TrackingAgentData</p> <p>More...</p> <ul> <li><code>#include &lt;AgentFactory.hpp&gt;</code></li> </ul> <p>Inherits the following classes: walle::BaseAgentData</p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-attributes","title":"Public Attributes","text":"Type Name std::shared_ptr&lt; Alerter &gt; alerter   = = nullptr cse491::GridPosition start_pos Where the TrackingAgent begins from patrolling from and returns two after the target moves out of range. std::string string_path String representation of the path traveled (e.g. \"n s e w\" for north south east west) like in PathAgent . cse491::Entity * target Goal Entity being tracked (must not be null or else the agent simply behaves like a PathAgent ) int tracking_distance   = = 5Distance that the TrackingAgent can \"see\" such that when the target enters that range, it begins tracking. std::vector&lt; cse491::GridPosition &gt; vector_path Set of grid positions that are applied to the agent's position during one step (constructed from string_path) like in PathAgent ."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-attributes-inherited-from-wallebaseagentdata","title":"Public Attributes inherited from walle::BaseAgentData","text":"<p>See walle::BaseAgentData</p> Type Name std::string name Name of the agent. cse491::GridPosition position Agent's position. char symbol   = = '*'Agent's representation."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-functions","title":"Public Functions","text":"Type Name TrackingAgentData () = defaultUse initial values. TrackingAgentData (std::string name, cse491::GridPosition curr_pos, char symbol, std::string path, cse491::Entity * target, int tracking_dist, cse491::GridPosition start_pos, std::shared_ptr&lt; Alerter &gt; alerter) Set all values."},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#detailed-description","title":"Detailed Description","text":"<p>Stores data for a TrackingAgent </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-alerter","title":"variable alerter","text":"<pre><code>std::shared_ptr&lt;Alerter&gt; alerter;\n</code></pre> <p>Shared reference to an Alerter, which is non-null if the agent should be able to tell other agents to immediately focus on their targets </p> <p>Remark:</p> <p>You should be using the same shared pointer across multiple instances of TrackingAgentData in order to make the TrackingAgents part of the same network. This means you need to copy around this shared pointer when using the factory </p>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-start_pos","title":"variable start_pos","text":"<pre><code>cse491::GridPosition start_pos;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-string_path","title":"variable string_path","text":"<pre><code>std::string string_path;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-target","title":"variable target","text":"<pre><code>cse491::Entity* target;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-tracking_distance","title":"variable tracking_distance","text":"<pre><code>int tracking_distance;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#variable-vector_path","title":"variable vector_path","text":"<pre><code>std::vector&lt;cse491::GridPosition&gt; vector_path;\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#function-trackingagentdata-12","title":"function TrackingAgentData [1/2]","text":"<pre><code>walle::TrackingAgentData::TrackingAgentData () = default\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/structwalle_1_1_tracking_agent_data/#function-trackingagentdata-22","title":"function TrackingAgentData [2/2]","text":"<pre><code>inline walle::TrackingAgentData::TrackingAgentData (\n    std::string name,\n    cse491::GridPosition curr_pos,\n    char symbol,\n    std::string path,\n    cse491::Entity * target,\n    int tracking_dist,\n    cse491::GridPosition start_pos,\n    std::shared_ptr&lt; Alerter &gt; alerter\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Agent%20Library%28Group%201%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Agents <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Agent%20Library%28Group%201%29/dir_425e53e3c77c59c8573ea1fd0ff9622a/","title":"Dir source/Agents","text":"<p>FileList &gt; Agents</p>"},{"location":"Agent%20Library%28Group%201%29/dir_425e53e3c77c59c8573ea1fd0ff9622a/#files","title":"Files","text":"Type Name file AStarAgent.hpp AStar Agent Class. file AgentFactory.hpp A factory class that abstracts away the initialization of adding an agent to a world. file AgentLibary.hpp file PacingAgent.hpp file PathAgent.cpp Path Agent Class. file PathAgent.hpp file RandomAgent.hpp An Agent that will move around using random actions. file TrackingAgent.hpp Agent that switches between user-defined custom movement pattern and tracking a given agent. <p>The documentation for this class was generated from the following file <code>source/Agents/</code></p>"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp/","title":"File AStarAgent.hpp","text":"<p>FileList &gt; Agents &gt; AStarAgent.hpp</p> <p>Go to the source code of this file</p> <p>AStar Agent Class. More...</p> <ul> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"AgentLibary.hpp\"</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp/#classes","title":"Classes","text":"Type Name class AStarAgent"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>Matt Kight </p> <p>The documentation for this class was generated from the following file <code>source/Agents/AStarAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_a_star_agent_8hpp_source/","title":"File AStarAgent.hpp","text":"<p>File List &gt; Agents &gt; AStarAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../core/AgentBase.hpp\"\n#include \"AgentLibary.hpp\"\n#include &lt;vector&gt;\n\nnamespace walle {\n\n    class AStarAgent : public cse491::AgentBase {\n    private:\n        std::vector&lt;cse491::GridPosition&gt; path; \n        cse491::GridPosition goal_position;     \n        int recalculate_after_x_turns = 100; \n        int current_move_num = 0;            \n\n    public:\n        AStarAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {}\n\n        ~AStarAgent() = default;\n\n        bool Initialize() override {\n            return HasAction(\"up\") &amp;&amp; HasAction(\"down\") &amp;&amp; HasAction(\"left\") &amp;&amp;\n                HasAction(\"right\");\n        }\n\n        void SetGoalPosition(const double x, const double y) {\n            goal_position = cse491::GridPosition(x, y);\n        }\n\n        void SetGoalPosition(const cse491::GridPosition gp) {\n            goal_position = gp;\n        }\n\n        cse491::GridPosition GetGoalPosition() const {return goal_position; }\n\n        int GetRecalculateValue() const {return recalculate_after_x_turns; }\n\n        int GetPathLength() const {return path.size(); }\n\n\n        void SetRecalculate(const int recalculate) {\n            recalculate_after_x_turns = recalculate;\n        }\n\n        void RecalculatePath() {\n            path = GetShortestPath(GetPosition(), goal_position, GetWorld(), *this);\n            if (!path.empty()){path.pop_back();} // Remove the val that we are currently at\n            current_move_num = 0;\n        }\n\n        [[nodiscard]] cse491::GridPosition GetNextPosition() override {\n            return !path.empty() ? path.back() : GetPosition();\n        }\n\n        size_t SelectAction(const cse491::WorldGrid &amp; /*grid*/,\n                            const cse491::type_options_t &amp; /* type_options*/,\n                            const cse491::item_map_t &amp; /* item_map*/,\n                            const cse491::agent_map_t &amp; /* agent_map*/) override {\n            // We are taking an action so another turn has passed\n            ++current_move_num;\n            // If the last step failed, or we need a new path the then regenerate the\n            // path\n            if (action_result == 0 || path.empty() ||\n                current_move_num &gt; recalculate_after_x_turns) {\n            RecalculatePath();\n            }\n            // Return whatever action gets us closer to our goal\n            if (!path.empty()) {\n            auto pos = path.back();\n            path.pop_back();\n            if (pos == position.Above())\n                return action_map[\"up\"];\n            if (pos == position.Below())\n                return action_map[\"down\"];\n            if (pos == position.ToLeft())\n                return action_map[\"left\"];\n            if (pos == position.ToRight())\n                return action_map[\"right\"];\n            }\n            return 0; // If no path then do not do anything\n        }\n    };\n}; // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp/","title":"File AgentFactory.hpp","text":"<p>FileList &gt; Agents &gt; AgentFactory.hpp</p> <p>Go to the source code of this file</p> <p>A factory class that abstracts away the initialization of adding an agent to a world. More...</p> <ul> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"AStarAgent.hpp\"</code></li> <li><code>#include \"PacingAgent.hpp\"</code></li> <li><code>#include \"PathAgent.hpp\"</code></li> <li><code>#include \"TrackingAgent.hpp\"</code></li> <li><code>#include \"AgentLibary.hpp\"</code></li> <li><code>#include \"../core/Entity.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp/#classes","title":"Classes","text":"Type Name struct AStarAgentData class AgentFactory struct BaseAgentData struct PacingAgentData struct PathAgentData struct TrackingAgentData"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>Matt Kight </p> <p>Author:</p> <p>David Rackerby </p> <p>The documentation for this class was generated from the following file <code>source/Agents/AgentFactory.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_agent_factory_8hpp_source/","title":"File AgentFactory.hpp","text":"<p>File List &gt; Agents &gt; AgentFactory.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../core/AgentBase.hpp\"\n#include \"AStarAgent.hpp\"\n#include \"PacingAgent.hpp\"\n#include \"PathAgent.hpp\"\n#include \"TrackingAgent.hpp\"\n#include \"AgentLibary.hpp\"\n\n#include \"../core/Entity.hpp\"\n#include \"../core/WorldBase.hpp\"\n\nnamespace walle {\n\n// Forward-declare since it's easier to understand how AddXAgent works \n// when the structs are defined nearby\nstruct PacingAgentData;\nstruct PathAgentData;\nstruct AStarAgentData;\nstruct TrackingAgentData;\n\nclass AgentFactory {\nprivate:\n    cse491::WorldBase &amp;world;   \n\npublic:\n    AgentFactory() = delete;\n\n    explicit AgentFactory(cse491::WorldBase &amp;world) : world(world) {}\n\n    AStarAgent &amp;AddAStarAgent(const AStarAgentData &amp;agent_data);\n    cse491::PacingAgent &amp;AddPacingAgent(const PacingAgentData &amp;agent_data);\n    TrackingAgent &amp;AddTrackingAgent(const TrackingAgentData &amp;agent_data);\n    PathAgent &amp;AddPathAgent(const PathAgentData &amp;agent_data);\n\n}; // class AgentFactory\n\nstruct BaseAgentData {\n    std::string name;\n\n    cse491::GridPosition position;\n\n    char symbol = '*';\n};\n\nstruct PacingAgentData : public BaseAgentData {\n    bool vertical = false;\n};\n\ncse491::PacingAgent &amp;AgentFactory::AddPacingAgent(const PacingAgentData &amp;agent_data) {\n    auto &amp;entity = world.AddAgent&lt;cse491::PacingAgent&gt;(agent_data.name).SetPosition(agent_data.position).SetProperty(\n        \"symbol\",\n        agent_data.symbol);\n    auto &amp;agent = DownCastAgent&lt;cse491::PacingAgent&gt;(entity);\n    agent.SetVertical(agent_data.vertical);\n    return agent;\n}\n\nstruct PathAgentData : public BaseAgentData {\n    int index;\n\n    std::string string_path;\n\n    std::vector&lt;cse491::GridPosition&gt; vector_path;\n};\n\nPathAgent &amp;AgentFactory::AddPathAgent(const PathAgentData &amp;agent_data) {\n    auto &amp;entity = world.AddAgent&lt;walle::PathAgent&gt;(agent_data.name).SetPosition(agent_data.position).SetProperty(\n        \"symbol\",\n        agent_data.symbol);\n    auto &amp;agent = DownCastAgent&lt;walle::PathAgent&gt;(entity);\n    if (!agent_data.string_path.empty()) {\n        agent.SetProperty&lt;std::basic_string_view&lt;char&gt;&gt;(\"path\",\n                                                    agent_data.string_path); // TODO add another option to provide grid point\n    } else {\n        agent.SetPath(agent_data.vector_path);\n    }\n    agent.Initialize();\n    return agent;\n}\n\nstruct AStarAgentData : public BaseAgentData {\n    int recalculate_after_x_turns = 5;\n\n    cse491::GridPosition goal_pos;\n};\n\nAStarAgent &amp;AgentFactory::AddAStarAgent(const AStarAgentData &amp;agent_data) {\n    auto &amp;entity = world.AddAgent&lt;walle::AStarAgent&gt;(agent_data.name).SetPosition(agent_data.position).SetProperty(\n        \"symbol\",\n        agent_data.symbol);\n    auto &amp;agent = DownCastAgent&lt;walle::AStarAgent&gt;(entity);\n    agent.SetGoalPosition(agent_data.goal_pos);\n    agent.SetRecalculate(agent_data.recalculate_after_x_turns);\n    return agent;\n}\n\nstruct TrackingAgentData : public BaseAgentData {\n    std::vector&lt;cse491::GridPosition&gt; vector_path;\n\n    std::string string_path;\n\n    cse491::Entity *target;\n\n    int tracking_distance = 5;\n\n    cse491::GridPosition start_pos;\n\n    std::shared_ptr&lt;Alerter&gt; alerter = nullptr;\n\n    TrackingAgentData() = default;\n\n    TrackingAgentData(std::string name,\n                    cse491::GridPosition curr_pos,\n                    char symbol,\n                    std::string path,\n                    cse491::Entity * target,\n                    int tracking_dist,\n                    cse491::GridPosition start_pos,\n                    std::shared_ptr&lt;Alerter&gt; alerter)\n        : BaseAgentData({std::move(name), curr_pos, symbol}),\n        vector_path(StrToOffsets(path)),\n        string_path(std::move(path)),\n        target(target),\n        tracking_distance(tracking_dist),\n        start_pos(start_pos),\n        alerter(alerter) {}\n};\n\nTrackingAgent &amp;AgentFactory::AddTrackingAgent(const TrackingAgentData &amp;agent_data) {\n    auto &amp;entity = world.AddAgent&lt;walle::TrackingAgent&gt;(agent_data.name).SetPosition(agent_data.position).SetProperty(\n        \"symbol\",\n        agent_data.symbol);\n    auto &amp;agent = DownCastAgent&lt;TrackingAgent&gt;(entity);\n    if (!agent_data.string_path.empty()) {\n        agent.SetProperty&lt;std::basic_string_view&lt;char&gt;&gt;(\"path\", agent_data.string_path);\n    } else {\n        agent.SetPath(agent_data.vector_path);\n    }\n    agent.SetTarget(agent_data.target);\n    agent.SetTrackingDistance(agent_data.tracking_distance);\n    agent.SetStartPosition(agent_data.start_pos);\n    if (agent_data.alerter != nullptr) {\n        agent.SetProperty(\"alerter\", agent_data.alerter);\n    }\n    agent.Initialize();\n    return agent;\n}\n\n} // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_agent_libary_8hpp/","title":"File AgentLibary.hpp","text":"<p>FileList &gt; Agents &gt; AgentLibary.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_agent_libary_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_agent_libary_8hpp/#classes","title":"Classes","text":"Type Name struct CompareNodes Custom comparison function for priority queue. struct Node Node class to hold information about positions for A* search. <p>The documentation for this class was generated from the following file <code>source/Agents/AgentLibary.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_agent_libary_8hpp_source/","title":"File AgentLibary.hpp","text":"<p>File List &gt; Agents &gt; AgentLibary.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;regex&gt;\n#include &lt;sstream&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\n#include \"../core/AgentBase.hpp\"\n#include \"../core/WorldBase.hpp\"\n\nnamespace walle {\n\n    struct Node {\n        cse491::GridPosition position; \n        double g;                      \n        double h; \n        std::shared_ptr&lt;Node&gt;\n            parent; \n\n        Node(const cse491::GridPosition &amp;position, double g, double h,\n            std::shared_ptr&lt;Node&gt; parent)\n            : position(position), g(g), h(h), parent(std::move(parent)) {}\n\n        [[nodiscard]] double f() const { return g + h; }\n    };\n\n    struct CompareNodes {\n        bool operator()(const std::shared_ptr&lt;walle::Node&gt; &amp;a,\n                        const std::shared_ptr&lt;walle::Node&gt; &amp;b) const {\n            return a-&gt;f() &gt; b-&gt;f();\n        }\n    };\n\n    inline std::vector&lt;cse491::GridPosition&gt;\n    GetShortestPath(const cse491::GridPosition &amp;start,\n                    const cse491::GridPosition &amp;end, const cse491::WorldBase &amp;world,\n                    const cse491::AgentBase &amp;agent) {\n    // Generated with the help of chat.openai.com\n    const size_t rows = world.GetGrid().GetWidth();\n    const size_t cols = world.GetGrid().GetHeight();\n    std::vector&lt;cse491::GridPosition&gt; path;\n    // If the start or end is not valid then return empty list\n    if (!(world.GetGrid().IsValid(start) &amp;&amp; world.GetGrid().IsValid(end)))\n        return path;\n\n    // Define possible movements (up, down, left, right)\n    const int dx[] = {-1, 1, 0, 0};\n    const int dy[] = {0, 0, -1, 1};\n\n    // Create a 2D vector to store the cost to reach each cell\n    std::vector&lt;std::vector&lt;double&gt;&gt; cost(rows,\n                                            std::vector&lt;double&gt;(cols, INT_MAX));\n\n    // Create an open list as a priority queue\n    std::priority_queue&lt;std::shared_ptr&lt;walle::Node&gt;,\n                        std::vector&lt;std::shared_ptr&lt;walle::Node&gt;&gt;,\n                        walle::CompareNodes&gt;\n        openList;\n\n    // Create the start and end nodes\n    auto startNode = std::make_shared&lt;walle::Node&gt;(start, 0, 0, nullptr);\n    auto endNode = std::make_shared&lt;walle::Node&gt;(end, 0, 0, nullptr);\n\n    openList.push(startNode);\n    cost[start.CellX()][start.CellY()] = 0;\n\n    while (!openList.empty()) {\n        auto current = openList.top();\n        openList.pop();\n\n        if (current-&gt;position == endNode-&gt;position) {\n\n        // Reached the goal, reconstruct the path\n        while (current != nullptr) {\n            path.push_back(current-&gt;position);\n            current = current-&gt;parent;\n        }\n        break;\n        }\n\n        // Explore the neighbors\n        for (int i = 0; i &lt; 4; ++i) {\n            cse491::GridPosition newPos(current-&gt;position.GetX() + dx[i],\n                                        current-&gt;position.GetY() + dy[i]);\n            // Check if the neighbor is within bounds and is a valid move\n            if (world.GetGrid().IsValid(newPos) &amp;&amp;\n                world.IsTraversable(agent, newPos)) {\n                double newG =\n                    current-&gt;g + 1; // Assuming a cost of 1 to move to a neighbor\n                double newH = std::abs(newPos.GetX() - endNode-&gt;position.GetX()) +\n                    std::abs(newPos.GetY() -\n                        endNode-&gt;position.GetY()); // Manhattan distance\n\n                if (newG + newH &lt; cost[newPos.CellX()][newPos.CellY()]) {\n                    auto neighbor =\n                        std::make_shared&lt;walle::Node&gt;(newPos, newG, newH, current);\n                    openList.push(neighbor);\n                    cost[newPos.CellX()][newPos.CellY()] = newG + newH;\n                }\n            }\n        }\n    }\n    return path;\n    }\n\n    inline std::vector&lt;cse491::GridPosition&gt;\n    StrToOffsets(std::string_view commands) {\n        std::vector&lt;cse491::GridPosition&gt; positions;\n\n        // Regex capturing groups logically mean the following:\n        // Group 0: whole regex\n        // Group 1: `steps` and `*` pair (optional)(unused)\n        // Group 2: `steps` (optional)\n        // Group 3: `*` (optional, only matches when Group 2 matches)\n        // Group 4: direction\n        std::regex pattern(\"(([1-9]\\\\d*)(\\\\*?))?([nswex])\");\n        std::istringstream iss{std::string(commands)};\n        iss &gt;&gt; std::skipws;\n\n        std::string single_command;\n        while (iss &gt;&gt; single_command) {\n            std::smatch pattern_match;\n            if (std::regex_match(single_command, pattern_match, pattern)) {\n                int steps = 1;\n\n                if (pattern_match[2].length() &gt; 0) {\n                    std::istringstream step_val(pattern_match[1].str());\n                    step_val &gt;&gt; steps;\n                }\n\n                bool multiply = pattern_match[3].length() &gt; 0;\n\n                char direction = pattern_match[4].str()[0];\n\n                cse491::GridPosition base_pos;\n                switch (direction) {\n                    // Move up\n                    case 'n': {\n                        if (multiply) {\n                            positions.push_back(base_pos.Above(steps));\n                        } else {\n                            for (int i = 0; i &lt; steps; ++i) {\n                                positions.push_back(base_pos.Above());\n                            }\n                        }\n                        break;\n                    }\n\n                    // Move down\n                    case 's': {\n                        if (multiply) {\n                            positions.push_back(base_pos.Below(steps));\n                        } else {\n                            for (int i = 0; i &lt; steps; ++i) {\n                                positions.push_back(base_pos.Below());\n                            }\n                        }\n                        break;\n                    }\n\n                    // Move left\n                    case 'w': {\n                        if (multiply) {\n                            positions.push_back(base_pos.ToLeft(steps));\n                        } else {\n                            for (int i = 0; i &lt; steps; ++i) {\n                                positions.push_back(base_pos.ToLeft());\n                            }\n                        }\n                        break;\n                    }\n\n                    // Move right\n                    case 'e': {\n                        if (multiply) {\n                            positions.push_back(base_pos.ToRight(steps));\n                        } else {\n                            for (int i = 0; i &lt; steps; ++i) {\n                                positions.push_back(base_pos.ToRight());\n                            }\n                        }\n                        break;\n                    }\n\n                    // Stay\n                    case 'x': {\n                        // Using the `*` does nothing to scale the offset since it's scaling {0,\n                        // 0}\n                        steps = multiply ? 1 : steps;\n\n                        for (int i = 0; i &lt; steps; ++i) {\n                            positions.push_back(base_pos);\n                        }\n                    }\n                }\n            } else {\n                std::ostringstream what;\n                what &lt;&lt; \"Incorrectly formatted argument: \" &lt;&lt; single_command;\n                throw std::invalid_argument(what.str());\n            }\n\n            iss &gt;&gt; std::skipws;\n        }\n        return positions;\n    }\n\n    template&lt;typename T&gt;\n    concept Agent_Type = std::is_base_of_v&lt;cse491::AgentBase, T&gt;;\n\n    template&lt;typename T&gt;\n    T &amp;DownCastAgent(cse491::Entity &amp;entity) requires(Agent_Type&lt;T&gt;) {\n        assert(dynamic_cast&lt;T *&gt;(&amp;entity)!=nullptr);\n        return static_cast&lt;T &amp;&gt;(entity);\n    }\n\n} // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_pacing_agent_8hpp/","title":"File PacingAgent.hpp","text":"<p>FileList &gt; Agents &gt; PacingAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_pacing_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 An Agent that will walk back and forth along a row or column."},{"location":"Agent%20Library%28Group%201%29/_pacing_agent_8hpp/#classes","title":"Classes","text":"Type Name class PacingAgent <p>The documentation for this class was generated from the following file <code>source/Agents/PacingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_pacing_agent_8hpp_source/","title":"File PacingAgent.hpp","text":"<p>File List &gt; Agents &gt; PacingAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"../core/AgentBase.hpp\"\n\nnamespace cse491 {\n\nclass PacingAgent : public AgentBase {\n protected:\n    bool vertical = true; \n    bool reverse = false;  \n\n public:\n    PacingAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {}\n    ~PacingAgent() = default;\n\n    bool Initialize() override {\n        return HasAction(\"up\") &amp;&amp; HasAction(\"down\") &amp;&amp; HasAction(\"left\") &amp;&amp; HasAction(\"right\");\n    }\n\n    size_t SelectAction(const WorldGrid &amp; /* grid*/,\n                        const type_options_t &amp; /* type_options*/,\n                        const item_map_t &amp; /* item_map*/,\n                        const agent_map_t &amp; /* agent_map*/) override {\n        // If the last step failed, try going in the other direction.\n        if (action_result == 0) {\n            reverse = !reverse;\n        }\n        // Take as tep in the direction we are trying to go in.\n        if (vertical) {\n            if (reverse) return action_map[\"up\"];\n            else return action_map[\"down\"];\n        } else {\n            if (reverse) return action_map[\"left\"];\n            else return action_map[\"right\"];\n        }\n        return 0;  // Should never actually get here...\n    }\n\n    PacingAgent &amp;SetVertical(bool vert) {\n        vertical = vert;\n        return *this;\n    }\n\n    bool GetVertical() const { return vertical; }\n\n};\n\n} // End of namespace cse491\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8cpp/","title":"File PathAgent.cpp","text":"<p>FileList &gt; Agents &gt; PathAgent.cpp</p> <p>Go to the source code of this file</p> <p>Path Agent Class. More...</p> <ul> <li><code>#include \"PathAgent.hpp\"</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Path Agent Class: Agent to move in a predefined path.</p> <p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>David Rackerby </p> <p>The documentation for this class was generated from the following file <code>source/Agents/PathAgent.cpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8cpp_source/","title":"File PathAgent.cpp","text":"<p>File List &gt; Agents &gt; PathAgent.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"PathAgent.hpp\"\n\n#include &lt;sstream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;vector&gt;\n\nnamespace walle {\n\n    PathAgent::PathAgent(size_t id, std::string const &amp;name)\n        : cse491::AgentBase(id, name) {}\n\n    PathAgent::PathAgent(size_t id, std::string const &amp;name, std::vector&lt;cse491::GridPosition&gt; offsets)\n        : cse491::AgentBase(id, name), offsets_(std::move(offsets)) {\n        if (offsets_.empty()) {\n            throw std::invalid_argument(\"Sequence of input offsets must not be empty\");\n        }\n    }\n\n    PathAgent::PathAgent(size_t id, std::string const &amp;name, std::string_view commands)\n        : cse491::AgentBase(id, name), offsets_(StrToOffsets(commands)) {\n        if (offsets_.empty()) {\n            throw std::invalid_argument(\"Sequence of input offsets must not be empty\");\n        }\n    }\n\n    bool PathAgent::Initialize() {\n        if (property_map.contains(\"path\")) {\n            offsets_ = StrToOffsets(GetProperty&lt;std::basic_string_view&lt;char&gt;&gt;(\"path\"));\n        } else {\n            return false;\n        }\n        return HasAction(\"move_arbitrary\") &amp;&amp; index_ &gt;= 0 &amp;&amp;\n            static_cast&lt;size_t&gt;(index_) &lt; offsets_.size();\n    }\n\n    void PathAgent::IncrementIndex() {\n        ++index_;\n\n        // Wrap-around to front of offsets\n        if (index_ &gt;= static_cast&lt;int&gt;(offsets_.size())) {\n            index_ = 0;\n        }\n    }\n\n    void PathAgent::DecrementIndex() {\n        --index_;\n\n        // Wrap-around to back of offsets\n        if (index_ &lt; 0) {\n            index_ = static_cast&lt;int&gt;(offsets_.size()) - 1;\n        }\n    }\n\n    cse491::GridPosition PathAgent::CalcNextPos() const {\n        return offsets_[index_] + GetPosition();\n    }\n\n    cse491::GridPosition PathAgent::UpdateAndGetNextPos(bool increment) {\n        auto next_pos = CalcNextPos();\n        if (increment) {\n            IncrementIndex();\n        } else {\n            DecrementIndex();\n        }\n        return next_pos;\n    }\n\n    cse491::GridPosition PathAgent::GetNextPosition() {\n        return UpdateAndGetNextPos(true);\n    }\n\n    size_t PathAgent::SelectAction(cse491::WorldGrid const &amp; /* grid*/,\n                                cse491::type_options_t const &amp; /* type_options*/,\n                                cse491::item_map_t const &amp; /* item_map*/,\n                                cse491::agent_map_t const &amp; /* agent_map*/) {\n        assert(HasAction(\"move_arbitrary\"));\n        return action_map[\"move_arbitrary\"];\n    }\n\n    PathAgent &amp;PathAgent::SetPath(std::vector&lt;cse491::GridPosition&gt; offsets, size_t start_index) {\n        offsets_ = offsets;\n        index_ = static_cast&lt;int&gt;(start_index);\n        if (static_cast&lt;size_t&gt;(index_) &gt;= offsets_.size()) {\n            std::ostringstream what;\n            what &lt;&lt; \"Out of bounds offset index to begin from: \" &lt;&lt; index_\n                &lt;&lt; \", number of offsets: \" &lt;&lt; offsets_.size();\n            throw std::invalid_argument(what.str());\n        }\n        return *this;\n    }\n\n    PathAgent &amp;PathAgent::SetPath(std::string_view commands, size_t start_index) {\n        offsets_.clear();\n        return SetPath(StrToOffsets(commands), start_index);\n    }\n\n    int PathAgent::GetIndex() const { return index_; }\n\n    std::vector&lt;cse491::GridPosition&gt; const &amp;PathAgent::GetPath() const { return offsets_; }\n\n} // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8hpp/","title":"File PathAgent.hpp","text":"<p>FileList &gt; Agents &gt; PathAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include \"AgentLibary.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8hpp/#classes","title":"Classes","text":"Type Name class PathAgent <p>The documentation for this class was generated from the following file <code>source/Agents/PathAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_path_agent_8hpp_source/","title":"File PathAgent.hpp","text":"<p>File List &gt; Agents &gt; PathAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#ifndef GROUP_1_PROJECT_SOURCE_AGENTS_PATHAGENT_H_\n#define GROUP_1_PROJECT_SOURCE_AGENTS_PATHAGENT_H_\n\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;vector&gt;\n\n#include \"../core/AgentBase.hpp\"\n#include \"../core/GridPosition.hpp\"\n#include \"AgentLibary.hpp\"\n\nnamespace walle {\n\n    class PathAgent : public cse491::AgentBase {\n    protected:\n        std::vector&lt;cse491::GridPosition&gt; offsets_;\n\n        int index_ = 0;\n\n    public:\n        PathAgent() = delete;\n        PathAgent(size_t id, std::string const &amp;name);\n        PathAgent(size_t id, std::string const &amp;name,\n                std::vector&lt;cse491::GridPosition&gt; offsets);\n        PathAgent(size_t id, std::string const &amp;name, std::string_view commands);\n        ~PathAgent() override = default;\n\n        bool Initialize() override;\n\n        void IncrementIndex();\n        void DecrementIndex();\n\n        [[nodiscard]] cse491::GridPosition CalcNextPos() const;\n\n        virtual cse491::GridPosition UpdateAndGetNextPos(bool increment);\n\n        size_t SelectAction(cse491::WorldGrid const &amp;, cse491::type_options_t const &amp;,\n                            cse491::item_map_t const &amp;, cse491::agent_map_t const &amp;) override;\n\n        [[nodiscard]] cse491::GridPosition GetNextPosition() override;\n\n        PathAgent &amp;SetPath(std::vector&lt;cse491::GridPosition&gt; offsets,\n                        size_t start_index = 0);\n        PathAgent &amp;SetPath(std::string_view commands, size_t start_index = 0);\n\n        [[nodiscard]] int GetIndex() const;\n\n        [[nodiscard]] std::vector&lt;cse491::GridPosition&gt; const &amp;GetPath() const;\n\n        PathAgent &amp;ResetIndex() {\n            index_ = 0;\n            return *this;\n        }\n    };\n\n} // namespace walle\n\n#endif // GROUP_1_PROJECT_SOURCE_AGENTS_PATHAGENT_H_\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp/","title":"File RandomAgent.hpp","text":"<p>FileList &gt; Agents &gt; RandomAgent.hpp</p> <p>Go to the source code of this file</p> <p>An Agent that will move around using random actions. More...</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp/#classes","title":"Classes","text":"Type Name class RandomAgent"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 Course Project</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>Yousif Murrani </p> <p>The documentation for this class was generated from the following file <code>source/Agents/RandomAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_random_agent_8hpp_source/","title":"File RandomAgent.hpp","text":"<p>File List &gt; Agents &gt; RandomAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include \"../core/AgentBase.hpp\"\n#include \"../core/GridPosition.hpp\"\n#include \"../core/WorldBase.hpp\"\n\nnamespace walle {\n\n    class RandomAgent : public cse491::AgentBase {\n\n        private:\n\n            double random_val = 4.0; \n\n            bool moving = true; \n\n        public:\n            RandomAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {\n            }\n\n            ~RandomAgent() = default;\n\n            bool Initialize() override {\n                return HasAction(\"up\") &amp;&amp; HasAction(\"down\") &amp;&amp; HasAction(\"left\") &amp;&amp; HasAction(\"right\");\n            }\n\n            size_t SelectAction(const cse491::WorldGrid &amp; /*grid*/,\n                                const cse491::type_options_t &amp; /* type_options*/,\n                                const cse491::item_map_t &amp; /* item_map*/,\n                                const cse491::agent_map_t &amp; /* agent_map*/) override {\n                // We are taking an action so another turn has passed\n\n                CalculateRandom(random_val);\n\n                if(moving){\n                    if(random_val &lt; 1.0){\n                        return action_map[\"up\"];\n                    }\n                    else if(random_val &lt; 2.0){\n                        return action_map[\"down\"];\n                    }\n                    else if(random_val &lt; 3.0){\n                        return action_map[\"left\"];\n                    }\n                    else{\n                        return action_map[\"right\"];\n                    }\n                }\n\n                return 0; // should not reach this point\n            }\n\n            void CalculateRandom(double multiplier){\n                random_val = GetWorld().GetRandom(multiplier);\n            }\n\n            void SetDirection(double direction) { random_val = direction; }\n\n            void SetMoving(bool move) { moving = move; }\n\n            double GetRandom() const { return random_val; }\n\n            bool GetMoving() const { return moving; }\n    };\n}\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp/","title":"File TrackingAgent.hpp","text":"<p>FileList &gt; Agents &gt; TrackingAgent.hpp</p> <p>Go to the source code of this file</p> <p>Agent that switches between user-defined custom movement pattern and tracking a given agent. More...</p> <ul> <li><code>#include \"../core/AgentBase.hpp\"</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include \"AStarAgent.hpp\"</code></li> <li><code>#include \"PathAgent.hpp\"</code></li> <li><code>#include \"AgentLibary.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace walle"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp/#classes","title":"Classes","text":"Type Name class Alerter class TrackingAgent"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 Course Project</p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>David Rackerby </p> <p>Author:</p> <p>Matt Kight </p> <p>The documentation for this class was generated from the following file <code>source/Agents/TrackingAgent.hpp</code></p>"},{"location":"Agent%20Library%28Group%201%29/_tracking_agent_8hpp_source/","title":"File TrackingAgent.hpp","text":"<p>File List &gt; Agents &gt; TrackingAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../core/AgentBase.hpp\"\n#include \"../core/GridPosition.hpp\"\n#include \"AStarAgent.hpp\"\n#include \"PathAgent.hpp\"\n#include \"AgentLibary.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;limits&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;type_traits&gt;\n#include &lt;unordered_set&gt;\n#include &lt;variant&gt;\n#include &lt;vector&gt;\n\nnamespace walle {\n\nclass Alerter {\n private:\n    cse491::WorldBase *world_ptr_;\n\n    std::unordered_set&lt;size_t&gt; agent_network_set_;\n\n public:\n    // Must be constructed with an associated world\n    Alerter() = delete;\n    explicit Alerter(cse491::WorldBase *world_ptr);\n    Alerter(cse491::WorldBase *world_ptr, size_t id);\n    void AddAgent(size_t id);\n    void RemoveAgent(size_t id);\n    void AlertAllTrackingAgents(size_t caller_id);\n\n    std::unordered_set&lt;size_t&gt; const &amp;GetNetworkSet() const { return agent_network_set_; }\n}; // Alerter\n\nenum class TrackingState { RETURNING_TO_START, TRACKING, PATROLLING };\n\ntemplate&lt;typename T&gt;\nconcept TrackingAgentInner_Type = std::is_same_v&lt;PathAgent, T&gt; || std::is_same_v&lt;AStarAgent, T&gt;;\n\nclass TrackingAgent : public cse491::AgentBase {\n private:\n    std::variant&lt;PathAgent, AStarAgent&gt; inner_;\n\n    TrackingState state_ = TrackingState::PATROLLING;\n\n    std::vector&lt;cse491::GridPosition&gt; offsets_;\n\n    cse491::GridPosition start_pos_;\n\n    Entity *target_ = nullptr;\n\n    double tracking_distance_ = 50;\n\n    std::shared_ptr&lt;Alerter&gt; alerter_ = nullptr;\n\n public:\n    TrackingAgent() = delete;\n\n    TrackingAgent(size_t id, std::string const &amp;name)\n        : cse491::AgentBase(id, name),\n          inner_(std::in_place_type&lt;PathAgent&gt;, id, name) {}\n\n    TrackingAgent(size_t id,\n                  std::string const &amp;name,\n                  std::vector&lt;cse491::GridPosition&gt; &amp;&amp;offsets,\n                  std::shared_ptr&lt;Alerter&gt; &amp;&amp;alerter = nullptr)\n        : cse491::AgentBase(id, name),\n          inner_(std::in_place_type&lt;PathAgent&gt;, id, name, offsets),\n          offsets_(offsets),\n          alerter_(alerter) {}\n\n    TrackingAgent(size_t id,\n                  std::string const &amp;name,\n                  std::string_view commands,\n                  std::shared_ptr&lt;Alerter&gt; &amp;&amp;alerter = nullptr)\n        : cse491::AgentBase(id, name),\n          inner_(std::in_place_type&lt;PathAgent&gt;, id, name, commands),\n          offsets_(StrToOffsets(commands)),\n          alerter_(alerter) {}\n\n    ~TrackingAgent() override {\n        RemoveFromAlerter();\n    }\n\n    bool Initialize() override {\n        SetStartPosition(GetPosition());\n        if (property_map.contains(\"path\")) {\n            auto view = GetProperty&lt;std::basic_string_view&lt;char&gt;&gt;(\"path\");\n            offsets_ = StrToOffsets(view);\n            std::get&lt;PathAgent&gt;(inner_).SetProperty(\"path\", view);\n            std::get&lt;PathAgent&gt;(inner_).SetWorld(GetWorld());\n            std::get&lt;PathAgent&gt;(inner_).SetPosition(GetPosition());\n\n            if (property_map.contains(\"alerter\")) {\n                auto alerter_property = GetProperty&lt;std::shared_ptr&lt;Alerter&gt;&gt;(\"alerter\");\n                AddToAlerter(alerter_property);\n            }\n            return std::get&lt;PathAgent&gt;(inner_).Initialize();\n        }\n        return false;\n    }\n\n    void MakeAlerter() {\n        alerter_ = std::make_shared&lt;Alerter&gt;(&amp;GetWorld(), id);\n    }\n\n    void AddToAlerter(std::shared_ptr&lt;Alerter&gt; alerter) {\n        assert(alerter != nullptr);\n        alerter-&gt;AddAgent(id);\n        alerter_ = alerter;\n    }\n\n    void RemoveFromAlerter() {\n        if (alerter_ != nullptr) {\n            alerter_-&gt;RemoveAgent(id);\n            alerter_ = nullptr;\n        }\n    }\n\n    [[nodiscard]] std::shared_ptr&lt;Alerter&gt; GetAlerter() const {\n        return alerter_;\n    }\n\n    void CallAlerter(size_t agent_id) {\n        if (alerter_ != nullptr) {\n            alerter_-&gt;AlertAllTrackingAgents(agent_id);\n        }\n    }\n\n    void UpdateState(bool alerting = true) {\n        SetPosition(std::visit([](TrackingAgentInner_Type auto const &amp;agent) { return agent.GetPosition(); }, inner_));\n        switch (state_) {\n            // Tracking can transition only to Returning\n            case TrackingState::TRACKING: {\n                // Reached goal position\n                if (GetPosition() == std::get&lt;AStarAgent&gt;(inner_).GetGoalPosition()) {\n                    if (target_ != nullptr &amp;&amp; GetPosition().Distance(target_-&gt;GetPosition()) &lt; tracking_distance_) {\n                        // Target is still in range of goal position so\n                        std::get&lt;AStarAgent&gt;(inner_).SetGoalPosition(target_-&gt;GetPosition());\n\n                        // Alert all trackers\n                        if (alerting) {\n                            CallAlerter(id);\n                        }\n                    } else {\n                        state_ = TrackingState::RETURNING_TO_START;\n                        std::get&lt;AStarAgent&gt;(inner_).SetGoalPosition(start_pos_);\n                    }\n                    std::get&lt;AStarAgent&gt;(inner_).RecalculatePath();\n                    std::get&lt;AStarAgent&gt;(inner_).SetActionResult(1);\n                }\n                break;\n            }\n\n                // Returning can transition to either Patrolling or Tracking\n            case TrackingState::RETURNING_TO_START: {\n                // Within tracking range, start tracking again\n                if (target_ != nullptr &amp;&amp; GetPosition().Distance(target_-&gt;GetPosition()) &lt; tracking_distance_) {\n                    state_ = TrackingState::TRACKING;\n                    std::get&lt;AStarAgent&gt;(inner_).SetGoalPosition(target_-&gt;GetPosition());\n                    std::get&lt;AStarAgent&gt;(inner_).RecalculatePath();\n                    std::get&lt;AStarAgent&gt;(inner_).SetActionResult(1);\n\n                    // Alert other trackers\n                    if (alerting) {\n                        CallAlerter(id);\n                    }\n                }\n\n                    // Returned to the beginning, start patrolling again\n                else if (GetPosition() == start_pos_) {\n                    state_ = TrackingState::PATROLLING;\n                    inner_.emplace&lt;PathAgent&gt;(id, name);\n                    std::get&lt;PathAgent&gt;(inner_).SetPosition(GetPosition());\n                    std::get&lt;PathAgent&gt;(inner_).SetPath(std::vector(offsets_));\n\n                    // Inner world_ptr needs to be reset\n                    SetWorld(GetWorld());\n                }\n                break;\n            }\n\n                // Patrolling can transition only to Tracking\n            case TrackingState::PATROLLING: {\n                // Within tracking range, needs internal object replacement\n                if (target_ != nullptr &amp;&amp; GetPosition().Distance(target_-&gt;GetPosition()) &lt; tracking_distance_) {\n                    state_ = TrackingState::TRACKING;\n                    inner_.emplace&lt;AStarAgent&gt;(id, name);\n                    // Set internal AStarAgent's position to the outer position\n                    std::get&lt;AStarAgent&gt;(inner_).SetPosition(GetPosition());\n                    std::get&lt;AStarAgent&gt;(inner_).SetGoalPosition(target_-&gt;GetPosition());\n\n                    // Inner world_ptr needs to be set\n                    SetWorld(GetWorld());\n\n                    std::get&lt;AStarAgent&gt;(inner_).RecalculatePath();\n                    std::get&lt;AStarAgent&gt;(inner_).SetActionResult(1);\n\n                    // Alert all other trackers\n                    if (alerting) {\n                        CallAlerter(id);\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    [[nodiscard]] cse491::GridPosition GetNextPosition() override {\n        auto pos = std::get&lt;PathAgent&gt;(inner_).GetNextPosition();\n        std::get&lt;PathAgent&gt;(inner_).SetPosition(pos);\n        return pos;\n    }\n\n    size_t SelectInnerAction(PathAgent &amp;agent,\n                             cse491::WorldGrid const &amp;grid,\n                             cse491::type_options_t const &amp;type,\n                             cse491::item_map_t const &amp;item_set,\n                             cse491::agent_map_t const &amp;agent_set) {\n        return agent.SelectAction(grid, type, item_set, agent_set);\n    }\n\n    size_t SelectInnerAction(AStarAgent &amp;agent,\n                             cse491::WorldGrid const &amp;grid,\n                             cse491::type_options_t const &amp;type,\n                             cse491::item_map_t const &amp;item_set,\n                             cse491::agent_map_t const &amp;agent_set) {\n        auto next_pos = agent.GetNextPosition();\n        auto res = agent.SelectAction(grid, type, item_set, agent_set);\n        agent.SetPosition(next_pos);\n        return res;\n    }\n\n    size_t SelectAction(cse491::WorldGrid const &amp;grid,\n                        cse491::type_options_t const &amp;type,\n                        cse491::item_map_t const &amp;item_set,\n                        cse491::agent_map_t const &amp;agent_set) override {\n        UpdateState();\n        return std::visit([&amp;](TrackingAgentInner_Type auto &amp;agent) {\n                              return SelectInnerAction(agent, grid, type, item_set, agent_set);\n                          },\n                          inner_);\n    }\n\n    TrackingAgent &amp;SetStartPosition(cse491::GridPosition pos) {\n        start_pos_ = pos;\n        return *this;\n    }\n\n    TrackingAgent &amp;SetStartPosition(double x, double y) {\n        start_pos_ = cse491::GridPosition(x, y);\n        return *this;\n    }\n\n    TrackingAgent &amp;SetTarget(Entity *agent) {\n        target_ = agent;\n        return *this;\n    }\n\n    [[nodiscard]] double GetTrackingDistance() const { return tracking_distance_; }\n\n    TrackingAgent &amp;SetTrackingDistance(double dist) {\n        tracking_distance_ = dist;\n        return *this;\n    }\n\n    TrackingAgent &amp;SetWorld(cse491::WorldBase &amp;in_world) override {\n        Entity::SetWorld(in_world);\n        std::visit([&amp;in_world](TrackingAgentInner_Type auto &amp;agent) {\n            agent.SetWorld(in_world);\n            std::as_const(in_world).ConfigAgent(agent);\n        }, inner_);\n        return *this;\n    }\n\n    TrackingState GetState() {\n        return state_;\n    }\n\n    TrackingAgent &amp;SetPath(std::vector&lt;cse491::GridPosition&gt; offsets) {\n        offsets_ = std::move(offsets);\n        if (offsets_.empty()) {\n            std::ostringstream what;\n            what &lt;&lt; \"TrackingAgent cannot have empty path. If you meant to make the agent stay still, use \\\"x\\\"\";\n            throw std::invalid_argument(what.str());\n        }\n        return *this;\n    }\n\n    TrackingAgent &amp;SetPath(std::string_view offsets) {\n        return SetPath(StrToOffsets(offsets));\n    }\n\n    std::vector&lt;cse491::GridPosition&gt; const &amp;GetPath() const { return offsets_; }\n\n    cse491::Entity const *GetTarget() const { return target_; }\n\n}; // TrackingAgent\n\nAlerter::Alerter(cse491::WorldBase *world_ptr) : world_ptr_(world_ptr) { assert(world_ptr != nullptr); }\n\nAlerter::Alerter(cse491::WorldBase *world_ptr, size_t id) : world_ptr_(world_ptr) {\n    assert(world_ptr != nullptr);\n    AddAgent(id);\n}\n\nvoid Alerter::AddAgent(size_t id) {\n    // Note: GetAgent already handles checking that the agent exists, but we must type-check\n    assert(dynamic_cast&lt;TrackingAgent *&gt;(&amp;(world_ptr_-&gt;GetAgent(id))) != nullptr);\n    agent_network_set_.insert(id);\n}\n\nvoid Alerter::RemoveAgent(size_t id) {\n    agent_network_set_.erase(id);\n}\n\nvoid Alerter::AlertAllTrackingAgents(size_t caller_id) {\n    for (auto id : agent_network_set_) {\n        // Do not update the caller who gave the alert\n        if (caller_id == id) {\n            continue;\n        }\n        auto &amp;tracking_agent = DownCastAgent&lt;TrackingAgent&gt;(world_ptr_-&gt;GetAgent(id));\n        // UpdateState sets an agent's TrackingState to TRACKING if it is within some distance of the goal_pos\n        // if this distance is positive infinity, then the state will always be reset (given that there IS a goal_pos)\n        // Important: UpdateState must be called with alerting == false in order to\n        // avoid infinite recursion from recursively calling AlertAllTrackingAgents\n        double old_tracking_dist = tracking_agent.GetTrackingDistance();\n        tracking_agent.SetTrackingDistance(std::numeric_limits&lt;double&gt;::infinity());\n        tracking_agent.UpdateState(false);\n        tracking_agent.SetTrackingDistance(old_tracking_dist);\n    }\n}\n\n} // namespace walle\n\n</code></pre>"},{"location":"Agent%20Library%28Group%201%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cse491 An Agent that will walk back and forth along a row or column. </li> <li>namespace walle </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/","title":"Class Index","text":""},{"location":"Agent%20Library%28Group%201%29/classes/#a","title":"a","text":"<ul> <li>AgentFactory (walle)</li> <li>Alerter (walle)</li> <li>AStarAgent (walle)</li> <li>AStarAgentData (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#b","title":"b","text":"<ul> <li>BaseAgentData (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#c","title":"c","text":"<ul> <li>CompareNodes (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#n","title":"n","text":"<ul> <li>Node (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#p","title":"p","text":"<ul> <li>PacingAgent (cse491)</li> <li>PacingAgentData (walle)</li> <li>PathAgent (walle)</li> <li>PathAgentData (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#r","title":"r","text":"<ul> <li>RandomAgent (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/classes/#t","title":"t","text":"<ul> <li>TrackingAgent (walle)</li> <li>TrackingAgentData (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class walle::AgentFactory </li> <li>class walle::Alerter </li> <li>struct walle::BaseAgentData <ul> <li>struct walle::AStarAgentData </li> <li>struct walle::PacingAgentData </li> <li>struct walle::PathAgentData </li> <li>struct walle::TrackingAgentData </li> </ul> </li> <li>struct walle::CompareNodes Custom comparison function for priority queue. </li> <li>struct walle::Node Node class to hold information about positions for A* search.</li> <li>class AgentBase <ul> <li>class cse491::PacingAgent </li> <li>class walle::AStarAgent </li> <li>class walle::PathAgent </li> <li>class walle::RandomAgent </li> <li>class walle::TrackingAgent </li> </ul> </li> </ul>"},{"location":"Agent%20Library%28Group%201%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Agent%20Library%28Group%201%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Agent%20Library%28Group%201%29/class_members/","title":"Class Members","text":""},{"location":"Agent%20Library%28Group%201%29/class_members/#a","title":"a","text":"<ul> <li>AStarAgent (walle::AStarAgent)</li> <li>AddAStarAgent (walle::AgentFactory)</li> <li>AddPacingAgent (walle::AgentFactory)</li> <li>AddPathAgent (walle::AgentFactory)</li> <li>AddTrackingAgent (walle::AgentFactory)</li> <li>AgentFactory (walle::AgentFactory)</li> <li>AddAgent (walle::Alerter)</li> <li>AlertAllTrackingAgents (walle::Alerter)</li> <li>Alerter (walle::Alerter)</li> <li>agent_network_set_ (walle::Alerter)</li> <li>AddToAlerter (walle::TrackingAgent)</li> <li>alerter_ (walle::TrackingAgent)</li> <li>alerter (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#c","title":"c","text":"<ul> <li>current_move_num (walle::AStarAgent)</li> <li>CalcNextPos (walle::PathAgent)</li> <li>CalculateRandom (walle::RandomAgent)</li> <li>CallAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#d","title":"d","text":"<ul> <li>DecrementIndex (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#f","title":"f","text":"<ul> <li>f (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#g","title":"g","text":"<ul> <li>GetVertical (cse491::PacingAgent)</li> <li>GetGoalPosition (walle::AStarAgent)</li> <li>GetNextPosition (walle::AStarAgent, walle::PathAgent, walle::TrackingAgent)</li> <li>GetPathLength (walle::AStarAgent)</li> <li>GetRecalculateValue (walle::AStarAgent)</li> <li>goal_position (walle::AStarAgent)</li> <li>goal_pos (walle::AStarAgentData)</li> <li>GetNetworkSet (walle::Alerter)</li> <li>g (walle::Node)</li> <li>GetIndex (walle::PathAgent)</li> <li>GetPath (walle::PathAgent, walle::TrackingAgent)</li> <li>GetMoving (walle::RandomAgent)</li> <li>GetRandom (walle::RandomAgent)</li> <li>GetAlerter (walle::TrackingAgent)</li> <li>GetState (walle::TrackingAgent)</li> <li>GetTarget (walle::TrackingAgent)</li> <li>GetTrackingDistance (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#h","title":"h","text":"<ul> <li>h (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#i","title":"i","text":"<ul> <li>Initialize (cse491::PacingAgent, walle::AStarAgent, walle::PathAgent, walle::RandomAgent, walle::TrackingAgent)</li> <li>IncrementIndex (walle::PathAgent)</li> <li>index_ (walle::PathAgent)</li> <li>index (walle::PathAgentData)</li> <li>inner_ (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#m","title":"m","text":"<ul> <li>moving (walle::RandomAgent)</li> <li>MakeAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#n","title":"n","text":"<ul> <li>name (walle::BaseAgentData)</li> <li>Node (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#o","title":"o","text":"<ul> <li>operator() (walle::CompareNodes)</li> <li>offsets_ (walle::PathAgent, walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#p","title":"p","text":"<ul> <li>PacingAgent (cse491::PacingAgent)</li> <li>path (walle::AStarAgent)</li> <li>position (walle::BaseAgentData, walle::Node)</li> <li>parent (walle::Node)</li> <li>PathAgent (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#r","title":"r","text":"<ul> <li>reverse (cse491::PacingAgent)</li> <li>RecalculatePath (walle::AStarAgent)</li> <li>recalculate_after_x_turns (walle::AStarAgent, walle::AStarAgentData)</li> <li>RemoveAgent (walle::Alerter)</li> <li>ResetIndex (walle::PathAgent)</li> <li>RandomAgent (walle::RandomAgent)</li> <li>random_val (walle::RandomAgent)</li> <li>RemoveFromAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#s","title":"s","text":"<ul> <li>SelectAction (cse491::PacingAgent, walle::AStarAgent, walle::PathAgent, walle::RandomAgent, walle::TrackingAgent)</li> <li>SetVertical (cse491::PacingAgent)</li> <li>SetGoalPosition (walle::AStarAgent)</li> <li>SetRecalculate (walle::AStarAgent)</li> <li>symbol (walle::BaseAgentData)</li> <li>SetPath (walle::PathAgent, walle::TrackingAgent)</li> <li>string_path (walle::PathAgentData, walle::TrackingAgentData)</li> <li>SetDirection (walle::RandomAgent)</li> <li>SetMoving (walle::RandomAgent)</li> <li>SelectInnerAction (walle::TrackingAgent)</li> <li>SetStartPosition (walle::TrackingAgent)</li> <li>SetTarget (walle::TrackingAgent)</li> <li>SetTrackingDistance (walle::TrackingAgent)</li> <li>SetWorld (walle::TrackingAgent)</li> <li>start_pos_ (walle::TrackingAgent)</li> <li>state_ (walle::TrackingAgent)</li> <li>start_pos (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#t","title":"t","text":"<ul> <li>TrackingAgent (walle::TrackingAgent)</li> <li>target_ (walle::TrackingAgent)</li> <li>tracking_distance_ (walle::TrackingAgent)</li> <li>TrackingAgentData (walle::TrackingAgentData)</li> <li>target (walle::TrackingAgentData)</li> <li>tracking_distance (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#u","title":"u","text":"<ul> <li>UpdateAndGetNextPos (walle::PathAgent)</li> <li>UpdateState (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#v","title":"v","text":"<ul> <li>vertical (cse491::PacingAgent, walle::PacingAgentData)</li> <li>vector_path (walle::PathAgentData, walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#w","title":"w","text":"<ul> <li>world (walle::AgentFactory)</li> <li>world_ptr_ (walle::Alerter)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_members/#_1","title":"~","text":"<ul> <li>~PacingAgent (cse491::PacingAgent)</li> <li>~AStarAgent (walle::AStarAgent)</li> <li>~PathAgent (walle::PathAgent)</li> <li>~RandomAgent (walle::RandomAgent)</li> <li>~TrackingAgent (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#a","title":"a","text":"<ul> <li>AStarAgent (walle::AStarAgent)</li> <li>AddAStarAgent (walle::AgentFactory)</li> <li>AddPacingAgent (walle::AgentFactory)</li> <li>AddPathAgent (walle::AgentFactory)</li> <li>AddTrackingAgent (walle::AgentFactory)</li> <li>AgentFactory (walle::AgentFactory)</li> <li>AddAgent (walle::Alerter)</li> <li>AlertAllTrackingAgents (walle::Alerter)</li> <li>Alerter (walle::Alerter)</li> <li>AddToAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#c","title":"c","text":"<ul> <li>CalcNextPos (walle::PathAgent)</li> <li>CalculateRandom (walle::RandomAgent)</li> <li>CallAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#d","title":"d","text":"<ul> <li>DecrementIndex (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#f","title":"f","text":"<ul> <li>f (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#g","title":"g","text":"<ul> <li>GetVertical (cse491::PacingAgent)</li> <li>GetGoalPosition (walle::AStarAgent)</li> <li>GetNextPosition (walle::AStarAgent, walle::PathAgent, walle::TrackingAgent)</li> <li>GetPathLength (walle::AStarAgent)</li> <li>GetRecalculateValue (walle::AStarAgent)</li> <li>GetNetworkSet (walle::Alerter)</li> <li>GetIndex (walle::PathAgent)</li> <li>GetPath (walle::PathAgent, walle::TrackingAgent)</li> <li>GetMoving (walle::RandomAgent)</li> <li>GetRandom (walle::RandomAgent)</li> <li>GetAlerter (walle::TrackingAgent)</li> <li>GetState (walle::TrackingAgent)</li> <li>GetTarget (walle::TrackingAgent)</li> <li>GetTrackingDistance (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (cse491::PacingAgent, walle::AStarAgent, walle::PathAgent, walle::RandomAgent, walle::TrackingAgent)</li> <li>IncrementIndex (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#m","title":"m","text":"<ul> <li>MakeAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#n","title":"n","text":"<ul> <li>Node (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#o","title":"o","text":"<ul> <li>operator() (walle::CompareNodes)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#p","title":"p","text":"<ul> <li>PacingAgent (cse491::PacingAgent)</li> <li>PathAgent (walle::PathAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#r","title":"r","text":"<ul> <li>RecalculatePath (walle::AStarAgent)</li> <li>RemoveAgent (walle::Alerter)</li> <li>ResetIndex (walle::PathAgent)</li> <li>RandomAgent (walle::RandomAgent)</li> <li>RemoveFromAlerter (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (cse491::PacingAgent, walle::AStarAgent, walle::PathAgent, walle::RandomAgent, walle::TrackingAgent)</li> <li>SetVertical (cse491::PacingAgent)</li> <li>SetGoalPosition (walle::AStarAgent)</li> <li>SetRecalculate (walle::AStarAgent)</li> <li>SetPath (walle::PathAgent, walle::TrackingAgent)</li> <li>SetDirection (walle::RandomAgent)</li> <li>SetMoving (walle::RandomAgent)</li> <li>SelectInnerAction (walle::TrackingAgent)</li> <li>SetStartPosition (walle::TrackingAgent)</li> <li>SetTarget (walle::TrackingAgent)</li> <li>SetTrackingDistance (walle::TrackingAgent)</li> <li>SetWorld (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#t","title":"t","text":"<ul> <li>TrackingAgent (walle::TrackingAgent)</li> <li>TrackingAgentData (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#u","title":"u","text":"<ul> <li>UpdateAndGetNextPos (walle::PathAgent)</li> <li>UpdateState (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~PacingAgent (cse491::PacingAgent)</li> <li>~AStarAgent (walle::AStarAgent)</li> <li>~PathAgent (walle::PathAgent)</li> <li>~RandomAgent (walle::RandomAgent)</li> <li>~TrackingAgent (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#a","title":"a","text":"<ul> <li>agent_network_set_ (walle::Alerter)</li> <li>alerter_ (walle::TrackingAgent)</li> <li>alerter (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#c","title":"c","text":"<ul> <li>current_move_num (walle::AStarAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#g","title":"g","text":"<ul> <li>goal_position (walle::AStarAgent)</li> <li>goal_pos (walle::AStarAgentData)</li> <li>g (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#h","title":"h","text":"<ul> <li>h (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#i","title":"i","text":"<ul> <li>index_ (walle::PathAgent)</li> <li>index (walle::PathAgentData)</li> <li>inner_ (walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#m","title":"m","text":"<ul> <li>moving (walle::RandomAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#n","title":"n","text":"<ul> <li>name (walle::BaseAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#o","title":"o","text":"<ul> <li>offsets_ (walle::PathAgent, walle::TrackingAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#p","title":"p","text":"<ul> <li>path (walle::AStarAgent)</li> <li>position (walle::BaseAgentData, walle::Node)</li> <li>parent (walle::Node)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#r","title":"r","text":"<ul> <li>reverse (cse491::PacingAgent)</li> <li>recalculate_after_x_turns (walle::AStarAgent, walle::AStarAgentData)</li> <li>random_val (walle::RandomAgent)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#s","title":"s","text":"<ul> <li>symbol (walle::BaseAgentData)</li> <li>string_path (walle::PathAgentData, walle::TrackingAgentData)</li> <li>start_pos_ (walle::TrackingAgent)</li> <li>state_ (walle::TrackingAgent)</li> <li>start_pos (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#t","title":"t","text":"<ul> <li>target_ (walle::TrackingAgent)</li> <li>tracking_distance_ (walle::TrackingAgent)</li> <li>target (walle::TrackingAgentData)</li> <li>tracking_distance (walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#v","title":"v","text":"<ul> <li>vertical (cse491::PacingAgent, walle::PacingAgentData)</li> <li>vector_path (walle::PathAgentData, walle::TrackingAgentData)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_variables/#w","title":"w","text":"<ul> <li>world (walle::AgentFactory)</li> <li>world_ptr_ (walle::Alerter)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Agent%20Library%28Group%201%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Agent%20Library%28Group%201%29/namespace_members/","title":"Namespace Members","text":""},{"location":"Agent%20Library%28Group%201%29/namespace_members/#d","title":"d","text":"<ul> <li>DownCastAgent (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_members/#g","title":"g","text":"<ul> <li>GetShortestPath (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_members/#s","title":"s","text":"<ul> <li>StrToOffsets (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_members/#t","title":"t","text":"<ul> <li>TrackingState (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"Agent%20Library%28Group%201%29/namespace_member_functions/#d","title":"d","text":"<ul> <li>DownCastAgent (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_functions/#g","title":"g","text":"<ul> <li>GetShortestPath (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_functions/#s","title":"s","text":"<ul> <li>StrToOffsets (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Agent%20Library%28Group%201%29/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"Agent%20Library%28Group%201%29/namespace_member_enums/#t","title":"t","text":"<ul> <li>TrackingState (walle)</li> </ul>"},{"location":"Agent%20Library%28Group%201%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Agent%20Library%28Group%201%29/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Agent%20Library%28Group%201%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Agent%20Library%28Group%201%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace DataCollection <ul> <li>class AgentData Represents data collected for an agent, including their name, actions, positions, and associated IDs. </li> <li>class AgentInteractionCollector A data collector class to quantify agent interactions. </li> <li>class AgentReceiver Data receiver class specialized for storing AgentData objects. </li> <li>class DamageCollector A data collector class for damage of game items. </li> <li>class DamageData Represents damage related data between an agent and other entities (agents, items, grids, etc) </li> <li>class DamageReceiver Data receiver class specialized for storing DamageData objects.</li> <li>class DataManager Represents a data control system to hold all related receivers and collectors. </li> <li>class DataReceiver Generic data receiver template class. </li> <li>class GameData </li> <li>class GameReceiver Represents a receiver specifically designed to handle game-related data. </li> <li>class ItemUseCollector A data collector class for usage amount of game items. </li> <li>class JsonBuilder Builds a JSON object from the data collected for an agent. </li> </ul> </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir DataCollection <ul> <li>file AgentData.hpp </li> <li>file AgentInteractionCollector.hpp </li> <li>file AgentReciever.hpp </li> <li>file DamageCollector.hpp </li> <li>file DamageData.hpp </li> <li>file DamageReceiver.hpp </li> <li>file DataManager.hpp </li> <li>file DataReceiver.hpp </li> <li>file GameData.hpp </li> <li>file GameReceiver.hpp </li> <li>file ItemUseCollector.hpp </li> <li>file JsonBuilder.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/namespace_data_collection/","title":"Namespace DataCollection","text":"<p>Namespace List &gt; DataCollection</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_data_collection/#classes","title":"Classes","text":"Type Name class AgentData Represents data collected for an agent, including their name, actions, positions, and associated IDs. class AgentInteractionCollector A data collector class to quantify agent interactions. class AgentReceiver Data receiver class specialized for storing AgentData objects. class DamageCollector A data collector class for damage of game items. class DamageData Represents damage related data between an agent and other entities (agents, items, grids, etc) class DamageReceiver Data receiver class specialized for storing DamageData objects. class DataManager Represents a data control system to hold all related receivers and collectors. class DataReceiver &lt;typename T&gt;Generic data receiver template class. class GameData class GameReceiver Represents a receiver specifically designed to handle game-related data. class ItemUseCollector A data collector class for usage amount of game items. class JsonBuilder Builds a JSON object from the data collected for an agent. <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/","title":"Class DataCollection::AgentData","text":"<p>ClassList &gt; DataCollection &gt; AgentData</p> <p>Represents data collected for an agent, including their name, actions, positions, and associated IDs. </p> <ul> <li><code>#include &lt;AgentData.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#public-functions","title":"Public Functions","text":"Type Name AgentData (std::string name) Default constructor for AgentData class. int GetActionSize () const auto &amp; GetActions () Retrieves the stored actions. auto GetAgentIds () constGets the agent IDs associated with the stored actions. std::string GetName () const int GetPositionSize () constGets the size of the stored grid positions. std::vector&lt; cse491::GridPosition &gt; GetPositions () const void SetActions (const std::vector&lt; std::unordered_map&lt; std::string, size_t &gt; &gt; &amp; newActions) Sets the stored actions to a new set of actions. void StoreAction (std::unordered_map&lt; std::string, size_t &gt; action) Stores an action for the agent. void StoreAgentId (int id) Stores an agent ID associated with an action. void StorePositions (cse491::GridPosition pos) Stores a grid position for the agent. ~AgentData () = defaultDestructor for AgentData class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-agentdata","title":"function AgentData","text":"<pre><code>inline DataCollection::AgentData::AgentData (\n    std::string name\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getactionsize","title":"function GetActionSize","text":"<pre><code>inline int DataCollection::AgentData::GetActionSize () const\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getactions","title":"function GetActions","text":"<p>Retrieves the stored actions. </p> <pre><code>inline auto &amp; DataCollection::AgentData::GetActions () \n</code></pre> <p>Returns:</p> <p>Reference to the vector of action maps. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getagentids","title":"function GetAgentIds","text":"<p>Gets the agent IDs associated with the stored actions. </p> <pre><code>inline auto DataCollection::AgentData::GetAgentIds () const\n</code></pre> <p>Returns:</p> <p>The vector of agent IDs. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getname","title":"function GetName","text":"<pre><code>inline std::string DataCollection::AgentData::GetName () const\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getpositionsize","title":"function GetPositionSize","text":"<p>Gets the size of the stored grid positions. </p> <pre><code>inline int DataCollection::AgentData::GetPositionSize () const\n</code></pre> <p>Returns:</p> <p>The number of stored grid positions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-getpositions","title":"function GetPositions","text":"<pre><code>inline std::vector&lt; cse491::GridPosition &gt; DataCollection::AgentData::GetPositions () const\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-setactions","title":"function SetActions","text":"<p>Sets the stored actions to a new set of actions. </p> <pre><code>inline void DataCollection::AgentData::SetActions (\n    const std::vector&lt; std::unordered_map&lt; std::string, size_t &gt; &gt; &amp; newActions\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>newActions</code> The new set of actions to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-storeaction","title":"function StoreAction","text":"<p>Stores an action for the agent. </p> <pre><code>inline void DataCollection::AgentData::StoreAction (\n    std::unordered_map&lt; std::string, size_t &gt; action\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>action</code> The action to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-storeagentid","title":"function StoreAgentId","text":"<p>Stores an agent ID associated with an action. </p> <pre><code>inline void DataCollection::AgentData::StoreAgentId (\n    int id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> The agent ID to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-storepositions","title":"function StorePositions","text":"<p>Stores a grid position for the agent. </p> <pre><code>inline void DataCollection::AgentData::StorePositions (\n    cse491::GridPosition pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_data/#function-agentdata_1","title":"function ~AgentData","text":"<pre><code>DataCollection::AgentData::~AgentData () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/","title":"Class DataCollection::AgentInteractionCollector","text":"<p>ClassList &gt; DataCollection &gt; AgentInteractionCollector</p> <p>A data collector class to quantify agent interactions. More...</p> <ul> <li><code>#include &lt;AgentInteractionCollector.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#public-functions","title":"Public Functions","text":"Type Name AgentInteractionCollector () = defaultData storage map of agent name to interactions. const std::unordered_map&lt; std::string, int &gt; &amp; GetInteractionData ()  size_t GetUniqueInteractions ()  void RecordInteraction (const std::string &amp; agentName)  void WriteToInteractionFile (const std::string filename)"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#detailed-description","title":"Detailed Description","text":"<p>Useful for setting up graphs for common interactions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-agentinteractioncollector","title":"function AgentInteractionCollector","text":"<p>Data storage map of agent name to interactions. </p> <pre><code>DataCollection::AgentInteractionCollector::AgentInteractionCollector () = default\n</code></pre> <p>Default constructor for AgentInteractionCollector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-getinteractiondata","title":"function GetInteractionData","text":"<pre><code>inline const std::unordered_map&lt; std::string, int &gt; &amp; DataCollection::AgentInteractionCollector::GetInteractionData () \n</code></pre> <p>Getter for interaction data </p> <p>Returns:</p> <p>Const reference to the interaction data storage. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-getuniqueinteractions","title":"function GetUniqueInteractions","text":"<pre><code>inline size_t DataCollection::AgentInteractionCollector::GetUniqueInteractions () \n</code></pre> <p>Get the amount of unique agents that occured </p> <p>Returns:</p> <p>int amount of agent occurances </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-recordinteraction","title":"function RecordInteraction","text":"<pre><code>inline void DataCollection::AgentInteractionCollector::RecordInteraction (\n    const std::string &amp; agentName\n) \n</code></pre> <p>Increment occurance amount for a certain agent. </p> <p>Parameters:</p> <ul> <li><code>agentName</code> Agent name to record new interaction with </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_interaction_collector/#function-writetointeractionfile","title":"function WriteToInteractionFile","text":"<pre><code>inline void DataCollection::AgentInteractionCollector::WriteToInteractionFile (\n    const std::string filename\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentInteractionCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/","title":"Class DataCollection::AgentReceiver","text":"<p>ClassList &gt; DataCollection &gt; AgentReceiver</p> <p>Data receiver class specialized for storing AgentData objects.More...</p> <ul> <li><code>#include &lt;AgentReciever.hpp&gt;</code></li> </ul> <p>Inherits the following classes: DataCollection::DataReceiver</p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#public-functions","title":"Public Functions","text":"Type Name void AddAgent (const std::string &amp; name) Stores agent data into the storage and writes to a json file. std::shared_ptr&lt; AgentData &gt; GetAgent (const std::string &amp; name)  AgentData GetAgentData (const std::string &amp; name)  void StoreData (std::string name, cse491::GridPosition pos, int last_action) Stores a grid position and last action ID associated with an agent. void WriteToPositionFile (std::string path) Writes the stored AgentData Positions to a JSON file."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#public-functions-inherited-from-datacollectiondatareceiver","title":"Public Functions inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name DataReceiver () = defaultDefault constructor for DataReceiver class. bool IsEmpty () Checks if the storage is empty. void StoreIntoStorage (T obj) Store a data object into the storage. std::vector&lt; T &gt; &amp; getStorage () Retrieves the stored data objects. virtual ~DataReceiver () = defaultVirtual destructor for DataReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#protected-attributes-inherited-from-datacollectiondatareceiver","title":"Protected Attributes inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name std::vector&lt; T &gt; storage Vector to store shared_ptr data objects of type T."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#detailed-description","title":"Detailed Description","text":"<p>This class extends DataReceiver class and provides specific functionality for storing AgentData objects along with grid positions and last action IDs. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-addagent","title":"function AddAgent","text":"<p>Stores agent data into the storage and writes to a json file. </p> <pre><code>inline void DataCollection::AgentReceiver::AddAgent (\n    const std::string &amp; name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> the name of the agent </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-getagent","title":"function GetAgent","text":"<pre><code>inline std::shared_ptr&lt; AgentData &gt; DataCollection::AgentReceiver::GetAgent (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-getagentdata","title":"function GetAgentData","text":"<pre><code>inline AgentData DataCollection::AgentReceiver::GetAgentData (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-storedata","title":"function StoreData","text":"<p>Stores a grid position and last action ID associated with an agent. </p> <pre><code>inline void DataCollection::AgentReceiver::StoreData (\n    std::string name,\n    cse491::GridPosition pos,\n    int last_action\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position to be stored. </li> <li><code>last_action</code> The last action ID associated with the agent. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_agent_receiver/#function-writetopositionfile","title":"function WriteToPositionFile","text":"<p>Writes the stored AgentData Positions to a JSON file.</p> <pre><code>inline void DataCollection::AgentReceiver::WriteToPositionFile (\n    std::string path\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The AgentData Position to be stored. </li> </ul> <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentReciever.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/","title":"Class DataCollection::DamageCollector","text":"<p>ClassList &gt; DataCollection &gt; DamageCollector</p> <p>A data collector class for damage of game items. More...</p> <ul> <li><code>#include &lt;DamageCollector.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#public-functions","title":"Public Functions","text":"Type Name double CalculateAverageDamage (const std::string &amp; itemName)  DamageCollector () = defaultDefault constructor for DamageCollector . std::vector&lt; double &gt; &amp; GetDamageAmounts (std::string itemName)  void RecordDamageResult (const std::string &amp; itemName, double damageAmt)  void WriteToDamageFile (std::string path)"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#detailed-description","title":"Detailed Description","text":"<p>Useful for setting up graphs for analysis of item balancing. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-calculateaveragedamage","title":"function CalculateAverageDamage","text":"<pre><code>inline double DataCollection::DamageCollector::CalculateAverageDamage (\n    const std::string &amp; itemName\n) \n</code></pre> <p>Calculate average damage for a certain item </p> <p>Parameters:</p> <ul> <li><code>itemName</code> Item name to calculate average for </li> </ul> <p>Returns:</p> <p>The average damage as a double, -1 if the item does not exist </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-damagecollector","title":"function DamageCollector","text":"<pre><code>DataCollection::DamageCollector::DamageCollector () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-getdamageamounts","title":"function GetDamageAmounts","text":"<pre><code>inline std::vector&lt; double &gt; &amp; DataCollection::DamageCollector::GetDamageAmounts (\n    std::string itemName\n) \n</code></pre> <p>Get the damage amounts for a certain item. </p> <p>Parameters:</p> <ul> <li><code>itemName</code> Name of the item to get damage amounts for </li> </ul> <p>Returns:</p> <p>Reference to the vector of damage amounts </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-recorddamageresult","title":"function RecordDamageResult","text":"<pre><code>inline void DataCollection::DamageCollector::RecordDamageResult (\n    const std::string &amp; itemName,\n    double damageAmt\n) \n</code></pre> <p>Store a damage amount for a certain item. </p> <p>Parameters:</p> <ul> <li><code>itemName</code> Name of the item to store the damage for </li> <li><code>damageAmt</code> Amount of damage this item did </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_collector/#function-writetodamagefile","title":"function WriteToDamageFile","text":"<pre><code>inline void DataCollection::DamageCollector::WriteToDamageFile (\n    std::string path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/","title":"Class DataCollection::DamageData","text":"<p>ClassList &gt; DataCollection &gt; DamageData</p> <p>Represents damage related data between an agent and other entities (agents, items, grids, etc) </p> <ul> <li><code>#include &lt;DamageData.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/#public-functions","title":"Public Functions","text":"Type Name DamageData (std::shared_ptr&lt; cse491::AgentBase &gt; agnt, std::shared_ptr&lt; cse491::Entity &gt; src, int amt) The amount of damage taken from this source. ~DamageData () = defaultDestructor for DamageData class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/#function-damagedata","title":"function DamageData","text":"<p>The amount of damage taken from this source. </p> <pre><code>inline DataCollection::DamageData::DamageData (\n    std::shared_ptr&lt; cse491::AgentBase &gt; agnt,\n    std::shared_ptr&lt; cse491::Entity &gt; src,\n    int amt\n) \n</code></pre> <p>Default constructor for a DamageData </p> <p>Parameters:</p> <ul> <li><code>src</code> Damage source entity </li> <li><code>amt</code> Amount of damage taken </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_data/#function-damagedata_1","title":"function ~DamageData","text":"<pre><code>DataCollection::DamageData::~DamageData () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_receiver/","title":"Class DataCollection::DamageReceiver","text":"<p>ClassList &gt; DataCollection &gt; DamageReceiver</p> <p>Data receiver class specialized for storing DamageData objects.More...</p> <ul> <li><code>#include &lt;DamageReceiver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: DataCollection::DataReceiver</p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_receiver/#public-functions-inherited-from-datacollectiondatareceiver","title":"Public Functions inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name DataReceiver () = defaultDefault constructor for DataReceiver class. bool IsEmpty () Checks if the storage is empty. void StoreIntoStorage (T obj) Store a data object into the storage. std::vector&lt; T &gt; &amp; getStorage () Retrieves the stored data objects. virtual ~DataReceiver () = defaultVirtual destructor for DataReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_receiver/#protected-attributes-inherited-from-datacollectiondatareceiver","title":"Protected Attributes inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name std::vector&lt; T &gt; storage Vector to store shared_ptr data objects of type T."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_damage_receiver/#detailed-description","title":"Detailed Description","text":"<p>This class extends DataReceiver class and provides specific functionality for storing DamageData objects along with damage sources and amounts. </p> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/","title":"Class DataCollection::DataManager","text":"<p>ClassList &gt; DataCollection &gt; DataManager</p> <p>Represents a data control system to hold all related receivers and collectors. More...</p> <ul> <li><code>#include &lt;DataManager.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#public-functions","title":"Public Functions","text":"Type Name AgentInteractionCollector &amp; GetAgentInteractionCollector ()  AgentReceiver &amp; GetAgentReceiver ()  const DamageCollector &amp; GetDamageCollector ()  const GameReceiver &amp; GetGameReceiver ()  ItemUseCollector &amp; GetItemUseCollector ()  void WriteToJson ()  ~DataManager () = default"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#public-static-functions","title":"Public Static Functions","text":"Type Name DataManager &amp; GetInstance ()"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#detailed-description","title":"Detailed Description","text":"<p>World should report back relevant data here and it will be stored appropriately. Also manages graphing utilities. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getagentinteractioncollector","title":"function GetAgentInteractionCollector","text":"<pre><code>inline AgentInteractionCollector &amp; DataCollection::DataManager::GetAgentInteractionCollector () \n</code></pre> <p>Get a handle to the agent interaction collector </p> <p>Returns:</p> <p>Reference to the agent interaction collector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getagentreceiver","title":"function GetAgentReceiver","text":"<pre><code>inline AgentReceiver &amp; DataCollection::DataManager::GetAgentReceiver () \n</code></pre> <p>Get a handle to the agent receiver </p> <p>Returns:</p> <p>Reference to the agent receiver </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getdamagecollector","title":"function GetDamageCollector","text":"<pre><code>inline const DamageCollector &amp; DataCollection::DataManager::GetDamageCollector () \n</code></pre> <p>Get a handle to the damage collector </p> <p>Returns:</p> <p>Const reference to the damage collector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getgamereceiver","title":"function GetGameReceiver","text":"<pre><code>inline const GameReceiver &amp; DataCollection::DataManager::GetGameReceiver () \n</code></pre> <p>Get a handle to the game receiver </p> <p>Returns:</p> <p>Const reference to the game receiver </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getitemusecollector","title":"function GetItemUseCollector","text":"<pre><code>inline ItemUseCollector &amp; DataCollection::DataManager::GetItemUseCollector () \n</code></pre> <p>Get a handle to the item use collector </p> <p>Returns:</p> <p>Reference to the item use collector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-writetojson","title":"function WriteToJson","text":"<pre><code>inline void DataCollection::DataManager::WriteToJson () \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-datamanager","title":"function ~DataManager","text":"<pre><code>DataCollection::DataManager::~DataManager () = default\n</code></pre> <p>Destructor </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_manager/#function-getinstance","title":"function GetInstance","text":"<pre><code>static inline DataManager &amp; DataCollection::DataManager::GetInstance () \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DataManager.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/","title":"Class DataCollection::DataReceiver","text":"<p>template &lt;typename T typename T&gt;</p> <p>ClassList &gt; DataCollection &gt; DataReceiver</p> <p>Generic data receiver template class. More...</p> <ul> <li><code>#include &lt;DataReceiver.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#public-functions","title":"Public Functions","text":"Type Name DataReceiver () = defaultDefault constructor for DataReceiver class. bool IsEmpty () Checks if the storage is empty. void StoreIntoStorage (T obj) Store a data object into the storage. std::vector&lt; T &gt; &amp; getStorage () Retrieves the stored data objects. virtual ~DataReceiver () = defaultVirtual destructor for DataReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; T &gt; storage Vector to store shared_ptr data objects of type T."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#detailed-description","title":"Detailed Description","text":"<p>This class provides a template for storing and retrieving data objects of a specified type. </p> <p>Template parameters:</p> <ul> <li><code>T</code> The type of data to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-datareceiver","title":"function DataReceiver","text":"<pre><code>DataCollection::DataReceiver::DataReceiver () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-isempty","title":"function IsEmpty","text":"<p>Checks if the storage is empty. </p> <pre><code>inline bool DataCollection::DataReceiver::IsEmpty () \n</code></pre> <p>Returns:</p> <p>True if the storage is empty, false otherwise. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-storeintostorage","title":"function StoreIntoStorage","text":"<p>Store a data object into the storage. </p> <pre><code>inline void DataCollection::DataReceiver::StoreIntoStorage (\n    T obj\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>obj</code> The data object to store </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-getstorage","title":"function getStorage","text":"<p>Retrieves the stored data objects. </p> <pre><code>inline std::vector&lt; T &gt; &amp; DataCollection::DataReceiver::getStorage () \n</code></pre> <p>Returns:</p> <p>Reference to the vector containing stored data objects. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#function-datareceiver_1","title":"function ~DataReceiver","text":"<pre><code>virtual DataCollection::DataReceiver::~DataReceiver () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_data_receiver/#variable-storage","title":"variable storage","text":"<pre><code>std::vector&lt;T&gt; storage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/DataReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/","title":"Class DataCollection::GameData","text":"<p>ClassList &gt; DataCollection &gt; GameData</p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#public-functions","title":"Public Functions","text":"Type Name GameData () = defaultDefault constructor for AgentData class. const std::vector&lt; int &gt; &amp; GetCollisions () constRetrieve the stored collisions data. const std::vector&lt; size_t &gt; &amp; GetShortestPathActions () constRetrieve the stored shortest path actions. const std::vector&lt; cse491::GridPosition &gt; GetShortestPathPos () constRetrieve the stored shortest path positions. void StoreCollision (int collision) Store collision data. void StoreShortestPathAction (size_t action) Store a shortest path action. void StoreShortestPathPos (const cse491::GridPosition pos) Store a shortest path position. int getNumOfCol () constGet the number of collisions. void setNumOfCol (int value) Set the number of collisions. ~GameData () = defaultDestructor for AgentData class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-gamedata","title":"function GameData","text":"<pre><code>DataCollection::GameData::GameData () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-getcollisions","title":"function GetCollisions","text":"<p>Retrieve the stored collisions data. </p> <pre><code>inline const std::vector&lt; int &gt; &amp; DataCollection::GameData::GetCollisions () const\n</code></pre> <p>Returns:</p> <p>A constant reference to the vector of collisions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-getshortestpathactions","title":"function GetShortestPathActions","text":"<p>Retrieve the stored shortest path actions. </p> <pre><code>inline const std::vector&lt; size_t &gt; &amp; DataCollection::GameData::GetShortestPathActions () const\n</code></pre> <p>Returns:</p> <p>A constant reference to the vector of shortest path actions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-getshortestpathpos","title":"function GetShortestPathPos","text":"<p>Retrieve the stored shortest path positions. </p> <pre><code>inline const std::vector&lt; cse491::GridPosition &gt; DataCollection::GameData::GetShortestPathPos () const\n</code></pre> <p>Returns:</p> <p>A constant reference to the vector of shortest path positions. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-storecollision","title":"function StoreCollision","text":"<p>Store collision data. </p> <pre><code>inline void DataCollection::GameData::StoreCollision (\n    int collision\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>collision</code> Collision data to store. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-storeshortestpathaction","title":"function StoreShortestPathAction","text":"<p>Store a shortest path action. </p> <pre><code>inline void DataCollection::GameData::StoreShortestPathAction (\n    size_t action\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>action</code> Shortest path action to store. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-storeshortestpathpos","title":"function StoreShortestPathPos","text":"<p>Store a shortest path position. </p> <pre><code>inline void DataCollection::GameData::StoreShortestPathPos (\n    const cse491::GridPosition pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>position</code> Shortest path position to store. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-getnumofcol","title":"function getNumOfCol","text":"<p>Get the number of collisions. </p> <pre><code>inline int DataCollection::GameData::getNumOfCol () const\n</code></pre> <p>Returns:</p> <p>Number of collisions. -----------These member functions are generated by Chatgpt </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-setnumofcol","title":"function setNumOfCol","text":"<p>Set the number of collisions. </p> <pre><code>inline void DataCollection::GameData::setNumOfCol (\n    int value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The value to set. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_data/#function-gamedata_1","title":"function ~GameData","text":"<pre><code>DataCollection::GameData::~GameData () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/GameData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/","title":"Class DataCollection::GameReceiver","text":"<p>ClassList &gt; DataCollection &gt; GameReceiver</p> <p>Represents a receiver specifically designed to handle game-related data. More...</p> <ul> <li><code>#include &lt;GameReceiver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: DataCollection::DataReceiver</p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#public-functions","title":"Public Functions","text":"Type Name GameReceiver () = defaultDefault constructor for the GameReceiver class. void store_GameData (const GameData &amp; gameData) Store a GameData object into the receiver's storage. ~GameReceiver () overrideDestructor for the GameReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#public-functions-inherited-from-datacollectiondatareceiver","title":"Public Functions inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name DataReceiver () = defaultDefault constructor for DataReceiver class. bool IsEmpty () Checks if the storage is empty. void StoreIntoStorage (T obj) Store a data object into the storage. std::vector&lt; T &gt; &amp; getStorage () Retrieves the stored data objects. virtual ~DataReceiver () = defaultVirtual destructor for DataReceiver class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#protected-attributes-inherited-from-datacollectiondatareceiver","title":"Protected Attributes inherited from DataCollection::DataReceiver","text":"<p>See DataCollection::DataReceiver</p> Type Name std::vector&lt; T &gt; storage Vector to store shared_ptr data objects of type T."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#detailed-description","title":"Detailed Description","text":"<p>GameReceiver is an extension of the generic DataReceiver, specialized to handle data related to games. It provides methods for storing and processing game-specific data types such as GameData. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#function-gamereceiver","title":"function GameReceiver","text":"<pre><code>DataCollection::GameReceiver::GameReceiver () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#function-store_gamedata","title":"function store_GameData","text":"<p>Store a GameData object into the receiver's storage.</p> <pre><code>inline void DataCollection::GameReceiver::store_GameData (\n    const GameData &amp; gameData\n) \n</code></pre> <p>This method allows for the addition of game-specific data into the receiver's storage for further processing or analysis.</p> <p>Parameters:</p> <ul> <li><code>gameData</code> The GameData object to be stored. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_game_receiver/#function-gamereceiver_1","title":"function ~GameReceiver","text":"<pre><code>DataCollection::GameReceiver::~GameReceiver () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/GameReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/","title":"Class DataCollection::ItemUseCollector","text":"<p>ClassList &gt; DataCollection &gt; ItemUseCollector</p> <p>A data collector class for usage amount of game items. More...</p> <ul> <li><code>#include &lt;ItemUseCollector.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#public-functions","title":"Public Functions","text":"Type Name std::string GetLeastFrequent ()  std::string GetMostFrequent ()  int GetNumberOfItems ()  const std::unordered_map&lt; std::string, int &gt; &amp; GetUsageData ()  void IncrementItemUsage (const std::string &amp; itemName)  ItemUseCollector () = defaultDamage storage map of item name to amount of uses. void WriteToItemUseFile (std::string path)"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#detailed-description","title":"Detailed Description","text":"<p>Useful for setting up graphs for analysis of item balancing. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-getleastfrequent","title":"function GetLeastFrequent","text":"<pre><code>inline std::string DataCollection::ItemUseCollector::GetLeastFrequent () \n</code></pre> <p>Get the least frequently used item in the game. </p> <p>Returns:</p> <p>Name of the least item as a string, empty string if no data </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-getmostfrequent","title":"function GetMostFrequent","text":"<pre><code>inline std::string DataCollection::ItemUseCollector::GetMostFrequent () \n</code></pre> <p>Get the most frequently used item in the game. </p> <p>Returns:</p> <p>Name of the most frequent item as a string, empty string if no data </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-getnumberofitems","title":"function GetNumberOfItems","text":"<pre><code>inline int DataCollection::ItemUseCollector::GetNumberOfItems () \n</code></pre> <p>Get the amount of unique items that are collected </p> <p>Returns:</p> <p>int amount of unique items </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-getusagedata","title":"function GetUsageData","text":"<pre><code>inline const std::unordered_map&lt; std::string, int &gt; &amp; DataCollection::ItemUseCollector::GetUsageData () \n</code></pre> <p>Getter for item usage data </p> <p>Returns:</p> <p>Const reference to the usage data storage. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-incrementitemusage","title":"function IncrementItemUsage","text":"<pre><code>inline void DataCollection::ItemUseCollector::IncrementItemUsage (\n    const std::string &amp; itemName\n) \n</code></pre> <p>Increment usage amount for a certain item. </p> <p>Parameters:</p> <ul> <li><code>itemName</code> Item name to record new usage of </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-itemusecollector","title":"function ItemUseCollector","text":"<p>Damage storage map of item name to amount of uses. </p> <pre><code>DataCollection::ItemUseCollector::ItemUseCollector () = default\n</code></pre> <p>Default constructor for ItemUseCollector </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_item_use_collector/#function-writetoitemusefile","title":"function WriteToItemUseFile","text":"<pre><code>inline void DataCollection::ItemUseCollector::WriteToItemUseFile (\n    std::string path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/ItemUseCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/","title":"Class DataCollection::JsonBuilder","text":"<p>ClassList &gt; DataCollection &gt; JsonBuilder</p> <p>Builds a JSON object from the data collected for an agent. </p> <ul> <li><code>#include &lt;JsonBuilder.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#public-functions","title":"Public Functions","text":"Type Name void AddDamage (double damage)  void AddInt (std::string title, int usage)  void AddName (std::string name) Adds the agent's name to the JSON object. void AddPosition (cse491::GridPosition pos) Adds a grid position to the JSON object. void Addagentname (std::string name)  void ClearJSON ()  nlohmann::json GetJSON () Retrieves the JSON object. nlohmann::json GetJSONArray ()  void InputToArray (std::string title, nlohmann::json input)  JsonBuilder () = defaultDefault constructor for JSONBuilder class. void StartArray (std::string title)  void WriteToFile (std::ofstream &amp; jsonfilestream, nlohmann::json Json) Writes the JSON object to a file. ~JsonBuilder () = defaultDestructor for JSONBuilder class."},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-adddamage","title":"function AddDamage","text":"<pre><code>inline void DataCollection::JsonBuilder::AddDamage (\n    double damage\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-addint","title":"function AddInt","text":"<pre><code>inline void DataCollection::JsonBuilder::AddInt (\n    std::string title,\n    int usage\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-addname","title":"function AddName","text":"<p>Adds the agent's name to the JSON object. </p> <pre><code>inline void DataCollection::JsonBuilder::AddName (\n    std::string name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> The agent's name. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-addposition","title":"function AddPosition","text":"<p>Adds a grid position to the JSON object. </p> <pre><code>inline void DataCollection::JsonBuilder::AddPosition (\n    cse491::GridPosition pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position to be added. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-addagentname","title":"function Addagentname","text":"<pre><code>inline void DataCollection::JsonBuilder::Addagentname (\n    std::string name\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-clearjson","title":"function ClearJSON","text":"<pre><code>inline void DataCollection::JsonBuilder::ClearJSON () \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-getjson","title":"function GetJSON","text":"<p>Retrieves the JSON object. </p> <pre><code>inline nlohmann::json DataCollection::JsonBuilder::GetJSON () \n</code></pre> <p>Returns:</p> <p>The JSON object. </p>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-getjsonarray","title":"function GetJSONArray","text":"<pre><code>inline nlohmann::json DataCollection::JsonBuilder::GetJSONArray () \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-inputtoarray","title":"function InputToArray","text":"<pre><code>inline void DataCollection::JsonBuilder::InputToArray (\n    std::string title,\n    nlohmann::json input\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-jsonbuilder","title":"function JsonBuilder","text":"<pre><code>DataCollection::JsonBuilder::JsonBuilder () = default\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-startarray","title":"function StartArray","text":"<pre><code>inline void DataCollection::JsonBuilder::StartArray (\n    std::string title\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-writetofile","title":"function WriteToFile","text":"<pre><code>inline void DataCollection::JsonBuilder::WriteToFile (\n    std::ofstream &amp; jsonfilestream,\n    nlohmann::json Json\n) \n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/class_data_collection_1_1_json_builder/#function-jsonbuilder_1","title":"function ~JsonBuilder","text":"<pre><code>DataCollection::JsonBuilder::~JsonBuilder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/DataCollection/JsonBuilder.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Data%20Collection%28Group%202%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir DataCollection <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Data%20Collection%28Group%202%29/dir_8adf75fe53ae17187785c216cf2633db/","title":"Dir source/DataCollection","text":"<p>FileList &gt; DataCollection</p>"},{"location":"Data%20Collection%28Group%202%29/dir_8adf75fe53ae17187785c216cf2633db/#files","title":"Files","text":"Type Name file AgentData.hpp file AgentInteractionCollector.hpp file AgentReciever.hpp file DamageCollector.hpp file DamageData.hpp file DamageReceiver.hpp file DataManager.hpp file DataReceiver.hpp file GameData.hpp file GameReceiver.hpp file ItemUseCollector.hpp file JsonBuilder.hpp <p>The documentation for this class was generated from the following file <code>source/DataCollection/</code></p>"},{"location":"Data%20Collection%28Group%202%29/_agent_data_8hpp/","title":"File AgentData.hpp","text":"<p>FileList &gt; DataCollection &gt; AgentData.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_agent_data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_agent_data_8hpp/#classes","title":"Classes","text":"Type Name class AgentData Represents data collected for an agent, including their name, actions, positions, and associated IDs. <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_agent_data_8hpp_source/","title":"File AgentData.hpp","text":"<p>File List &gt; DataCollection &gt; AgentData.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;string&gt;\n#include &lt;list&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include \"../core/GridPosition.hpp\"\n\nnamespace DataCollection\n{\n    class AgentData {\n    private:\n        std::string name;  \n        std::vector&lt;int&gt; actionIds;  \n        std::vector&lt;cse491::GridPosition&gt; position;  \n        std::vector&lt;std::unordered_map&lt;std::string,size_t&gt;&gt; actions;  \n\n    public:\n//        AgentData() = default;\n        AgentData(std::string name) : name(std::move(name)) {}\n\n        ~AgentData() = default;\n\n        void StorePositions(cse491::GridPosition pos) {\n            position.push_back(pos);\n        }\n\n        void StoreAction(std::unordered_map&lt;std::string, size_t&gt; action) {\n            actions.push_back(action);\n        }\n\n        void StoreAgentId(int id) {\n            actionIds.push_back(id);\n        }\n\n        auto&amp; GetActions() {\n            return actions;\n        }\n\n        int GetActionSize() const {\n            return actions.size();\n        }\n\n        void SetActions(const std::vector&lt;std::unordered_map&lt;std::string, size_t&gt;&gt;&amp; newActions) {\n            actions = newActions;\n        }\n\n        int GetPositionSize() const {\n            return position.size();\n        }\n\n        auto GetAgentIds() const {\n            return actionIds;\n        }\n\n        std::string GetName() const {\n            return name;\n        }\n\n        std::vector&lt;cse491::GridPosition&gt; GetPositions() const {\n            return position;\n        }\n    };\n} // namespace DataCollection\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_agent_interaction_collector_8hpp/","title":"File AgentInteractionCollector.hpp","text":"<p>FileList &gt; DataCollection &gt; AgentInteractionCollector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_agent_interaction_collector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_agent_interaction_collector_8hpp/#classes","title":"Classes","text":"Type Name class AgentInteractionCollector A data collector class to quantify agent interactions. <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentInteractionCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_agent_interaction_collector_8hpp_source/","title":"File AgentInteractionCollector.hpp","text":"<p>File List &gt; DataCollection &gt; AgentInteractionCollector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n    class AgentInteractionCollector {\n    private:\n        std::unordered_map&lt;std::string, int&gt; interactionData;  \n    public:\n        AgentInteractionCollector() = default;\n\n        const std::unordered_map&lt;std::string, int&gt;&amp; GetInteractionData() { return interactionData; }\n\n        size_t GetUniqueInteractions() { return interactionData.size(); }\n\n        void RecordInteraction(const std::string&amp; agentName) { interactionData[agentName]++; }\n\n        void WriteToInteractionFile(const std::string filename){\n            JsonBuilder json_builder;\n            std::ofstream jsonfilestream(filename);\n            json_builder.StartArray(\"agentInteractions\");\n            for (auto&amp; [agentName, interactionCount] : interactionData) {\n                json_builder.AddName(agentName);\n                json_builder.AddInt(\"interactionCount\", interactionCount);\n                json_builder.InputToArray(\"agentInteractions\", json_builder.GetJSON());\n                json_builder.ClearJSON();\n            }\n            json_builder.WriteToFile(jsonfilestream, json_builder.GetJSONArray());\n            jsonfilestream.close();\n        }\n\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_agent_reciever_8hpp/","title":"File AgentReciever.hpp","text":"<p>FileList &gt; DataCollection &gt; AgentReciever.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include \"DataReceiver.hpp\"</code></li> <li><code>#include \"AgentData.hpp\"</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_agent_reciever_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_agent_reciever_8hpp/#classes","title":"Classes","text":"Type Name class AgentReceiver Data receiver class specialized for storing AgentData objects. <p>The documentation for this class was generated from the following file <code>source/DataCollection/AgentReciever.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_agent_reciever_8hpp_source/","title":"File AgentReciever.hpp","text":"<p>File List &gt; DataCollection &gt; AgentReciever.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;filesystem&gt;\n#include \"DataReceiver.hpp\"\n#include \"AgentData.hpp\"\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n    class AgentReceiver : public DataReceiver&lt;AgentData&gt; {\n    private:\n        std::unordered_map&lt;std::string, std::shared_ptr&lt;AgentData&gt;&gt; agent_map;\n\n    public:\n        void StoreData(std::string name, cse491::GridPosition pos, [[maybe_unused]] int last_action) {\n            std::shared_ptr&lt;AgentData&gt; agent = GetAgent(name);\n            agent-&gt;StorePositions(pos);\n//            agent-&gt;StoreAction(last_action);\n            StoreIntoStorage(*agent);\n        }\n\n//        void StoreIntoStorage(AgentData obj) override {\n//            storage.push_back(obj);\n//        }\n\n        void AddAgent(const std::string&amp; name) {\n            AgentData agent(name);\n            agent_map[name] = std::make_shared&lt;AgentData&gt;(agent);\n\n        }\n\n        std::shared_ptr&lt;AgentData&gt; GetAgent(const std::string&amp; name)\n        {\n            if (agent_map.find(name)==agent_map.end()) {\n                AddAgent(name);\n                return agent_map[name];\n            }\n            else {\n                return agent_map[name];\n            }\n        }\n\n        AgentData GetAgentData(const std::string&amp; name) {\n            return *agent_map[name];\n        }\n\n        void WriteToPositionFile(std::string path) {\n            std::ofstream jsonfilestream(path);\n            JsonBuilder json_builder;\n            json_builder.StartArray(\"AgentPositions\");\n            for (auto&amp; agent : agent_map) {\n                json_builder.Addagentname(agent.first);\n                for (auto&amp; pos: agent.second-&gt;GetPositions()) {\n                    json_builder.AddPosition(pos);\n                }\n                json_builder.InputToArray(\"AgentPositions\", json_builder.GetJSON());\n                json_builder.ClearJSON();\n            }\n            json_builder.WriteToFile(jsonfilestream, json_builder.GetJSONArray());\n            jsonfilestream.close();\n        }\n    };\n} // namespace DataCollection\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_damage_collector_8hpp/","title":"File DamageCollector.hpp","text":"<p>FileList &gt; DataCollection &gt; DamageCollector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_damage_collector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_damage_collector_8hpp/#classes","title":"Classes","text":"Type Name class DamageCollector A data collector class for damage of game items. <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_damage_collector_8hpp_source/","title":"File DamageCollector.hpp","text":"<p>File List &gt; DataCollection &gt; DamageCollector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;fstream&gt;\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n     class DamageCollector {\n     private:\n         std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; damageData;  // Damage storage map of item name to damage amounts\n     public:\n         DamageCollector() = default;\n\n         void RecordDamageResult(const std::string&amp; itemName, double damageAmt) {\n             damageData[itemName].push_back(damageAmt);\n         }\n\n         std::vector&lt;double&gt;&amp; GetDamageAmounts(std::string itemName) {\n             if (damageData.contains(itemName)) {\n                 return damageData[itemName];\n             } else {\n                 // Created only once, subsequent calls will reference this\n                 static std::vector&lt;double&gt; empty;\n                 return empty;\n             }\n         }\n\n        double CalculateAverageDamage(const std::string&amp; itemName) {\n             if (damageData.contains(itemName)) {\n                 std::vector&lt;double&gt;&amp; damages = damageData[itemName];\n                 return std::accumulate(damages.begin(), damages.end(), 0.0) / damages.size();\n             }\n\n             return -1.0;\n         }\n\n         void WriteToDamageFile(std::string path) {\n             std::ofstream jsonfilestream(path);\n             JsonBuilder json_builder;\n             for (auto&amp; damage : damageData) {\n                 json_builder.AddName(damage.first);\n                 for (auto&amp; damageAmt : damage.second) {\n                     json_builder.AddDamage(damageAmt);\n                 }\n             }\n         }\n     };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_damage_data_8hpp/","title":"File DamageData.hpp","text":"<p>FileList &gt; DataCollection &gt; DamageData.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"../core/Entity.hpp\"</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_damage_data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_damage_data_8hpp/#classes","title":"Classes","text":"Type Name class DamageData Represents damage related data between an agent and other entities (agents, items, grids, etc) <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_damage_data_8hpp_source/","title":"File DamageData.hpp","text":"<p>File List &gt; DataCollection &gt; DamageData.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n#include \"../core/Entity.hpp\"\n#include \"../core/AgentBase.hpp\"\n\nnamespace DataCollection {\n\n    class DamageData {\n    private:\n        std::shared_ptr&lt;cse491::AgentBase&gt; agent;   \n        std::shared_ptr&lt;cse491::Entity&gt; source;     \n        int amount;                                 \n\n    public:\n        DamageData(std::shared_ptr&lt;cse491::AgentBase&gt; agnt,\n                   std::shared_ptr&lt;cse491::Entity&gt; src,\n                   int amt) : agent(std::move(agnt)), source(std::move(src)), amount(amt) {}\n\n        ~DamageData() = default;\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_damage_receiver_8hpp/","title":"File DamageReceiver.hpp","text":"<p>FileList &gt; DataCollection &gt; DamageReceiver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"DataReceiver.hpp\"</code></li> <li><code>#include \"DamageData.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_damage_receiver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_damage_receiver_8hpp/#classes","title":"Classes","text":"Type Name class DamageReceiver Data receiver class specialized for storing DamageData objects. <p>The documentation for this class was generated from the following file <code>source/DataCollection/DamageReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_damage_receiver_8hpp_source/","title":"File DamageReceiver.hpp","text":"<p>File List &gt; DataCollection &gt; DamageReceiver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include \"DataReceiver.hpp\"\n#include \"DamageData.hpp\"\n\nnamespace DataCollection {\n\n    class DamageReceiver : public DataReceiver&lt;DamageData&gt; {\n\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_data_manager_8hpp/","title":"File DataManager.hpp","text":"<p>FileList &gt; DataCollection &gt; DataManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AgentReciever.hpp\"</code></li> <li><code>#include \"GameReceiver.hpp\"</code></li> <li><code>#include \"DamageCollector.hpp\"</code></li> <li><code>#include \"ItemUseCollector.hpp\"</code></li> <li><code>#include \"AgentInteractionCollector.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_data_manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_data_manager_8hpp/#classes","title":"Classes","text":"Type Name class DataManager Represents a data control system to hold all related receivers and collectors. <p>The documentation for this class was generated from the following file <code>source/DataCollection/DataManager.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_data_manager_8hpp_source/","title":"File DataManager.hpp","text":"<p>File List &gt; DataCollection &gt; DataManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include \"AgentReciever.hpp\"\n#include \"GameReceiver.hpp\"\n#include \"DamageCollector.hpp\"\n#include \"ItemUseCollector.hpp\"\n#include \"AgentInteractionCollector.hpp\"\n\nnamespace DataCollection {\n\n    class DataManager {\n    private:\n        AgentReceiver agentReceiver;                            \n        GameReceiver gameReceiver;                              \n        DamageCollector damageCollector;                        \n        ItemUseCollector itemUseCollector;                      \n        AgentInteractionCollector agentInteractionCollector;    \n        DataManager() {}\n\n        DataManager(const DataManager&amp;) = delete;\n        DataManager&amp; operator=(const DataManager&amp;) = delete;\n    public:\n         ~DataManager() = default;\n\n         static DataManager&amp; GetInstance() {\n             static DataManager instance;\n             return instance;\n         }\n\n         AgentReceiver&amp; GetAgentReceiver() {\n             return agentReceiver;\n         }\n\n        AgentInteractionCollector&amp; GetAgentInteractionCollector() {\n            return agentInteractionCollector;\n        }\n\n         ItemUseCollector&amp; GetItemUseCollector() {\n             return itemUseCollector;\n         }\n\n        const GameReceiver&amp; GetGameReceiver() {\n            return gameReceiver;\n        }\n\n        const DamageCollector&amp; GetDamageCollector() {\n            return damageCollector;\n        }\n\n        void WriteToJson() {\n            std::filesystem::path currentPath = std::filesystem::current_path().parent_path().parent_path();\n            currentPath = currentPath / \"source\" / \"DataCollection\" / \"GRAPH\";\n            // Construct the full path to the data directory and the damage_data.json file\n            std::filesystem::path DamagefilePath = currentPath  / \"damage_data.json\";\n            std::filesystem::path ItemUsefilePath = currentPath  / \"itemUsage.json\";\n            std::filesystem::path ItemdamagefilePath = currentPath  / \"itemDamage.json\";\n            std::filesystem::path PositionfilePath = currentPath  / \"gridPositions.json\";\n            std::filesystem::path InteractionfilePath = currentPath  / \"agentInteractions.json\";\n            agentReceiver.WriteToPositionFile(PositionfilePath.string());\n            itemUseCollector.WriteToItemUseFile(ItemUsefilePath.string());\n            agentInteractionCollector.WriteToInteractionFile(InteractionfilePath.string());\n        }\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_data_receiver_8hpp/","title":"File DataReceiver.hpp","text":"<p>FileList &gt; DataCollection &gt; DataReceiver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_data_receiver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_data_receiver_8hpp/#classes","title":"Classes","text":"Type Name class DataReceiver &lt;typename T&gt;Generic data receiver template class. <p>The documentation for this class was generated from the following file <code>source/DataCollection/DataReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_data_receiver_8hpp_source/","title":"File DataReceiver.hpp","text":"<p>File List &gt; DataCollection &gt; DataReceiver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;vector&gt;\nnamespace DataCollection {\n\n    template &lt;typename T&gt;\n    class DataReceiver {\n    public:\n        DataReceiver() = default;\n\n        virtual ~DataReceiver() = default;\n\n        std::vector&lt;T&gt;&amp; getStorage() {\n            return storage;\n        }\n\n        void StoreIntoStorage(T obj){\n            storage.push_back(obj);\n        }\n\n        bool IsEmpty() {\n            return storage.empty();\n        }\n\n    protected:\n        std::vector&lt;T&gt; storage; \n    };\n} // namespace DataCollection\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_game_data_8hpp/","title":"File GameData.hpp","text":"<p>FileList &gt; DataCollection &gt; GameData.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_game_data_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_game_data_8hpp/#classes","title":"Classes","text":"Type Name class GameData <p>The documentation for this class was generated from the following file <code>source/DataCollection/GameData.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_game_data_8hpp_source/","title":"File GameData.hpp","text":"<p>File List &gt; DataCollection &gt; GameData.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;vector&gt;\n#include\"../core/GridPosition.hpp\"\nnamespace DataCollection{\n    class GameData{\n    private:\n        /* number of collisions */\n        int numOfCol;\n\n        std::vector&lt;int&gt;collisions;\n        std::vector&lt;size_t&gt;shortestPathAction; \n        std::vector&lt;cse491::GridPosition&gt;shortestPathPos;\n    public:\n        GameData() = default;\n\n        ~GameData() = default;\n\n        int getNumOfCol() const {\n            return numOfCol;\n        }\n\n        void setNumOfCol(int value) {\n            numOfCol = value;\n        }\n\n        void StoreCollision(int collision) {\n            collisions.push_back(collision);\n        }\n\n        const std::vector&lt;int&gt;&amp; GetCollisions() const {\n            return collisions;\n        }\n\n        void StoreShortestPathAction(size_t action) {\n            shortestPathAction.push_back(action);\n        }\n\n        const std::vector&lt;size_t&gt;&amp; GetShortestPathActions() const {\n            return shortestPathAction;\n        }\n\n        void StoreShortestPathPos(const cse491::GridPosition pos) {\n            shortestPathPos.push_back(pos);\n        }\n\n        const std::vector&lt;cse491::GridPosition&gt; GetShortestPathPos() const {\n            return shortestPathPos;\n        }\n    };\n    }\n\n\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_game_receiver_8hpp/","title":"File GameReceiver.hpp","text":"<p>FileList &gt; DataCollection &gt; GameReceiver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"GameData.hpp\"</code></li> <li><code>#include \"DataReceiver.hpp\"</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_game_receiver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_game_receiver_8hpp/#classes","title":"Classes","text":"Type Name class GameReceiver Represents a receiver specifically designed to handle game-related data. <p>The documentation for this class was generated from the following file <code>source/DataCollection/GameReceiver.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_game_receiver_8hpp_source/","title":"File GameReceiver.hpp","text":"<p>File List &gt; DataCollection &gt; GameReceiver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;iostream&gt;\n#include \"GameData.hpp\"\n#include \"DataReceiver.hpp\"\n#include \"../core/GridPosition.hpp\"\n#include &lt;unordered_map&gt;\n#include &lt;fstream&gt;\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n    class GameReceiver : public DataReceiver&lt;GameData&gt; {\n    public:\n        GameReceiver() = default;\n\n        ~GameReceiver() override = default;\n\n        void store_GameData(const GameData&amp; gameData) {\n            this-&gt;storage.push_back(gameData);\n        }\n    };\n\n}\n\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_item_use_collector_8hpp/","title":"File ItemUseCollector.hpp","text":"<p>FileList &gt; DataCollection &gt; ItemUseCollector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"JsonBuilder.hpp\"</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_item_use_collector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_item_use_collector_8hpp/#classes","title":"Classes","text":"Type Name class ItemUseCollector A data collector class for usage amount of game items. <p>The documentation for this class was generated from the following file <code>source/DataCollection/ItemUseCollector.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_item_use_collector_8hpp_source/","title":"File ItemUseCollector.hpp","text":"<p>File List &gt; DataCollection &gt; ItemUseCollector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include \"JsonBuilder.hpp\"\n\nnamespace DataCollection {\n\n    class ItemUseCollector {\n    private:\n        std::unordered_map&lt;std::string, int&gt; usageData;  \n    public:\n        ItemUseCollector() = default;\n\n        const std::unordered_map&lt;std::string, int&gt;&amp; GetUsageData() {\n            return usageData;\n        }\n\n        int GetNumberOfItems() {\n            return usageData.size();\n        }\n\n        void IncrementItemUsage(const std::string&amp; itemName) {\n            usageData[itemName]++;\n        }\n\n        std::string GetMostFrequent() {\n            if (!usageData.empty()) {\n                auto maxItr = std::max_element(usageData.begin(), usageData.end(),\n                        [](const auto&amp; firstItem, const auto&amp; secondItem) {\n                            return firstItem.second &lt; secondItem.second;\n                        }\n                );\n\n                return maxItr-&gt;first;\n            }\n\n            return \"\";\n        }\n\n        std::string GetLeastFrequent() {\n            if (!usageData.empty()) {\n                auto maxItr = std::min_element(usageData.begin(), usageData.end(),\n                        [](const auto&amp; firstItem, const auto&amp; secondItem) {\n                            return firstItem.second &lt; secondItem.second;\n                        }\n                );\n\n                return maxItr-&gt;first;\n            }\n\n            return \"\";\n        }\n\n        void WriteToItemUseFile(std::string path)\n        {\n            JsonBuilder json_builder;\n            std::ofstream jsonfilestream(path);\n            json_builder.StartArray(\"items\");\n            for (auto&amp; usage: usageData) {\n                json_builder.AddName(usage.first);\n                json_builder.AddInt(\"amountOfUses\", usage.second);\n                json_builder.InputToArray(\"items\", json_builder.GetJSON());\n                json_builder.ClearJSON();\n            }\n            json_builder.WriteToFile(jsonfilestream, json_builder.GetJSONArray());\n            jsonfilestream.close();\n        }\n    };\n}\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/_json_builder_8hpp/","title":"File JsonBuilder.hpp","text":"<p>FileList &gt; DataCollection &gt; JsonBuilder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"../core/GridPosition.hpp\"</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> </ul>"},{"location":"Data%20Collection%28Group%202%29/_json_builder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace DataCollection"},{"location":"Data%20Collection%28Group%202%29/_json_builder_8hpp/#classes","title":"Classes","text":"Type Name class JsonBuilder Builds a JSON object from the data collected for an agent. <p>The documentation for this class was generated from the following file <code>source/DataCollection/JsonBuilder.hpp</code></p>"},{"location":"Data%20Collection%28Group%202%29/_json_builder_8hpp_source/","title":"File JsonBuilder.hpp","text":"<p>File List &gt; DataCollection &gt; JsonBuilder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;fstream&gt;\n#include \"../core/GridPosition.hpp\"\n#include &lt;nlohmann/json.hpp&gt;\n\nnamespace DataCollection{\n    class JsonBuilder {\n    private:\n        nlohmann::json json;  \n        nlohmann::json json_array;\n    public:\n        JsonBuilder() = default;\n\n        ~JsonBuilder() = default;\n\n        void StartArray(std::string title) {\n            json_array[title] = nlohmann::json::array();\n        }\n\n        void InputToArray(std::string title, nlohmann::json input) {\n            json_array[title].push_back(input);\n        }\n\n        void AddName(std::string name) {\n            json[\"name\"] = name;\n        }\n\n        void Addagentname(std::string name) {\n            json[\"agentname\"] = name;\n        }\n\n        void AddPosition(cse491::GridPosition pos) {\n            json[\"positions\"].push_back({{\"x\", pos.GetX()}, {\"y\", pos.GetY()}});\n        }\n\n        void AddDamage(double damage) {\n            json[\"damage\"].push_back(damage);\n        }\n\n        nlohmann::json GetJSON() {\n            return json;\n        }\n\n        void ClearJSON() {\n            json.clear();\n        }\n\n        nlohmann::json GetJSONArray() {\n            return json_array;\n        }\n\n        void AddInt(std::string title, int usage) {\n            json[title] = usage;\n        }\n\n        void WriteToFile(std::ofstream &amp;jsonfilestream, nlohmann::json Json)\n        {\n            jsonfilestream &lt;&lt; Json.dump(4);\n        }\n    };\n} // namespace DataCollection\n\n</code></pre>"},{"location":"Data%20Collection%28Group%202%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace DataCollection </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/","title":"Class Index","text":""},{"location":"Data%20Collection%28Group%202%29/classes/#a","title":"a","text":"<ul> <li>AgentData (DataCollection)</li> <li>AgentInteractionCollector (DataCollection)</li> <li>AgentReceiver (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/#d","title":"d","text":"<ul> <li>DamageCollector (DataCollection)</li> <li>DamageData (DataCollection)</li> <li>DamageReceiver (DataCollection)</li> <li>DataManager (DataCollection)</li> <li>DataReceiver (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/#g","title":"g","text":"<ul> <li>GameData (DataCollection)</li> <li>GameReceiver (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/#i","title":"i","text":"<ul> <li>ItemUseCollector (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/classes/#j","title":"j","text":"<ul> <li>JsonBuilder (DataCollection)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class DataCollection::AgentData Represents data collected for an agent, including their name, actions, positions, and associated IDs. </li> <li>class DataCollection::AgentInteractionCollector A data collector class to quantify agent interactions. </li> <li>class DataCollection::DataReceiver Generic data receiver template class. </li> <li>class DataCollection::DamageCollector A data collector class for damage of game items. </li> <li>class DataCollection::DamageData Represents damage related data between an agent and other entities (agents, items, grids, etc) </li> <li>class DataCollection::DataManager Represents a data control system to hold all related receivers and collectors. </li> <li>class DataCollection::GameData </li> <li>class DataCollection::ItemUseCollector A data collector class for usage amount of game items. </li> <li>class DataCollection::JsonBuilder Builds a JSON object from the data collected for an agent. </li> </ul>"},{"location":"Data%20Collection%28Group%202%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Data%20Collection%28Group%202%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Data%20Collection%28Group%202%29/class_members/","title":"Class Members","text":""},{"location":"Data%20Collection%28Group%202%29/class_members/#a","title":"a","text":"<ul> <li>AgentData (DataCollection::AgentData)</li> <li>actionIds (DataCollection::AgentData)</li> <li>actions (DataCollection::AgentData)</li> <li>AgentInteractionCollector (DataCollection::AgentInteractionCollector)</li> <li>AddAgent (DataCollection::AgentReceiver)</li> <li>agent_map (DataCollection::AgentReceiver)</li> <li>agent (DataCollection::DamageData)</li> <li>amount (DataCollection::DamageData)</li> <li>agentInteractionCollector (DataCollection::DataManager)</li> <li>agentReceiver (DataCollection::DataManager)</li> <li>AddDamage (DataCollection::JsonBuilder)</li> <li>AddInt (DataCollection::JsonBuilder)</li> <li>AddName (DataCollection::JsonBuilder)</li> <li>AddPosition (DataCollection::JsonBuilder)</li> <li>Addagentname (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#c","title":"c","text":"<ul> <li>CalculateAverageDamage (DataCollection::DamageCollector)</li> <li>collisions (DataCollection::GameData)</li> <li>ClearJSON (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#d","title":"d","text":"<ul> <li>DamageCollector (DataCollection::DamageCollector)</li> <li>damageData (DataCollection::DamageCollector)</li> <li>DamageData (DataCollection::DamageData)</li> <li>DataManager (DataCollection::DataManager)</li> <li>damageCollector (DataCollection::DataManager)</li> <li>DataReceiver (DataCollection::DataReceiver)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#g","title":"g","text":"<ul> <li>GetActionSize (DataCollection::AgentData)</li> <li>GetActions (DataCollection::AgentData)</li> <li>GetAgentIds (DataCollection::AgentData)</li> <li>GetName (DataCollection::AgentData)</li> <li>GetPositionSize (DataCollection::AgentData)</li> <li>GetPositions (DataCollection::AgentData)</li> <li>GetInteractionData (DataCollection::AgentInteractionCollector)</li> <li>GetUniqueInteractions (DataCollection::AgentInteractionCollector)</li> <li>GetAgent (DataCollection::AgentReceiver)</li> <li>GetAgentData (DataCollection::AgentReceiver)</li> <li>GetDamageAmounts (DataCollection::DamageCollector)</li> <li>GetAgentInteractionCollector (DataCollection::DataManager)</li> <li>GetAgentReceiver (DataCollection::DataManager)</li> <li>GetDamageCollector (DataCollection::DataManager)</li> <li>GetGameReceiver (DataCollection::DataManager)</li> <li>GetInstance (DataCollection::DataManager)</li> <li>GetItemUseCollector (DataCollection::DataManager)</li> <li>gameReceiver (DataCollection::DataManager)</li> <li>getStorage (DataCollection::DataReceiver)</li> <li>GameData (DataCollection::GameData)</li> <li>GetCollisions (DataCollection::GameData)</li> <li>GetShortestPathActions (DataCollection::GameData)</li> <li>GetShortestPathPos (DataCollection::GameData)</li> <li>getNumOfCol (DataCollection::GameData)</li> <li>GameReceiver (DataCollection::GameReceiver)</li> <li>GetLeastFrequent (DataCollection::ItemUseCollector)</li> <li>GetMostFrequent (DataCollection::ItemUseCollector)</li> <li>GetNumberOfItems (DataCollection::ItemUseCollector)</li> <li>GetUsageData (DataCollection::ItemUseCollector)</li> <li>GetJSON (DataCollection::JsonBuilder)</li> <li>GetJSONArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#i","title":"i","text":"<ul> <li>interactionData (DataCollection::AgentInteractionCollector)</li> <li>itemUseCollector (DataCollection::DataManager)</li> <li>IsEmpty (DataCollection::DataReceiver)</li> <li>IncrementItemUsage (DataCollection::ItemUseCollector)</li> <li>ItemUseCollector (DataCollection::ItemUseCollector)</li> <li>InputToArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#j","title":"j","text":"<ul> <li>JsonBuilder (DataCollection::JsonBuilder)</li> <li>json (DataCollection::JsonBuilder)</li> <li>json_array (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#n","title":"n","text":"<ul> <li>name (DataCollection::AgentData)</li> <li>numOfCol (DataCollection::GameData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#o","title":"o","text":"<ul> <li>operator= (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#p","title":"p","text":"<ul> <li>position (DataCollection::AgentData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#r","title":"r","text":"<ul> <li>RecordInteraction (DataCollection::AgentInteractionCollector)</li> <li>RecordDamageResult (DataCollection::DamageCollector)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#s","title":"s","text":"<ul> <li>SetActions (DataCollection::AgentData)</li> <li>StoreAction (DataCollection::AgentData)</li> <li>StoreAgentId (DataCollection::AgentData)</li> <li>StorePositions (DataCollection::AgentData)</li> <li>StoreData (DataCollection::AgentReceiver)</li> <li>source (DataCollection::DamageData)</li> <li>StoreIntoStorage (DataCollection::DataReceiver)</li> <li>storage (DataCollection::DataReceiver)</li> <li>StoreCollision (DataCollection::GameData)</li> <li>StoreShortestPathAction (DataCollection::GameData)</li> <li>StoreShortestPathPos (DataCollection::GameData)</li> <li>setNumOfCol (DataCollection::GameData)</li> <li>shortestPathAction (DataCollection::GameData)</li> <li>shortestPathPos (DataCollection::GameData)</li> <li>store_GameData (DataCollection::GameReceiver)</li> <li>StartArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#u","title":"u","text":"<ul> <li>usageData (DataCollection::ItemUseCollector)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#w","title":"w","text":"<ul> <li>WriteToInteractionFile (DataCollection::AgentInteractionCollector)</li> <li>WriteToPositionFile (DataCollection::AgentReceiver)</li> <li>WriteToDamageFile (DataCollection::DamageCollector)</li> <li>WriteToJson (DataCollection::DataManager)</li> <li>WriteToItemUseFile (DataCollection::ItemUseCollector)</li> <li>WriteToFile (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_members/#_1","title":"~","text":"<ul> <li>~AgentData (DataCollection::AgentData)</li> <li>~DamageData (DataCollection::DamageData)</li> <li>~DataManager (DataCollection::DataManager)</li> <li>~DataReceiver (DataCollection::DataReceiver)</li> <li>~GameData (DataCollection::GameData)</li> <li>~GameReceiver (DataCollection::GameReceiver)</li> <li>~JsonBuilder (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#a","title":"a","text":"<ul> <li>AgentData (DataCollection::AgentData)</li> <li>AgentInteractionCollector (DataCollection::AgentInteractionCollector)</li> <li>AddAgent (DataCollection::AgentReceiver)</li> <li>AddDamage (DataCollection::JsonBuilder)</li> <li>AddInt (DataCollection::JsonBuilder)</li> <li>AddName (DataCollection::JsonBuilder)</li> <li>AddPosition (DataCollection::JsonBuilder)</li> <li>Addagentname (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#c","title":"c","text":"<ul> <li>CalculateAverageDamage (DataCollection::DamageCollector)</li> <li>ClearJSON (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#d","title":"d","text":"<ul> <li>DamageCollector (DataCollection::DamageCollector)</li> <li>DamageData (DataCollection::DamageData)</li> <li>DataManager (DataCollection::DataManager)</li> <li>DataReceiver (DataCollection::DataReceiver)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#g","title":"g","text":"<ul> <li>GetActionSize (DataCollection::AgentData)</li> <li>GetActions (DataCollection::AgentData)</li> <li>GetAgentIds (DataCollection::AgentData)</li> <li>GetName (DataCollection::AgentData)</li> <li>GetPositionSize (DataCollection::AgentData)</li> <li>GetPositions (DataCollection::AgentData)</li> <li>GetInteractionData (DataCollection::AgentInteractionCollector)</li> <li>GetUniqueInteractions (DataCollection::AgentInteractionCollector)</li> <li>GetAgent (DataCollection::AgentReceiver)</li> <li>GetAgentData (DataCollection::AgentReceiver)</li> <li>GetDamageAmounts (DataCollection::DamageCollector)</li> <li>GetAgentInteractionCollector (DataCollection::DataManager)</li> <li>GetAgentReceiver (DataCollection::DataManager)</li> <li>GetDamageCollector (DataCollection::DataManager)</li> <li>GetGameReceiver (DataCollection::DataManager)</li> <li>GetInstance (DataCollection::DataManager)</li> <li>GetItemUseCollector (DataCollection::DataManager)</li> <li>getStorage (DataCollection::DataReceiver)</li> <li>GameData (DataCollection::GameData)</li> <li>GetCollisions (DataCollection::GameData)</li> <li>GetShortestPathActions (DataCollection::GameData)</li> <li>GetShortestPathPos (DataCollection::GameData)</li> <li>getNumOfCol (DataCollection::GameData)</li> <li>GameReceiver (DataCollection::GameReceiver)</li> <li>GetLeastFrequent (DataCollection::ItemUseCollector)</li> <li>GetMostFrequent (DataCollection::ItemUseCollector)</li> <li>GetNumberOfItems (DataCollection::ItemUseCollector)</li> <li>GetUsageData (DataCollection::ItemUseCollector)</li> <li>GetJSON (DataCollection::JsonBuilder)</li> <li>GetJSONArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#i","title":"i","text":"<ul> <li>IsEmpty (DataCollection::DataReceiver)</li> <li>IncrementItemUsage (DataCollection::ItemUseCollector)</li> <li>ItemUseCollector (DataCollection::ItemUseCollector)</li> <li>InputToArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#j","title":"j","text":"<ul> <li>JsonBuilder (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#r","title":"r","text":"<ul> <li>RecordInteraction (DataCollection::AgentInteractionCollector)</li> <li>RecordDamageResult (DataCollection::DamageCollector)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#s","title":"s","text":"<ul> <li>SetActions (DataCollection::AgentData)</li> <li>StoreAction (DataCollection::AgentData)</li> <li>StoreAgentId (DataCollection::AgentData)</li> <li>StorePositions (DataCollection::AgentData)</li> <li>StoreData (DataCollection::AgentReceiver)</li> <li>StoreIntoStorage (DataCollection::DataReceiver)</li> <li>StoreCollision (DataCollection::GameData)</li> <li>StoreShortestPathAction (DataCollection::GameData)</li> <li>StoreShortestPathPos (DataCollection::GameData)</li> <li>setNumOfCol (DataCollection::GameData)</li> <li>store_GameData (DataCollection::GameReceiver)</li> <li>StartArray (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#w","title":"w","text":"<ul> <li>WriteToInteractionFile (DataCollection::AgentInteractionCollector)</li> <li>WriteToPositionFile (DataCollection::AgentReceiver)</li> <li>WriteToDamageFile (DataCollection::DamageCollector)</li> <li>WriteToJson (DataCollection::DataManager)</li> <li>WriteToItemUseFile (DataCollection::ItemUseCollector)</li> <li>WriteToFile (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~AgentData (DataCollection::AgentData)</li> <li>~DamageData (DataCollection::DamageData)</li> <li>~DataManager (DataCollection::DataManager)</li> <li>~DataReceiver (DataCollection::DataReceiver)</li> <li>~GameData (DataCollection::GameData)</li> <li>~GameReceiver (DataCollection::GameReceiver)</li> <li>~JsonBuilder (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#a","title":"a","text":"<ul> <li>actionIds (DataCollection::AgentData)</li> <li>actions (DataCollection::AgentData)</li> <li>agent_map (DataCollection::AgentReceiver)</li> <li>agent (DataCollection::DamageData)</li> <li>amount (DataCollection::DamageData)</li> <li>agentInteractionCollector (DataCollection::DataManager)</li> <li>agentReceiver (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#c","title":"c","text":"<ul> <li>collisions (DataCollection::GameData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#d","title":"d","text":"<ul> <li>damageData (DataCollection::DamageCollector)</li> <li>damageCollector (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#g","title":"g","text":"<ul> <li>gameReceiver (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#i","title":"i","text":"<ul> <li>interactionData (DataCollection::AgentInteractionCollector)</li> <li>itemUseCollector (DataCollection::DataManager)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#j","title":"j","text":"<ul> <li>json (DataCollection::JsonBuilder)</li> <li>json_array (DataCollection::JsonBuilder)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#n","title":"n","text":"<ul> <li>name (DataCollection::AgentData)</li> <li>numOfCol (DataCollection::GameData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#p","title":"p","text":"<ul> <li>position (DataCollection::AgentData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#s","title":"s","text":"<ul> <li>source (DataCollection::DamageData)</li> <li>storage (DataCollection::DataReceiver)</li> <li>shortestPathAction (DataCollection::GameData)</li> <li>shortestPathPos (DataCollection::GameData)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_variables/#u","title":"u","text":"<ul> <li>usageData (DataCollection::ItemUseCollector)</li> </ul>"},{"location":"Data%20Collection%28Group%202%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Data%20Collection%28Group%202%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Data%20Collection%28Group%202%29/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Data%20Collection%28Group%202%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Data%20Collection%28Group%202%29/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Data%20Collection%28Group%202%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Data%20Collection%28Group%202%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cse491 A low-end text interface providing a bare-minimum level of interaction. <ul> <li>class TrashInterface </li> </ul> </li> <li>namespace i_2D <ul> <li>class Button </li> <li>class Inventory </li> <li>class MainInterface Represents the main interface for a 2D maze game. </li> <li>class Menu </li> <li>class MessageBoard </li> <li>class TextBox </li> <li>class TextureHolder </li> </ul> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Interfaces <ul> <li>file Button.cpp </li> <li>file Button.hpp </li> <li>file Inventory.cpp </li> <li>file Inventory.hpp </li> <li>file MainInterface.cpp MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. </li> <li>file MainInterface.hpp MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. </li> <li>file Menu.cpp </li> <li>file Menu.hpp </li> <li>file MessageBoard.cpp </li> <li>file MessageBoard.hpp </li> <li>file TextBox.cpp </li> <li>file TextBox.hpp </li> <li>file TextureHolder.cpp </li> <li>file TextureHolder.hpp </li> <li>file TrashInterface.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>A low-end text interface providing a bare-minimum level of interaction. More...</p>"},{"location":"2D%20Interface%28Group%203%29/namespacecse491/#classes","title":"Classes","text":"Type Name class TrashInterface"},{"location":"2D%20Interface%28Group%203%29/namespacecse491/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TrashInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/","title":"Class cse491::TrashInterface","text":"<p>ClassList &gt; cse491 &gt; TrashInterface</p> <p>Inherits the following classes: InterfaceBase</p>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#public-functions","title":"Public Functions","text":"Type Name bool Initialize () override void Notify (const std::string &amp; message, const std::string &amp;=\"none\") override size_t SelectAction (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) override TrashInterface (size_t id, const std::string &amp; name)  ~TrashInterface () = default"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#protected-attributes","title":"Protected Attributes","text":"Type Name bool wait_for_input   = = trueShould we pause and wait for the user to hit a key?"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#protected-functions","title":"Protected Functions","text":"Type Name void DrawGrid (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map)"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-initialize","title":"function Initialize","text":"<pre><code>inline bool cse491::TrashInterface::Initialize () override\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-notify","title":"function Notify","text":"<pre><code>inline void cse491::TrashInterface::Notify (\n    const std::string &amp; message,\n    const std::string &amp;=\"none\"\n) override\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cse491::TrashInterface::SelectAction (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) override\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-trashinterface","title":"function TrashInterface","text":"<pre><code>inline cse491::TrashInterface::TrashInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-trashinterface_1","title":"function ~TrashInterface","text":"<pre><code>cse491::TrashInterface::~TrashInterface () = default\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#variable-wait_for_input","title":"variable wait_for_input","text":"<pre><code>bool wait_for_input;\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classcse491_1_1_trash_interface/#function-drawgrid","title":"function DrawGrid","text":"<pre><code>inline void cse491::TrashInterface::DrawGrid (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TrashInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/","title":"Namespace i_2D","text":"<p>Namespace List &gt; i_2D</p> <p>More...</p>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#classes","title":"Classes","text":"Type Name class Button class Inventory class MainInterface Represents the main interface for a 2D maze game. class Menu class MessageBoard class TextBox class TextureHolder"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#public-attributes","title":"Public Attributes","text":"Type Name const int MAX_NUMBER_OF_ITEMS_MENU_ITEMS   = = 3 float elapsedTime   = = 0.0f sf::Clock timer"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>: Team - 3 </p> <p>Date:</p> <p>: 11/02/2023 Button class creates a SF::Rectangle and SF::Text on top</p> <p>Author:</p> <p>: Team - 3 </p> <p>Date:</p> <p>: 11/15/2023 Inventory class creates an array of buttons and uses it as inventory</p> <p>Author:</p> <p>: Team - 3 </p> <p>Date:</p> <p>: 10/3/2023 Menu class creates a menu and displays it in the render window </p>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#variable-max_number_of_items_menu_items","title":"variable MAX_NUMBER_OF_ITEMS_MENU_ITEMS","text":"<pre><code>const int MAX_NUMBER_OF_ITEMS_MENU_ITEMS;\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#variable-elapsedtime","title":"variable elapsedTime","text":"<pre><code>float elapsedTime;\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/namespacei__2_d/#variable-timer","title":"variable timer","text":"<pre><code>sf::Clock timer;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Button.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/","title":"Class i_2D::Button","text":"<p>ClassList &gt; i_2D &gt; Button</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#public-functions","title":"Public Functions","text":"Type Name Button (const std::string &amp; t, sf::Vector2f size, sf::Color bgColor, sf::Color textColor, const sf::Font &amp; font) Construct the text with font. Then set text and shape properties with params. void DrawTo (sf::RenderWindow &amp; window) draws the button onto the window bool IsMouseOver (sf::RenderWindow &amp; window) checks if mouse position is in a button void SetBackColor (sf::Color color) set the background color of the button void SetButtonSize (sf::Vector2f size) set the button size void SetFont (const sf::Font &amp; font) set the font of the button void SetMFont (const sf::Font &amp; font) set the font of the button void SetPosition (sf::Vector2f pos) set the position of the button void SetString (const std::string &amp; s) set the string of the button void SetTextColor (sf::Color color) set the text color of the string"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-button","title":"function Button","text":"<p>Construct the text with font. Then set text and shape properties with params. </p> <pre><code>i_2D::Button::Button (\n    const std::string &amp; t,\n    sf::Vector2f size,\n    sf::Color bgColor,\n    sf::Color textColor,\n    const sf::Font &amp; font\n) \n</code></pre> <p>Constructs the button</p> <p>Parameters:</p> <ul> <li><code>t</code> the string to be displayed by button </li> <li><code>size</code> the size of the rectangle shape </li> <li><code>bgColor</code> the background color of the shape </li> <li><code>textColor</code> the color of the text </li> <li><code>font</code> the font style </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-drawto","title":"function DrawTo","text":"<p>draws the button onto the window </p> <pre><code>inline void i_2D::Button::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-ismouseover","title":"function IsMouseOver","text":"<p>checks if mouse position is in a button </p> <pre><code>bool i_2D::Button::IsMouseOver (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> </li> </ul> <p>Returns:</p> <p>returns turn if mouse position is in the button </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setbackcolor","title":"function SetBackColor","text":"<p>set the background color of the button </p> <pre><code>inline void i_2D::Button::SetBackColor (\n    sf::Color color\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>color</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setbuttonsize","title":"function SetButtonSize","text":"<p>set the button size </p> <pre><code>inline void i_2D::Button::SetButtonSize (\n    sf::Vector2f size\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setfont","title":"function SetFont","text":"<p>set the font of the button </p> <pre><code>inline void i_2D::Button::SetFont (\n    const sf::Font &amp; font\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setmfont","title":"function SetMFont","text":"<pre><code>void i_2D::Button::SetMFont (\n    const sf::Font &amp; font\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setposition","title":"function SetPosition","text":"<p>set the position of the button </p> <pre><code>void i_2D::Button::SetPosition (\n    sf::Vector2f pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> position on the window </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-setstring","title":"function SetString","text":"<p>set the string of the button </p> <pre><code>inline void i_2D::Button::SetString (\n    const std::string &amp; s\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> label of the button </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_button/#function-settextcolor","title":"function SetTextColor","text":"<p>set the text color of the string </p> <pre><code>inline void i_2D::Button::SetTextColor (\n    sf::Color color\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>color</code> </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Button.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/","title":"Class i_2D::Inventory","text":"<p>ClassList &gt; i_2D &gt; Inventory</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#public-functions","title":"Public Functions","text":"Type Name void ConstructInventory (sf::Font &amp; font, const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory) Build an inventory window and an inventory list. void DrawTo (sf::RenderWindow &amp; window) Draws the inventory onto the render window. std::string HandleMouseMove (sf::RenderWindow &amp; window) Handle the mouse move event. Inventory (const sf::Vector2f size) Constructor - save the value of the world's dimension. void SetItemDisplay (sf::Texture &amp; texture) Set the Displayed item's texture. void SetSize (const sf::Vector2f size) Set the value saved as the world's dimension."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-constructinventory","title":"function ConstructInventory","text":"<p>Build an inventory window and an inventory list. </p> <pre><code>void i_2D::Inventory::ConstructInventory (\n    sf::Font &amp; font,\n    const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> The font used by the inventory list </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-drawto","title":"function DrawTo","text":"<p>Draws the inventory onto the render window. </p> <pre><code>void i_2D::Inventory::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> The render window of the world </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-handlemousemove","title":"function HandleMouseMove","text":"<p>Handle the mouse move event. </p> <pre><code>std::string i_2D::Inventory::HandleMouseMove (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> The render window of the world </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-inventory","title":"function Inventory","text":"<pre><code>inline explicit i_2D::Inventory::Inventory (\n    const sf::Vector2f size\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-setitemdisplay","title":"function SetItemDisplay","text":"<pre><code>inline void i_2D::Inventory::SetItemDisplay (\n    sf::Texture &amp; texture\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_inventory/#function-setsize","title":"function SetSize","text":"<pre><code>inline void i_2D::Inventory::SetSize (\n    const sf::Vector2f size\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Inventory.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/","title":"Class i_2D::MainInterface","text":"<p>ClassList &gt; i_2D &gt; MainInterface</p> <p>Represents the main interface for a 2D maze game. More...</p> <ul> <li><code>#include &lt;MainInterface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: InterfaceBase</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#public-functions","title":"Public Functions","text":"Type Name void CheckLargerGrid ()  std::vector&lt; std::string &gt; CreateVectorMaze (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) Creates a vector representation of the maze grid. void DrawGrid (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) Draws the maze grid and entities on the SFML window. bool Initialize () overrideInitializes the main interface. MainInterface (size_t id, const std::string &amp; name) Constructs a <code>MainInterface</code> object. void Notify (const std::string &amp; message, const std::string &amp;=\"none\") overridenotifies the world if the player have any progress message size_t SelectAction (const WorldGrid &amp; grid, const type_options_t &amp; type_options, const item_map_t &amp; item_map, const agent_map_t &amp; agent_map) overrideHandles user input for selecting actions. void SetLargeGrid (bool b)  void setMInputWaitTime (double mInputWaitTime)  ~MainInterface () = defaultDestructor for the <code>MainInterface</code> class."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#detailed-description","title":"Detailed Description","text":"<p>This class inherits from <code>InterfaceBase</code> and provides functionality for creating and displaying a 2D maze game world, handling user input, and updating the graphical representation of the game. </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-checklargergrid","title":"function CheckLargerGrid","text":"<pre><code>void i_2D::MainInterface::CheckLargerGrid () \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-createvectormaze","title":"function CreateVectorMaze","text":"<p>Creates a vector representation of the maze grid. </p> <pre><code>std::vector&lt; std::string &gt; i_2D::MainInterface::CreateVectorMaze (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The WorldGrid representing the maze. </li> <li><code>type_options</code> The type options for symbols. </li> <li><code>item_map</code> The map of ids to items in the maze. </li> <li><code>agent_map</code> The map of ids to agents in the maze.</li> </ul> <p>Returns:</p> <p>A vector of strings representing the maze grid. </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-drawgrid","title":"function DrawGrid","text":"<p>Draws the maze grid and entities on the SFML window. </p> <pre><code>void i_2D::MainInterface::DrawGrid (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The WorldGrid representing the maze. </li> <li><code>type_options</code> The type options for symbols. </li> <li><code>item_map</code> The map of ids to items in the maze. </li> <li><code>agent_map</code> The map of ids to agents in t </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-initialize","title":"function Initialize","text":"<p>Initializes the main interface. </p> <pre><code>inline bool i_2D::MainInterface::Initialize () override\n</code></pre> <p>Returns:</p> <p>True if initialization is successful; otherwise, false. </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-maininterface","title":"function MainInterface","text":"<p>Constructs a <code>MainInterface</code> object.</p> <pre><code>i_2D::MainInterface::MainInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> The identifier for this interface. </li> <li><code>name</code> The name of this interface. </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-notify","title":"function Notify","text":"<p>notifies the world if the player have any progress message </p> <pre><code>inline void i_2D::MainInterface::Notify (\n    const std::string &amp; message,\n    const std::string &amp;=\"none\"\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>message</code> that notifies the world </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-selectaction","title":"function SelectAction","text":"<p>Handles user input for selecting actions. </p> <pre><code>size_t i_2D::MainInterface::SelectAction (\n    const WorldGrid &amp; grid,\n    const type_options_t &amp; type_options,\n    const item_map_t &amp; item_map,\n    const agent_map_t &amp; agent_map\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The WorldGrid representing the maze. </li> <li><code>type_options</code> The type options for symbols. </li> <li><code>item_map</code> The map of ids to items in the maze. </li> <li><code>agent_map</code> The map of ids to agents in the maze. </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-setlargegrid","title":"function SetLargeGrid","text":"<pre><code>inline void i_2D::MainInterface::SetLargeGrid (\n    bool b\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-setminputwaittime","title":"function setMInputWaitTime","text":"<pre><code>void i_2D::MainInterface::setMInputWaitTime (\n    double mInputWaitTime\n) \n</code></pre> <p>Sets the inputwait time for netwrok interface</p> <p>Parameters:</p> <ul> <li><code>waitTime</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_main_interface/#function-maininterface_1","title":"function ~MainInterface","text":"<pre><code>i_2D::MainInterface::~MainInterface () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MainInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/","title":"Class i_2D::Menu","text":"<p>ClassList &gt; i_2D &gt; Menu</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#public-functions","title":"Public Functions","text":"Type Name void ConstructInventory (const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory) Builds an inventory. void DeconstructInventory () Destroy the inventory object. void DrawTo (sf::RenderWindow &amp; window) draws each menu button to the window std::vector&lt; std::unique_ptr&lt; Button &gt; &gt; &amp; GetMenu () Getter for MenuBar. void HandleMouseButtonPressed (sf::RenderWindow &amp; window, const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory) check if the mouse click the exit button closes window accordingly std::string HandleMouseMove (sf::RenderWindow &amp; window) check for mouse hoovering over the menu buttons change button color accordingly void Initialize (sf::Font &amp; font, sf::Vector2f size) initialize the buttons at the top of the window bool IsInventoryOpen () Check if the inventory interface is open. void SetInventoryItemDisplay (sf::Texture &amp; texture)  void SetWorldSize (sf::Vector2f size) Keep track of the world's size."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-constructinventory","title":"function ConstructInventory","text":"<pre><code>inline void i_2D::Menu::ConstructInventory (\n    const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-deconstructinventory","title":"function DeconstructInventory","text":"<pre><code>inline void i_2D::Menu::DeconstructInventory () \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-drawto","title":"function DrawTo","text":"<p>draws each menu button to the window </p> <pre><code>void i_2D::Menu::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> the main window of the graphic interface </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-getmenu","title":"function GetMenu","text":"<p>Getter for MenuBar. </p> <pre><code>inline std::vector&lt; std::unique_ptr&lt; Button &gt; &gt; &amp; i_2D::Menu::GetMenu () \n</code></pre> <p>Returns:</p> <p>MenuBar </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-handlemousebuttonpressed","title":"function HandleMouseButtonPressed","text":"<p>check if the mouse click the exit button closes window accordingly </p> <pre><code>void i_2D::Menu::HandleMouseButtonPressed (\n    sf::RenderWindow &amp; window,\n    const std::vector&lt; std::string &gt; &amp; interfaceAgentInventory\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> the main window of the graphic interface </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-handlemousemove","title":"function HandleMouseMove","text":"<p>check for mouse hoovering over the menu buttons change button color accordingly </p> <pre><code>std::string i_2D::Menu::HandleMouseMove (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> the main window of the graphic interface </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-initialize","title":"function Initialize","text":"<pre><code>void i_2D::Menu::Initialize (\n    sf::Font &amp; font,\n    sf::Vector2f size\n) \n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-isinventoryopen","title":"function IsInventoryOpen","text":"<p>Check if the inventory interface is open. </p> <pre><code>inline bool i_2D::Menu::IsInventoryOpen () \n</code></pre> <p>Returns:</p> <p>True if inventory interface is on, otherwise false </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-setinventoryitemdisplay","title":"function SetInventoryItemDisplay","text":"<pre><code>inline void i_2D::Menu::SetInventoryItemDisplay (\n    sf::Texture &amp; texture\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>texture</code> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_menu/#function-setworldsize","title":"function SetWorldSize","text":"<p>Keep track of the world's size. </p> <pre><code>inline void i_2D::Menu::SetWorldSize (\n    sf::Vector2f size\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>size</code> Size of the world </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Menu.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/","title":"Class i_2D::MessageBoard","text":"<p>ClassList &gt; i_2D &gt; MessageBoard</p> <p>More...</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#public-functions","title":"Public Functions","text":"Type Name void DrawTo (sf::RenderWindow &amp; window) Draws the message board onto the render window. MessageBoard (sf::Font &amp; font) Construct the message board. void Send (const std::string &amp; message) Set the text of the message board."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#detailed-description","title":"Detailed Description","text":"<p>is where the backend and users communicate by words </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#function-drawto","title":"function DrawTo","text":"<p>Draws the message board onto the render window. </p> <pre><code>void i_2D::MessageBoard::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> The render window to be drawn on </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#function-messageboard","title":"function MessageBoard","text":"<p>Construct the message board. </p> <pre><code>explicit i_2D::MessageBoard::MessageBoard (\n    sf::Font &amp; font\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> The font used by message borad </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_message_board/#function-send","title":"function Send","text":"<p>Set the text of the message board. </p> <pre><code>inline void i_2D::MessageBoard::Send (\n    const std::string &amp; message\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>message</code> The message to set the text to </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MessageBoard.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/","title":"Class i_2D::TextBox","text":"<p>ClassList &gt; i_2D &gt; TextBox</p> <p>More...</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#public-functions","title":"Public Functions","text":"Type Name bool Contains (sf::Vector2f point) constChecks if a point is within the TextBox . void DrawTo (sf::RenderWindow &amp; window) Draws the text to the render window. std::string GetText () Get the string that was input by user. bool IsSelected () constChecks if TextBox is active. void SetFont (const sf::Font &amp; font) Set the font of the TextBox . void SetLimit (bool ToF) Set the limit of the TextBox . void SetLimit (bool ToF, int lim) Set the limit of the TextBox . void SetPosition (sf::Vector2f pos) The position of the TextBox . void SetSelected (bool sel) Setter for isSelected, updates the text displayed in the box. void SetString (const std::string &amp; s) Set the string of the text. TextBox () = default TextBox (const sf::Font &amp; font, int size=25, sf::Color color=sf::Color::Red, bool sel=false) Constructor. void TypedOn (sf::Event input) TypedOn event handler."},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#detailed-description","title":"Detailed Description","text":"<p>is where users write to interface and the world </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-contains","title":"function Contains","text":"<p>Checks if a point is within the TextBox .</p> <pre><code>inline bool i_2D::TextBox::Contains (\n    sf::Vector2f point\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>point</code> an xy point to check the location of </li> </ul> <p>Returns:</p> <p>True if the point is in bounds, False otherwise </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-drawto","title":"function DrawTo","text":"<p>Draws the text to the render window. </p> <pre><code>void i_2D::TextBox::DrawTo (\n    sf::RenderWindow &amp; window\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>window</code> The render window to be drawn on </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-gettext","title":"function GetText","text":"<p>Get the string that was input by user. </p> <pre><code>inline std::string i_2D::TextBox::GetText () \n</code></pre> <p>Returns:</p> <p>Return the string </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-isselected","title":"function IsSelected","text":"<p>Checks if TextBox is active.</p> <pre><code>inline bool i_2D::TextBox::IsSelected () const\n</code></pre> <p>Returns:</p> <p>True if active, else False </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setfont","title":"function SetFont","text":"<p>Set the font of the TextBox .</p> <pre><code>inline void i_2D::TextBox::SetFont (\n    const sf::Font &amp; font\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> The font to be set to </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setlimit-12","title":"function SetLimit [1/2]","text":"<p>Set the limit of the TextBox .</p> <pre><code>inline void i_2D::TextBox::SetLimit (\n    bool ToF\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ToF</code> True of False </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setlimit-22","title":"function SetLimit [2/2]","text":"<p>Set the limit of the TextBox .</p> <pre><code>inline void i_2D::TextBox::SetLimit (\n    bool ToF,\n    int lim\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ToF</code> True or False </li> <li><code>lim</code> The limit of the TextBox </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setposition","title":"function SetPosition","text":"<p>The position of the TextBox .</p> <pre><code>inline void i_2D::TextBox::SetPosition (\n    sf::Vector2f pos\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The position to be set to </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setselected","title":"function SetSelected","text":"<p>Setter for isSelected, updates the text displayed in the box. </p> <pre><code>void i_2D::TextBox::SetSelected (\n    bool sel\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>sel</code> whether the TextBox is to be set selected or not </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-setstring","title":"function SetString","text":"<p>Set the string of the text. </p> <pre><code>void i_2D::TextBox::SetString (\n    const std::string &amp; s\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>s</code> The string to be set to </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-textbox-12","title":"function TextBox [1/2]","text":"<pre><code>i_2D::TextBox::TextBox () = default\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-textbox-22","title":"function TextBox [2/2]","text":"<p>Constructor. </p> <pre><code>explicit i_2D::TextBox::TextBox (\n    const sf::Font &amp; font,\n    int size=25,\n    sf::Color color=sf::Color::Red,\n    bool sel=false\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>font</code> The font used by TextBox </li> <li><code>size</code> The size of the text </li> <li><code>color</code> The color of the text </li> <li><code>sel</code> Set the activity of TextBox </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_text_box/#function-typedon","title":"function TypedOn","text":"<p>TypedOn event handler. </p> <pre><code>void i_2D::TextBox::TypedOn (\n    sf::Event input\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>input</code> the new text that has been typed into the TextBox </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextBox.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/","title":"Class i_2D::TextureHolder","text":"<p>ClassList &gt; i_2D &gt; TextureHolder</p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#public-functions","title":"Public Functions","text":"Type Name std::map&lt; char, sf::Texture &gt; GenerativeWorldTexture () This function loads texture for the generative world images group 6. const sf::Texture &amp; GetTexture (std::string id) Returns a held texture matching the given id. void LoadTexture (std::string id, std::string file_name) Stores a texture under the given id/name;. std::map&lt; char, sf::Texture &gt; ManualWorldTexture () This function loads texture for the manual world images group 8. std::map&lt; char, sf::Texture &gt; MazeTexture () This function loads texture for the maze world images - Default maze. std::map&lt; char, sf::Texture &gt; SecondWorldTexture () This function loads texture for the second world images group 4. TextureHolder () = default ~TextureHolder () = default"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-generativeworldtexture","title":"function GenerativeWorldTexture","text":"<p>This function loads texture for the generative world images group 6. </p> <pre><code>std::map&lt; char, sf::Texture &gt; i_2D::TextureHolder::GenerativeWorldTexture () \n</code></pre> <p>Returns:</p> <p>std::map&lt; name, texture&gt; returns the map, key is the name of the texture and values is the actual texture </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-gettexture","title":"function GetTexture","text":"<p>Returns a held texture matching the given id. </p> <pre><code>const sf::Texture &amp; i_2D::TextureHolder::GetTexture (\n    std::string id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> Identifier/Name of the texture stored. </li> </ul> <p>Returns:</p> <p>The sf::Texture matching the id. </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-loadtexture","title":"function LoadTexture","text":"<p>Stores a texture under the given id/name;. </p> <pre><code>void i_2D::TextureHolder::LoadTexture (\n    std::string id,\n    std::string file_name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> Identifier used to reference this texture in the future. </li> <li><code>file_name</code> File to load the texture from. </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-manualworldtexture","title":"function ManualWorldTexture","text":"<p>This function loads texture for the manual world images group 8. </p> <pre><code>std::map&lt; char, sf::Texture &gt; i_2D::TextureHolder::ManualWorldTexture () \n</code></pre> <p>Returns:</p> <p>std::map&lt; name, texture&gt; returns the map, key is the name of the texture and values is the actual texture </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-mazetexture","title":"function MazeTexture","text":"<p>This function loads texture for the maze world images - Default maze. </p> <pre><code>std::map&lt; char, sf::Texture &gt; i_2D::TextureHolder::MazeTexture () \n</code></pre> <p>Returns:</p> <p>std::map&lt; name, texture&gt; returns the map, key is the name of the texture and values is the actual texture </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-secondworldtexture","title":"function SecondWorldTexture","text":"<p>This function loads texture for the second world images group 4. </p> <pre><code>std::map&lt; char, sf::Texture &gt; i_2D::TextureHolder::SecondWorldTexture () \n</code></pre> <p>Returns:</p> <p>std::map&lt; name, texture&gt; returns the map, key is the name of the texture and values is the actual texture </p>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-textureholder","title":"function TextureHolder","text":"<pre><code>i_2D::TextureHolder::TextureHolder () = default\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/classi__2_d_1_1_texture_holder/#function-textureholder_1","title":"function ~TextureHolder","text":"<pre><code>i_2D::TextureHolder::~TextureHolder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextureHolder.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"2D%20Interface%28Group%203%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Interfaces <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"2D%20Interface%28Group%203%29/dir_e52260c07c5ca641bf485ae92612dd08/","title":"Dir source/Interfaces","text":"<p>FileList &gt; Interfaces</p>"},{"location":"2D%20Interface%28Group%203%29/dir_e52260c07c5ca641bf485ae92612dd08/#files","title":"Files","text":"Type Name file Button.cpp file Button.hpp file Inventory.cpp file Inventory.hpp file MainInterface.cpp MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. file MainInterface.hpp MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. file Menu.cpp file Menu.hpp file MessageBoard.cpp file MessageBoard.hpp file TextBox.cpp file TextBox.hpp file TextureHolder.cpp file TextureHolder.hpp file TrashInterface.hpp <p>The documentation for this class was generated from the following file <code>source/Interfaces/</code></p>"},{"location":"2D%20Interface%28Group%203%29/_button_8cpp/","title":"File Button.cpp","text":"<p>FileList &gt; Interfaces &gt; Button.cpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"Button.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_button_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_button_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>muiph </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Button.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_button_8cpp_source/","title":"File Button.cpp","text":"<p>File List &gt; Interfaces &gt; Button.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"Button.hpp\"\n\nnamespace i_2D {\n    Button::Button(const std::string &amp;t, sf::Vector2f size, sf::Color bgColor,\n                   sf::Color textColor, const sf::Font &amp;font) {\n        text = std::make_unique&lt;sf::Text&gt;(font);\n\n        text-&gt;setString(t);\n        text-&gt;setFillColor(textColor);\n\n        button.setSize(size);\n        button.setFillColor(bgColor);\n    }\n\n    void Button::SetMFont(const sf::Font &amp;font) {\n        text = std::make_unique&lt;sf::Text&gt;(font);\n    }\n\n    void Button::SetPosition(sf::Vector2f pos) {\n        button.setPosition(pos);\n        float xPos = (pos.x + button.getGlobalBounds().width / 2) - (text-&gt;getLocalBounds().width / 2);\n        float yPos = (pos.y + button.getGlobalBounds().height / 2) - (text-&gt;getLocalBounds().height / 2);\n        text-&gt;setPosition({xPos, yPos});\n    }\n\n    bool Button::IsMouseOver(sf::RenderWindow &amp;window) {\n        float mouseX = sf::Mouse::getPosition(window).x;\n        float mouseY = sf::Mouse::getPosition(window).y;\n\n        float btnPosX = button.getPosition().x;\n        float btnPosY = button.getPosition().y;\n\n        float btnXPosWidth = button.getPosition().x + button.getLocalBounds().width;\n        float btnYPosHeight = button.getPosition().y + button.getLocalBounds().height;\n\n        if (mouseX &lt; btnXPosWidth &amp;&amp; mouseX &gt; btnPosX &amp;&amp; mouseY &lt; btnYPosHeight &amp;&amp; mouseY &gt; btnPosY) {\n            return true;\n        }\n        return false;\n    }\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_button_8hpp/","title":"File Button.hpp","text":"<p>FileList &gt; Interfaces &gt; Button.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_button_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_button_8hpp/#classes","title":"Classes","text":"Type Name class Button <p>The documentation for this class was generated from the following file <code>source/Interfaces/Button.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_button_8hpp_source/","title":"File Button.hpp","text":"<p>File List &gt; Interfaces &gt; Button.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;memory&gt;\n\nnamespace i_2D {\n    /***\n     * @class Button\n     *\n     * @brief Simple RectangleShape and a Text inside the shape\n     * Responsive rectangles on the Renderwindow that handles mouse's hover and click events\n     */\n    class Button {\n    private:\n        sf::RectangleShape button;\n        std::unique_ptr&lt;sf::Text&gt; text;\n\n\n    public:\n        Button(const std::string &amp;t, sf::Vector2f size, sf::Color bgColor,\n               sf::Color textColor, const sf::Font &amp;font);\n\n        void SetString(const std::string &amp;s){\n            text-&gt;setString(s);\n        }\n\n        void SetMFont(const sf::Font &amp;font);\n\n        void SetFont(const sf::Font &amp;font) {\n            text-&gt;setFont(font);\n        }\n\n        void SetButtonSize(sf::Vector2f size){\n            button.setSize(size);\n        }\n\n        void SetBackColor(sf::Color color){\n            button.setFillColor(color);\n        }\n\n        void SetTextColor(sf::Color color){\n            text-&gt;setFillColor(color);\n        }\n\n        void SetPosition(sf::Vector2f pos);\n\n        void DrawTo(sf::RenderWindow &amp;window){\n            window.draw(button);\n            window.draw(*text);\n        }\n\n        bool IsMouseOver(sf::RenderWindow &amp;window);\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8cpp/","title":"File Inventory.cpp","text":"<p>FileList &gt; Interfaces &gt; Inventory.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"Inventory.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D <p>The documentation for this class was generated from the following file <code>source/Interfaces/Inventory.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8cpp_source/","title":"File Inventory.cpp","text":"<p>File List &gt; Interfaces &gt; Inventory.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include &lt;algorithm&gt;\n#include \"Inventory.hpp\"\n\nnamespace i_2D {\n    void Inventory::ConstructInventory(sf::Font &amp;font, const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory) {\n        mCanvas = std::make_unique&lt;sf::RectangleShape&gt;();\n        mCanvas-&gt;setSize({mWorldSize.x, mWorldSize.y / 2});\n        mCanvas-&gt;setFillColor(sf::Color::Black);\n        mCanvas-&gt;setPosition(sf::Vector2f{0.f, 50.f});\n\n        mItems.clear();\n        mItems.resize(interfaceAgentInventory.size());\n        std::copy(interfaceAgentInventory.begin(), interfaceAgentInventory.end(), \n            mItems.begin());\n\n        // Set row &amp; col sizes\n        if (mWorldSize.x &gt; 1800) {\n            mCol = 5;\n        } else mCol = 3;\n        if (mWorldSize.y &gt; 900) {\n            mRow = 4;\n        } else mRow = 3;\n\n        // Create 2d vector of buttons\n        size_t Index = 0;\n        for (int i = 0; i &lt; mRow; i++) {\n            std::vector&lt;std::unique_ptr&lt;Button&gt;&gt; v1;\n            for (int j = 0; j &lt; mCol; j++) {\n                v1.push_back(std::make_unique&lt;Button&gt;(\n                        \"\", sf::Vector2f{(mWorldSize.x) / mCol, (mWorldSize.y / 2 - 50) / mRow},\n                        sf::Color::Black, sf::Color::White, font));\n                if (Index &lt; mItems.size()) {\n                    v1[j]-&gt;SetString(mItems[Index]);\n                    ++Index;\n                } else {\n                    v1[j]-&gt;SetString(\"empty\");\n                }\n                v1[j]-&gt;SetPosition(sf::Vector2f{j * (mWorldSize.x / mCol),\n                                                mWorldSize.y / 2 + 50 + i * (mWorldSize.y / 2 - 50) / mRow});\n            }\n            mListOfButtons.push_back(std::move(v1));\n        }\n    }\n\n    void Inventory::DrawTo(sf::RenderWindow &amp;window) {\n        window.draw(*mCanvas);\n        for (const auto &amp;x: mListOfButtons) {\n            for (const auto &amp;y: x) {\n                y-&gt;DrawTo(window);\n            }\n        }\n        if(mItemDisplay) {\n            sf::RectangleShape rect(\n                    sf::Vector2f(window.getSize().x/2-10,(window.getSize().y-50)/2-10));\n            rect.setPosition({5,55});\n            rect.setTexture(&amp;*mItemDisplay);\n            window.draw(rect);\n        }\n    }\n\n    std::string Inventory::HandleMouseMove(sf::RenderWindow &amp;window) {\n        std::string s1 = \"null\";\n        for(int i = 0; i &lt; mListOfButtons.size(); ++i){\n            for(int j = 0; j &lt; mListOfButtons.size(); ++j){\n                if(mListOfButtons[i][j]-&gt;IsMouseOver(window)){\n                    mListOfButtons[i][j]-&gt;SetBackColor(sf::Color::Magenta);\n                    if(i*mCol+j &lt; mItems.size()){\n                        s1 = (mItems[i*mCol+j]);\n                        if(s1 == \"Boots\"){\n                            s1 = s1.substr(0,s1.size()-1);\n                        }\n                        s1[0] = tolower(s1[0]);\n                        s1 += \"Texture\";\n                    }\n                }else{\n                    mListOfButtons[i][j]-&gt;SetBackColor(sf::Color::Black);\n                }\n            }\n        }\n        return s1;\n    }\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8hpp/","title":"File Inventory.hpp","text":"<p>FileList &gt; Interfaces &gt; Inventory.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include \"Button.hpp\"</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_inventory_8hpp/#classes","title":"Classes","text":"Type Name class Inventory <p>The documentation for this class was generated from the following file <code>source/Interfaces/Inventory.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_inventory_8hpp_source/","title":"File Inventory.hpp","text":"<p>File List &gt; Interfaces &gt; Inventory.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include \"Button.hpp\"\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nnamespace i_2D {\n    /***\n     * @class Inventory\n     *\n     * @brief Represent the inventory of entities.\n     *\n     * An interface/visual representation of an inventory.\n     */\n    class Inventory {\n    private:\n        std::unique_ptr&lt;sf::RectangleShape&gt; mCanvas;\n        std::vector&lt;std::vector&lt;std::unique_ptr&lt;Button&gt;&gt;&gt; mListOfButtons;\n        sf::Vector2f mWorldSize; \n        int mCol=0; \n        int mRow=0; \n\n        std::vector&lt;std::string&gt; mItems; \n        std::unique_ptr&lt;sf::Texture&gt; mItemDisplay; \n\n    public:\n        void SetItemDisplay(sf::Texture &amp;texture){\n            if(mItemDisplay) mItemDisplay.reset();\n            mItemDisplay = std::make_unique&lt;sf::Texture&gt;(texture);\n        }\n        explicit Inventory(const sf::Vector2f size) : mWorldSize(size) {}\n        void SetSize(const sf::Vector2f size) {\n            mWorldSize = size;\n        }\n        void ConstructInventory(sf::Font &amp;font,const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory);\n        void DrawTo(sf::RenderWindow &amp;window);\n        std::string HandleMouseMove(sf::RenderWindow &amp;window);\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8cpp/","title":"File MainInterface.cpp","text":"<p>FileList &gt; Interfaces &gt; MainInterface.cpp</p> <p>Go to the source code of this file</p> <p>MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. More...</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include \"MainInterface.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Authors:</p> <p>Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>10/03/2023  </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MainInterface.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8cpp_source/","title":"File MainInterface.cpp","text":"<p>File List &gt; Interfaces &gt; MainInterface.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include &lt;map&gt;\n#include \"MainInterface.hpp\"\n\nnamespace i_2D {\n\n    sf::Clock timer; // To drawTimer function\n    float elapsedTime = 0.0f; // Sets elapsed time  = 0.0\n\n    MainInterface::MainInterface(size_t id, const std::string &amp;name) : InterfaceBase(id, name),\n                                                                       mWindow(sf::VideoMode({1000, 800}),\n                                                                               \"Maze Window\") {\n        if (!mFont.loadFromFile(\"../../assets/font/ArialNarrow7.ttf\")) {\n            std::cout &lt;&lt; \"Error loading font file: ../assets/font/ArialNarrow7.ttf\" &lt;&lt; std::endl;\n        }\n        mMessageBoard = std::make_unique&lt;MessageBoard&gt;(mFont);\n        mTextBox = std::make_unique&lt;TextBox&gt;(mFont);\n        auto a = mWindow.getSize().x;\n        auto b = mWindow.getSize().y;\n        mMenu.Initialize(mFont, sf::Vector2f{static_cast&lt;float&gt;(a), static_cast&lt;float&gt;(b)});\n        ChooseTexture();\n    }\n\n    std::vector&lt;std::string&gt; MainInterface::CreateVectorMaze(\n            const WorldGrid &amp;grid, const type_options_t &amp;type_options,\n            const item_map_t &amp;item_map, const agent_map_t &amp;agent_map) {\n\n        std::vector&lt;std::string&gt; symbol_grid(grid.GetHeight());\n\n        mGridHeight = grid.GetHeight();\n        mGridWidth = grid.GetWidth();\n\n        // Load the world into the symbol_grid;\n        for (size_t y = 0; y &lt; grid.GetHeight(); ++y) {\n            symbol_grid[y].resize(grid.GetWidth());\n            for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n                symbol_grid[y][x] = type_options[grid.At(x, y)].symbol;\n            }\n        }\n\n        // Add in the entities\n        for (const auto &amp;[id, item_ptr]: item_map) {\n            GridPosition pos = item_ptr-&gt;GetPosition();\n            char c = '+';\n            if (item_ptr-&gt;HasProperty(\"symbol\")) {\n                c = item_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n            }\n            if(pos.CellX() &gt;= 0 &amp;&amp; pos.CellY() &gt;= 0 &amp;&amp; \n                pos.CellX() &lt; grid.GetWidth() &amp;&amp; pos.CellY() &lt; grid.GetHeight() &amp;&amp; \n                !item_ptr-&gt;IsOwned()){\n              symbol_grid[pos.CellY()][pos.CellX()] = c;\n            }\n        }\n\n        // Add in the agents\n        for (const auto &amp;[id, agent_ptr]: agent_map) {\n            GridPosition pos = agent_ptr-&gt;GetPosition();\n            char c = '*';\n            if (agent_ptr-&gt;HasProperty(\"symbol\")) {\n                c = agent_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n            }\n            if (!agent_ptr-&gt;HasProperty(\"deleted\")){\n                symbol_grid[pos.CellY()][pos.CellX()] = c;\n            }\n        }\n        return symbol_grid;\n    }\n\n    sf::Vector2f MainInterface::CalculateCellSize(const WorldGrid &amp;grid) {\n\n        float cellSizeWide, cellSizeTall;\n        if (mGridSizeLarge) {\n            cellSizeWide = mWindow.getSize().x / COL;\n            cellSizeTall = mWindow.getSize().y / ROW;\n        } else {\n            cellSizeWide = mWindow.getSize().x / grid.GetWidth();\n            cellSizeTall = mWindow.getSize().y / grid.GetHeight();\n        }\n\n        float cellSize = std::min(cellSizeWide, cellSizeTall);\n        return sf::Vector2f(cellSize, cellSize);\n    }\n\n    void MainInterface::DrawGrid(const WorldGrid &amp;grid, const type_options_t &amp;type_options, const item_map_t &amp;item_map,\n                                 const agent_map_t &amp;agent_map) {\n        // Clear old drawing\n        mWindow.clear(sf::Color::White);\n\n        // Check player's position\n        mPlayerPosition = sf::Vector2i(this-&gt;position.GetX(), this-&gt;position.GetY());\n\n        // Create grid of symbols representing the world\n        std::vector&lt;std::string&gt; symbol_grid;\n        std::vector&lt;std::string&gt; default_grid = CreateVectorMaze(grid, type_options, item_map, agent_map);\n\n        // Determine cell size\n        sf::Vector2f cellSize = CalculateCellSize(grid);\n        float drawSpaceWidth, drawSpaceHeight, drawCenterX, drawCenterY;\n        CalculateDrawSpace(grid, cellSize.x, drawSpaceWidth,\n                           drawSpaceHeight, drawCenterX, drawCenterY);\n\n        if (mGridSizeLarge) {\n            symbol_grid = LargeDisplayGrid(default_grid);\n        } else {\n            symbol_grid = default_grid;\n        }\n        //CheckLargerGrid();\n        // Create a render texture to draw the grid\n        sf::RenderTexture renderTexture;\n        [[maybe_unused]] bool success =\n          renderTexture.create({static_cast&lt;unsigned int&gt;(drawSpaceWidth), static_cast&lt;unsigned int&gt;(drawSpaceHeight)});\n\n        renderTexture.clear(sf::Color::White);\n\n        for (size_t iterY = 0; iterY &lt; symbol_grid.size(); ++iterY) {\n            for (size_t iterX = 0; iterX &lt; symbol_grid[0].size(); ++iterX) {\n                float cellPosX = static_cast&lt;float&gt;(iterX) * cellSize.x;\n                float cellPosY = static_cast&lt;float&gt;(iterY) * cellSize.y;\n                char symbol = symbol_grid[iterY][iterX];\n\n                sf::RectangleShape cellRect(sf::Vector2f(cellSize.x, cellSize.y));\n                cellRect.setPosition(sf::Vector2f(cellPosX, cellPosY));\n\n                sf::RectangleShape cell(sf::Vector2f(cellSize.x, cellSize.y));\n                cell.setPosition(sf::Vector2f(cellPosX, cellPosY));\n\n                SwitchCellSelect(renderTexture, cellRect, cell, symbol);\n            }\n        }\n        renderTexture.display();\n        DrawTimer();\n        DrawHealthInfo();\n\n        // Draw the texture to the window\n        sf::Sprite sprite(renderTexture.getTexture());\n        sprite.setPosition({drawCenterX, drawCenterY});\n        mWindow.draw(sprite);\n\n        // Display everything\n        mTextBox-&gt;DrawTo(mWindow);\n        mMessageBoard-&gt;DrawTo(mWindow);\n        mMenu.DrawTo(mWindow);\n        mWindow.display();\n    }\n\n    void MainInterface::DrawTimer() {\n        // Get elapsed time in seconds\n        elapsedTime = timer.getElapsedTime().asSeconds();\n\n        // Set up font and location\n        sf::Text timerText(mFont);\n        timerText.setCharacterSize(24);\n        timerText.setPosition({750.0f, 75.0f}); // Adjust position as needed\n\n        // Format the elapsed time with 2 decimal points\n        std::ostringstream stream;\n        stream &lt;&lt; \"Time: \" &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; elapsedTime &lt;&lt; \" S\";\n        std::string formattedTime = stream.str();\n\n        // Create text for current value\n        timerText.setString(formattedTime);\n        timerText.setFillColor(sf::Color::Blue);\n        mWindow.draw(timerText);\n    }\n\n    void MainInterface::DrawHealthInfo() {\n        if(!HasProperty(\"Health\")) return;\n\n        int health = property_map.at(\"Health\")-&gt;ToInt();\n\n        // Set text properties and draw\n        sf::Text healthText(mFont);\n        healthText.setCharacterSize(24);\n        healthText.setPosition({20.0f, 75.0f});\n        healthText.setFillColor(sf::Color::Green);\n        healthText.setString(\"Hp: \" + std::to_string(health));\n        mWindow.draw(healthText);\n    }\n\n    std::vector&lt;std::string&gt; MainInterface::LargeDisplayGrid(const std::vector&lt;std::string&gt; &amp;symbol_grid) {\n        // Determine the top-left corner of the 9x23 window\n        int topLeftX = std::max(0,\n                                std::min(mPlayerPosition.x - COL / 2, static_cast&lt;int&gt;(symbol_grid[0].size()) - COL));\n        int topLeftY = std::max(0, std::min(mPlayerPosition.y - ROW / 2, static_cast&lt;int&gt;(symbol_grid.size()) - ROW));\n\n        // Create a new symbol grid for the 9x23 display window\n        std::vector&lt;std::string&gt; display_grid;\n        for (int iterY = 0; iterY &lt; ROW; ++iterY) {\n            std::string row;\n            for (int iterX = 0; iterX &lt; COL; ++iterX) {\n                int posX = topLeftX + iterX;\n                int posY = topLeftY + iterY;\n\n                // Copy the symbol from symbol_grid to display_grid\n                row.push_back(symbol_grid[posY][posX]);\n            }\n            display_grid.push_back(row);\n        }\n\n        return display_grid;\n    }\n\n    void MainInterface::CalculateDrawSpace(const WorldGrid &amp;grid, float cellSize, float &amp;drawSpaceWidth,\n                                           float &amp;drawSpaceHeight, float &amp;drawCenterX, float &amp;drawCenterY) {\n        if (mGridSizeLarge) {\n            drawSpaceWidth = static_cast&lt;float&gt;(COL) * cellSize;\n            drawSpaceHeight = static_cast&lt;float&gt;(ROW) * cellSize;\n        } else {\n            drawSpaceWidth = static_cast&lt;float&gt;(grid.GetWidth()) * cellSize;\n            drawSpaceHeight = static_cast&lt;float&gt;(grid.GetHeight()) * cellSize;\n        }\n\n        drawCenterX = (mWindow.getSize().x - drawSpaceWidth) / 2.0f;\n        drawCenterY = (mWindow.getSize().y - drawSpaceHeight) / 2.0f;\n    }\n\n    size_t MainInterface::SelectAction(const WorldGrid &amp;grid,\n                                       const type_options_t &amp;type_options,\n                                       const item_map_t &amp;item_map,\n                                       const agent_map_t &amp;agent_map) {\n        // Initialize action_id and timer\n        size_t action_id = 0;\n        timer.restart();\n\n        // While the timer is going\n        while (mWindow.isOpen() &amp;&amp; timer.getElapsedTime().asSeconds() &lt; mInputWaitTime) {\n            sf::Event event;\n\n            // Check through all events generated in this frame\n            while (mWindow.pollEvent(event)) {\n                if (event.type == sf::Event::Closed) {\n                    mWindow.close();\n                    exitCleanup();\n\n                } else if (event.type == sf::Event::TextEntered) {\n                    if (mTextBox-&gt;IsSelected()) {\n                        mTextBox-&gt;TypedOn(event);\n                    }\n\n                } else if (event.type == sf::Event::KeyPressed) {\n                    action_id = HandleKeyEvent(event);\n\n                } else if (event.type == sf::Event::Resized) {\n                    HandleResize(event, grid);\n\n                } else if (event.type == sf::Event::MouseMoved) {\n                    auto textureName = mMenu.HandleMouseMove(mWindow);\n                    if(textureName!=\"null\"){\n                        auto texture = mTextureHolder.GetTexture(textureName);\n                        mMenu.SetInventoryItemDisplay(texture);\n                    }\n                } else if (event.type == sf::Event::MouseButtonPressed) {\n                    MouseClickEvent(event, GetID(), item_map);\n\n                }\n            }\n\n            // Check if a valid action was taken and return that if so\n            if (action_id != 0) {\n                return action_id;\n            }\n\n            // Otherwise update the screen drawing again...\n            DrawGrid(grid, type_options, item_map, agent_map);\n\n        }\n        // The timer has ended or the window has been closed\n        return 0;\n    }\n\n    size_t MainInterface::HandleKeyEvent(const sf::Event &amp;event) {\n        size_t action_id = 0;\n        if (mTextBox-&gt;IsSelected()) {\n            // TextBox is selected, handle specific cases\n            switch (event.key.code) {\n                case sf::Keyboard::Enter:\n                    mMessageBoard-&gt;Send(mTextBox-&gt;GetText());\n                    mTextBox-&gt;SetString(\"\");\n                    mTextBox-&gt;SetSelected(false);\n                    break;\n                case sf::Keyboard::Escape:\n                    mTextBox-&gt;SetString(\"\");\n                    mTextBox-&gt;SetSelected(false);\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            // TextBox is not selected, handle movement keys\n            switch (event.key.code) {\n              case sf::Keyboard::W:\n                  if (mTextBox-&gt;IsSelected())break;\n                  action_id = GetActionID(\"up\");\n                  break;\n              case sf::Keyboard::A:\n                  if (mTextBox-&gt;IsSelected())break;\n                  action_id = GetActionID(\"left\");\n                  break;\n              case sf::Keyboard::S:\n                  if (mTextBox-&gt;IsSelected())break;\n                  action_id = GetActionID(\"down\");\n                  break;\n              case sf::Keyboard::D:\n                  if (mTextBox-&gt;IsSelected())break;\n                  action_id = GetActionID(\"right\");\n                  break;\n              case sf::Keyboard::Up:\n                  action_id = GetActionID(\"up\");\n                  break;\n              case sf::Keyboard::Left:\n                  action_id = GetActionID(\"left\");\n                  break;\n              case sf::Keyboard::Down:\n                  action_id = GetActionID(\"down\");\n                  break;\n              case sf::Keyboard::Right:\n                  action_id = GetActionID(\"right\");\n                  break;\n              case sf::Keyboard::H:\n                  action_id = GetActionID(\"heal\");\n                  break;\n              case sf::Keyboard::T:\n                  if (GetName() == \"Interface\") action_id = GetActionID(\"drop\");\n                  else if (GetName() == \"Interface3\") action_id = GetActionID(\"stats\");\n                  break;\n              case sf::Keyboard::C:\n                  action_id = GetActionID(\"use_axe\");\n                  break;\n              case sf::Keyboard::V:\n                  action_id = GetActionID(\"use_boat\");\n                  break;\n              case sf::Keyboard::F:\n                  action_id = GetActionID(\"attack\");\n                  break;\n              case sf::Keyboard::G:\n                  action_id = GetActionID(\"special\");\n                  break;\n              case sf::Keyboard::B:\n                  action_id = GetActionID(\"buff\");\n                  break;\n              case sf::Keyboard::R:\n                  action_id = GetActionID(\"run\");\n                  break;\n              case sf::Keyboard::Y:\n                  action_id = GetActionID(\"help\");\n                  break;\n              default:\n                  break; // The user pressed an unknown key.\n            }\n        }\n        // If we waited for input, but don't understand it, notify the user.\n        if (action_id == 0 &amp;&amp; !mTextBox-&gt;IsSelected()) {\n            std::cout &lt;&lt; \"Unknown key.\" &lt;&lt; std::endl;\n        }\n        // No action performed\n        return action_id;\n    }\n\n\n    void MainInterface::HandleResize(const sf::Event &amp;event, const WorldGrid &amp;grid) {\n        // Check size limits of window\n        float widthWindow = event.size.width;\n        float heightWindow = event.size.height;\n        float widthMin, heightMin;\n        if (mGridSizeLarge) {\n            widthMin = COL * MIN_SIZE_CELL;\n            heightMin = ROW * MIN_SIZE_CELL;\n        } else {\n            widthMin = grid.GetWidth() * MIN_SIZE_CELL;\n            heightMin = grid.GetHeight() * MIN_SIZE_CELL;\n        }\n\n        widthWindow = std::max(widthWindow, widthMin);\n        heightWindow = std::max(heightWindow, heightMin);\n\n        mMenu.SetWorldSize(sf::Vector2f(widthWindow, heightWindow));\n        if (mMenu.IsInventoryOpen()) {\n\n            mMenu.DeconstructInventory();\n            mMenu.ConstructInventory(mAgentInventory);\n        }\n        // Restrict window size if necessary\n        if (widthWindow &lt;= widthMin || heightWindow &lt;= heightMin) {\n            mWindow.setSize(sf::Vector2u(widthWindow, heightWindow));\n        }\n\n        // Resize the view to match window size to prevent deformation\n        sf::FloatRect viewArea(sf::Vector2f(0, 0), sf::Vector2f(widthWindow, heightWindow));\n        mWindow.setView(sf::View(viewArea));\n\n        // Update TextBox position for resizing\n        if (mTextBox) {\n            // Define the percentage values for the position\n            float xPosPercentage = 0.01f; // 5% of the window width\n            float yPosPercentage = 0.9f;  // 80% of the window height\n\n            // Calculate the actual position based on percentages\n            float xPos = (widthWindow * xPosPercentage);\n            float yPos = (heightWindow * yPosPercentage);\n\n            // Set the position of your textbox\n            mTextBox-&gt;SetPosition({xPos, yPos});\n\n        }\n    }\n\n    /*\n     * This function chooses the world to load the texture for it's images\n     * and sets the current texture map for drawing\n     */\n    void MainInterface::ChooseTexture() {\n        if (GetName() == \"Interface1\") {\n            mTexturesDefault = mTextureHolder.MazeTexture();\n            mTexturesCurrent = mTexturesDefault;\n        } else if (GetName() == \"Interface\") {\n            mTexturesSecondWorld = mTextureHolder.SecondWorldTexture();\n            mTexturesCurrent = mTexturesSecondWorld;\n        } else if (GetName() == \"Interface3\") {\n            mTexturesManualWorld = mTextureHolder.ManualWorldTexture();\n            mTexturesCurrent = mTexturesManualWorld;\n        } else if (GetName() == \"Interface2\") {\n            mTexturesGenerativeWorld = mTextureHolder.GenerativeWorldTexture();\n            mTexturesCurrent = mTexturesGenerativeWorld;\n        }\n\n    }\n\n    void MainInterface::MouseClickEvent(const sf::Event &amp;event, const size_t /*entity_id*/, const item_map_t &amp;item_map) {\n        if (event.mouseButton.button == sf::Mouse::Left) {\n            sf::Vector2f mousePos(static_cast&lt;float&gt;(event.mouseButton.x), static_cast&lt;float&gt;(event.mouseButton.y));\n\n            // Check if the mouse click is inside the TextBox bounds\n            if (mTextBox-&gt;Contains(mousePos)) {\n                // Toggle the selected state of the TextBox\n                mTextBox-&gt;SetSelected(!mTextBox-&gt;IsSelected());\n            } else {\n                // If the click is outside the TextBox, deselect it\n                mTextBox-&gt;SetSelected(false);\n            }\n\n            // Check if the mouse is over specific menu items\n            if (mMenu.GetMenu()[4]-&gt;IsMouseOver(mWindow) ) {\n                SetLargeGrid(true);\n            } else if (mMenu.GetMenu()[3]-&gt;IsMouseOver(mWindow)) {\n                SetLargeGrid(false);\n            } else if (mMenu.GetMenu()[2]-&gt;IsMouseOver(mWindow)) {\n                exitCleanup();\n            } else {\n                // Handle mouse button press for the general menu\n                mAgentInventory.clear();\n                for(const auto &amp;[x,y]:item_map){\n                    if(GetID() == y-&gt;GetOwnerID()){\n                        mAgentInventory.push_back(y-&gt;GetName());\n                    }\n                }\n                mMenu.HandleMouseButtonPressed(mWindow, mAgentInventory);\n            }\n        }\n    }\n\n    void MainInterface::SwitchCellSelect(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect,\n                                         sf::RectangleShape &amp;cell, char symbol) {\n        switch (symbol) {\n            case '#':\n                DrawWall(renderTexture, cellRect, mTexturesCurrent[symbol]);\n                break;\n            default:\n                DrawAgentCell(renderTexture, cellRect, cell, mTexturesCurrent[symbol]);\n                break;\n        }\n    }\n\n    void MainInterface::DrawAgentCell(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect,\n                                      sf::RectangleShape &amp;cell, sf::Texture &amp;agent) {\n        cellRect.setTexture(&amp;agent);\n        cell.setTexture(&amp;mTexturesCurrent[' ']);\n        if (&amp;agent == &amp;mTexturesCurrent['+'] and GetName() == \"Interface\") {\n            cellRect.setFillColor(sf::Color::Green);\n        }\n        renderTexture.draw(cell);\n        renderTexture.draw(cellRect);\n    }\n\n    void MainInterface::DrawWall(sf::RenderTexture &amp;renderTexture,\n                                 sf::RectangleShape &amp;cellRect, sf::Texture &amp;wallTexture) {\n\n        cellRect.setTexture(&amp;wallTexture);\n        renderTexture.draw(cellRect);\n    }\n    void MainInterface::setMInputWaitTime(double waitTime) {\n        MainInterface::mInputWaitTime = waitTime;\n    }\n\n    void MainInterface::CheckLargerGrid()\n    {\n        if (mGridWidth == mGridHeight)\n        {\n            mGridSizeLarge = true;\n        }\n    }\n\n\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp/","title":"File MainInterface.hpp","text":"<p>FileList &gt; Interfaces &gt; MainInterface.hpp</p> <p>Go to the source code of this file</p> <p>MainInterface class manages the game's user interface, including the menu, textbox, message box, inventory, and texture holder. It serves as the main class responsible for creating and managing the game window, drawing the grid, handling player movements, and displaying menu and inventory details. More...</p> <ul> <li><code>#include \"SFML/Graphics.hpp\"</code></li> <li><code>#include \"SFML/Graphics/Transformable.hpp\"</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"Button.hpp\"</code></li> <li><code>#include \"Menu.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"../core/Data.hpp\"</code></li> <li><code>#include \"../core/InterfaceBase.hpp\"</code></li> <li><code>#include \"TextureHolder.hpp\"</code></li> <li><code>#include \"TextBox.hpp\"</code></li> <li><code>#include \"MessageBoard.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp/#classes","title":"Classes","text":"Type Name class MainInterface Represents the main interface for a 2D maze game."},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>:Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>: 10/03/2023 </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MainInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_main_interface_8hpp_source/","title":"File MainInterface.hpp","text":"<p>File List &gt; Interfaces &gt; MainInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"SFML/Graphics.hpp\"\n#include \"SFML/Graphics/Transformable.hpp\"\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;sstream&gt;\n#include \"Button.hpp\"\n#include \"Menu.hpp\"\n#include &lt;memory&gt;\n\n#include \"../core/Data.hpp\"\n#include \"../core/InterfaceBase.hpp\"\n#include \"TextureHolder.hpp\"\n#include \"TextBox.hpp\"\n#include \"MessageBoard.hpp\"\n\n\nnamespace i_2D {\n\n    using namespace cse491;\n\n\n    class MainInterface : public virtual InterfaceBase {\n\n    private:\n        sf::RenderWindow mWindow; \n        float const MIN_SIZE_CELL = 16; \n\n        // Menu and message vars\n        Menu mMenu; \n        sf::Font mFont; \n        std::unique_ptr&lt;TextBox&gt; mTextBox; \n        std::unique_ptr&lt;MessageBoard&gt; mMessageBoard; \n        std::vector&lt;std::string&gt; mAgentInventory;\n\n        // Texture vars\n        TextureHolder mTextureHolder; \n        std::map&lt;char, sf::Texture&gt; mTexturesDefault; \n        std::map&lt;char, sf::Texture&gt; mTexturesSecondWorld; \n        std::map&lt;char, sf::Texture&gt; mTexturesManualWorld; \n        std::map&lt;char, sf::Texture&gt; mTexturesGenerativeWorld; \n        std::map&lt;char, sf::Texture&gt; mTexturesCurrent; \n\n        // Render range vars\n        sf::Vector2i mPlayerPosition = sf::Vector2i(0, 0); \n        bool mGridSizeLarge = false; \n        int const ROW = 9; \n        int const COL = 20; \n\n        int mGridWidth = 0; \n        int mGridHeight = 0; \n\n        double mInputWaitTime = 0.5f;  \n\n        size_t HandleKeyEvent(const sf::Event &amp;event);\n\n        void CalculateDrawSpace(const WorldGrid &amp;grid, float cellSize, float &amp;drawSpaceWidth, float &amp;drawSpaceHeight,\n                                float &amp;drawCenterX, float &amp;drawCenterY);\n\n        sf::Vector2f CalculateCellSize(const WorldGrid &amp;grid);\n\n        void HandleResize(const sf::Event &amp;event, const WorldGrid &amp;grid);\n\n        void ChooseTexture();\n\n        std::vector&lt;std::string&gt; LargeDisplayGrid(const std::vector&lt;std::string&gt; &amp;symbol_grid);\n\n        void MouseClickEvent(const sf::Event &amp;event,const size_t entity_id, const item_map_t &amp;item_map);\n\n        void DrawAgentCell(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect, sf::RectangleShape &amp;cell,\n                           sf::Texture &amp;agent);\n\n        void\n        SwitchCellSelect(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect, sf::RectangleShape &amp;cell,\n                         char symbol);\n\n        void DrawWall(sf::RenderTexture &amp;renderTexture, sf::RectangleShape &amp;cellRect, sf::Texture &amp;wallTexture);\n\n        void DrawTimer();\n\n        void DrawHealthInfo();\n\n    public:\n        MainInterface(size_t id, const std::string &amp;name);\n\n        ~MainInterface() = default;\n\n\n        std::vector&lt;std::string&gt; CreateVectorMaze(\n                const WorldGrid &amp;grid,\n                const type_options_t &amp;type_options,\n                const item_map_t &amp;item_map,\n                const agent_map_t &amp;agent_map);\n\n        void DrawGrid(const WorldGrid &amp;grid, const type_options_t &amp;type_options,\n                      const item_map_t &amp;item_map, const agent_map_t &amp;agent_map);\n\n        void setMInputWaitTime(double mInputWaitTime);\n        void SetLargeGrid(bool b){ mGridSizeLarge = b; } \n\n        bool Initialize() override {\n            return true;\n        }\n\n        size_t SelectAction(const WorldGrid &amp;grid,\n                            const type_options_t &amp;type_options,\n                            const item_map_t &amp;item_map,\n                            const agent_map_t &amp;agent_map) override;\n\n\n        void Notify(const std::string &amp;message,\n                    const std::string &amp; /*msg_type*/= \"none\") override {\n            std::cout &lt;&lt; message &lt;&lt; std::endl;\n            mMessageBoard-&gt;Send(message);\n        }\n\n        void CheckLargerGrid();\n    };\n\n} // End of namespace 2D\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/","title":"File Menu.cpp","text":"<p>FileList &gt; Interfaces &gt; Menu.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Menu.hpp\"</code></li> <li><code>#include &lt;SFML/Window.hpp&gt;</code></li> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/#public-functions","title":"Public Functions","text":"Type Name const sf::Vector2f MENU_BUTTON_SIZE ({200.f, 50.f})"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp/#function-menu_button_size","title":"function MENU_BUTTON_SIZE","text":"<pre><code>const sf::Vector2f MENU_BUTTON_SIZE (\n    {200.f, 50.f}\n) \n</code></pre> <p>Author:</p> <p>: Team - 3 </p> <p>Date:</p> <p>: 10/3/2023 Menu class creates a menu and displays it in the render window </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/Menu.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_menu_8cpp_source/","title":"File Menu.cpp","text":"<p>File List &gt; Interfaces &gt; Menu.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"Menu.hpp\"\n#include &lt;SFML/Window.hpp&gt;\n#include &lt;SFML/Graphics.hpp&gt;\n\nconst sf::Vector2f MENU_BUTTON_SIZE({200.f,50.f});\nnamespace i_2D {\n\n    void Menu::Initialize(sf::Font &amp;font, sf::Vector2f size) {\n        sf::Color backgroundcolor = sf::Color::Black;\n        sf::Color textcolor = sf::Color::White;\n        mFont = &amp;font;\n        mWorldSize = size;\n\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Menu\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[0]-&gt;SetPosition({0,0});\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Inventory\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[1]-&gt;SetPosition({200,0});\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Exit\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[2]-&gt;SetPosition({400,0});\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Normal\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[3]-&gt;SetPosition({600,0});\n        mMenuBar.emplace_back(std::make_unique&lt;Button&gt;(\n                \"Enlarge\", MENU_BUTTON_SIZE, backgroundcolor, textcolor, font));\n        mMenuBar[4]-&gt;SetPosition({800,0});\n\n    }\n\n    void Menu::DrawTo(sf::RenderWindow &amp;window) {\n        for( const auto &amp;button : mMenuBar){\n            button-&gt;DrawTo(window);\n        }\n        if(mInventory) {\n            mInventory-&gt;DrawTo(window);\n        }\n    }\n\n    std::string Menu::HandleMouseMove(sf::RenderWindow &amp;window) {\n        std::string s1 = \"null\";\n        for (size_t i = 0; i &lt; mMenuBar.size(); ++i) {\n            if (mMenuBar[i]-&gt;IsMouseOver(window)) {\n                mMenuBar[i]-&gt;SetBackColor(sf::Color::Magenta);\n            } else {\n                mMenuBar[i]-&gt;SetBackColor(sf::Color::Black);\n            }\n        }\n        if(mInventory){\n            s1 = mInventory-&gt;HandleMouseMove(window);\n        }\n        return s1;\n    }\n    void Menu::HandleMouseButtonPressed(sf::RenderWindow &amp;window,\n                                        const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory) {\n        if(mMenuBar[1]-&gt;IsMouseOver(window)){\n            if(mInventory){\n                DeconstructInventory();\n            }else {\n                ConstructInventory(interfaceAgentInventory);\n            }\n        }\n\n    }\n}\n\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_menu_8hpp/","title":"File Menu.hpp","text":"<p>FileList &gt; Interfaces &gt; Menu.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include \"Button.hpp\"</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"Inventory.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_menu_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_menu_8hpp/#classes","title":"Classes","text":"Type Name class Menu <p>The documentation for this class was generated from the following file <code>source/Interfaces/Menu.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_menu_8hpp_source/","title":"File Menu.hpp","text":"<p>File List &gt; Interfaces &gt; Menu.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include \"Button.hpp\"\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include \"Inventory.hpp\"\n\nnamespace i_2D {\n    const int MAX_NUMBER_OF_ITEMS_MENU_ITEMS = 3;\n\n    class Menu {\n    private:\n        std::vector&lt;std::unique_ptr&lt;Button&gt;&gt; mMenuBar;\n        std::unique_ptr&lt;Inventory&gt; mInventory; \n        sf::Font * mFont; \n        sf::Vector2f mWorldSize; \n\n    public:\n        void SetInventoryItemDisplay(sf::Texture &amp;texture){\n            if(mInventory) mInventory-&gt;SetItemDisplay(texture);\n        }\n        void Initialize(sf::Font &amp;font,sf::Vector2f size);\n        void DrawTo(sf::RenderWindow &amp;window);\n        std::string HandleMouseMove(sf::RenderWindow &amp;window);\n        void HandleMouseButtonPressed(sf::RenderWindow &amp;window,\n                                      const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory);\n        std::vector&lt;std::unique_ptr&lt;Button&gt;&gt; &amp;GetMenu()\n        {\n            return mMenuBar;\n        }\n        void SetWorldSize(sf::Vector2f size){\n            mWorldSize = size;\n        }\n\n        bool IsInventoryOpen(){\n            if(mInventory){\n                return true;\n            }else return false;\n        }\n\n        void ConstructInventory(const std::vector&lt;std::string&gt; &amp;interfaceAgentInventory){\n            mInventory = std::make_unique&lt;Inventory&gt;(mWorldSize);\n            mInventory-&gt;ConstructInventory(*mFont, interfaceAgentInventory);\n        }\n\n        void DeconstructInventory(){\n            mInventory.reset();\n        }\n\n    };\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8cpp/","title":"File MessageBoard.cpp","text":"<p>FileList &gt; Interfaces &gt; MessageBoard.cpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"MessageBoard.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_message_board_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Authors:</p> <p>Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>: 11/03/2023 MessageBoard class communicate messages to the interface entity </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/MessageBoard.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8cpp_source/","title":"File MessageBoard.cpp","text":"<p>File List &gt; Interfaces &gt; MessageBoard.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"MessageBoard.hpp\"\n\nnamespace i_2D {\n\n    MessageBoard::MessageBoard(sf::Font &amp;font) {\n\n        mText = std::make_unique&lt;sf::Text&gt;(font);\n        mText-&gt;setString(\"Welcome!\");\n        mText-&gt;setCharacterSize(35);\n        mText-&gt;setFillColor(sf::Color::Blue);\n        mText-&gt;setPosition({5, 125});\n        mStartTime = std::chrono::system_clock::now();\n    }\n\n    void MessageBoard::DrawTo(sf::RenderWindow &amp;window) {\n        if (std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(\n                std::chrono::system_clock::now() - mStartTime).count() &gt; 10000) {\n            mText-&gt;setString(\"\");\n        } else window.draw(*mText);\n    }\n\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8hpp/","title":"File MessageBoard.hpp","text":"<p>FileList &gt; Interfaces &gt; MessageBoard.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_message_board_8hpp/#classes","title":"Classes","text":"Type Name class MessageBoard <p>The documentation for this class was generated from the following file <code>source/Interfaces/MessageBoard.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_message_board_8hpp_source/","title":"File MessageBoard.hpp","text":"<p>File List &gt; Interfaces &gt; MessageBoard.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;memory&gt;\n#include &lt;chrono&gt;\n\nnamespace i_2D {\n\n    class MessageBoard {\n\n    private:\n        std::unique_ptr&lt;sf::Text&gt; mText;\n        std::chrono::time_point&lt;std::chrono::system_clock&gt; mStartTime;\n\n    public:\n        explicit MessageBoard(sf::Font &amp;font);\n\n        void DrawTo(sf::RenderWindow &amp;window);\n\n        void Send(const std::string &amp;message) {\n            mText-&gt;setString(message);\n            mStartTime = std::chrono::system_clock::now();\n        }\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8cpp/","title":"File TextBox.cpp","text":"<p>FileList &gt; Interfaces &gt; TextBox.cpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"TextBox.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_text_box_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Authors:</p> <p>Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>: 11/02/2023 TextBox class enables interface entity to send message to the MessageBoard and World </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextBox.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8cpp_source/","title":"File TextBox.cpp","text":"<p>File List &gt; Interfaces &gt; TextBox.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"TextBox.hpp\"\n\nnamespace i_2D {\n\n    TextBox::TextBox(const sf::Font &amp;font, int size, sf::Color color, bool sel) {\n\n        mText = std::make_unique&lt;sf::Text&gt;(font);\n        mText-&gt;setCharacterSize(size);\n        mText-&gt;setFillColor(color);\n        mText-&gt;setPosition({10, 650});\n        isSelected = sel;\n        if (!isSelected)\n            mText-&gt;setString(\"Press Click!\");\n\n    }\n\n    void TextBox::SetString(const std::string &amp;s) {\n        mText-&gt;setString(s);\n        mStreamText.str(\"\");\n        mStreamText &lt;&lt; s;\n    }\n\n    void TextBox::SetSelected(bool sel) {\n        isSelected = sel;\n        if (!sel) {\n            std::string t = mStreamText.str();\n            std::string newT;\n            for (char i: t) {\n                newT += i;\n            }\n            mText-&gt;setString((newT));\n        }\n    }\n\n    void TextBox::TypedOn(sf::Event input) {\n        if (isSelected) {\n            int charTyped = static_cast&lt;int&gt;(input.text.unicode);\n            if (charTyped &lt; 128) {\n                if (hasLimit) {\n                    if (static_cast&lt;int&gt;(mStreamText.str().length()) &lt; limit) {\n                        InputLogic(charTyped);\n                    } else if (static_cast&lt;int&gt;(mStreamText.str().length()) &gt;= limit &amp;&amp; charTyped == DELETE_KEY) {\n                        DeleteLastChar();\n                    }\n                } else {\n                    InputLogic(charTyped);\n                }\n            }\n        }\n    }\n\n    void TextBox::InputLogic(int charTyped) {\n        if (isSelected) {\n            if (charTyped != DELETE_KEY &amp;&amp; charTyped != ENTER_KEY &amp;&amp; charTyped != ESCAPE_KEY) {\n                    mStreamText &lt;&lt; static_cast&lt;char&gt;(charTyped);\n            } else if (charTyped == DELETE_KEY) {\n                if (mStreamText.str().length() &gt; 0) {\n                    DeleteLastChar();\n                }\n            }\n        }\n\n        mText-&gt;setString(mStreamText.str() + \"_\");\n    }\n\n    void TextBox::DeleteLastChar() {\n        std::string t = mStreamText.str();\n        mStreamText.str(\"\");\n        mStreamText &lt;&lt; t.substr(0,t.size()-1);\n        mText-&gt;setString(mStreamText.str());\n    }\n\n    void TextBox::DrawTo(sf::RenderWindow &amp;window) {\n\n        mBorderRect.setSize(sf::Vector2f(800, 50));\n        //Subtracts the vector (5, 5) from the position of mTextBox. This creates a new position\n        // slightly to the left and up from the original position, effectively creating a margin.\n\n        mBorderRect.setPosition(mText-&gt;getPosition() - sf::Vector2f(5, 5));\n        mBorderRect.setFillColor(sf::Color(200, 200, 200));\n        mBorderRect.setOutlineThickness(2.0f);  //  thickness of the border\n        mBorderRect.setOutlineColor(sf::Color::Black);\n\n        window.draw(mBorderRect);\n        window.draw(*mText);\n\n    }\n\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/","title":"File TextBox.hpp","text":"<p>FileList &gt; Interfaces &gt; TextBox.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#classes","title":"Classes","text":"Type Name class TextBox"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#macros","title":"Macros","text":"Type Name define DELETE_KEY  8value for delete key define ENTER_KEY  13value for the enter key define ESCAPE_KEY  27value for the escape key"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Authors:</p> <p>Gaya Kanagaraj, Vincenzo Felici, Mui Pham </p> <p>Date:</p> <p>: 11/02/2023 TextBox class enables interface entity to send message to the MessageBoard and World </p>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#define-delete_key","title":"define DELETE_KEY","text":"<pre><code>#define DELETE_KEY 8\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#define-enter_key","title":"define ENTER_KEY","text":"<pre><code>#define ENTER_KEY 13\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp/#define-escape_key","title":"define ESCAPE_KEY","text":"<pre><code>#define ESCAPE_KEY 27\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextBox.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_text_box_8hpp_source/","title":"File TextBox.hpp","text":"<p>File List &gt; Interfaces &gt; TextBox.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include&lt;iostream&gt;\n#include&lt;SFML/Graphics.hpp&gt;\n#include&lt;sstream&gt;\n\nnamespace i_2D {\n\n#define DELETE_KEY 8 \n#define ENTER_KEY 13 \n#define ESCAPE_KEY 27 \n\n    class TextBox {\n\n    private:\n        std::unique_ptr&lt;sf::Text&gt; mText;\n        std::ostringstream mStreamText; \n        bool isSelected = false; \n        bool hasLimit = true; \n        int limit = 60; \n        // Draw the border around the TextBox\n        sf::RectangleShape mBorderRect;\n\n        void InputLogic(int charTyped);\n\n        void DeleteLastChar();\n\n    public:\n        TextBox() = default;\n\n        explicit TextBox(const sf::Font &amp;font, int size = 25, sf::Color color = sf::Color::Red, bool sel = false);\n\n        void SetString(const std::string &amp;s);\n\n        void SetFont(const sf::Font &amp;font) {\n            mText-&gt;setFont(font);\n        }\n\n        void SetPosition(sf::Vector2f pos) {\n            mText-&gt;setPosition(pos);\n        }\n\n        void SetLimit(bool ToF) {\n            hasLimit = ToF;\n        }\n\n        void SetLimit(bool ToF, int lim) {\n            hasLimit = ToF;\n            limit = lim;\n        }\n\n        void SetSelected(bool sel);\n\n        std::string GetText() {\n            return mStreamText.str();\n        }\n\n        void DrawTo(sf::RenderWindow &amp;window);\n\n        void TypedOn(sf::Event input);\n\n        bool IsSelected() const {\n            return isSelected;\n        }\n\n        bool Contains(sf::Vector2f point) const {\n            return mBorderRect.getGlobalBounds().contains(point);\n        }\n\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8cpp/","title":"File TextureHolder.cpp","text":"<p>FileList &gt; Interfaces &gt; TextureHolder.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"TextureHolder.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextureHolder.cpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8cpp_source/","title":"File TextureHolder.cpp","text":"<p>File List &gt; Interfaces &gt; TextureHolder.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n//\n// Created by Vincenzo on 10/18/2023.\n//\n\n#include \"TextureHolder.hpp\"\n\nnamespace i_2D\n{\n    void TextureHolder::LoadTexture(std::string id, std::string file_name) {\n        // Load texture to pointer\n        std::unique_ptr&lt;sf::Texture&gt; texture(new sf::Texture());\n        if(!texture-&gt;loadFromFile(file_name))\n        {\n            throw std::runtime_error(\"Failed to load texture from: \" + file_name);\n        }\n\n        // Insert the pointer to map with id as key\n        textures_.insert(std::make_pair(id, std::move(texture)));\n        return;\n    }\n\n    const sf::Texture &amp;TextureHolder::GetTexture(std::string id) {\n        // Find iterator of matching id (avoids copy of unique_ptr)\n        auto got = textures_.find(id);\n        // Return dereference unique_ptr found at iterator pair\n        return *got-&gt;second;\n    }\n\n    std::map&lt;char, sf::Texture&gt; TextureHolder::MazeTexture()\n    {\n\n        std::map&lt;char, sf::Texture&gt; textures;\n\n        // Load textures\n\n        LoadTexture(\"wallTexture\", \"../assets/walls/wall.png\");\n        LoadTexture(\"trollTexture\", \"../assets/agents/troll.png\");\n        LoadTexture(\"agentTexture\", \"../assets/agents/default-the-first.png\");\n        textures['#'] = GetTexture(\"wallTexture\");\n        textures['*'] = GetTexture(\"trollTexture\");\n        textures['@'] = GetTexture(\"agentTexture\");\n        return textures;\n    }\n    std::map&lt;char, sf::Texture&gt; TextureHolder::SecondWorldTexture()\n    {\n\n        std::map&lt;char, sf::Texture&gt; textures;\n\n        // Load textures\n        LoadTexture(\"wallTexture\", \"../assets/walls/wall.png\");\n        LoadTexture(\"trollTexture\", \"../assets/agents/troll.png\");\n        LoadTexture(\"agentTexture\", \"../assets/agents/witch-girl.png\");\n        LoadTexture(\"armourTexture\", \"../assets/weapons/leather_armor.png\");\n        LoadTexture(\"swordTexture\", \"../assets/weapons/longsword.png\");\n        LoadTexture(\"axeTexture\", \"../assets/weapons/w_axe_war.png\");\n        LoadTexture(\"daggerTexture\", \"../assets/weapons/dagger.png\");\n        LoadTexture(\"chestTexture\", \"../assets/weapons/chest_closed.png\");\n        LoadTexture(\"flagTexture\", \"../assets/weapons/flag.png\");\n        LoadTexture(\"pathTexture\", \"../assets/Ground_tiles/Grass2.png\");\n        LoadTexture(\"sword of PowerTexture\", \"../assets/weapons/longsword.png\");\n        LoadTexture(\"axe of HealthTexture\", \"../assets/weapons/w_axe_war.png\");\n        LoadTexture(\"inferno SlicerTexture\", \"../assets/weapons/dagger.png\");\n        LoadTexture(\"electric DaggerTexture\", \"../assets/weapons/dagger.png\");\n        LoadTexture(\"fire DaggerTexture\", \"../assets/weapons/dagger.png\");\n        LoadTexture(\"daedric ArmorTexture\", \"../assets/weapons/leather_armor.png\");\n        LoadTexture(\"leather ArmorTexture\", \"../assets/weapons/leather_armor.png\");\n        LoadTexture(\"hammerTexture\", \"../assets/weapons/w_axe_war.png\");\n        LoadTexture(\"waterTexture\", \"../assets/Ground_tiles/water.jpg\");\n\n        textures['#'] = GetTexture(\"wallTexture\");\n        textures['*'] = GetTexture(\"trollTexture\");\n        textures['@'] = GetTexture(\"agentTexture\");\n        textures['+'] = GetTexture(\"armourTexture\");\n        textures['S'] = GetTexture(\"swordTexture\");\n        textures['A'] = GetTexture(\"axeTexture\");\n        textures['D'] = GetTexture(\"daggerTexture\");\n        textures['C'] = GetTexture(\"chestTexture\");\n        textures['g'] = GetTexture(\"flagTexture\");\n        textures[' '] = GetTexture(\"pathTexture\");\n        textures['w'] = GetTexture(\"waterTexture\");\n        textures['u'] = GetTexture(\"waterTexture\");\n\n        return textures;\n    }\n    std::map&lt;char, sf::Texture&gt; TextureHolder::ManualWorldTexture()\n    {\n\n        std::map&lt;char, sf::Texture&gt; textures;\n\n        // Load textures\n        LoadTexture(\"wallTexture\", \"../assets/walls/brick_wall.png\");\n        LoadTexture(\"trollTexture\", \"../assets/agents/troll.png\");\n        LoadTexture(\"agentTexture\", \"../assets/agents/witch-girl.png\");\n        LoadTexture(\"treeTexture\", \"../assets/trees/tree1.png\");\n        LoadTexture(\"waterTexture\", \"../assets/Ground_tiles/water.jpg\");\n        LoadTexture(\"axeTexture\", \"../assets/weapons/w_axe_war_steel.png\");\n        LoadTexture(\"boatTexture\", \"../assets/weapons/Boat_color1_2.png\");\n        LoadTexture(\"pathTexture\", \"../assets/Ground_tiles/Sand1.png\");\n        LoadTexture(\"portal1Texture\", \"../assets/walls/portal1.png\");\n        LoadTexture(\"portal2Texture\", \"../assets/walls/portal2.png\");\n        LoadTexture(\"portal3Texture\", \"../assets/walls/portal3.png\");\n        LoadTexture(\"portal4Texture\", \"../assets/walls/portal4.png\");\n        LoadTexture(\"healthTexture\", \"../assets/walls/teleport.png\");\n        LoadTexture(\"rockTexture\", \"../assets/walls/gray_wall.png\");\n        LoadTexture(\"swordTexture\", \"../assets/weapons/longsword.png\");\n        textures['P'] = GetTexture(\"axeTexture\");\n        textures['U'] = GetTexture(\"boatTexture\");\n        textures['#'] = GetTexture(\"wallTexture\");\n        textures['*'] = GetTexture(\"trollTexture\");\n        textures['@'] = GetTexture(\"agentTexture\");\n        textures['^'] = GetTexture(\"treeTexture\");\n        textures['~'] = GetTexture(\"waterTexture\");\n        textures[' '] = GetTexture(\"pathTexture\");\n        textures['{'] = GetTexture(\"portal1Texture\");\n        textures['}'] = GetTexture(\"portal2Texture\");\n        textures['('] = GetTexture(\"portal3Texture\");\n        textures[')'] = GetTexture(\"portal4Texture\");\n        textures['j'] = GetTexture(\"healthTexture\");\n        textures['t'] = GetTexture(\"swordTexture\");\n        textures['$'] = GetTexture(\"rockTexture\");\n\n        return textures;\n    }\n    std::map&lt;char, sf::Texture&gt; TextureHolder::GenerativeWorldTexture()\n    {\n\n        std::map&lt;char, sf::Texture&gt; textures;\n\n        // Load textures\n        LoadTexture(\"wallTexture\", \"../assets/walls/stone_wall02.png\");\n        LoadTexture(\"trollTexture\", \"../assets/agents/troll.png\");\n        LoadTexture(\"agentTexture\", \"../assets/agents/Character_03_Front.png\");\n        LoadTexture(\"tarTexture\", \"../assets/Ground_tiles/tar.jpg\");\n        LoadTexture(\"doorTexture\", \"../assets/walls/castledoors.png\");\n        LoadTexture(\"spikeTexture\", \"../assets/weapons/Individual_Spike.png\");\n        LoadTexture(\"keyTexture\", \"../assets/weapons/key.png\");\n        LoadTexture(\"pathTexture\", \"../assets/Ground_tiles/Dirt1.png\");\n        LoadTexture(\"bootTexture\", \"../assets/weapons/2.png\");\n        LoadTexture(\"shieldTexture\", \"../assets/weapons/shield.png\");\n        LoadTexture(\"teleportTexture\", \"../assets/walls/teleport.png\");\n        LoadTexture(\"armoryTexture\", \"../assets/weapons/steel_armor.png\");\n        LoadTexture(\"waterTexture\", \"../assets/Ground_tiles/water.jpg\");\n        LoadTexture(\"sandTexture\", \"../assets/Ground_tiles/Sand1.png\");\n        LoadTexture(\"grassTexture\", \"../assets/Ground_tiles/Grass2.png\");\n        LoadTexture(\"dirtTexture\", \"../assets/Ground_tiles/Dirt1.png\");\n        textures['~'] = GetTexture(\"dirtTexture\");\n        textures['M'] = GetTexture(\"grassTexture\");\n        textures['-'] = GetTexture(\"sandTexture\");\n        textures['W'] = GetTexture(\"waterTexture\");\n        textures['B'] = GetTexture(\"bootTexture\");\n        textures['X'] = GetTexture(\"spikeTexture\");\n        textures['O'] = GetTexture(\"tarTexture\");\n        textures['#'] = GetTexture(\"wallTexture\");\n        textures['*'] = GetTexture(\"trollTexture\");\n        textures['@'] = GetTexture(\"agentTexture\");\n        textures['D'] = GetTexture(\"doorTexture\");\n        textures['K'] = GetTexture(\"keyTexture\");\n        textures[' '] = GetTexture(\"pathTexture\");\n        textures['S'] = GetTexture(\"shieldTexture\");\n        textures['T'] = GetTexture(\"teleportTexture\");\n        textures['A'] = GetTexture(\"armoryTexture\");\n\n        return textures;\n    }\n\n}\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8hpp/","title":"File TextureHolder.hpp","text":"<p>FileList &gt; Interfaces &gt; TextureHolder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include \"SFML/Graphics.hpp\"</code></li> <li><code>#include \"../core/Data.hpp\"</code></li> <li><code>#include \"../core/InterfaceBase.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace i_2D"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8hpp/#classes","title":"Classes","text":"Type Name class TextureHolder <p>The documentation for this class was generated from the following file <code>source/Interfaces/TextureHolder.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_texture_holder_8hpp_source/","title":"File TextureHolder.hpp","text":"<p>File List &gt; Interfaces &gt; TextureHolder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n//\n// Created by Vincenzo on 10/18/2023.\n//\n\n#pragma once\n\n#include &lt;map&gt;\n#include \"SFML/Graphics.hpp\"\n#include \"../core/Data.hpp\"\n#include \"../core/InterfaceBase.hpp\"\n\nnamespace i_2D\n{\n    using namespace cse491;\n    class TextureHolder {\n\n    private:\n        std::unordered_map&lt;std::string, std::unique_ptr&lt;sf::Texture&gt;&gt; textures_;\n\n    public:\n        TextureHolder() = default;\n        ~TextureHolder() = default;\n        void LoadTexture(std::string id, std::string file_name);\n        const sf::Texture&amp; GetTexture(std::string id);\n        std::map&lt;char, sf::Texture&gt; MazeTexture();\n        std::map&lt;char, sf::Texture&gt; SecondWorldTexture();\n        std::map&lt;char, sf::Texture&gt; ManualWorldTexture();\n        std::map&lt;char, sf::Texture&gt; GenerativeWorldTexture();\n\n    };\n}\n\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/_trash_interface_8hpp/","title":"File TrashInterface.hpp","text":"<p>FileList &gt; Interfaces &gt; TrashInterface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../core/Data.hpp\"</code></li> <li><code>#include \"../core/InterfaceBase.hpp\"</code></li> <li><code>#include \"../DataCollection/DataManager.hpp\"</code></li> </ul>"},{"location":"2D%20Interface%28Group%203%29/_trash_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A low-end text interface providing a bare-minimum level of interaction."},{"location":"2D%20Interface%28Group%203%29/_trash_interface_8hpp/#classes","title":"Classes","text":"Type Name class TrashInterface <p>The documentation for this class was generated from the following file <code>source/Interfaces/TrashInterface.hpp</code></p>"},{"location":"2D%20Interface%28Group%203%29/_trash_interface_8hpp_source/","title":"File TrashInterface.hpp","text":"<p>File List &gt; Interfaces &gt; TrashInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#include \"../core/Data.hpp\"\n#include \"../core/InterfaceBase.hpp\"\n#include \"../DataCollection/DataManager.hpp\"\n\nnamespace cse491 {\n\n  class TrashInterface : public InterfaceBase {\n  protected:\n    bool wait_for_input = true;  \n\n    // -- Helper Functions --\n    void DrawGrid(const WorldGrid &amp; grid, const type_options_t &amp; type_options,\n                  const item_map_t &amp; item_map, const agent_map_t &amp; agent_map)\n    {\n      std::vector&lt;std::string&gt; symbol_grid(grid.GetHeight());\n\n      // Load the world into the symbol_grid;\n      for (size_t y=0; y &lt; grid.GetHeight(); ++y) {\n        symbol_grid[y].resize(grid.GetWidth());\n        for (size_t x=0; x &lt; grid.GetWidth(); ++x) {\n          symbol_grid[y][x] = type_options[ grid.At(x,y) ].symbol;\n        }\n      }\n\n      // Add in the agents / entities\n      for (const auto &amp; [id, item_ptr] : item_map) {\n        GridPosition pos = item_ptr-&gt;GetPosition();\n\n        if (pos.IsValid() &amp;&amp; !item_ptr-&gt;IsOwned()) {\n          char c = '+';\n          if (item_ptr-&gt;HasProperty(\"symbol\")) {\n            c = item_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n          }\n          if (grid.IsValid(pos)){\n            symbol_grid[pos.CellY()][pos.CellX()] = c;\n          }\n        }\n      }\n\n      for (const auto &amp; [id, agent_ptr] : agent_map) {\n        GridPosition pos = agent_ptr-&gt;GetPosition();\n        char c = '*';\n        if(agent_ptr-&gt;HasProperty(\"symbol\")){\n          c = agent_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n        }\n        if (!agent_ptr-&gt;HasProperty(\"deleted\")){\n          symbol_grid[pos.CellY()][pos.CellX()] = c;\n        }\n      }\n\n      // Print out the symbol_grid with a box around it.\n      std::cout &lt;&lt; '+' &lt;&lt; std::string(grid.GetWidth(),'-') &lt;&lt; \"+\\n\";\n      for (const auto &amp; row : symbol_grid) {\n        std::cout &lt;&lt; \"|\";\n        for (char cell : row) {\n          // std::cout &lt;&lt; ' ' &lt;&lt; cell;\n          std::cout &lt;&lt; cell;\n        }\n        std::cout &lt;&lt; \"|\\n\";\n      }\n      std::cout &lt;&lt; '+' &lt;&lt; std::string(grid.GetWidth(),'-') &lt;&lt; \"+\\n\";\n      std::cout &lt;&lt; \"\\nYour move? \";\n      std::cout.flush();\n    }\n\n  public:\n    TrashInterface(size_t id, const std::string &amp; name) : InterfaceBase(id, name) { }\n    ~TrashInterface() = default; // Already virtual from Entity\n\n    // -- AgentBase overrides --\n\n    bool Initialize() override {\n      return true;\n    }\n\n      size_t SelectAction(const WorldGrid &amp; grid,\n                        const type_options_t &amp; type_options,\n                        const item_map_t &amp; item_map,\n                        const agent_map_t &amp; agent_map) override\n    {\n      // Update the current state of the world.\n      DrawGrid(grid, type_options, item_map, agent_map);\n\n      // See if there are any keys waiting in standard input (wait if needed)\n      char input;\n      do {\n        std::cin &gt;&gt; input;\n      } while (!std::cin &amp;&amp; wait_for_input);\n\n      // Respond to the user input...\n      size_t action_id = 0;\n      switch (input) {\n        case 'w': case 'W': action_id = GetActionID(\"up\");    break;\n        case 'a': case 'A': action_id = GetActionID(\"left\");  break;\n        case 's': case 'S': action_id = GetActionID(\"down\");  break;\n        case 'd': case 'D': action_id = GetActionID(\"right\"); break;\n        case 't': case 'T': action_id = GetActionID(\"drop\");  break;\n        case 'h': case 'H': action_id = GetActionID(\"heal\"); break;\n        // Can't have 2 cases for T, so we'll have to decide which one to change.\n        //case 't': case 'T': action_id = GetActionID(\"stats\"); break;\n        case 'c': case 'C': action_id = GetActionID(\"use_axe\"); break;\n        case 'v': case 'V': action_id = GetActionID(\"use_boat\"); break;\n        case 'f': case 'F': action_id = GetActionID(\"attack\"); break;\n        case 'g': case 'G': action_id = GetActionID(\"special\"); break;\n        case 'b': case 'B': action_id = GetActionID(\"buff\"); break;\n        case 'r': case 'R': action_id = GetActionID(\"run\"); break;\n        case 'y': case 'Y': action_id = GetActionID(\"help\"); break;\n        case 'q': case 'Q': exitCleanup(); // Quit!\n      }\n\n      // If we waited for input, but don't understand it, notify the user.\n      if (wait_for_input &amp;&amp; action_id == 0) {\n        std::cout &lt;&lt; \"Unknown key '\" &lt;&lt; input &lt;&lt; \"'.\" &lt;&lt; std::endl;\n      }\n\n      // Do the action!\n      return action_id;\n    }\n\n    void Notify(const std::string &amp; message,\n                const std::string &amp; /*msg_type*/=\"none\") override\n    {\n      std::cout &lt;&lt; message &lt;&lt; std::endl;\n    }\n  };\n\n\n} // End of namespace cse491\n\n</code></pre>"},{"location":"2D%20Interface%28Group%203%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cse491 A low-end text interface providing a bare-minimum level of interaction. </li> <li>namespace i_2D </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classes/","title":"Class Index","text":""},{"location":"2D%20Interface%28Group%203%29/classes/#b","title":"b","text":"<ul> <li>Button (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classes/#i","title":"i","text":"<ul> <li>Inventory (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classes/#m","title":"m","text":"<ul> <li>MainInterface (i_2D)</li> <li>Menu (i_2D)</li> <li>MessageBoard (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/classes/#t","title":"t","text":"<ul> <li>TextBox (i_2D)</li> <li>TextureHolder (i_2D)</li> <li>TrashInterface (cse491)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class i_2D::Button </li> <li>class i_2D::Inventory </li> <li>class i_2D::Menu </li> <li>class i_2D::MessageBoard </li> <li>class i_2D::TextBox </li> <li>class i_2D::TextureHolder </li> <li>class InterfaceBase <ul> <li>class cse491::TrashInterface </li> <li>class i_2D::MainInterface Represents the main interface for a 2D maze game. </li> </ul> </li> </ul>"},{"location":"2D%20Interface%28Group%203%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"2D%20Interface%28Group%203%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"2D%20Interface%28Group%203%29/class_members/","title":"Class Members","text":""},{"location":"2D%20Interface%28Group%203%29/class_members/#b","title":"b","text":"<ul> <li>Button (i_2D::Button)</li> <li>button (i_2D::Button)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#c","title":"c","text":"<ul> <li>ConstructInventory (i_2D::Inventory, i_2D::Menu)</li> <li>COL (i_2D::MainInterface)</li> <li>CalculateCellSize (i_2D::MainInterface)</li> <li>CalculateDrawSpace (i_2D::MainInterface)</li> <li>CheckLargerGrid (i_2D::MainInterface)</li> <li>ChooseTexture (i_2D::MainInterface)</li> <li>CreateVectorMaze (i_2D::MainInterface)</li> <li>Contains (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#d","title":"d","text":"<ul> <li>DrawGrid (cse491::TrashInterface, i_2D::MainInterface)</li> <li>DrawTo (i_2D::Button, i_2D::Inventory, i_2D::Menu, i_2D::MessageBoard, i_2D::TextBox)</li> <li>DrawAgentCell (i_2D::MainInterface)</li> <li>DrawHealthInfo (i_2D::MainInterface)</li> <li>DrawTimer (i_2D::MainInterface)</li> <li>DrawWall (i_2D::MainInterface)</li> <li>DeconstructInventory (i_2D::Menu)</li> <li>DeleteLastChar (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#g","title":"g","text":"<ul> <li>GetMenu (i_2D::Menu)</li> <li>GetText (i_2D::TextBox)</li> <li>GenerativeWorldTexture (i_2D::TextureHolder)</li> <li>GetTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#h","title":"h","text":"<ul> <li>HandleMouseMove (i_2D::Inventory, i_2D::Menu)</li> <li>HandleKeyEvent (i_2D::MainInterface)</li> <li>HandleResize (i_2D::MainInterface)</li> <li>HandleMouseButtonPressed (i_2D::Menu)</li> <li>hasLimit (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#i","title":"i","text":"<ul> <li>Initialize (cse491::TrashInterface, i_2D::MainInterface, i_2D::Menu)</li> <li>IsMouseOver (i_2D::Button)</li> <li>Inventory (i_2D::Inventory)</li> <li>IsInventoryOpen (i_2D::Menu)</li> <li>InputLogic (i_2D::TextBox)</li> <li>IsSelected (i_2D::TextBox)</li> <li>isSelected (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#l","title":"l","text":"<ul> <li>LargeDisplayGrid (i_2D::MainInterface)</li> <li>limit (i_2D::TextBox)</li> <li>LoadTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#m","title":"m","text":"<ul> <li>mCanvas (i_2D::Inventory)</li> <li>mCol (i_2D::Inventory)</li> <li>mItemDisplay (i_2D::Inventory)</li> <li>mItems (i_2D::Inventory)</li> <li>mListOfButtons (i_2D::Inventory)</li> <li>mRow (i_2D::Inventory)</li> <li>mWorldSize (i_2D::Inventory, i_2D::Menu)</li> <li>MIN_SIZE_CELL (i_2D::MainInterface)</li> <li>MainInterface (i_2D::MainInterface)</li> <li>MouseClickEvent (i_2D::MainInterface)</li> <li>mAgentInventory (i_2D::MainInterface)</li> <li>mFont (i_2D::MainInterface, i_2D::Menu)</li> <li>mGridHeight (i_2D::MainInterface)</li> <li>mGridSizeLarge (i_2D::MainInterface)</li> <li>mGridWidth (i_2D::MainInterface)</li> <li>mInputWaitTime (i_2D::MainInterface)</li> <li>mMenu (i_2D::MainInterface)</li> <li>mMessageBoard (i_2D::MainInterface)</li> <li>mPlayerPosition (i_2D::MainInterface)</li> <li>mTextBox (i_2D::MainInterface)</li> <li>mTextureHolder (i_2D::MainInterface)</li> <li>mTexturesCurrent (i_2D::MainInterface)</li> <li>mTexturesDefault (i_2D::MainInterface)</li> <li>mTexturesGenerativeWorld (i_2D::MainInterface)</li> <li>mTexturesManualWorld (i_2D::MainInterface)</li> <li>mTexturesSecondWorld (i_2D::MainInterface)</li> <li>mWindow (i_2D::MainInterface)</li> <li>mInventory (i_2D::Menu)</li> <li>mMenuBar (i_2D::Menu)</li> <li>MessageBoard (i_2D::MessageBoard)</li> <li>mStartTime (i_2D::MessageBoard)</li> <li>mText (i_2D::MessageBoard, i_2D::TextBox)</li> <li>mBorderRect (i_2D::TextBox)</li> <li>mStreamText (i_2D::TextBox)</li> <li>ManualWorldTexture (i_2D::TextureHolder)</li> <li>MazeTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#n","title":"n","text":"<ul> <li>Notify (cse491::TrashInterface, i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#r","title":"r","text":"<ul> <li>ROW (i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#s","title":"s","text":"<ul> <li>SelectAction (cse491::TrashInterface, i_2D::MainInterface)</li> <li>SetBackColor (i_2D::Button)</li> <li>SetButtonSize (i_2D::Button)</li> <li>SetFont (i_2D::Button, i_2D::TextBox)</li> <li>SetMFont (i_2D::Button)</li> <li>SetPosition (i_2D::Button, i_2D::TextBox)</li> <li>SetString (i_2D::Button, i_2D::TextBox)</li> <li>SetTextColor (i_2D::Button)</li> <li>SetItemDisplay (i_2D::Inventory)</li> <li>SetSize (i_2D::Inventory)</li> <li>SetLargeGrid (i_2D::MainInterface)</li> <li>SwitchCellSelect (i_2D::MainInterface)</li> <li>setMInputWaitTime (i_2D::MainInterface)</li> <li>SetInventoryItemDisplay (i_2D::Menu)</li> <li>SetWorldSize (i_2D::Menu)</li> <li>Send (i_2D::MessageBoard)</li> <li>SetLimit (i_2D::TextBox)</li> <li>SetSelected (i_2D::TextBox)</li> <li>SecondWorldTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#t","title":"t","text":"<ul> <li>TrashInterface (cse491::TrashInterface)</li> <li>text (i_2D::Button)</li> <li>TextBox (i_2D::TextBox)</li> <li>TypedOn (i_2D::TextBox)</li> <li>TextureHolder (i_2D::TextureHolder)</li> <li>textures_ (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#w","title":"w","text":"<ul> <li>wait_for_input (cse491::TrashInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_members/#_1","title":"~","text":"<ul> <li>~TrashInterface (cse491::TrashInterface)</li> <li>~MainInterface (i_2D::MainInterface)</li> <li>~TextureHolder (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#b","title":"b","text":"<ul> <li>Button (i_2D::Button)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#c","title":"c","text":"<ul> <li>ConstructInventory (i_2D::Inventory, i_2D::Menu)</li> <li>CalculateCellSize (i_2D::MainInterface)</li> <li>CalculateDrawSpace (i_2D::MainInterface)</li> <li>CheckLargerGrid (i_2D::MainInterface)</li> <li>ChooseTexture (i_2D::MainInterface)</li> <li>CreateVectorMaze (i_2D::MainInterface)</li> <li>Contains (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#d","title":"d","text":"<ul> <li>DrawGrid (cse491::TrashInterface, i_2D::MainInterface)</li> <li>DrawTo (i_2D::Button, i_2D::Inventory, i_2D::Menu, i_2D::MessageBoard, i_2D::TextBox)</li> <li>DrawAgentCell (i_2D::MainInterface)</li> <li>DrawHealthInfo (i_2D::MainInterface)</li> <li>DrawTimer (i_2D::MainInterface)</li> <li>DrawWall (i_2D::MainInterface)</li> <li>DeconstructInventory (i_2D::Menu)</li> <li>DeleteLastChar (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#g","title":"g","text":"<ul> <li>GetMenu (i_2D::Menu)</li> <li>GetText (i_2D::TextBox)</li> <li>GenerativeWorldTexture (i_2D::TextureHolder)</li> <li>GetTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#h","title":"h","text":"<ul> <li>HandleMouseMove (i_2D::Inventory, i_2D::Menu)</li> <li>HandleKeyEvent (i_2D::MainInterface)</li> <li>HandleResize (i_2D::MainInterface)</li> <li>HandleMouseButtonPressed (i_2D::Menu)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (cse491::TrashInterface, i_2D::MainInterface, i_2D::Menu)</li> <li>IsMouseOver (i_2D::Button)</li> <li>Inventory (i_2D::Inventory)</li> <li>IsInventoryOpen (i_2D::Menu)</li> <li>InputLogic (i_2D::TextBox)</li> <li>IsSelected (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#l","title":"l","text":"<ul> <li>LargeDisplayGrid (i_2D::MainInterface)</li> <li>LoadTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#m","title":"m","text":"<ul> <li>MainInterface (i_2D::MainInterface)</li> <li>MouseClickEvent (i_2D::MainInterface)</li> <li>MessageBoard (i_2D::MessageBoard)</li> <li>ManualWorldTexture (i_2D::TextureHolder)</li> <li>MazeTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#n","title":"n","text":"<ul> <li>Notify (cse491::TrashInterface, i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (cse491::TrashInterface, i_2D::MainInterface)</li> <li>SetBackColor (i_2D::Button)</li> <li>SetButtonSize (i_2D::Button)</li> <li>SetFont (i_2D::Button, i_2D::TextBox)</li> <li>SetMFont (i_2D::Button)</li> <li>SetPosition (i_2D::Button, i_2D::TextBox)</li> <li>SetString (i_2D::Button, i_2D::TextBox)</li> <li>SetTextColor (i_2D::Button)</li> <li>SetItemDisplay (i_2D::Inventory)</li> <li>SetSize (i_2D::Inventory)</li> <li>SetLargeGrid (i_2D::MainInterface)</li> <li>SwitchCellSelect (i_2D::MainInterface)</li> <li>setMInputWaitTime (i_2D::MainInterface)</li> <li>SetInventoryItemDisplay (i_2D::Menu)</li> <li>SetWorldSize (i_2D::Menu)</li> <li>Send (i_2D::MessageBoard)</li> <li>SetLimit (i_2D::TextBox)</li> <li>SetSelected (i_2D::TextBox)</li> <li>SecondWorldTexture (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#t","title":"t","text":"<ul> <li>TrashInterface (cse491::TrashInterface)</li> <li>TextBox (i_2D::TextBox)</li> <li>TypedOn (i_2D::TextBox)</li> <li>TextureHolder (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~TrashInterface (cse491::TrashInterface)</li> <li>~MainInterface (i_2D::MainInterface)</li> <li>~TextureHolder (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#b","title":"b","text":"<ul> <li>button (i_2D::Button)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#c","title":"c","text":"<ul> <li>COL (i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#h","title":"h","text":"<ul> <li>hasLimit (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#i","title":"i","text":"<ul> <li>isSelected (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#l","title":"l","text":"<ul> <li>limit (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#m","title":"m","text":"<ul> <li>mCanvas (i_2D::Inventory)</li> <li>mCol (i_2D::Inventory)</li> <li>mItemDisplay (i_2D::Inventory)</li> <li>mItems (i_2D::Inventory)</li> <li>mListOfButtons (i_2D::Inventory)</li> <li>mRow (i_2D::Inventory)</li> <li>mWorldSize (i_2D::Inventory, i_2D::Menu)</li> <li>MIN_SIZE_CELL (i_2D::MainInterface)</li> <li>mAgentInventory (i_2D::MainInterface)</li> <li>mFont (i_2D::MainInterface, i_2D::Menu)</li> <li>mGridHeight (i_2D::MainInterface)</li> <li>mGridSizeLarge (i_2D::MainInterface)</li> <li>mGridWidth (i_2D::MainInterface)</li> <li>mInputWaitTime (i_2D::MainInterface)</li> <li>mMenu (i_2D::MainInterface)</li> <li>mMessageBoard (i_2D::MainInterface)</li> <li>mPlayerPosition (i_2D::MainInterface)</li> <li>mTextBox (i_2D::MainInterface)</li> <li>mTextureHolder (i_2D::MainInterface)</li> <li>mTexturesCurrent (i_2D::MainInterface)</li> <li>mTexturesDefault (i_2D::MainInterface)</li> <li>mTexturesGenerativeWorld (i_2D::MainInterface)</li> <li>mTexturesManualWorld (i_2D::MainInterface)</li> <li>mTexturesSecondWorld (i_2D::MainInterface)</li> <li>mWindow (i_2D::MainInterface)</li> <li>mInventory (i_2D::Menu)</li> <li>mMenuBar (i_2D::Menu)</li> <li>mStartTime (i_2D::MessageBoard)</li> <li>mText (i_2D::MessageBoard, i_2D::TextBox)</li> <li>mBorderRect (i_2D::TextBox)</li> <li>mStreamText (i_2D::TextBox)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#r","title":"r","text":"<ul> <li>ROW (i_2D::MainInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#t","title":"t","text":"<ul> <li>text (i_2D::Button)</li> <li>textures_ (i_2D::TextureHolder)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_variables/#w","title":"w","text":"<ul> <li>wait_for_input (cse491::TrashInterface)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"2D%20Interface%28Group%203%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"2D%20Interface%28Group%203%29/namespace_members/","title":"Namespace Members","text":""},{"location":"2D%20Interface%28Group%203%29/namespace_members/#e","title":"e","text":"<ul> <li>elapsedTime (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_members/#m","title":"m","text":"<ul> <li>MAX_NUMBER_OF_ITEMS_MENU_ITEMS (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_members/#t","title":"t","text":"<ul> <li>timer (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"2D%20Interface%28Group%203%29/namespace_member_variables/#e","title":"e","text":"<ul> <li>elapsedTime (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_NUMBER_OF_ITEMS_MENU_ITEMS (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_variables/#t","title":"t","text":"<ul> <li>timer (i_2D)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"2D%20Interface%28Group%203%29/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"2D%20Interface%28Group%203%29/functions/","title":"Functions","text":""},{"location":"2D%20Interface%28Group%203%29/functions/#m","title":"m","text":"<ul> <li>MENU_BUTTON_SIZE (Menu.cpp)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/macros/","title":"Macros","text":""},{"location":"2D%20Interface%28Group%203%29/macros/#d","title":"d","text":"<ul> <li>DELETE_KEY (TextBox.hpp)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/macros/#e","title":"e","text":"<ul> <li>ENTER_KEY (TextBox.hpp)</li> <li>ESCAPE_KEY (TextBox.hpp)</li> </ul>"},{"location":"2D%20Interface%28Group%203%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"2D%20Interface%28Group%203%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Networks%20%28Group%205%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cse491 </li> <li>namespace i_2D </li> <li>namespace netWorth A networking interface that allows information to be sent across a network. <ul> <li>class ClientInterface </li> <li>class ClientManager </li> <li>class ControlledAgent </li> <li>class NetworkingInterface </li> <li>class ServerInterface </li> <li>class ServerManager </li> </ul> </li> <li>namespace sf </li> </ul>"},{"location":"Networks%20%28Group%205%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Interfaces <ul> <li>dir NetWorth <ul> <li>file NetworkInterface.hpp </li> <li>dir client <ul> <li>file ClientInterface.hpp </li> <li>file ClientManager.hpp </li> <li>file ControlledAgent.hpp </li> </ul> </li> <li>dir server <ul> <li>file ServerInterface.hpp </li> <li>file ServerManager.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"Networks%20%28Group%205%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Networks%20%28Group%205%29/namespacei__2_d/","title":"Namespace i_2D","text":"<p>Namespace List &gt; i_2D</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Networks%20%28Group%205%29/namespacenet_worth/","title":"Namespace netWorth","text":"<p>Namespace List &gt; netWorth</p> <p>A networking interface that allows information to be sent across a network. More...</p>"},{"location":"Networks%20%28Group%205%29/namespacenet_worth/#classes","title":"Classes","text":"Type Name class ClientInterface class ClientManager class ControlledAgent class NetworkingInterface class ServerInterface class ServerManager"},{"location":"Networks%20%28Group%205%29/namespacenet_worth/#detailed-description","title":"Detailed Description","text":"<p>An Agent that will walk back and forth along a row or column.</p> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROTOTYPE</p> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/","title":"Class netWorth::ClientInterface","text":"<p>ClassList &gt; netWorth &gt; ClientInterface</p> <p>Inherits the following classes: netWorth::NetworkingInterface,  MainInterface</p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#public-functions","title":"Public Functions","text":"Type Name ClientInterface (size_t id, const std::string &amp; name)  bool Initialize () override size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; typeOptions, const cse491::item_map_t &amp; itemMap, const cse491::agent_map_t &amp; agentMap) override"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#public-functions-inherited-from-networthnetworkinginterface","title":"Public Functions inherited from netWorth::NetworkingInterface","text":"<p>See netWorth::NetworkingInterface</p> Type Name NetworkingInterface (size_t id, const std::string &amp; name) the destination port of the machine this communicates with virtual bool bindSocket (UdpSocket &amp; socket, unsigned short port)  virtual UdpSocket * getSocket ()  virtual bool receivePacket (Packet &amp; pkt, std::optional&lt; IpAddress &gt; &amp; sender, unsigned short &amp; port)  virtual bool sendPacket (Packet packet, IpAddress destAddr, const unsigned short port)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#protected-attributes-inherited-from-networthnetworkinginterface","title":"Protected Attributes inherited from netWorth::NetworkingInterface","text":"<p>See netWorth::NetworkingInterface</p> Type Name std::optional&lt; IpAddress &gt; m_ip The socket we are going to make our connection. unsigned short m_port   = = 0the destination IP of the machine this communicates with UdpSocket m_socket"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#function-clientinterface","title":"function ClientInterface","text":"<pre><code>inline netWorth::ClientInterface::ClientInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#function-initialize","title":"function Initialize","text":"<pre><code>inline bool netWorth::ClientInterface::Initialize () override\n</code></pre> <p>Establish connection with server, initializing interface </p> <p>Returns:</p> <p>True if successful, false if error </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_interface/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t netWorth::ClientInterface::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; typeOptions,\n    const cse491::item_map_t &amp; itemMap,\n    const cse491::agent_map_t &amp; agentMap\n) override\n</code></pre> <p>Choose action for player agent </p> <p>Parameters:</p> <ul> <li><code>grid</code> the client-side grid </li> <li><code>typeOptions</code> different cell types of the world </li> <li><code>item_map</code> the items that may be apart of the grid </li> <li><code>agent_map</code> the agents that may be apart of the grid </li> </ul> <p>Returns:</p> <p>action ID of the interface </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/","title":"Class netWorth::ClientManager","text":"<p>ClassList &gt; netWorth &gt; ClientManager</p> <p>More...</p> <ul> <li><code>#include &lt;ClientManager.hpp&gt;</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#public-functions","title":"Public Functions","text":"Type Name ClientManager () = defaultId of client. void clearActionMap ()  size_t getActionID (size_t id)  size_t getClientID () const std::string getSerializedAgents ()  bool iDPresent (size_t id)  void packetToActionMap (sf::Packet pkt)  void setClientID (size_t id)  void setUpdatePort (unsigned short port)  void setupGameUpdateSocket (sf::UdpSocket * socket)  void setupSocket (sf::UdpSocket * socket, std::optional&lt; sf::IpAddress &gt; ip)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#detailed-description","title":"Detailed Description","text":"<p>The server that will be running and that allows clients to connect to </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-clientmanager","title":"function ClientManager","text":"<p>Id of client. </p> <pre><code>netWorth::ClientManager::ClientManager () = default\n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-clearactionmap","title":"function clearActionMap","text":"<pre><code>inline void netWorth::ClientManager::clearActionMap () \n</code></pre> <p>Clear action map after ClientInterface moves </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-getactionid","title":"function getActionID","text":"<pre><code>inline size_t netWorth::ClientManager::getActionID (\n    size_t id\n) \n</code></pre> <p>Return action ID correspoding to agent ID </p> <p>Parameters:</p> <ul> <li><code>id</code> Agent ID </li> </ul> <p>Returns:</p> <p>action ID </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-getclientid","title":"function getClientID","text":"<pre><code>inline size_t netWorth::ClientManager::getClientID () const\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-getserializedagents","title":"function getSerializedAgents","text":"<pre><code>inline std::string netWorth::ClientManager::getSerializedAgents () \n</code></pre> <p>Receive serialized agent data for midgame updates </p> <p>Returns:</p> <p>serialized data (or empty if no update) </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-idpresent","title":"function iDPresent","text":"<pre><code>inline bool netWorth::ClientManager::iDPresent (\n    size_t id\n) \n</code></pre> <p>Check if Agent ID is present in agent action map </p> <p>Parameters:</p> <ul> <li><code>id</code> Agent ID </li> </ul> <p>Returns:</p> <p>true if ID is present </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-packettoactionmap","title":"function packetToActionMap","text":"<pre><code>inline void netWorth::ClientManager::packetToActionMap (\n    sf::Packet pkt\n) \n</code></pre> <p>Turn packet from server into action map for ControlledAgents </p> <p>Parameters:</p> <ul> <li><code>pkt</code> received packet </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-setclientid","title":"function setClientID","text":"<pre><code>inline void netWorth::ClientManager::setClientID (\n    size_t id\n) \n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-setupdateport","title":"function setUpdatePort","text":"<pre><code>inline void netWorth::ClientManager::setUpdatePort (\n    unsigned short port\n) \n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-setupgameupdatesocket","title":"function setupGameUpdateSocket","text":"<pre><code>inline void netWorth::ClientManager::setupGameUpdateSocket (\n    sf::UdpSocket * socket\n) \n</code></pre> <p>Set socket for game updates </p> <p>Parameters:</p> <ul> <li><code>socket</code> pointer to socket </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_client_manager/#function-setupsocket","title":"function setupSocket","text":"<pre><code>inline void netWorth::ClientManager::setupSocket (\n    sf::UdpSocket * socket,\n    std::optional&lt; sf::IpAddress &gt; ip\n) \n</code></pre> <p>Set receiving socket for action map and IP/port info </p> <p>Parameters:</p> <ul> <li><code>socket</code> pointer to ClientInterface's socket </li> <li><code>ip</code> server IP </li> <li><code>port</code> server port </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientManager.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/","title":"Class netWorth::ControlledAgent","text":"<p>ClassList &gt; netWorth &gt; ControlledAgent</p> <p>Inherits the following classes: AgentBase</p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#public-functions","title":"Public Functions","text":"Type Name ControlledAgent (size_t id, const std::string &amp; name) Client manager to access agent action map. bool Initialize () overrideThis agent needs a specific set of actions to function. size_t SelectAction (const cse491::WorldGrid &amp;, const cse491::type_options_t &amp;, const cse491::item_map_t &amp;, const cse491::agent_map_t &amp;) overrideChoose the action to take a step in the appropriate direction."},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#function-controlledagent","title":"function ControlledAgent","text":"<pre><code>inline netWorth::ControlledAgent::ControlledAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool netWorth::ControlledAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_controlled_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t netWorth::ControlledAgent::SelectAction (\n    const cse491::WorldGrid &amp;,\n    const cse491::type_options_t &amp;,\n    const cse491::item_map_t &amp;,\n    const cse491::agent_map_t &amp;\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ControlledAgent.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/","title":"Class netWorth::NetworkingInterface","text":"<p>ClassList &gt; netWorth &gt; NetworkingInterface</p> <p>Inherits the following classes: InterfaceBase</p> <p>Inherited by the following classes: netWorth::ClientInterface,  netWorth::ServerInterface</p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#public-functions","title":"Public Functions","text":"Type Name NetworkingInterface (size_t id, const std::string &amp; name) the destination port of the machine this communicates with virtual bool bindSocket (UdpSocket &amp; socket, unsigned short port)  virtual UdpSocket * getSocket ()  virtual bool receivePacket (Packet &amp; pkt, std::optional&lt; IpAddress &gt; &amp; sender, unsigned short &amp; port)  virtual bool sendPacket (Packet packet, IpAddress destAddr, const unsigned short port)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#protected-attributes","title":"Protected Attributes","text":"Type Name std::optional&lt; IpAddress &gt; m_ip The socket we are going to make our connection. unsigned short m_port   = = 0the destination IP of the machine this communicates with UdpSocket m_socket"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-networkinginterface","title":"function NetworkingInterface","text":"<p>the destination port of the machine this communicates with </p> <pre><code>inline netWorth::NetworkingInterface::NetworkingInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-bindsocket","title":"function bindSocket","text":"<pre><code>inline virtual bool netWorth::NetworkingInterface::bindSocket (\n    UdpSocket &amp; socket,\n    unsigned short port\n) \n</code></pre> <p>Bind socket to port number </p> <p>Parameters:</p> <ul> <li><code>socket</code> Socket to be bound </li> <li><code>port</code> Port number </li> </ul> <p>Returns:</p> <p>true if successful </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-getsocket","title":"function getSocket","text":"<pre><code>inline virtual UdpSocket * netWorth::NetworkingInterface::getSocket () \n</code></pre> <p>Receives a socket that has been connected between client and server </p> <p>Returns:</p> <p>the udp socket </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-receivepacket","title":"function receivePacket","text":"<pre><code>inline virtual bool netWorth::NetworkingInterface::receivePacket (\n    Packet &amp; pkt,\n    std::optional&lt; IpAddress &gt; &amp; sender,\n    unsigned short &amp; port\n) \n</code></pre> <p>Starts the connection by receiving the first packet </p> <p>Parameters:</p> <ul> <li><code>sender</code> IP of sending machine </li> <li><code>port</code> port number of sending machine </li> </ul> <p>Returns:</p> <p>received packet </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#function-sendpacket","title":"function sendPacket","text":"<pre><code>inline virtual bool netWorth::NetworkingInterface::sendPacket (\n    Packet packet,\n    IpAddress destAddr,\n    const unsigned short port\n) \n</code></pre> <p>Sends a packet across the socket </p> <p>Parameters:</p> <ul> <li><code>packet</code> the packet we want to send </li> <li><code>destAddr</code> the destination address we want to send to </li> <li><code>port</code> the port of the connection </li> </ul> <p>Returns:</p> <p>true if successfully sent </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#variable-m_ip","title":"variable m_ip","text":"<pre><code>std::optional&lt;IpAddress&gt; m_ip;\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#variable-m_port","title":"variable m_port","text":"<pre><code>unsigned short m_port;\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_networking_interface/#variable-m_socket","title":"variable m_socket","text":"<pre><code>UdpSocket m_socket;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/NetworkInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/","title":"Class netWorth::ServerInterface","text":"<p>ClassList &gt; netWorth &gt; ServerInterface</p> <p>More...</p> <ul> <li><code>#include &lt;ServerInterface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: netWorth::NetworkingInterface</p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-functions","title":"Public Functions","text":"Type Name bool Initialize () override size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; typeOptions, const cse491::item_map_t &amp; itemMap, const cse491::agent_map_t &amp; agentMap) override ServerInterface (size_t id, const std::string &amp; name) Port used by server manager to handle world updates."},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-functions-inherited-from-networthnetworkinginterface","title":"Public Functions inherited from netWorth::NetworkingInterface","text":"<p>See netWorth::NetworkingInterface</p> Type Name NetworkingInterface (size_t id, const std::string &amp; name) the destination port of the machine this communicates with virtual bool bindSocket (UdpSocket &amp; socket, unsigned short port)  virtual UdpSocket * getSocket ()  virtual bool receivePacket (Packet &amp; pkt, std::optional&lt; IpAddress &gt; &amp; sender, unsigned short &amp; port)  virtual bool sendPacket (Packet packet, IpAddress destAddr, const unsigned short port)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-static-functions","title":"Public Static Functions","text":"Type Name Packet gridToPacket (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; typeOptions, const cse491::item_map_t &amp; itemMap, const cse491::agent_map_t &amp; agentMap)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#protected-attributes-inherited-from-networthnetworkinginterface","title":"Protected Attributes inherited from netWorth::NetworkingInterface","text":"<p>See netWorth::NetworkingInterface</p> Type Name std::optional&lt; IpAddress &gt; m_ip The socket we are going to make our connection. unsigned short m_port   = = 0the destination IP of the machine this communicates with UdpSocket m_socket"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#detailed-description","title":"Detailed Description","text":"<p>The server that will be running and that allows clients to connect to, acts as a sort of clone </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#function-initialize","title":"function Initialize","text":"<pre><code>inline bool netWorth::ServerInterface::Initialize () override\n</code></pre> <p>Function that initializes server interface </p> <p>Returns:</p> <p>boolean stating whether initialization was successful or not </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t netWorth::ServerInterface::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; typeOptions,\n    const cse491::item_map_t &amp; itemMap,\n    const cse491::agent_map_t &amp; agentMap\n) override\n</code></pre> <p>Choose action for player agent (mirror client agent) </p> <p>Parameters:</p> <ul> <li><code>grid</code> the server-side grid </li> <li><code>typeOptions</code> different cell types of the world </li> <li><code>itemMap</code> the items that may be apart of the grid </li> <li><code>agentMap</code> the agents that may be apart of the grid </li> </ul> <p>Returns:</p> <p>action ID of the interface </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#function-serverinterface","title":"function ServerInterface","text":"<p>Port used by server manager to handle world updates. </p> <pre><code>inline netWorth::ServerInterface::ServerInterface (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_interface/#function-gridtopacket","title":"function gridToPacket","text":"<pre><code>static inline Packet netWorth::ServerInterface::gridToPacket (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; typeOptions,\n    const cse491::item_map_t &amp; itemMap,\n    const cse491::agent_map_t &amp; agentMap\n) \n</code></pre> <p>The grid that will be sent to the client from the server after the connection so the client can start asking to make moves </p> <p>Parameters:</p> <ul> <li><code>grid</code> the grid to send to the server </li> <li><code>typeOptions</code> different cell types of the world </li> <li><code>itemMap</code> the items that may be apart of the grid </li> <li><code>agentMap</code> the agents that may be apart of the grid </li> </ul> <p>Returns:</p> <p>the grid that will be sent to the client </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/ServerInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/","title":"Class netWorth::ServerManager","text":"<p>ClassList &gt; netWorth &gt; ServerManager</p> <p>More...</p> <ul> <li><code>#include &lt;ServerManager.hpp&gt;</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-attributes","title":"Public Attributes","text":"Type Name unsigned short m_max_client_port   = = 55000Port for initial client connection."},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const constexpr unsigned short m_init_connection_port   = = 55000Boolean that states if there are interfaces present on the server."},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-functions","title":"Public Functions","text":"Type Name ServerManager () = defaultPort that is incremented for client thread handoff. sf::Packet actionMapToPacket ()  void addToInterfaceSet (size_t agent_id)  void addToUpdatePairs (sf::IpAddress ip, unsigned short port)  std::string getSerializedAgents ()  bool hasAgentsPresent () const void increasePort ()  void removeFromActionMap (size_t key)  void removeFromUpdatePairs (sf::IpAddress ip, unsigned short port)  void removeInterface (size_t id)  void sendGameUpdates ()  void setNewAgent (bool hasNewAgent)  void setSerializedAgents (std::string &amp; serializedAgents)  void writeToActionMap (size_t key, size_t val)"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#detailed-description","title":"Detailed Description","text":"<p>The server that will be running and that allows clients to connect to </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#variable-m_max_client_port","title":"variable m_max_client_port","text":"<pre><code>unsigned short m_max_client_port;\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#variable-m_init_connection_port","title":"variable m_init_connection_port","text":"<pre><code>const constexpr unsigned short m_init_connection_port;\n</code></pre>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-servermanager","title":"function ServerManager","text":"<p>Port that is incremented for client thread handoff. </p> <pre><code>netWorth::ServerManager::ServerManager () = default\n</code></pre> <p>Default constructor (AgentBase) </p> <p>Parameters:</p> <ul> <li><code>id</code> agent ID </li> <li><code>name</code> agent name </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-actionmaptopacket","title":"function actionMapToPacket","text":"<pre><code>inline sf::Packet netWorth::ServerManager::actionMapToPacket () \n</code></pre> <p>Convert action map to packet to send to client </p> <p>Returns:</p> <p>packet containing action map as series of integers </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-addtointerfaceset","title":"function addToInterfaceSet","text":"<pre><code>inline void netWorth::ServerManager::addToInterfaceSet (\n    size_t agent_id\n) \n</code></pre> <p>Adds and interface to the interface set </p> <p>Parameters:</p> <ul> <li><code>agent_id</code> </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-addtoupdatepairs","title":"function addToUpdatePairs","text":"<pre><code>inline void netWorth::ServerManager::addToUpdatePairs (\n    sf::IpAddress ip,\n    unsigned short port\n) \n</code></pre> <p>Adds an IP and port to a vector for group update </p> <p>Parameters:</p> <ul> <li><code>ip</code> IP address of client receiving updates </li> <li><code>port</code> port of client receiving updates </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-getserializedagents","title":"function getSerializedAgents","text":"<pre><code>inline std::string netWorth::ServerManager::getSerializedAgents () \n</code></pre> <p>Returns the current serialized agents </p> <p>Returns:</p> <p>a string of the current serialized agents </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-hasagentspresent","title":"function hasAgentsPresent","text":"<pre><code>inline bool netWorth::ServerManager::hasAgentsPresent () const\n</code></pre> <p>Returns if there are agents present on the server as a boolean </p> <p>Returns:</p> <p>boolean representing if there are agents present on the server </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-increaseport","title":"function increasePort","text":"<pre><code>inline void netWorth::ServerManager::increasePort () \n</code></pre> <p>Increases the max client port </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-removefromactionmap","title":"function removeFromActionMap","text":"<pre><code>inline void netWorth::ServerManager::removeFromActionMap (\n    size_t key\n) \n</code></pre> <p>Removes an interface from action map by key </p> <p>Parameters:</p> <ul> <li><code>key</code> </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-removefromupdatepairs","title":"function removeFromUpdatePairs","text":"<pre><code>inline void netWorth::ServerManager::removeFromUpdatePairs (\n    sf::IpAddress ip,\n    unsigned short port\n) \n</code></pre> <p>Removes ip and port from the update vector </p> <p>Parameters:</p> <ul> <li><code>ip</code> ip to remove </li> <li><code>port</code> port to remove </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-removeinterface","title":"function removeInterface","text":"<pre><code>inline void netWorth::ServerManager::removeInterface (\n    size_t id\n) \n</code></pre> <p>Removes an interface by ID </p> <p>Parameters:</p> <ul> <li><code>id</code> </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-sendgameupdates","title":"function sendGameUpdates","text":"<pre><code>inline void netWorth::ServerManager::sendGameUpdates () \n</code></pre> <p>Sends game updates to all clients when a new agent joins </p>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-setnewagent","title":"function setNewAgent","text":"<pre><code>inline void netWorth::ServerManager::setNewAgent (\n    bool hasNewAgent\n) \n</code></pre> <p>Sets a boolean stating if the server has received a new agent </p> <p>Parameters:</p> <ul> <li><code>hasNewAgent</code> boolean stating that a new agent has joined </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-setserializedagents","title":"function setSerializedAgents","text":"<pre><code>inline void netWorth::ServerManager::setSerializedAgents (\n    std::string &amp; serializedAgents\n) \n</code></pre> <p>Sets the current serialized agents of the server </p> <p>Parameters:</p> <ul> <li><code>serializedAgents</code> string reference representing the serialized agents </li> </ul>"},{"location":"Networks%20%28Group%205%29/classnet_worth_1_1_server_manager/#function-writetoactionmap","title":"function writeToActionMap","text":"<pre><code>inline void netWorth::ServerManager::writeToActionMap (\n    size_t key,\n    size_t val\n) \n</code></pre> <p>Writes to the action map </p> <p>Parameters:</p> <ul> <li><code>key</code> to reference </li> <li><code>val</code> to write </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/ServerManager.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/namespacesf/","title":"Namespace sf","text":"<p>Namespace List &gt; sf</p> <p>More...</p>"},{"location":"Networks%20%28Group%205%29/namespacesf/#detailed-description","title":"Detailed Description","text":"<p>The interface of our client that will be interacting and connection with our server </p> <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Networks%20%28Group%205%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Interfaces <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Networks%20%28Group%205%29/dir_e52260c07c5ca641bf485ae92612dd08/","title":"Dir source/Interfaces","text":"<p>FileList &gt; Interfaces</p>"},{"location":"Networks%20%28Group%205%29/dir_e52260c07c5ca641bf485ae92612dd08/#directories","title":"Directories","text":"Type Name dir NetWorth <p>The documentation for this class was generated from the following file <code>source/Interfaces/</code></p>"},{"location":"Networks%20%28Group%205%29/dir_0121daa1f68cbca759acb74b3e906cff/","title":"Dir source/Interfaces/NetWorth","text":"<p>FileList &gt; Interfaces &gt; NetWorth</p>"},{"location":"Networks%20%28Group%205%29/dir_0121daa1f68cbca759acb74b3e906cff/#files","title":"Files","text":"Type Name file NetworkInterface.hpp"},{"location":"Networks%20%28Group%205%29/dir_0121daa1f68cbca759acb74b3e906cff/#directories","title":"Directories","text":"Type Name dir client dir server <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/</code></p>"},{"location":"Networks%20%28Group%205%29/_network_interface_8hpp/","title":"File NetworkInterface.hpp","text":"<p>FileList &gt; Interfaces &gt; NetWorth &gt; NetworkInterface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;SFML/Network/UdpSocket.hpp&gt;</code></li> <li><code>#include &lt;SFML/Network/Packet.hpp&gt;</code></li> <li><code>#include \"../../core/InterfaceBase.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_network_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_network_interface_8hpp/#classes","title":"Classes","text":"Type Name class NetworkingInterface <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/NetworkInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_network_interface_8hpp_source/","title":"File NetworkInterface.hpp","text":"<p>File List &gt; Interfaces &gt; NetWorth &gt; NetworkInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n#include &lt;SFML/Network/UdpSocket.hpp&gt;\n#include &lt;SFML/Network/Packet.hpp&gt;\n#include \"../../core/InterfaceBase.hpp\"\n\nnamespace netWorth{\n\n    using namespace sf;\n\n    class NetworkingInterface : public virtual cse491::InterfaceBase {\n        private:\n\n        protected:\n            UdpSocket m_socket;             \n            std::optional&lt;IpAddress&gt; m_ip;  \n            unsigned short m_port = 0;      \n\n        public:\n            NetworkingInterface(size_t id, const std::string &amp; name) : cse491::InterfaceBase(id, name) {\n\n            }\n\n            virtual UdpSocket * getSocket(){\n                return &amp;m_socket;\n            }\n\n            virtual bool bindSocket(UdpSocket &amp;socket, unsigned short port) {\n                std::cout &lt;&lt; \"Binding socket on port: \" &lt;&lt; port &lt;&lt; std::endl;\n                if (socket.bind(port) != Socket::Status::Done) {\n                    std::cerr &lt;&lt; \"Failed to bind socket\" &lt;&lt; std::endl;\n                    return false;\n                }\n                return true;\n            }\n\n            virtual bool sendPacket(Packet packet, IpAddress destAddr, const unsigned short port){\n                if (m_socket.send(packet, destAddr, port) != Socket::Status::Done) {\n                    std::cerr &lt;&lt; \"Could not connect to\" &lt;&lt; destAddr &lt;&lt; \" at port \" &lt;&lt; port &lt;&lt; std::endl;\n                    return false;\n                }\n                return true;\n            }\n\n            virtual bool receivePacket(Packet &amp; pkt, std::optional&lt;IpAddress&gt; &amp;sender, unsigned short &amp;port){\n                if (m_socket.receive(pkt, sender,port) != Socket::Status::Done) {\n                    std::cerr &lt;&lt; \"Failed to receive\" &lt;&lt; std::endl;\n                    return false;\n                }\n                return true;\n            }\n\n        }; // End of NetworkingInterface\n} // End of namespace netWorth\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/dir_d63376ef77eb621cc9b73f8097e771f8/","title":"Dir source/Interfaces/NetWorth/client","text":"<p>FileList &gt; client</p>"},{"location":"Networks%20%28Group%205%29/dir_d63376ef77eb621cc9b73f8097e771f8/#files","title":"Files","text":"Type Name file ClientInterface.hpp file ClientManager.hpp file ControlledAgent.hpp <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/</code></p>"},{"location":"Networks%20%28Group%205%29/_client_interface_8hpp/","title":"File ClientInterface.hpp","text":"<p>FileList &gt; client &gt; ClientInterface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Interfaces/NetWorth/NetworkInterface.hpp\"</code></li> <li><code>#include \"Interfaces/TrashInterface.hpp\"</code></li> <li><code>#include \"Interfaces/MainInterface.hpp\"</code></li> <li><code>#include \"ClientManager.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_client_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network. namespace sf"},{"location":"Networks%20%28Group%205%29/_client_interface_8hpp/#classes","title":"Classes","text":"Type Name class ClientInterface <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_client_interface_8hpp_source/","title":"File ClientInterface.hpp","text":"<p>File List &gt; client &gt; ClientInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"Interfaces/NetWorth/NetworkInterface.hpp\"\n#include \"Interfaces/TrashInterface.hpp\"\n#include \"Interfaces/MainInterface.hpp\"\n#include \"ClientManager.hpp\"\n\nnamespace netWorth{\n    using namespace sf;\n\n    class ClientInterface : public NetworkingInterface, i_2D::MainInterface {\n        private:\n            netWorth::ClientManager *m_manager = nullptr;\n\n        protected:\n\n        public:\n            ClientInterface(size_t id, const std::string &amp; name) : cse491::InterfaceBase(id, name),\n                                                                   NetworkingInterface(id, name),\n                                                                   i_2D::MainInterface(id, name) {}\n\n            bool Initialize() override {\n                // resolve port and IP from entity properties\n                m_ip = sf::IpAddress::resolve(NetworkingInterface::GetProperty&lt;std::string&gt;(\"server_ip\"));\n                m_port = NetworkingInterface::GetProperty&lt;unsigned short&gt;(\"server_port\");\n                m_manager = GetProperty&lt;netWorth::ClientManager *&gt;(\"manager\");\n                m_manager-&gt;setupSocket(&amp;m_socket, m_ip);\n                m_manager-&gt;setClientID(id);\n\n                Packet sendPkt, recvPkt,twoPkt;\n                setMInputWaitTime(0.25f);\n\n                // send request message\n                sendPkt &lt;&lt; \"New client requesting connection.\";\n                auto ip = m_ip.value();\n                if (!sendPacket(sendPkt, ip, m_port)) return false;\n\n                // receive from server\n                if (!receivePacket(recvPkt, m_ip, m_port)) return false;\n                // print received string (Connection established.)\n                std::string msg;\n                recvPkt &gt;&gt; msg;\n                std::cout &lt;&lt; msg &lt;&lt; std::endl;\n\n                // request map to start send/receive loop\n                sendPkt.clear();\n                sendPkt &lt;&lt; \"Requesting start\";\n                if (!sendPacket(sendPkt, m_ip.value(), m_port)) return false;\n\n\n                // receive action map from server for previous agents\n                receivePacket(recvPkt, m_ip, m_port);\n                m_manager-&gt;packetToActionMap(recvPkt);\n\n                return true;\n            }\n\n            size_t SelectAction(const cse491::WorldGrid &amp; grid,\n                                const cse491::type_options_t &amp; typeOptions,\n                                const cse491::item_map_t &amp; itemMap,\n                                const cse491::agent_map_t &amp; agentMap) override\n            {\n                // Receive and draw map\n                sf::Packet sendPkt, recvPkt;\n\n                // grab action ID from MainInterface\n                size_t actionID = i_2D::MainInterface::SelectAction(grid, typeOptions,\n                            itemMap, agentMap);\n\n                // Send instruction to server\n                sendPkt &lt;&lt; static_cast&lt;uint64_t&gt;(actionID);\n                sendPacket(sendPkt, m_ip.value(), m_port);\n\n                m_manager-&gt;clearActionMap();\n                DrawGrid(grid, typeOptions, itemMap, agentMap);\n\n                // await action map from server\n                receivePacket(recvPkt, m_ip, m_port);\n                m_manager-&gt;packetToActionMap(recvPkt);\n\n                // Do the action!\n                return actionID;\n            }\n\n    }; // End of ClientInterface\n} // End of namespace NetWorth\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/_client_manager_8hpp/","title":"File ClientManager.hpp","text":"<p>FileList &gt; client &gt; ClientManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_client_manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_client_manager_8hpp/#classes","title":"Classes","text":"Type Name class ClientManager <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ClientManager.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_client_manager_8hpp_source/","title":"File ClientManager.hpp","text":"<p>File List &gt; client &gt; ClientManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n\nnamespace netWorth{\n    using namespace sf;\n\n    class ClientManager {\n    private:\n        sf::UdpSocket *m_socket = nullptr;                \n        sf::UdpSocket *m_game_update_socket = nullptr;    \n        std::optional&lt;sf::IpAddress&gt; m_ip;      \n        unsigned short m_update_port = 0; \n        std::unordered_map&lt;size_t, size_t&gt; m_action_map;     \n        size_t m_client_id = 0;     \n    protected:\n\n    public:\n\n        ClientManager()= default;\n\n        void setUpdatePort(unsigned short port) {m_update_port = port;}\n\n        void packetToActionMap(sf::Packet pkt) {\n            uint64_t dataSize, agentID, actionID;\n            pkt &gt;&gt; dataSize;\n            for (size_t i = 0; i &lt; dataSize; i++) {\n                pkt &gt;&gt; agentID &gt;&gt; actionID;\n                m_action_map[agentID] = actionID;\n            }\n        }\n\n        void setupSocket(sf::UdpSocket *socket, std::optional&lt;sf::IpAddress&gt; ip) {\n            m_socket = socket;\n            m_ip = ip;\n        }\n\n        void setupGameUpdateSocket(sf::UdpSocket *socket) {\n            m_game_update_socket = socket;\n            m_game_update_socket-&gt;setBlocking(false);\n            if (m_game_update_socket-&gt;bind(m_update_port) != Socket::Status::Done){\n                std::cerr &lt;&lt; \"Failed to setup game update socket\" &lt;&lt; std::endl;\n            }\n        }\n\n        bool iDPresent(size_t id) {\n            return m_action_map.contains(id);\n        }\n\n        size_t getActionID(size_t id) {\n            return m_action_map[id];\n        }\n\n        void clearActionMap() {\n            m_action_map.clear();\n        }\n\n        std::string getSerializedAgents() {\n            sf::Packet recvPkt;\n            std::optional&lt;sf::IpAddress&gt; tempIP;\n            unsigned short tempPort;\n            if (m_game_update_socket-&gt;receive(recvPkt, tempIP, tempPort) == sf::Socket::Status::Done) {\n                std::string data;\n                recvPkt &gt;&gt; data;\n                return data;\n            }\n            return \"\";\n        }\n\n\n        void setClientID(size_t id) {\n            m_client_id = id;\n        }\n\n        size_t getClientID() const{\n            return m_client_id;\n        }\n\n    }; // End of class ClientManager\n} // End of namespace netWorth\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/_controlled_agent_8hpp/","title":"File ControlledAgent.hpp","text":"<p>FileList &gt; client &gt; ControlledAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"../../../core/AgentBase.hpp\"</code></li> <li><code>#include \"ClientManager.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_controlled_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_controlled_agent_8hpp/#classes","title":"Classes","text":"Type Name class ControlledAgent <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/client/ControlledAgent.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_controlled_agent_8hpp_source/","title":"File ControlledAgent.hpp","text":"<p>File List &gt; client &gt; ControlledAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"../../../core/AgentBase.hpp\"\n#include \"ClientManager.hpp\"\n\nnamespace netWorth\n{\n\n    class ControlledAgent : public cse491::AgentBase\n    {\n    private:\n        ClientManager* m_manager = nullptr;       \n\n    protected:\n\n    public:\n        ControlledAgent(size_t id, const std::string&amp; name) : AgentBase(id, name)\n        {\n        }\n\n        bool Initialize() override\n        {\n            m_manager = GetProperty&lt;ClientManager*&gt;(\"manager\");\n            return HasAction(\"up\") &amp;&amp; HasAction(\"down\") &amp;&amp; HasAction(\"left\") &amp;&amp; HasAction(\"right\");\n        }\n\n        size_t SelectAction(const cse491::WorldGrid&amp; /* grid*/,\n            const cse491::type_options_t&amp; /* type_options*/,\n            const cse491::item_map_t&amp; /* item_map*/,\n            const cse491::agent_map_t&amp; /* agent_map*/) override\n        {\n            if (!m_manager-&gt;iDPresent(id))\n            {\n                return 0;\n            }\n            return m_manager-&gt;getActionID(id);\n        }\n\n    };\n\n} // End of namespace cse491\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/dir_1ea711888d2c31b2ee5b33ee0d19cbd8/","title":"Dir source/Interfaces/NetWorth/server","text":"<p>FileList &gt; Interfaces &gt; NetWorth &gt; server</p>"},{"location":"Networks%20%28Group%205%29/dir_1ea711888d2c31b2ee5b33ee0d19cbd8/#files","title":"Files","text":"Type Name file ServerInterface.hpp file ServerManager.hpp <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/</code></p>"},{"location":"Networks%20%28Group%205%29/_server_interface_8hpp/","title":"File ServerInterface.hpp","text":"<p>FileList &gt; Interfaces &gt; NetWorth &gt; server &gt; ServerInterface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ServerManager.hpp\"</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"Interfaces/NetWorth/NetworkInterface.hpp\"</code></li> <li><code>#include \"Worlds/MazeWorld.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_server_interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_server_interface_8hpp/#classes","title":"Classes","text":"Type Name class ServerInterface <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/ServerInterface.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_server_interface_8hpp_source/","title":"File ServerInterface.hpp","text":"<p>File List &gt; Interfaces &gt; NetWorth &gt; server &gt; ServerInterface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"ServerManager.hpp\"\n#include &lt;thread&gt;\n#include &lt;sstream&gt;\n#include \"Interfaces/NetWorth/NetworkInterface.hpp\"\n#include \"Worlds/MazeWorld.hpp\"\n\nnamespace netWorth\n{\n    using namespace sf;\n\n    class ServerInterface : public NetworkingInterface\n    {\n    private:\n        ServerManager* m_manager = nullptr; \n\n        unsigned short m_world_update_port = 0;  \n    protected:\n\n    public:\n        ServerInterface(size_t id, const std::string&amp; name)\n            : cse491::InterfaceBase(id, name),\n              NetworkingInterface(id, name)\n        {\n\n        }\n\n        bool Initialize() override\n        {\n            // resolve port and IP from entity properties\n            m_ip = sf::IpAddress::resolve(NetworkingInterface::GetProperty&lt;std::string&gt;(\"client_ip\"));\n            m_world_update_port = NetworkingInterface::GetProperty&lt;unsigned short&gt;(\"client_port\");\n            m_manager = GetProperty&lt;netWorth::ServerManager*&gt;(\"server_manager\");\n\n            Packet sendPkt, recvPkt;\n            std::string str;\n\n            bindSocket(m_socket, GetProperty&lt;unsigned short&gt;(\"server_port\"));\n\n            // Await client\n            if (!receivePacket(recvPkt, m_ip, m_port))\n                return false;\n\n            std::cout &lt;&lt; m_ip.value() &lt;&lt; \" has connected successfully.\" &lt;&lt; std::endl;\n\n            // Acknowledge client\n            sendPkt &lt;&lt; \"Connection established.\";\n            if (!sendPacket(sendPkt, m_ip.value(), m_port))\n                return false;\n\n            recvPkt.clear();\n            // await request for map\n            if (!receivePacket(recvPkt, m_ip, m_port))\n                return false;\n\n            GetWorld().SetWorldRunning(true);\n            return true;\n        }\n\n        static Packet gridToPacket(const cse491::WorldGrid&amp; grid,\n            const cse491::type_options_t&amp; typeOptions,\n            const cse491::item_map_t&amp; itemMap,\n            const cse491::agent_map_t&amp; agentMap)\n        {\n            std::vector&lt;std::string&gt; packetGrid(grid.GetHeight());\n\n            // Load the world into the symbol_grid;\n            for (size_t y = 0; y &lt; grid.GetHeight(); ++y)\n            {\n                packetGrid[y].resize(grid.GetWidth());\n                for (size_t x = 0; x &lt; grid.GetWidth(); ++x)\n                {\n                    packetGrid[y][x] = typeOptions[grid.At(x, y)].symbol;\n                }\n            }\n\n            // Add in the agents / entities\n            for (const auto&amp; [id, entityPtr] : itemMap)\n            {\n                cse491::GridPosition pos = entityPtr-&gt;GetPosition();\n        if(!std::isnan(pos.GetX()) &amp;&amp; !std::isnan(pos.GetY())\n            &amp;&amp; pos.CellX() &lt; grid.GetWidth() &amp;&amp; pos.CellY() &lt; grid.GetHeight()){\n          packetGrid[pos.CellY()][pos.CellX()] = '+';\n        }\n            }\n\n            for (const auto&amp; [id, agent_ptr] : agentMap)\n            {\n                cse491::GridPosition pos = agent_ptr-&gt;GetPosition();\n                char c = '*';\n                if (agent_ptr-&gt;HasProperty(\"symbol\"))\n                {\n                    c = agent_ptr-&gt;GetProperty&lt;char&gt;(\"symbol\");\n                }\n        if(!std::isnan(pos.GetX()) &amp;&amp; !std::isnan(pos.GetY())\n            &amp;&amp; pos.CellX() &lt; grid.GetWidth() &amp;&amp; pos.CellY() &lt; grid.GetHeight()){\n                  packetGrid[pos.CellY()][pos.CellX()] = c;\n        }\n            }\n\n            // Print out the symbol_grid with a box around it.\n            std::ostringstream oss;\n            oss &lt;&lt; '+' &lt;&lt; std::string(grid.GetWidth(), '-') &lt;&lt; \"+\\n\";\n            for (const auto&amp; row : packetGrid)\n            {\n                oss &lt;&lt; \"|\";\n                for (char cell : row)\n                {\n                    oss &lt;&lt; cell;\n                }\n                oss &lt;&lt; \"|\\n\";\n            }\n            oss &lt;&lt; '+' &lt;&lt; std::string(grid.GetWidth(), '-') &lt;&lt; \"+\\n\";\n            std::string gridString = oss.str();\n\n            Packet gridPacket;\n            gridPacket &lt;&lt; gridString;\n\n            return gridPacket;\n        }\n\n        size_t SelectAction(const cse491::WorldGrid&amp; grid,\n            const cse491::type_options_t&amp; typeOptions,\n            const cse491::item_map_t&amp; itemMap,\n            const cse491::agent_map_t&amp; agentMap) override\n        {\n            // send action map to client\n            sf::Packet sendPkt = m_manager-&gt;actionMapToPacket();\n            std::cout &lt;&lt; \"Sending action map to \" &lt;&lt; m_ip.value().toString() &lt;&lt; \" on port \" &lt;&lt; m_port &lt;&lt; std::endl;\n            sendPacket(sendPkt, m_ip.value(), m_port);\n\n            // print server-side map (for test purposes)\n            sf::Packet mapPkt = gridToPacket(grid, typeOptions, itemMap, agentMap);\n            std::string map;\n            mapPkt &gt;&gt; map;\n            std::cout &lt;&lt; map &lt;&lt; std::endl;\n\n            // receive player input\n            sf::Packet recvPkt;\n            uint64_t actionID;\n            receivePacket(recvPkt, m_ip, m_port);\n            recvPkt &gt;&gt; actionID;\n\n            // handle leaving client\n            if (actionID == 9999)\n            {\n                m_manager-&gt;removeInterface(GetID());\n                m_manager-&gt;removeFromActionMap(GetID());\n                m_manager-&gt;removeFromUpdatePairs(m_ip.value(), m_world_update_port);\n            }\n\n            // return actionId\n            return actionID;\n        }\n\n    }; // End of class ServerInterface\n// End of namespace netWorth\n}\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/_server_manager_8hpp/","title":"File ServerManager.hpp","text":"<p>FileList &gt; Interfaces &gt; NetWorth &gt; server &gt; ServerManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Interfaces/NetWorth/NetworkInterface.hpp\"</code></li> </ul>"},{"location":"Networks%20%28Group%205%29/_server_manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace netWorth A networking interface that allows information to be sent across a network."},{"location":"Networks%20%28Group%205%29/_server_manager_8hpp/#classes","title":"Classes","text":"Type Name class ServerManager <p>The documentation for this class was generated from the following file <code>source/Interfaces/NetWorth/server/ServerManager.hpp</code></p>"},{"location":"Networks%20%28Group%205%29/_server_manager_8hpp_source/","title":"File ServerManager.hpp","text":"<p>File List &gt; Interfaces &gt; NetWorth &gt; server &gt; ServerManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n#include &lt;thread&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include \"Interfaces/NetWorth/NetworkInterface.hpp\"\n\nnamespace netWorth{\n    using namespace sf;\n\n    class ServerManager {\n    private:\n\n        sf::UdpSocket m_manager_socket;\n\n        std::set&lt;size_t&gt; m_interface_set;   \n\n        std::map&lt;size_t, size_t&gt; m_action_map; \n\n        std::string m_current_serialized_agents; \n\n        std::vector&lt;std::pair&lt;sf::IpAddress, unsigned short&gt;&gt; m_update_vec; \n\n        bool m_has_new_agent = false; \n\n        bool m_interfaces_present = false; \n\n    protected:\n\n    public:\n        const static constexpr unsigned short m_init_connection_port = 55000; \n\n        unsigned short m_max_client_port = 55000; \n\n        ServerManager() = default;\n\n        std::string getSerializedAgents(){return m_current_serialized_agents;}\n\n        void setSerializedAgents(std::string &amp; serializedAgents) { m_current_serialized_agents = serializedAgents;}\n\n        [[nodiscard]] bool hasAgentsPresent() const {return m_interfaces_present;}\n\n        void setNewAgent(bool hasNewAgent){ m_has_new_agent = hasNewAgent;}\n\n        sf::Packet actionMapToPacket()\n        {\n            sf::Packet pkt;\n\n            // serialize action map\n            pkt &lt;&lt; static_cast&lt;uint64_t&gt;(m_action_map.size());\n            for (auto [agent_id, action_id]: m_action_map) {\n                pkt &lt;&lt; static_cast&lt;uint64_t&gt;(agent_id) &lt;&lt; static_cast&lt;uint64_t&gt;(action_id);\n            }\n\n            return pkt;\n        }\n\n        void increasePort(){++m_max_client_port;}\n\n        void removeInterface(size_t id){\n            m_interface_set.erase(id);\n            if (m_interface_set.empty()) m_interfaces_present = false;\n        }\n\n        void addToUpdatePairs(sf::IpAddress ip, unsigned short port){\n            m_update_vec.emplace_back(ip, port);\n        }\n\n         void sendGameUpdates(){\n            if (m_has_new_agent)\n            {\n                sf::Packet serializedAgentPkt;\n                serializedAgentPkt &lt;&lt; getSerializedAgents();\n                //Loops through all pairs of IP and port and sends serialized agents\n                for (auto client: m_update_vec){\n                    std::cout &lt;&lt; \"sending game updates to IP: \" &lt;&lt; client.first.toString() &lt;&lt; \" with port \" &lt;&lt;\n                    client.second &lt;&lt; std::endl;\n                    if (m_manager_socket.send(serializedAgentPkt, client.first, client.second) != sf::Socket::Status::Done) {\n                        std::cerr &lt;&lt; \"Error sending updates to client at \" &lt;&lt; client.first.toString() &lt;&lt; \" port \" &lt;&lt; client.second &lt;&lt; std::endl;\n                    }\n                }\n                m_has_new_agent = false;\n            }\n        }\n\n        void removeFromActionMap(size_t key){\n            m_action_map.erase(key);\n        }\n\n        void removeFromUpdatePairs(sf::IpAddress ip, unsigned short port){\n            m_update_vec.erase(std::remove_if(m_update_vec.begin(), m_update_vec.end(),\n                [ip, port](std::pair&lt;sf::IpAddress, unsigned short&gt; pair){\n                return (pair.first == ip &amp;&amp; pair.second == port);\n            }), m_update_vec.end());\n        }\n\n        void writeToActionMap(size_t key, size_t val){\n            m_action_map.insert_or_assign(key, val);\n        }\n\n        void addToInterfaceSet(size_t agent_id){\n            m_interface_set.insert(agent_id);\n            m_interfaces_present = true;\n        }\n\n    }; // End of class ServerManager\n} // End of namespace netWorth\n\n</code></pre>"},{"location":"Networks%20%28Group%205%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cse491 </li> <li>namespace i_2D </li> <li>namespace netWorth A networking interface that allows information to be sent across a network. </li> <li>namespace sf </li> </ul>"},{"location":"Networks%20%28Group%205%29/classes/","title":"Class Index","text":""},{"location":"Networks%20%28Group%205%29/classes/#c","title":"c","text":"<ul> <li>ClientInterface (netWorth)</li> <li>ClientManager (netWorth)</li> <li>ControlledAgent (netWorth)</li> </ul>"},{"location":"Networks%20%28Group%205%29/classes/#n","title":"n","text":"<ul> <li>NetworkingInterface (netWorth)</li> </ul>"},{"location":"Networks%20%28Group%205%29/classes/#s","title":"s","text":"<ul> <li>ServerInterface (netWorth)</li> <li>ServerManager (netWorth)</li> </ul>"},{"location":"Networks%20%28Group%205%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class netWorth::ClientManager </li> <li>class netWorth::ServerManager </li> <li>class InterfaceBase <ul> <li>class netWorth::NetworkingInterface <ul> <li>class netWorth::ClientInterface </li> <li>class netWorth::ServerInterface </li> </ul> </li> <li>class netWorth::NetworkingInterface <ul> <li>class netWorth::ClientInterface </li> <li>class netWorth::ServerInterface </li> </ul> </li> <li>class netWorth::NetworkingInterface <ul> <li>class netWorth::ClientInterface </li> <li>class netWorth::ServerInterface </li> </ul> </li> </ul> </li> <li>class MainInterface <ul> <li>class netWorth::ClientInterface </li> </ul> </li> <li>class AgentBase <ul> <li>class netWorth::ControlledAgent </li> </ul> </li> </ul>"},{"location":"Networks%20%28Group%205%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Networks%20%28Group%205%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Networks%20%28Group%205%29/class_members/","title":"Class Members","text":""},{"location":"Networks%20%28Group%205%29/class_members/#a","title":"a","text":"<ul> <li>actionMapToPacket (netWorth::ServerManager)</li> <li>addToInterfaceSet (netWorth::ServerManager)</li> <li>addToUpdatePairs (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#b","title":"b","text":"<ul> <li>bindSocket (netWorth::NetworkingInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#c","title":"c","text":"<ul> <li>ClientInterface (netWorth::ClientInterface)</li> <li>ClientManager (netWorth::ClientManager)</li> <li>clearActionMap (netWorth::ClientManager)</li> <li>ControlledAgent (netWorth::ControlledAgent)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#g","title":"g","text":"<ul> <li>getActionID (netWorth::ClientManager)</li> <li>getClientID (netWorth::ClientManager)</li> <li>getSerializedAgents (netWorth::ClientManager, netWorth::ServerManager)</li> <li>getSocket (netWorth::NetworkingInterface)</li> <li>gridToPacket (netWorth::ServerInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#h","title":"h","text":"<ul> <li>hasAgentsPresent (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#i","title":"i","text":"<ul> <li>Initialize (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>iDPresent (netWorth::ClientManager)</li> <li>increasePort (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#m","title":"m","text":"<ul> <li>m_manager (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>m_action_map (netWorth::ClientManager, netWorth::ServerManager)</li> <li>m_client_id (netWorth::ClientManager)</li> <li>m_game_update_socket (netWorth::ClientManager)</li> <li>m_ip (netWorth::ClientManager, netWorth::NetworkingInterface)</li> <li>m_socket (netWorth::ClientManager, netWorth::NetworkingInterface)</li> <li>m_update_port (netWorth::ClientManager)</li> <li>m_port (netWorth::NetworkingInterface)</li> <li>m_world_update_port (netWorth::ServerInterface)</li> <li>m_current_serialized_agents (netWorth::ServerManager)</li> <li>m_has_new_agent (netWorth::ServerManager)</li> <li>m_init_connection_port (netWorth::ServerManager)</li> <li>m_interface_set (netWorth::ServerManager)</li> <li>m_interfaces_present (netWorth::ServerManager)</li> <li>m_manager_socket (netWorth::ServerManager)</li> <li>m_max_client_port (netWorth::ServerManager)</li> <li>m_update_vec (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#n","title":"n","text":"<ul> <li>NetworkingInterface (netWorth::NetworkingInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#p","title":"p","text":"<ul> <li>packetToActionMap (netWorth::ClientManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#r","title":"r","text":"<ul> <li>receivePacket (netWorth::NetworkingInterface)</li> <li>removeFromActionMap (netWorth::ServerManager)</li> <li>removeFromUpdatePairs (netWorth::ServerManager)</li> <li>removeInterface (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#s","title":"s","text":"<ul> <li>SelectAction (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>setClientID (netWorth::ClientManager)</li> <li>setUpdatePort (netWorth::ClientManager)</li> <li>setupGameUpdateSocket (netWorth::ClientManager)</li> <li>setupSocket (netWorth::ClientManager)</li> <li>sendPacket (netWorth::NetworkingInterface)</li> <li>ServerInterface (netWorth::ServerInterface)</li> <li>ServerManager (netWorth::ServerManager)</li> <li>sendGameUpdates (netWorth::ServerManager)</li> <li>setNewAgent (netWorth::ServerManager)</li> <li>setSerializedAgents (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_members/#w","title":"w","text":"<ul> <li>writeToActionMap (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Networks%20%28Group%205%29/class_member_functions/#a","title":"a","text":"<ul> <li>actionMapToPacket (netWorth::ServerManager)</li> <li>addToInterfaceSet (netWorth::ServerManager)</li> <li>addToUpdatePairs (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#b","title":"b","text":"<ul> <li>bindSocket (netWorth::NetworkingInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#c","title":"c","text":"<ul> <li>ClientInterface (netWorth::ClientInterface)</li> <li>ClientManager (netWorth::ClientManager)</li> <li>clearActionMap (netWorth::ClientManager)</li> <li>ControlledAgent (netWorth::ControlledAgent)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#g","title":"g","text":"<ul> <li>getActionID (netWorth::ClientManager)</li> <li>getClientID (netWorth::ClientManager)</li> <li>getSerializedAgents (netWorth::ClientManager, netWorth::ServerManager)</li> <li>getSocket (netWorth::NetworkingInterface)</li> <li>gridToPacket (netWorth::ServerInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#h","title":"h","text":"<ul> <li>hasAgentsPresent (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>iDPresent (netWorth::ClientManager)</li> <li>increasePort (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#n","title":"n","text":"<ul> <li>NetworkingInterface (netWorth::NetworkingInterface)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#p","title":"p","text":"<ul> <li>packetToActionMap (netWorth::ClientManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#r","title":"r","text":"<ul> <li>receivePacket (netWorth::NetworkingInterface)</li> <li>removeFromActionMap (netWorth::ServerManager)</li> <li>removeFromUpdatePairs (netWorth::ServerManager)</li> <li>removeInterface (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>setClientID (netWorth::ClientManager)</li> <li>setUpdatePort (netWorth::ClientManager)</li> <li>setupGameUpdateSocket (netWorth::ClientManager)</li> <li>setupSocket (netWorth::ClientManager)</li> <li>sendPacket (netWorth::NetworkingInterface)</li> <li>ServerInterface (netWorth::ServerInterface)</li> <li>ServerManager (netWorth::ServerManager)</li> <li>sendGameUpdates (netWorth::ServerManager)</li> <li>setNewAgent (netWorth::ServerManager)</li> <li>setSerializedAgents (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_functions/#w","title":"w","text":"<ul> <li>writeToActionMap (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Networks%20%28Group%205%29/class_member_variables/#m","title":"m","text":"<ul> <li>m_manager (netWorth::ClientInterface, netWorth::ControlledAgent, netWorth::ServerInterface)</li> <li>m_action_map (netWorth::ClientManager, netWorth::ServerManager)</li> <li>m_client_id (netWorth::ClientManager)</li> <li>m_game_update_socket (netWorth::ClientManager)</li> <li>m_ip (netWorth::ClientManager, netWorth::NetworkingInterface)</li> <li>m_socket (netWorth::ClientManager, netWorth::NetworkingInterface)</li> <li>m_update_port (netWorth::ClientManager)</li> <li>m_port (netWorth::NetworkingInterface)</li> <li>m_world_update_port (netWorth::ServerInterface)</li> <li>m_current_serialized_agents (netWorth::ServerManager)</li> <li>m_has_new_agent (netWorth::ServerManager)</li> <li>m_init_connection_port (netWorth::ServerManager)</li> <li>m_interface_set (netWorth::ServerManager)</li> <li>m_interfaces_present (netWorth::ServerManager)</li> <li>m_manager_socket (netWorth::ServerManager)</li> <li>m_max_client_port (netWorth::ServerManager)</li> <li>m_update_vec (netWorth::ServerManager)</li> </ul>"},{"location":"Networks%20%28Group%205%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Networks%20%28Group%205%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Networks%20%28Group%205%29/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Networks%20%28Group%205%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Networks%20%28Group%205%29/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Networks%20%28Group%205%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Networks%20%28Group%205%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cowboys An Agent based on genetic programming. <ul> <li>class CGPAgent An agent based on cartesian genetic programming. </li> <li>class CGPGenotype Holds all the information that uniquely defines a cartesian graph. </li> <li>struct CGPNodeGene Holds the representation of a cartesian graph node. </li> <li>struct CGPParameters Holds the parameters that define the structure of a cartesian graph. </li> <li>class GPAgent </li> <li>class GPAgentAnalyzer </li> <li>class GPAgentBase </li> <li>class GPAgentRegisters Class to hold the registers of the agent. <ul> <li>class iterator Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator. </li> </ul> </li> <li>class GPTrainingLoop <ul> <li>struct SaveDataParams </li> </ul> </li> <li>class Graph A graph of nodes that can be used to make decisions. </li> <li>class GraphBuilder A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs. </li> <li>class GraphNode A node in a decision graph. </li> <li>class LGPAgent </li> <li>struct NodeFunction A function pointer wrapper that holds extra arguments for the function pointer. </li> <li>class Sensors </li> <li>namespace base64 A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x)). </li> </ul> </li> <li>namespace cse491 </li> <li>namespace std </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Agents <ul> <li>dir GP <ul> <li>file CGPAgent.hpp </li> <li>file CGPGenotype.hpp </li> <li>file GPAgent.hpp </li> <li>file GPAgentAnalyze.h </li> <li>file GPAgentBase.hpp </li> <li>file GPAgentSensors.hpp </li> <li>file GPAgentsRegisters.hpp </li> <li>file GPTrainingLoop.hpp </li> <li>file Graph.hpp </li> <li>file GraphBuilder.hpp </li> <li>file GraphNode.hpp </li> <li>file LGPAgent.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/","title":"Namespace cowboys","text":"<p>Namespace List &gt; cowboys</p> <p>An Agent based on genetic programming. More...</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#namespaces","title":"Namespaces","text":"Type Name namespace base64 A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x))."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#classes","title":"Classes","text":"Type Name class CGPAgent An agent based on cartesian genetic programming. class CGPGenotype Holds all the information that uniquely defines a cartesian graph. struct CGPNodeGene Holds the representation of a cartesian graph node. struct CGPParameters Holds the parameters that define the structure of a cartesian graph. class GPAgent class GPAgentAnalyzer class GPAgentBase class GPAgentRegisters Class to hold the registers of the agent. class GPTrainingLoop &lt;class AgentType, class EnvironmentType&gt; class Graph A graph of nodes that can be used to make decisions. class GraphBuilder A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs. class GraphNode A node in a decision graph. class LGPAgent struct NodeFunction A function pointer wrapper that holds extra arguments for the function pointer. class Sensors"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; GraphLayer typedef double(*)(const GraphNode &amp;, const cse491::AgentBase &amp;) InnerFunction Function pointer for a node function. enum SensorDirection"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-attributes","title":"Public Attributes","text":"Type Name constexpr char HEADER_END   = = ';'The separator between the header and the genotype. constexpr char HEADER_SEP   = = ','The separator between each parameter in the header, defining the cartesian graph. constexpr size_t INPUT_SIZE   = = 9Don't know the maximum size a state can be, arbitrary large number. constexpr size_t LAYERS_BACK   = = 2The number of layers preceding a node's layer that the node can reference. const int LISTSIZE   = = 100 constexpr char NODE_GENE_SEP   = = '.'The separator between each attribute in a node. constexpr char NODE_SEP   = = ':'The separator between each node in the genotype. constexpr size_t NUM_LAYERS   = = 3Number of computational layers for each agent. constexpr size_t NUM_NODES_PER_LAYER   = = 2The number of nodes in each layer. constexpr unsigned int TRAINING_SEED   = = 0If this is 0, then a random seed will be used."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const std::vector&lt; InnerFunction &gt; FUNCTION_SET   = =  { std::vector&lt;InnerFunction&gt; functions; functions.reserve(NODE_FUNCTION_SET.size() + SENSOR_FUNCTION_SET.size()); functions.insert(functions.cend(), NODE_FUNCTION_SET.cbegin(), NODE_FUNCTION_SET.cend()); functions.insert(functions.cend(), SENSOR_FUNCTION_SET.cbegin(), SENSOR_FUNCTION_SET.cend()); return functions; }()A vector of all the node functions and sensors. const std::vector&lt; InnerFunction &gt; NODE_FUNCTION_SET   = { nullptr,  Sum,         And, AnyEq, Not,    Gate,   Sin,      Cos,      Product, Exp, LessThan, GreaterThan, Max, Min,   NegSum, Square, PosClamp, NegClamp, Sqrt}A vector of all the node functions. const std::vector&lt; InnerFunction &gt; SENSOR_FUNCTION_SET   = {WallDistanceUp, WallDistanceDown, WallDistanceLeft, WallDistanceRight, AStarDistance}A vector of all the sensor functions. constexpr int WALL   = = 2"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-functions","title":"Public Functions","text":"Type Name double AStarDistance (const GraphNode &amp; node, const cse491::AgentBase &amp; agent) Returns the distance to the grid position represented by the first two inputs using A*. double And (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if all inputs are not equal to 0, 0 otherwise. double AnyEq (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if any of the inputs besides the first are equal to the first input, 0 otherwise. double Cos (const GraphNode &amp; node, const cse491::AgentBase &amp;) Sums the cos(x) of all inputs. std::vector&lt; size_t &gt; EncodeActions (const std::unordered_map&lt; std::string, size_t &gt; &amp; action_map) Encodes the actions from an agent's action map into a vector of size_t, representing action IDs. std::vector&lt; double &gt; EncodeState (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp;, const cse491::item_map_t &amp;, const cse491::agent_map_t &amp;, const cse491::AgentBase * agent, const std::unordered_map&lt; std::string, double &gt; &amp; extra_agent_state) Translates state into nodes for the decision graph. double Exp (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of the exp(x) of all inputs. double Gate (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the input with index 0 if the condition (input with index 1) is not 0. double GreaterThan (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if all inputs are in ascending, 0 otherwise. If only one input, then defaults to 1. double LessThan (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if all inputs are in ascending, 0 otherwise. If only one input, then defaults to 1. double Max (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the maximum value of all inputs. double Min (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the minimum value of all inputs. double NegClamp (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of negatively clamped inputs. double NegSum (const GraphNode &amp; node, const cse491::AgentBase &amp; agent) Returns the sum of negated inputs. double Not (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns 1 if the first input is equal to 0 or there are no inputs, 0 otherwise. double PosClamp (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of positively clamped inputs. double Product (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the product of all inputs. double Reciprocal (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of the reciprocal of all inputs. double Sin (const GraphNode &amp; node, const cse491::AgentBase &amp;) Sums the sin(x) of all inputs. double Sqrt (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of square root of positively clamped inputs. double Square (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum of squared inputs. double Sum (const GraphNode &amp; node, const cse491::AgentBase &amp;) Returns the sum all inputs. double WallDistanceDown (const GraphNode &amp;, const cse491::AgentBase &amp; agent) Returns the distance to the nearest obstruction downwards from the agent. double WallDistanceLeft (const GraphNode &amp;, const cse491::AgentBase &amp; agent) Returns the distance to the nearest obstruction to the left of the agent. double WallDistanceRight (const GraphNode &amp;, const cse491::AgentBase &amp; agent) Returns the distance to the nearest obstruction to the right of the agent. double WallDistanceUp (const GraphNode &amp;, const cse491::AgentBase &amp; agent) Returns the distance to the nearest obstruction upwards from the agent."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#detailed-description","title":"Detailed Description","text":"<p>An Agent based on linear genetic programming.</p> <p>yeeeeeeeehaaaaaaaaa</p> <p>Namespace for GPAgent and its related classes.</p> <p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Note:</p> <p>yeeeeeeeehaaaaaaaaa \ud83e\udd20</p> <p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL</p> <p>currently a static class</p> <p>Author:</p> <p>@amantham20</p> <p>currenly supports only wall distance sensors for left, right, top and bottom. this is library of sensors for a given agent return </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#typedef-graphlayer","title":"typedef GraphLayer","text":"<pre><code>using GraphLayer =  std::vector&lt;std::shared_ptr&lt;GraphNode&gt; &gt;;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#typedef-innerfunction","title":"typedef InnerFunction","text":"<p>Function pointer for a node function. </p> <pre><code>using InnerFunction =  double (*)(const GraphNode &amp;, const cse491::AgentBase &amp;);\n</code></pre> <p>Forward declaration of GraphNode </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#enum-sensordirection","title":"enum SensorDirection","text":"<pre><code>enum cowboys::SensorDirection {\n    LEFT,\n    RIGHT,\n    ABOVE,\n    BELOW\n};\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-header_end","title":"variable HEADER_END","text":"<pre><code>constexpr char HEADER_END;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-header_sep","title":"variable HEADER_SEP","text":"<pre><code>constexpr char HEADER_SEP;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-input_size","title":"variable INPUT_SIZE","text":"<pre><code>constexpr size_t INPUT_SIZE;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-layers_back","title":"variable LAYERS_BACK","text":"<pre><code>constexpr size_t LAYERS_BACK;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-listsize","title":"variable LISTSIZE","text":"<pre><code>const int LISTSIZE;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-node_gene_sep","title":"variable NODE_GENE_SEP","text":"<pre><code>constexpr char NODE_GENE_SEP;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-node_sep","title":"variable NODE_SEP","text":"<pre><code>constexpr char NODE_SEP;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-num_layers","title":"variable NUM_LAYERS","text":"<pre><code>constexpr size_t NUM_LAYERS;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-num_nodes_per_layer","title":"variable NUM_NODES_PER_LAYER","text":"<pre><code>constexpr size_t NUM_NODES_PER_LAYER;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-training_seed","title":"variable TRAINING_SEED","text":"<pre><code>constexpr unsigned int TRAINING_SEED;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-function_set","title":"variable FUNCTION_SET","text":"<pre><code>const std::vector&lt;InnerFunction&gt; FUNCTION_SET;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-node_function_set","title":"variable NODE_FUNCTION_SET","text":"<pre><code>const std::vector&lt;InnerFunction&gt; NODE_FUNCTION_SET;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-sensor_function_set","title":"variable SENSOR_FUNCTION_SET","text":"<pre><code>const std::vector&lt;InnerFunction&gt; SENSOR_FUNCTION_SET;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#variable-wall","title":"variable WALL","text":"<pre><code>constexpr int WALL;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-astardistance","title":"function AStarDistance","text":"<p>Returns the distance to the grid position represented by the first two inputs using A*. </p> <pre><code>double cowboys::AStarDistance (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the grid position using A* </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-and","title":"function And","text":"<p>Returns 1 if all inputs are not equal to 0, 0 otherwise. </p> <pre><code>double cowboys::And (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-anyeq","title":"function AnyEq","text":"<p>Returns 1 if any of the inputs besides the first are equal to the first input, 0 otherwise. </p> <pre><code>double cowboys::AnyEq (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-cos","title":"function Cos","text":"<p>Sums the cos(x) of all inputs. </p> <pre><code>double cowboys::Cos (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-encodeactions","title":"function EncodeActions","text":"<p>Encodes the actions from an agent's action map into a vector of size_t, representing action IDs. </p> <pre><code>std::vector&lt; size_t &gt; cowboys::EncodeActions (\n    const std::unordered_map&lt; std::string, size_t &gt; &amp; action_map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>action_map</code> The action map from the agent. </li> </ul> <p>Returns:</p> <p>A vector of size_t, representing action IDs. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-encodestate","title":"function EncodeState","text":"<p>Translates state into nodes for the decision graph. </p> <pre><code>std::vector&lt; double &gt; cowboys::EncodeState (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp;,\n    const cse491::item_map_t &amp;,\n    const cse491::agent_map_t &amp;,\n    const cse491::AgentBase * agent,\n    const std::unordered_map&lt; std::string, double &gt; &amp; extra_agent_state\n) \n</code></pre> <p>Returns:</p> <p>A vector of doubles for the decision graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-exp","title":"function Exp","text":"<p>Returns the sum of the exp(x) of all inputs. </p> <pre><code>double cowboys::Exp (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-gate","title":"function Gate","text":"<p>Returns the input with index 0 if the condition (input with index 1) is not 0. </p> <pre><code>double cowboys::Gate (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-greaterthan","title":"function GreaterThan","text":"<p>Returns 1 if all inputs are in ascending, 0 otherwise. If only one input, then defaults to 1. </p> <pre><code>double cowboys::GreaterThan (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-lessthan","title":"function LessThan","text":"<p>Returns 1 if all inputs are in ascending, 0 otherwise. If only one input, then defaults to 1. </p> <pre><code>double cowboys::LessThan (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-max","title":"function Max","text":"<p>Returns the maximum value of all inputs. </p> <pre><code>double cowboys::Max (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-min","title":"function Min","text":"<p>Returns the minimum value of all inputs. </p> <pre><code>double cowboys::Min (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-negclamp","title":"function NegClamp","text":"<p>Returns the sum of negatively clamped inputs. </p> <pre><code>double cowboys::NegClamp (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-negsum","title":"function NegSum","text":"<p>Returns the sum of negated inputs. </p> <pre><code>double cowboys::NegSum (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-not","title":"function Not","text":"<p>Returns 1 if the first input is equal to 0 or there are no inputs, 0 otherwise. </p> <pre><code>double cowboys::Not (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-posclamp","title":"function PosClamp","text":"<p>Returns the sum of positively clamped inputs. </p> <pre><code>double cowboys::PosClamp (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-product","title":"function Product","text":"<p>Returns the product of all inputs. </p> <pre><code>double cowboys::Product (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-reciprocal","title":"function Reciprocal","text":"<p>Returns the sum of the reciprocal of all inputs. </p> <pre><code>double cowboys::Reciprocal (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-sin","title":"function Sin","text":"<p>Sums the sin(x) of all inputs. </p> <pre><code>double cowboys::Sin (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-sqrt","title":"function Sqrt","text":"<p>Returns the sum of square root of positively clamped inputs. </p> <pre><code>double cowboys::Sqrt (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-square","title":"function Square","text":"<p>Returns the sum of squared inputs. </p> <pre><code>double cowboys::Square (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-sum","title":"function Sum","text":"<p>Returns the sum all inputs. </p> <pre><code>double cowboys::Sum (\n    const GraphNode &amp; node,\n    const cse491::AgentBase &amp;\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to get the inputs from. </li> </ul> <p>Returns:</p> <p>The function result as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-walldistancedown","title":"function WallDistanceDown","text":"<p>Returns the distance to the nearest obstruction downwards from the agent. </p> <pre><code>double cowboys::WallDistanceDown (\n    const GraphNode &amp;,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the nearest obstruction downwards. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-walldistanceleft","title":"function WallDistanceLeft","text":"<p>Returns the distance to the nearest obstruction to the left of the agent. </p> <pre><code>double cowboys::WallDistanceLeft (\n    const GraphNode &amp;,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the nearest obstruction to the left. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-walldistanceright","title":"function WallDistanceRight","text":"<p>Returns the distance to the nearest obstruction to the right of the agent. </p> <pre><code>double cowboys::WallDistanceRight (\n    const GraphNode &amp;,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the nearest obstruction to the right. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys/#function-walldistanceup","title":"function WallDistanceUp","text":"<p>Returns the distance to the nearest obstruction upwards from the agent. </p> <pre><code>double cowboys::WallDistanceUp (\n    const GraphNode &amp;,\n    const cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that the node belongs to. </li> </ul> <p>Returns:</p> <p>The distance to the nearest obstruction upwards. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/","title":"Class cowboys::CGPAgent","text":"<p>ClassList &gt; cowboys &gt; CGPAgent</p> <p>An agent based on cartesian genetic programming. </p> <ul> <li><code>#include &lt;CGPAgent.hpp&gt;</code></li> </ul> <p>Inherits the following classes: cowboys::GPAgentBase</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#public-functions","title":"Public Functions","text":"Type Name CGPAgent (size_t id, const std::string &amp; name)  CGPAgent (size_t id, const std::string &amp; name, const CGPGenotype &amp; genotype)  void Configure (const CGPAgent &amp; other) Copies the genotype and behavior of another CGPAgent into this agent. virtual void Copy (const GPAgentBase &amp; other) overrideCopy the behavior of another agent into this agent. virtual std::string Export () overrideExport the genotype for this agent. virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) override double GetComplexity () constThe complexity of this agent. Used for fitness. const CGPGenotype &amp; GetGenotype () constGet the genotype for this agent. virtual void Import (const std::string &amp; genotype) overrideLoad in the string representation of a genotype and configure this agent based on it. bool Initialize () overrideSetup graph. virtual void MutateAgent (double mutation_rate=0.8) overrideMutate this agent. virtual void PrintAgent () override virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) overrideSerialize this agent to XML."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#public-functions-inherited-from-cowboysgpagentbase","title":"Public Functions inherited from cowboys::GPAgentBase","text":"<p>See cowboys::GPAgentBase</p> Type Name virtual void Copy (const GPAgentBase &amp; other) = 0Copy the behavior of another agent into this agent. virtual std::string Export ()  GPAgentBase (size_t id, const std::string &amp; name)  virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) = 0 const std::unordered_map&lt; std::string, double &gt; GetExtraState () constGet a map of extra state information. double GetRandom () Return a uniform random value between 0.0 and 1.0. double GetRandom (double max) Return a uniform random value between 0.0 and max. double GetRandom (double min, double max) Return a uniform random value between min and max. double GetRandomNormal () Return a gaussian random value with mean 0.0 and sd 1.0. double GetRandomNormal (double mean, double sd=1.0) Return a gaussian random value with provided mean and sd. size_t GetRandomULL (size_t max) Return a uniform random unsigned long long between 0 (inclusive) and max (exclusive) unsigned int GetSeed () constGet the seed used to initialize this RNG. virtual void Import (const std::string &amp; genotype) = 0 bool Initialize () overrideSetup graph. virtual void MutateAgent (double mutation_rate=0.8) = 0Mutate this agent. virtual void PrintAgent ()  virtual void Reset (bool=false)  size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) overrideChoose the action to take a step in the appropriate direction. virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) = 0 void SetSeed (unsigned int seed) Set the seed used to initialize this RNG. ~GPAgentBase () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name std::unique_ptr&lt; Graph &gt; decision_graph The decision graph for this agent. CGPGenotype genotype The genotype for this agent."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#protected-attributes-inherited-from-cowboysgpagentbase","title":"Protected Attributes inherited from cowboys::GPAgentBase","text":"<p>See cowboys::GPAgentBase</p> Type Name std::unordered_map&lt; std::string, double &gt; extra_state A map of extra state information. std::normal_distribution&lt; double &gt; norm_dist Normal distribution. std::mt19937 rng   = {seed}Random number generator. unsigned int seed   = = 0Seed for the random number generator. std::uniform_real_distribution&lt; double &gt; uni_dist Uniform distribution."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-cgpagent-12","title":"function CGPAgent [1/2]","text":"<pre><code>inline cowboys::CGPAgent::CGPAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-cgpagent-22","title":"function CGPAgent [2/2]","text":"<pre><code>inline cowboys::CGPAgent::CGPAgent (\n    size_t id,\n    const std::string &amp; name,\n    const CGPGenotype &amp; genotype\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-configure","title":"function Configure","text":"<p>Copies the genotype and behavior of another CGPAgent into this agent.</p> <pre><code>inline void cowboys::CGPAgent::Configure (\n    const CGPAgent &amp; other\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The CGPAgent to copy. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-copy","title":"function Copy","text":"<p>Copy the behavior of another agent into this agent. </p> <pre><code>inline virtual void cowboys::CGPAgent::Copy (\n    const GPAgentBase &amp; other\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The agent to copy. </li> </ul> <p>Implements cowboys::GPAgentBase::Copy</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-export","title":"function Export","text":"<p>Export the genotype for this agent. </p> <pre><code>inline virtual std::string cowboys::CGPAgent::Export () override\n</code></pre> <p>Returns:</p> <p>The string representation of the genotype for this agent. </p> <p>Implements cowboys::GPAgentBase::Export</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-getaction","title":"function GetAction","text":"<pre><code>inline virtual size_t cowboys::CGPAgent::GetAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_set,\n    const cse491::agent_map_t &amp; agent_set\n) override\n</code></pre> <p>Implements cowboys::GPAgentBase::GetAction</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-getcomplexity","title":"function GetComplexity","text":"<p>The complexity of this agent. Used for fitness. </p> <pre><code>inline double cowboys::CGPAgent::GetComplexity () const\n</code></pre> <p>Returns:</p> <p>The complexity of this agent. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-getgenotype","title":"function GetGenotype","text":"<p>Get the genotype for this agent. </p> <pre><code>inline const CGPGenotype &amp; cowboys::CGPAgent::GetGenotype () const\n</code></pre> <p>Returns:</p> <p>A const reference to the genotype for this agent. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-import","title":"function Import","text":"<p>Load in the string representation of a genotype and configure this agent based on it. </p> <pre><code>inline virtual void cowboys::CGPAgent::Import (\n    const std::string &amp; genotype\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>genotype</code> The string representation of a genotype. </li> </ul> <p>Implements cowboys::GPAgentBase::Import</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-initialize","title":"function Initialize","text":"<p>Setup graph. </p> <pre><code>inline bool cowboys::CGPAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-mutateagent","title":"function MutateAgent","text":"<p>Mutate this agent. </p> <pre><code>inline virtual void cowboys::CGPAgent::MutateAgent (\n    double mutation_rate=0.8\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The mutation rate. Between 0 and 1. </li> </ul> <p>Implements cowboys::GPAgentBase::MutateAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-printagent","title":"function PrintAgent","text":"<pre><code>inline virtual void cowboys::CGPAgent::PrintAgent () override\n</code></pre> <p>Implements cowboys::GPAgentBase::PrintAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#function-serializegp","title":"function SerializeGP","text":"<p>Serialize this agent to XML. </p> <pre><code>inline virtual void cowboys::CGPAgent::SerializeGP (\n    tinyxml2::XMLDocument &amp; doc,\n    tinyxml2::XMLElement * parentElem,\n    double fitness=-1\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>doc</code> The XML document to serialize to. </li> <li><code>parentElem</code> The parent element to serialize to. </li> <li><code>fitness</code> The fitness of this agent to write to the XML. </li> </ul> <p>Implements cowboys::GPAgentBase::SerializeGP</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#variable-decision_graph","title":"variable decision_graph","text":"<pre><code>std::unique_ptr&lt;Graph&gt; decision_graph;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_agent/#variable-genotype","title":"variable genotype","text":"<pre><code>CGPGenotype genotype;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/","title":"Class cowboys::CGPGenotype","text":"<p>ClassList &gt; cowboys &gt; CGPGenotype</p> <p>Holds all the information that uniquely defines a cartesian graph. </p> <ul> <li><code>#include &lt;CGPGenotype.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#public-functions","title":"Public Functions","text":"Type Name CGPGenotype () = defaultDefault constructor for the cartesian graph genotype. Will have 0 functional nodes. CGPGenotype (const CGPParameters &amp; parameters) Constructor for the cartesian graph genotype. Initializes the genotype with the given parameters and leaves everything default (nodes will be unconnected). CGPGenotype (const CGPGenotype &amp; other) Copy constructor for the cartesian graph genotype. CGPGenotype (CGPGenotype &amp;&amp; other) noexceptMove constructor for the cartesian graph genotype. CGPGenotype &amp; Configure (const std::string &amp; encoded_genotype) Configures this genotype from an encoded string. std::string Export () constExports this genotype into a string representation. std::string ExportRaw () constExports this genotype into a string representation. size_t GetLayersBack () constReturns the number of layers backward that a node can connect to. size_t GetNumConnections () constReturns the number of connected connections in the graph. size_t GetNumFunctionalNodes () constReturns the number of functional (non-input) nodes in the graph. size_t GetNumInputs () constReturns the number of inputs to the graph. size_t GetNumLayers () constReturns the number of middle layers in the graph. size_t GetNumNodesPerLayer () constReturns the number of nodes per middle layer. size_t GetNumOutputs () constReturns the number of outputs from the graph. size_t GetNumPossibleConnections () constReturns the number of possible connections in the graph. bool HasInputConnections () constIdentify if the genome has any non-zero input connections in it. void InitGenotype () Initializes an empty genotype with the cartesian graph parameters. CGPGenotype &amp; Mutate (double mutation_rate, GPAgentBase &amp; agent, std::function&lt; void(CGPNodeGene &amp;)&gt; mutation) Mutates the genotype. CGPGenotype &amp; MutateConnections (double mutation_rate, GPAgentBase &amp; agent) Mutates the input connections of the genotype. CGPGenotype &amp; MutateDefault (double mutation_rate, GPAgentBase &amp; agent, size_t num_functions=FUNCTION_SET.size()) Performs a mutation on the genotype with default parameters. CGPGenotype &amp; MutateFunctions (double mutation_rate, size_t num_functions, GPAgentBase &amp; agent) Mutates the genotype by changing the function of each node with a given probability between 0 and 1. CGPGenotype &amp; MutateHeader (double mutation_rate, GPAgentBase &amp; agent) Mutates the header of the genotype. CGPGenotype &amp; MutateOutputs (double mutation_rate, double mean, double std, GPAgentBase &amp; agent, bool additive=true) Mutates the genotype, changing the default output of nodes with probability between 0 and 1. void SetParameters (const CGPParameters &amp; params) Set the parameters of the cartesian graph. std::vector&lt; CGPNodeGene &gt;::iterator begin () Returns the iterator to the beginning of the node configurations. std::vector&lt; CGPNodeGene &gt;::const_iterator begin () constReturns the const iterator to the beginning of the node configurations. std::vector&lt; CGPNodeGene &gt;::const_iterator cbegin () constReturns the const iterator to the beginning of the node configurations. std::vector&lt; CGPNodeGene &gt;::const_iterator cend () constReturns the const iterator to the end of the node configurations. std::vector&lt; CGPNodeGene &gt;::iterator end () Returns the iterator to the end of the node configurations. std::vector&lt; CGPNodeGene &gt;::const_iterator end () constReturns the const iterator to the end of the node configurations. CGPGenotype &amp; operator= (const CGPGenotype &amp; other) Copy assignment operator for the cartesian graph genotype. CGPGenotype &amp; operator= (CGPGenotype &amp;&amp; other) noexceptMove assignment operator for the cartesian graph genotype. bool operator== (const CGPGenotype &amp; other) constCheck if two CGPGenotypes are equal. CGPParameters and CGPNodeGenes should be equal. ~CGPGenotype () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; CGPNodeGene &gt; nodes The node configurations. CGPParameters params The parameters of the cartesian graph."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype-14","title":"function CGPGenotype [1/4]","text":"<pre><code>cowboys::CGPGenotype::CGPGenotype () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype-24","title":"function CGPGenotype [2/4]","text":"<p>Constructor for the cartesian graph genotype. Initializes the genotype with the given parameters and leaves everything default (nodes will be unconnected). </p> <pre><code>inline cowboys::CGPGenotype::CGPGenotype (\n    const CGPParameters &amp; parameters\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>parameters</code> The parameters of the cartesian graph. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype-34","title":"function CGPGenotype [3/4]","text":"<p>Copy constructor for the cartesian graph genotype. </p> <pre><code>inline cowboys::CGPGenotype::CGPGenotype (\n    const CGPGenotype &amp; other\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other cartesian graph genotype to copy from. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype-44","title":"function CGPGenotype [4/4]","text":"<p>Move constructor for the cartesian graph genotype. </p> <pre><code>inline cowboys::CGPGenotype::CGPGenotype (\n    CGPGenotype &amp;&amp; other\n) noexcept\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other cartesian graph genotype to move from. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-configure","title":"function Configure","text":"<p>Configures this genotype from an encoded string. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::Configure (\n    const std::string &amp; encoded_genotype\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>encoded_genotype</code> The encoded genotype. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-export","title":"function Export","text":"<p>Exports this genotype into a string representation. </p> <pre><code>inline std::string cowboys::CGPGenotype::Export () const\n</code></pre> <p>Returns:</p> <p>The string representation of this genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-exportraw","title":"function ExportRaw","text":"<p>Exports this genotype into a string representation. </p> <pre><code>inline std::string cowboys::CGPGenotype::ExportRaw () const\n</code></pre> <p>Returns:</p> <p>The string representation of this genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getlayersback","title":"function GetLayersBack","text":"<p>Returns the number of layers backward that a node can connect to. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetLayersBack () const\n</code></pre> <p>Returns:</p> <p>The number of layers backward that a node can connect to. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumconnections","title":"function GetNumConnections","text":"<p>Returns the number of connected connections in the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumConnections () const\n</code></pre> <p>Returns:</p> <p>The number of connected connections in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumfunctionalnodes","title":"function GetNumFunctionalNodes","text":"<p>Returns the number of functional (non-input) nodes in the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumFunctionalNodes () const\n</code></pre> <p>Returns:</p> <p>The number of functional (non-input) nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnuminputs","title":"function GetNumInputs","text":"<p>Returns the number of inputs to the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumInputs () const\n</code></pre> <p>Returns:</p> <p>The number of inputs to the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumlayers","title":"function GetNumLayers","text":"<p>Returns the number of middle layers in the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumLayers () const\n</code></pre> <p>Returns:</p> <p>The number of middle layers in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumnodesperlayer","title":"function GetNumNodesPerLayer","text":"<p>Returns the number of nodes per middle layer. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumNodesPerLayer () const\n</code></pre> <p>Returns:</p> <p>The number of nodes per middle layer. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumoutputs","title":"function GetNumOutputs","text":"<p>Returns the number of outputs from the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumOutputs () const\n</code></pre> <p>Returns:</p> <p>The number of outputs from the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-getnumpossibleconnections","title":"function GetNumPossibleConnections","text":"<p>Returns the number of possible connections in the graph. </p> <pre><code>inline size_t cowboys::CGPGenotype::GetNumPossibleConnections () const\n</code></pre> <p>Returns:</p> <p>The number of possible connections in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-hasinputconnections","title":"function HasInputConnections","text":"<p>Identify if the genome has any non-zero input connections in it. </p> <pre><code>inline bool cowboys::CGPGenotype::HasInputConnections () const\n</code></pre> <p>Returns:</p> <p>Bool value to indicate if any input connections non-zero. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-initgenotype","title":"function InitGenotype","text":"<pre><code>inline void cowboys::CGPGenotype::InitGenotype () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutate","title":"function Mutate","text":"<p>Mutates the genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::Mutate (\n    double mutation_rate,\n    GPAgentBase &amp; agent,\n    std::function&lt; void( CGPNodeGene &amp;)&gt; mutation\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> Value between 0 and 1 representing the probability of mutating a value. </li> <li><code>mutation</code> The function to use for mutating the output. The function will receive the node gene as a parameter. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutateconnections","title":"function MutateConnections","text":"<p>Mutates the input connections of the genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateConnections (\n    double mutation_rate,\n    GPAgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The probability of mutating a connection. For a given connection, if it is chosen to be mutated, there is a 50% chance it will stay the same. </li> <li><code>agent</code> The agent to use for random number generation. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutatedefault","title":"function MutateDefault","text":"<p>Performs a mutation on the genotype with default parameters. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateDefault (\n    double mutation_rate,\n    GPAgentBase &amp; agent,\n    size_t num_functions=FUNCTION_SET.size()\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> Value between 0 and 1 representing the probability of mutating each value. </li> <li><code>agent</code> The agent to use for random number generation. </li> <li><code>num_functions</code> The number of functions available to the nodes. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutatefunctions","title":"function MutateFunctions","text":"<p>Mutates the genotype by changing the function of each node with a given probability between 0 and 1. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateFunctions (\n    double mutation_rate,\n    size_t num_functions,\n    GPAgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The probability of changing the function of a node. </li> <li><code>num_functions</code> The number of functions available to the nodes. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutateheader","title":"function MutateHeader","text":"<p>Mutates the header of the genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateHeader (\n    double mutation_rate,\n    GPAgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> Value between 0 and 1 representing the probability of mutating each value. </li> <li><code>agent</code> The agent to use for random number generation. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-mutateoutputs","title":"function MutateOutputs","text":"<p>Mutates the genotype, changing the default output of nodes with probability between 0 and 1. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::MutateOutputs (\n    double mutation_rate,\n    double mean,\n    double std,\n    GPAgentBase &amp; agent,\n    bool additive=true\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> Value between 0 and 1 representing the probability of mutating each value. </li> <li><code>min</code> The minimum value to generate for mutation. </li> <li><code>max</code> The maximum value to generate for mutation. </li> </ul> <p>Returns:</p> <p>This genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-setparameters","title":"function SetParameters","text":"<p>Set the parameters of the cartesian graph. </p> <pre><code>inline void cowboys::CGPGenotype::SetParameters (\n    const CGPParameters &amp; params\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>params</code> The parameters of the cartesian graph. Basically a 5-tuple. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-begin-12","title":"function begin [1/2]","text":"<p>Returns the iterator to the beginning of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::iterator cowboys::CGPGenotype::begin () \n</code></pre> <p>Returns:</p> <p>The iterator to the beginning of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-begin-22","title":"function begin [2/2]","text":"<p>Returns the const iterator to the beginning of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::const_iterator cowboys::CGPGenotype::begin () const\n</code></pre> <p>Returns:</p> <p>The const iterator to the beginning of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cbegin","title":"function cbegin","text":"<p>Returns the const iterator to the beginning of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::const_iterator cowboys::CGPGenotype::cbegin () const\n</code></pre> <p>Returns:</p> <p>The const iterator to the beginning of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cend","title":"function cend","text":"<p>Returns the const iterator to the end of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::const_iterator cowboys::CGPGenotype::cend () const\n</code></pre> <p>Returns:</p> <p>The const iterator to the end of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-end-12","title":"function end [1/2]","text":"<p>Returns the iterator to the end of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::iterator cowboys::CGPGenotype::end () \n</code></pre> <p>Returns:</p> <p>The iterator to the end of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-end-22","title":"function end [2/2]","text":"<p>Returns the const iterator to the end of the node configurations. </p> <pre><code>inline std::vector&lt; CGPNodeGene &gt;::const_iterator cowboys::CGPGenotype::end () const\n</code></pre> <p>Returns:</p> <p>The const iterator to the end of the node configurations. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-operator","title":"function operator=","text":"<p>Copy assignment operator for the cartesian graph genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::operator= (\n    const CGPGenotype &amp; other\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other cartesian graph genotype to copy from. </li> </ul> <p>Returns:</p> <p>This cartesian graph genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-operator_1","title":"function operator=","text":"<p>Move assignment operator for the cartesian graph genotype. </p> <pre><code>inline CGPGenotype &amp; cowboys::CGPGenotype::operator= (\n    CGPGenotype &amp;&amp; other\n) noexcept\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other cartesian graph genotype to move from. </li> </ul> <p>Returns:</p> <p>This cartesian graph genotype. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-operator_2","title":"function operator==","text":"<p>Check if two CGPGenotypes are equal. CGPParameters and CGPNodeGenes should be equal.</p> <pre><code>inline bool cowboys::CGPGenotype::operator== (\n    const CGPGenotype &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other CGPGenotype to compare to. </li> </ul> <p>Returns:</p> <p>True if the two CGPGenotypes are equal, false otherwise. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#function-cgpgenotype","title":"function ~CGPGenotype","text":"<pre><code>cowboys::CGPGenotype::~CGPGenotype () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#variable-nodes","title":"variable nodes","text":"<pre><code>std::vector&lt;CGPNodeGene&gt; nodes;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#variable-params","title":"variable params","text":"<pre><code>CGPParameters params;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#friends-documentation","title":"Friends Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_c_g_p_genotype/#friend-operator","title":"friend operator&lt;&lt;","text":"<p>Write the genotype representation to an output stream. </p> <pre><code>inline std::ostream &amp; cowboys::CGPGenotype::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const CGPGenotype &amp; genotype\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>os</code> The output stream to write to. </li> <li><code>genotype</code> The genotype to write. </li> </ul> <p>Returns:</p> <p>The output stream. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/","title":"Struct cowboys::CGPNodeGene","text":"<p>ClassList &gt; cowboys &gt; CGPNodeGene</p> <p>Holds the representation of a cartesian graph node. </p> <ul> <li><code>#include &lt;CGPGenotype.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#public-attributes","title":"Public Attributes","text":"Type Name double default_output   = {0}The default output of the node. size_t function_idx   = {0}The index of the function the node uses. std::vector&lt; char &gt; input_connections   = {}The input connections of this node. '1' means connected, '0' means not connected."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#public-functions","title":"Public Functions","text":"Type Name bool operator== (const CGPNodeGene &amp; other) constCompare two CGPNodeGenes for equality."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#variable-default_output","title":"variable default_output","text":"<pre><code>double default_output;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#variable-function_idx","title":"variable function_idx","text":"<pre><code>size_t function_idx;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#variable-input_connections","title":"variable input_connections","text":"<pre><code>std::vector&lt;char&gt; input_connections;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_node_gene/#function-operator","title":"function operator==","text":"<p>Compare two CGPNodeGenes for equality. </p> <pre><code>inline bool cowboys::CGPNodeGene::operator== (\n    const CGPNodeGene &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other CGPNodeGene to compare to. </li> </ul> <p>Returns:</p> <p>True if the two CGPNodeGenes are equal, false otherwise. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/","title":"Struct cowboys::CGPParameters","text":"<p>ClassList &gt; cowboys &gt; CGPParameters</p> <p>Holds the parameters that define the structure of a cartesian graph. </p> <ul> <li><code>#include &lt;CGPGenotype.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#public-attributes","title":"Public Attributes","text":"Type Name size_t layers_back   = {0}The number of layers backward that a node can connect to. size_t num_inputs   = {0}The number of inputs to the graph. size_t num_layers   = {0}The number of middle layers in the graph. size_t num_nodes_per_layer   = {0}The number of nodes per middle layer. size_t num_outputs   = {0}The number of outputs from the graph."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#public-functions","title":"Public Functions","text":"Type Name CGPParameters () = default CGPParameters (size_t num_inputs, size_t num_outputs, size_t num_layers, size_t num_nodes_per_layer, size_t layers_back) Constructor for the cartesian graph parameters. size_t GetFunctionalNodeCount () constReturns the number of functional nodes in the graph. bool operator== (const CGPParameters &amp; other) constCheck if two CGPParameters are equal."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-layers_back","title":"variable layers_back","text":"<pre><code>size_t layers_back;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-num_inputs","title":"variable num_inputs","text":"<pre><code>size_t num_inputs;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-num_layers","title":"variable num_layers","text":"<pre><code>size_t num_layers;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-num_nodes_per_layer","title":"variable num_nodes_per_layer","text":"<pre><code>size_t num_nodes_per_layer;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#variable-num_outputs","title":"variable num_outputs","text":"<pre><code>size_t num_outputs;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#function-cgpparameters-12","title":"function CGPParameters [1/2]","text":"<pre><code>cowboys::CGPParameters::CGPParameters () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#function-cgpparameters-22","title":"function CGPParameters [2/2]","text":"<pre><code>inline cowboys::CGPParameters::CGPParameters (\n    size_t num_inputs,\n    size_t num_outputs,\n    size_t num_layers,\n    size_t num_nodes_per_layer,\n    size_t layers_back\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#function-getfunctionalnodecount","title":"function GetFunctionalNodeCount","text":"<p>Returns the number of functional nodes in the graph. </p> <pre><code>inline size_t cowboys::CGPParameters::GetFunctionalNodeCount () const\n</code></pre> <p>Returns:</p> <p>The number of functional nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_c_g_p_parameters/#function-operator","title":"function operator==","text":"<p>Check if two CGPParameters are equal.</p> <pre><code>inline bool cowboys::CGPParameters::operator== (\n    const CGPParameters &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The other CGPParameters to compare to. </li> </ul> <p>Returns:</p> <p>True if the two CGPParameters are equal, false otherwise. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/","title":"Class cowboys::GPAgent","text":"<p>ClassList &gt; cowboys &gt; GPAgent</p> <p>Inherits the following classes: AgentBase</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#public-functions","title":"Public Functions","text":"Type Name GPAgent (size_t id, const std::string &amp; name)  bool Initialize () overrideThis agent needs a specific set of actions to function. size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_map, const cse491::agent_map_t &amp; agent_map) overrideChoose the action to take a step in the appropriate direction. ~GPAgent () override"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t movementIndex   = = 0current move of the agent const std::vector&lt; std::string &gt; predefinedMovement   = = { \"down\",  \"down\",  \"down\",  \"down\",  \"right\", \"right\", \"up\",    \"up\", \"up\",    \"up\",    \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"left\",  \"left\",  \"left\"}"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#function-gpagent","title":"function GPAgent","text":"<pre><code>inline cowboys::GPAgent::GPAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool cowboys::GPAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cowboys::GPAgent::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_map,\n    const cse491::agent_map_t &amp; agent_map\n) override\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#function-gpagent_1","title":"function ~GPAgent","text":"<pre><code>cowboys::GPAgent::~GPAgent () override\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#variable-movementindex","title":"variable movementIndex","text":"<pre><code>size_t movementIndex;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent/#variable-predefinedmovement","title":"variable predefinedMovement","text":"<pre><code>const std::vector&lt;std::string&gt; predefinedMovement;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/","title":"Class cowboys::GPAgentAnalyzer","text":"<p>ClassList &gt; cowboys &gt; GPAgentAnalyzer</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#public-functions","title":"Public Functions","text":"Type Name GPAgentAnalyzer () = defaultConstruct a new GP Agent Analyzer object. void addAverageFitness (double fitness) Adds the average fitness of the best agent. void addAverageScore (double score) Adds the average score of the best agent. void addEliteScore (double score) Adds the weighted score of the best agent. void addMaxFitness (double fitness) Adds the max fitness of the best agent. void addNumAgentsWithMaxFitness (double num_agents) Adds the number of agents with the max fitness. void saveToFile () Saves the data to a csv file. ~GPAgentAnalyzer () = defaultDestroy the GP Agent Analyzer object."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-gpagentanalyzer","title":"function GPAgentAnalyzer","text":"<pre><code>cowboys::GPAgentAnalyzer::GPAgentAnalyzer () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addaveragefitness","title":"function addAverageFitness","text":"<p>Adds the average fitness of the best agent. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addAverageFitness (\n    double fitness\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>fitness</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addaveragescore","title":"function addAverageScore","text":"<p>Adds the average score of the best agent. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addAverageScore (\n    double score\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>score</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addelitescore","title":"function addEliteScore","text":"<p>Adds the weighted score of the best agent. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addEliteScore (\n    double score\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>score</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addmaxfitness","title":"function addMaxFitness","text":"<p>Adds the max fitness of the best agent. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addMaxFitness (\n    double fitness\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>fitness</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-addnumagentswithmaxfitness","title":"function addNumAgentsWithMaxFitness","text":"<p>Adds the number of agents with the max fitness. </p> <pre><code>inline void cowboys::GPAgentAnalyzer::addNumAgentsWithMaxFitness (\n    double num_agents\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>num_agents</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-savetofile","title":"function saveToFile","text":"<pre><code>inline void cowboys::GPAgentAnalyzer::saveToFile () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_analyzer/#function-gpagentanalyzer_1","title":"function ~GPAgentAnalyzer","text":"<pre><code>cowboys::GPAgentAnalyzer::~GPAgentAnalyzer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentAnalyze.h</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/","title":"Class cowboys::GPAgentBase","text":"<p>ClassList &gt; cowboys &gt; GPAgentBase</p> <p>Inherits the following classes: AgentBase</p> <p>Inherited by the following classes: cowboys::CGPAgent,  cowboys::LGPAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#public-functions","title":"Public Functions","text":"Type Name virtual void Copy (const GPAgentBase &amp; other) = 0Copy the behavior of another agent into this agent. virtual std::string Export ()  GPAgentBase (size_t id, const std::string &amp; name)  virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) = 0 const std::unordered_map&lt; std::string, double &gt; GetExtraState () constGet a map of extra state information. double GetRandom () Return a uniform random value between 0.0 and 1.0. double GetRandom (double max) Return a uniform random value between 0.0 and max. double GetRandom (double min, double max) Return a uniform random value between min and max. double GetRandomNormal () Return a gaussian random value with mean 0.0 and sd 1.0. double GetRandomNormal (double mean, double sd=1.0) Return a gaussian random value with provided mean and sd. size_t GetRandomULL (size_t max) Return a uniform random unsigned long long between 0 (inclusive) and max (exclusive) unsigned int GetSeed () constGet the seed used to initialize this RNG. virtual void Import (const std::string &amp; genotype) = 0 bool Initialize () overrideSetup graph. virtual void MutateAgent (double mutation_rate=0.8) = 0Mutate this agent. virtual void PrintAgent ()  virtual void Reset (bool=false)  size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) overrideChoose the action to take a step in the appropriate direction. virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) = 0 void SetSeed (unsigned int seed) Set the seed used to initialize this RNG. ~GPAgentBase () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#protected-attributes","title":"Protected Attributes","text":"Type Name std::unordered_map&lt; std::string, double &gt; extra_state A map of extra state information. std::normal_distribution&lt; double &gt; norm_dist Normal distribution. std::mt19937 rng   = {seed}Random number generator. unsigned int seed   = = 0Seed for the random number generator. std::uniform_real_distribution&lt; double &gt; uni_dist Uniform distribution."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-copy","title":"function Copy","text":"<p>Copy the behavior of another agent into this agent. </p> <pre><code>virtual void cowboys::GPAgentBase::Copy (\n    const GPAgentBase &amp; other\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The agent to copy. Should be the same type. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-export","title":"function Export","text":"<pre><code>inline virtual std::string cowboys::GPAgentBase::Export () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-gpagentbase","title":"function GPAgentBase","text":"<pre><code>inline cowboys::GPAgentBase::GPAgentBase (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getaction","title":"function GetAction","text":"<pre><code>virtual size_t cowboys::GPAgentBase::GetAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_set,\n    const cse491::agent_map_t &amp; agent_set\n) = 0\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getextrastate","title":"function GetExtraState","text":"<p>Get a map of extra state information. </p> <pre><code>inline const std::unordered_map&lt; std::string, double &gt; cowboys::GPAgentBase::GetExtraState () const\n</code></pre> <p>Returns:</p> <p>Map of extra state information </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandom-13","title":"function GetRandom [1/3]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandom () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandom-23","title":"function GetRandom [2/3]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandom (\n    double max\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandom-33","title":"function GetRandom [3/3]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandom (\n    double min,\n    double max\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandomnormal-12","title":"function GetRandomNormal [1/2]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandomNormal () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandomnormal-22","title":"function GetRandomNormal [2/2]","text":"<pre><code>inline double cowboys::GPAgentBase::GetRandomNormal (\n    double mean,\n    double sd=1.0\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getrandomull","title":"function GetRandomULL","text":"<pre><code>inline size_t cowboys::GPAgentBase::GetRandomULL (\n    size_t max\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-getseed","title":"function GetSeed","text":"<pre><code>inline unsigned int cowboys::GPAgentBase::GetSeed () const\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-import","title":"function Import","text":"<pre><code>virtual void cowboys::GPAgentBase::Import (\n    const std::string &amp; genotype\n) = 0\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-initialize","title":"function Initialize","text":"<p>Setup graph. </p> <pre><code>inline bool cowboys::GPAgentBase::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-mutateagent","title":"function MutateAgent","text":"<p>Mutate this agent. </p> <pre><code>virtual void cowboys::GPAgentBase::MutateAgent (\n    double mutation_rate=0.8\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The mutation rate. Between 0 and 1. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-printagent","title":"function PrintAgent","text":"<pre><code>inline virtual void cowboys::GPAgentBase::PrintAgent () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-reset","title":"function Reset","text":"<pre><code>inline virtual void cowboys::GPAgentBase::Reset (\n    bool=false\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cowboys::GPAgentBase::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_set,\n    const cse491::agent_map_t &amp; agent_set\n) override\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-serializegp","title":"function SerializeGP","text":"<pre><code>virtual void cowboys::GPAgentBase::SerializeGP (\n    tinyxml2::XMLDocument &amp; doc,\n    tinyxml2::XMLElement * parentElem,\n    double fitness=-1\n) = 0\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-setseed","title":"function SetSeed","text":"<pre><code>inline void cowboys::GPAgentBase::SetSeed (\n    unsigned int seed\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#function-gpagentbase_1","title":"function ~GPAgentBase","text":"<pre><code>cowboys::GPAgentBase::~GPAgentBase () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-extra_state","title":"variable extra_state","text":"<pre><code>std::unordered_map&lt;std::string, double&gt; extra_state;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-norm_dist","title":"variable norm_dist","text":"<pre><code>std::normal_distribution&lt;double&gt; norm_dist;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-rng","title":"variable rng","text":"<pre><code>std::mt19937 rng;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-seed","title":"variable seed","text":"<pre><code>unsigned int seed;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_base/#variable-uni_dist","title":"variable uni_dist","text":"<pre><code>std::uniform_real_distribution&lt;double&gt; uni_dist;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentBase.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/","title":"Class cowboys::GPAgentRegisters","text":"<p>ClassList &gt; cowboys &gt; GPAgentRegisters</p> <p>Class to hold the registers of the agent. </p> <ul> <li><code>#include &lt;GPAgentsRegisters.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#classes","title":"Classes","text":"Type Name class iterator Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#public-functions","title":"Public Functions","text":"Type Name GPAgentRegisters (int numRegisters=16) Number of registers Default is 16. iterator begin ()  iterator end ()  size_t getNumRegisters () Get the number of registers. std::optional&lt; size_t &gt; getRegister (size_t index) Get the Register object. bool setRegister (size_t index, size_t value) Set the Register object. size_t size ()  ~GPAgentRegisters () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-gpagentregisters","title":"function GPAgentRegisters","text":"<p>Number of registers Default is 16. </p> <pre><code>inline cowboys::GPAgentRegisters::GPAgentRegisters (\n    int numRegisters=16\n) \n</code></pre> <p>Constructor for GPAgentRegisters </p> <p>Parameters:</p> <ul> <li><code>numRegisters</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-begin","title":"function begin","text":"<pre><code>inline iterator cowboys::GPAgentRegisters::begin () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-end","title":"function end","text":"<pre><code>inline iterator cowboys::GPAgentRegisters::end () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-getnumregisters","title":"function getNumRegisters","text":"<p>Get the number of registers. </p> <pre><code>inline size_t cowboys::GPAgentRegisters::getNumRegisters () \n</code></pre> <p>Returns:</p> <p>size of the registers </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-getregister","title":"function getRegister","text":"<p>Get the Register object. </p> <pre><code>inline std::optional&lt; size_t &gt; cowboys::GPAgentRegisters::getRegister (\n    size_t index\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>index</code> Index of the register </li> </ul> <p>Returns:</p> <p>std::optional&lt;size_t&gt; Returns the value of the register if it exists </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-setregister","title":"function setRegister","text":"<p>Set the Register object. </p> <pre><code>inline bool cowboys::GPAgentRegisters::setRegister (\n    size_t index,\n    size_t value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>index</code> </li> <li><code>value</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-size","title":"function size","text":"<pre><code>inline size_t cowboys::GPAgentRegisters::size () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers/#function-gpagentregisters_1","title":"function ~GPAgentRegisters","text":"<pre><code>cowboys::GPAgentRegisters::~GPAgentRegisters () = default\n</code></pre> <p>Destructor for GPAgentRegisters </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentsRegisters.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/","title":"Class cowboys::GPAgentRegisters::iterator","text":"<p>ClassList &gt; cowboys &gt; GPAgentRegisters &gt; iterator</p> <p>Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator.</p> <ul> <li><code>#include &lt;GPAgentsRegisters.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#public-functions","title":"Public Functions","text":"Type Name iterator (size_t index, GPAgentRegisters &amp; regs)  bool operator!= (const iterator &amp; other) constOverload not equal operator. size_t &amp; operator* ()  iterator &amp; operator++ ()  bool operator== (const iterator &amp; other) constOverload post-increment operator."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-iterator","title":"function iterator","text":"<pre><code>inline cowboys::GPAgentRegisters::iterator::iterator (\n    size_t index,\n    GPAgentRegisters &amp; regs\n) \n</code></pre> <p>Constructor for iterator </p> <p>Parameters:</p> <ul> <li><code>index</code> </li> <li><code>regs</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-operator","title":"function operator!=","text":"<p>Overload not equal operator. </p> <pre><code>inline bool cowboys::GPAgentRegisters::iterator::operator!= (\n    const iterator &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-operator_1","title":"function operator*","text":"<pre><code>inline size_t &amp; cowboys::GPAgentRegisters::iterator::operator* () \n</code></pre> <p>Overload dereference operator </p> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-operator_2","title":"function operator++","text":"<pre><code>inline iterator &amp; cowboys::GPAgentRegisters::iterator::operator++ () \n</code></pre> <p>Overload pre-increment operator </p> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_agent_registers_1_1iterator/#function-operator_3","title":"function operator==","text":"<p>Overload post-increment operator. </p> <pre><code>inline bool cowboys::GPAgentRegisters::iterator::operator== (\n    const iterator &amp; other\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> </li> </ul> <p>Returns:</p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentsRegisters.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/","title":"Class cowboys::GPTrainingLoop","text":"<p>template &lt;class AgentType class AgentType, class EnvironmentType class EnvironmentType&gt;</p> <p>ClassList &gt; cowboys &gt; GPTrainingLoop</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#classes","title":"Classes","text":"Type Name struct SaveDataParams"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-attributes","title":"Public Attributes","text":"Type Name bool ScavengerQueuing   = = false"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-functions","title":"Public Functions","text":"Type Name double AStarFitnessFunction (const cse491::GridPosition &amp; startpos, const cse491::GridPosition &amp; endpos, int arena, int a)  int AgentsAnalysisComputationsAndPrint (int generation, double deltaForMaxFitness=0.1)  std::string FormatPosition (const cse491::GridPosition &amp; pos, int precision=0)  std::filesystem::path FullLoadGrabLatestGeneration ()  GPTrainingLoop (const bool scavengerQueuing=false) : constructor size_t Get_A_StarDistance (const cse491::GridPosition &amp; startpos, const cse491::GridPosition &amp; endpos, int arenaIDX, int agentIDX)  void GpLoopMutateHelper () Helper function for the GP loop mutate function. void InitTEMPAgentFitness () : initialize the TEMP agent fitness vector void Initialize (size_t numArenas=5, size_t NumAgentsForArena=100) Initialize the training loop with a number of environments and agents per environment. void MemGOBYE () Clears the memory of the training loop. void MutateAgents (int start, int end, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; sortedAgents, std::vector&lt; std::vector&lt; cowboys::GPAgentBase * &gt; &gt; &amp; agents, double mutationRate) Helper function for the GP loop mutate function. This function mutates the agents. This function is called in a thread. void MutateAndCopyAgents (int start, int end, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; sortedAgents, std::vector&lt; std::vector&lt; cowboys::GPAgentBase * &gt; &gt; &amp; agents, int elitePopulationSize) Helper function for the GP loop mutate function. This function copies the elite agents and mutates them. This function is called in a thread. for th. void Printgrid (const std::vector&lt; cse491::GridPosition &gt; &amp; positions, char symbol='S') Prints the grid for a single arena. void ResetMainTagLastGenerations ()  void Run (size_t numGenerations, size_t numberOfTurns=100, size_t maxThreads=0, bool saveData=false) : runs the Genetic Programming training loop for a number of generations to evolve the agents void RunArena (size_t arena, size_t numberOfTurns) Runs the training loop for a single arena. This function is called in a thread. Each arena is run in a separate thread. void SaveDataCheckPoint (const SaveDataParams &amp; params)  void SerializeAgents (int generation, tinyxml2::XMLElement * rootElement, tinyxml2::XMLDocument &amp; paramDocument, size_t topN=5) : Serializes the agents to an XML file. double SimpleFitnessFunction (cse491::AgentBase &amp; agent, cse491::GridPosition startPosition)  void SortThemAgents () : sort the agents based on their fitness void ThreadTrainLoop (size_t maxThreads=1, int numberOfTurns=100)  void loadLastGeneration ()  void resetEnvironments () Resets the environments to their initial state. This function is called after each generation. This function currently only soft resets the environments. void saveXMLDoc (tinyxml2::XMLDocument &amp; paramdoc, std::string fullPath)  ~GPTrainingLoop () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-static-functions","title":"Public Static Functions","text":"Type Name std::string getDateStr ()  std::filesystem::path getSystemPath ()"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#variable-scavengerqueuing","title":"variable ScavengerQueuing","text":"<pre><code>bool ScavengerQueuing;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-astarfitnessfunction","title":"function AStarFitnessFunction","text":"<pre><code>inline double cowboys::GPTrainingLoop::AStarFitnessFunction (\n    const cse491::GridPosition &amp; startpos,\n    const cse491::GridPosition &amp; endpos,\n    int arena,\n    int a\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-agentsanalysiscomputationsandprint","title":"function AgentsAnalysisComputationsAndPrint","text":"<pre><code>inline int cowboys::GPTrainingLoop::AgentsAnalysisComputationsAndPrint (\n    int generation,\n    double deltaForMaxFitness=0.1\n) \n</code></pre> <p>Computes agents analysis metrics</p> <p>Parameters:</p> <ul> <li><code>generation</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-formatposition","title":"function FormatPosition","text":"<pre><code>inline std::string cowboys::GPTrainingLoop::FormatPosition (\n    const cse491::GridPosition &amp; pos,\n    int precision=0\n) \n</code></pre> <p>Helper function to format the data analysis </p> <p>Parameters:</p> <ul> <li><code>pos</code> </li> <li><code>precision</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-fullloadgrablatestgeneration","title":"function FullLoadGrabLatestGeneration","text":"<pre><code>inline std::filesystem::path cowboys::GPTrainingLoop::FullLoadGrabLatestGeneration () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-gptrainingloop","title":"function GPTrainingLoop","text":"<pre><code>inline cowboys::GPTrainingLoop::GPTrainingLoop (\n    const bool scavengerQueuing=false\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-get_a_stardistance","title":"function Get_A_StarDistance","text":"<pre><code>inline size_t cowboys::GPTrainingLoop::Get_A_StarDistance (\n    const cse491::GridPosition &amp; startpos,\n    const cse491::GridPosition &amp; endpos,\n    int arenaIDX,\n    int agentIDX\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-gploopmutatehelper","title":"function GpLoopMutateHelper","text":"<pre><code>inline void cowboys::GPTrainingLoop::GpLoopMutateHelper () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-inittempagentfitness","title":"function InitTEMPAgentFitness","text":"<pre><code>inline void cowboys::GPTrainingLoop::InitTEMPAgentFitness () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-initialize","title":"function Initialize","text":"<p>Initialize the training loop with a number of environments and agents per environment. </p> <pre><code>inline void cowboys::GPTrainingLoop::Initialize (\n    size_t numArenas=5,\n    size_t NumAgentsForArena=100\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>numArenas</code> </li> <li><code>NumAgentsForArena</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-memgobye","title":"function MemGOBYE","text":"<pre><code>inline void cowboys::GPTrainingLoop::MemGOBYE () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-mutateagents","title":"function MutateAgents","text":"<p>Helper function for the GP loop mutate function. This function mutates the agents. This function is called in a thread. </p> <pre><code>inline void cowboys::GPTrainingLoop::MutateAgents (\n    int start,\n    int end,\n    const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; sortedAgents,\n    std::vector&lt; std::vector&lt; cowboys::GPAgentBase * &gt; &gt; &amp; agents,\n    double mutationRate\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>start</code> : The start index of the agents to mutate. </li> <li><code>end</code> : The end index of the agents to mutate. </li> <li><code>sortedAgents</code> : The sorted agents' index vector. </li> <li><code>agents</code> : The agents vector. </li> <li><code>mutationRate</code> The mutation rate. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-mutateandcopyagents","title":"function MutateAndCopyAgents","text":"<p>Helper function for the GP loop mutate function. This function copies the elite agents and mutates them. This function is called in a thread. for th. </p> <pre><code>inline void cowboys::GPTrainingLoop::MutateAndCopyAgents (\n    int start,\n    int end,\n    const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp; sortedAgents,\n    std::vector&lt; std::vector&lt; cowboys::GPAgentBase * &gt; &gt; &amp; agents,\n    int elitePopulationSize\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>start</code> </li> <li><code>end</code> </li> <li><code>sortedAgents</code> </li> <li><code>agents</code> </li> <li><code>elitePopulationSize</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-printgrid","title":"function Printgrid","text":"<p>Prints the grid for a single arena. </p> <pre><code>inline void cowboys::GPTrainingLoop::Printgrid (\n    const std::vector&lt; cse491::GridPosition &gt; &amp; positions,\n    char symbol='S'\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>arenaId</code> </li> </ul> <p>Author:</p> <p>: @amantham20 </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-resetmaintaglastgenerations","title":"function ResetMainTagLastGenerations","text":"<pre><code>inline void cowboys::GPTrainingLoop::ResetMainTagLastGenerations () \n</code></pre> <p>Resets the xml for data that needs to be overwritten </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-run","title":"function Run","text":"<p>: runs the Genetic Programming training loop for a number of generations to evolve the agents </p> <pre><code>inline void cowboys::GPTrainingLoop::Run (\n    size_t numGenerations,\n    size_t numberOfTurns=100,\n    size_t maxThreads=0,\n    bool saveData=false\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>numGenerations</code> </li> <li><code>numberOfTurns</code> </li> <li><code>maxThreads</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-runarena","title":"function RunArena","text":"<p>Runs the training loop for a single arena. This function is called in a thread. Each arena is run in a separate thread. </p> <pre><code>inline void cowboys::GPTrainingLoop::RunArena (\n    size_t arena,\n    size_t numberOfTurns\n) \n</code></pre> <p>Author:</p> <p>: @amantham20 </p> <p>Parameters:</p> <ul> <li><code>arena</code> : The arena to run. </li> <li><code>numberOfTurns</code> : The number of turns to run the arena for. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-savedatacheckpoint","title":"function SaveDataCheckPoint","text":"<pre><code>inline void cowboys::GPTrainingLoop::SaveDataCheckPoint (\n    const SaveDataParams &amp; params\n) \n</code></pre> <p>Saves checkpoint data to XML files everyso often </p> <p>Parameters:</p> <ul> <li><code>params</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-serializeagents","title":"function SerializeAgents","text":"<p>: Serializes the agents to an XML file. </p> <pre><code>inline void cowboys::GPTrainingLoop::SerializeAgents (\n    int generation,\n    tinyxml2::XMLElement * rootElement,\n    tinyxml2::XMLDocument &amp; paramDocument,\n    size_t topN=5\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>countMaxAgents</code> </li> <li><code>generation</code> </li> <li><code>topN</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-simplefitnessfunction","title":"function SimpleFitnessFunction","text":"<pre><code>inline double cowboys::GPTrainingLoop::SimpleFitnessFunction (\n    cse491::AgentBase &amp; agent,\n    cse491::GridPosition startPosition\n) \n</code></pre> <p>Simple and temporary fitness function </p> <p>Parameters:</p> <ul> <li><code>agent</code> </li> <li><code>startPosition</code> </li> </ul> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-sortthemagents","title":"function SortThemAgents","text":"<pre><code>inline void cowboys::GPTrainingLoop::SortThemAgents () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-threadtrainloop","title":"function ThreadTrainLoop","text":"<pre><code>inline void cowboys::GPTrainingLoop::ThreadTrainLoop (\n    size_t maxThreads=1,\n    int numberOfTurns=100\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>maxThreads</code> </li> <li><code>numberOfTurns</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-loadlastgeneration","title":"function loadLastGeneration","text":"<pre><code>inline void cowboys::GPTrainingLoop::loadLastGeneration () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-resetenvironments","title":"function resetEnvironments","text":"<pre><code>inline void cowboys::GPTrainingLoop::resetEnvironments () \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-savexmldoc","title":"function saveXMLDoc","text":"<pre><code>inline void cowboys::GPTrainingLoop::saveXMLDoc (\n    tinyxml2::XMLDocument &amp; paramdoc,\n    std::string fullPath\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-gptrainingloop_1","title":"function ~GPTrainingLoop","text":"<pre><code>cowboys::GPTrainingLoop::~GPTrainingLoop () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-getdatestr","title":"function getDateStr","text":"<pre><code>static inline std::string cowboys::GPTrainingLoop::getDateStr () \n</code></pre> <p>Gets the date and time as a string </p> <p>Returns:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_g_p_training_loop/#function-getsystempath","title":"function getSystemPath","text":"<pre><code>static inline std::filesystem::path cowboys::GPTrainingLoop::getSystemPath () \n</code></pre> <p>Gets the path of the save location </p> <p>Returns:</p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPTrainingLoop.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/","title":"Struct cowboys::GPTrainingLoop::SaveDataParams","text":"<p>ClassList &gt; cowboys &gt; GPTrainingLoop &gt; SaveDataParams</p> <p>More...</p> <ul> <li><code>#include &lt;GPTrainingLoop.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#public-attributes","title":"Public Attributes","text":"Type Name size_t checkPointEvery   = = 5 size_t countMaxAgents   = = 0 std::string dateTimeStr   = = getDateStr() size_t generation std::filesystem::path normalizedAbsolutePath   = = getSystemPath() bool save   = = false bool saveAllAgentData   = = false bool saveLastGenerations   = = false bool saveMetaData   = = true bool saveTopAgents   = = false"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#public-functions","title":"Public Functions","text":"Type Name SaveDataParams (size_t gen)  void updateGeneration (size_t gen)"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#detailed-description","title":"Detailed Description","text":"<p>SaveDataParams for saving data in checkpoints </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-checkpointevery","title":"variable checkPointEvery","text":"<pre><code>size_t checkPointEvery;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-countmaxagents","title":"variable countMaxAgents","text":"<pre><code>size_t countMaxAgents;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-datetimestr","title":"variable dateTimeStr","text":"<pre><code>std::string dateTimeStr;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-generation","title":"variable generation","text":"<pre><code>size_t generation;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-normalizedabsolutepath","title":"variable normalizedAbsolutePath","text":"<pre><code>std::filesystem::path normalizedAbsolutePath;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-save","title":"variable save","text":"<pre><code>bool save;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-saveallagentdata","title":"variable saveAllAgentData","text":"<pre><code>bool saveAllAgentData;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-savelastgenerations","title":"variable saveLastGenerations","text":"<pre><code>bool saveLastGenerations;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-savemetadata","title":"variable saveMetaData","text":"<pre><code>bool saveMetaData;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#variable-savetopagents","title":"variable saveTopAgents","text":"<pre><code>bool saveTopAgents;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#function-savedataparams","title":"function SaveDataParams","text":"<pre><code>inline cowboys::GPTrainingLoop::SaveDataParams::SaveDataParams (\n    size_t gen\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_g_p_training_loop_1_1_save_data_params/#function-updategeneration","title":"function updateGeneration","text":"<pre><code>inline void cowboys::GPTrainingLoop::SaveDataParams::updateGeneration (\n    size_t gen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPTrainingLoop.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/","title":"Class cowboys::Graph","text":"<p>ClassList &gt; cowboys &gt; Graph</p> <p>A graph of nodes that can be used to make decisions. </p> <ul> <li><code>#include &lt;Graph.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#public-functions","title":"Public Functions","text":"Type Name void AddLayer (const GraphLayer &amp; layer) Add a layer to the graph. Purely organizational, but important for CGP for determining the \"layers back\" parameter. std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; GetFunctionalNodes () constReturns a vector of functional (non-input) nodes in the graph. size_t GetLayerCount () constGet the number of layers in the graph. size_t GetNodeCount () constGet the number of nodes in the graph. std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; GetNodes () constReturns a vector of all nodes in the graph. Graph () = default size_t MakeDecision (const std::vector&lt; double &gt; &amp; inputs, const std::vector&lt; size_t &gt; &amp; actions) Makes a decision based on the inputs and the action vector. ~Graph () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; GraphLayer &gt; layers Layers of nodes in the graph."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-addlayer","title":"function AddLayer","text":"<p>Add a layer to the graph. Purely organizational, but important for CGP for determining the \"layers back\" parameter. </p> <pre><code>inline void cowboys::Graph::AddLayer (\n    const GraphLayer &amp; layer\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>layer</code> The layer of nodes to add. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-getfunctionalnodes","title":"function GetFunctionalNodes","text":"<p>Returns a vector of functional (non-input) nodes in the graph. </p> <pre><code>inline std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; cowboys::Graph::GetFunctionalNodes () const\n</code></pre> <p>Returns:</p> <p>A vector of functional nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-getlayercount","title":"function GetLayerCount","text":"<p>Get the number of layers in the graph. </p> <pre><code>inline size_t cowboys::Graph::GetLayerCount () const\n</code></pre> <p>Returns:</p> <p>The number of layers in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-getnodecount","title":"function GetNodeCount","text":"<p>Get the number of nodes in the graph. </p> <pre><code>inline size_t cowboys::Graph::GetNodeCount () const\n</code></pre> <p>Returns:</p> <p>The number of nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-getnodes","title":"function GetNodes","text":"<p>Returns a vector of all nodes in the graph. </p> <pre><code>inline std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; cowboys::Graph::GetNodes () const\n</code></pre> <p>Returns:</p> <p>A vector of all nodes in the graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-graph","title":"function Graph","text":"<pre><code>cowboys::Graph::Graph () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-makedecision","title":"function MakeDecision","text":"<p>Makes a decision based on the inputs and the action vector. </p> <pre><code>inline size_t cowboys::Graph::MakeDecision (\n    const std::vector&lt; double &gt; &amp; inputs,\n    const std::vector&lt; size_t &gt; &amp; actions\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>inputs</code> The inputs to the graph. </li> <li><code>action_vec</code> The action vector. </li> </ul> <p>Returns:</p> <p>The action to take. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#function-graph_1","title":"function ~Graph","text":"<pre><code>cowboys::Graph::~Graph () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph/#variable-layers","title":"variable layers","text":"<pre><code>std::vector&lt;GraphLayer&gt; layers;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/Graph.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/","title":"Class cowboys::GraphBuilder","text":"<p>ClassList &gt; cowboys &gt; GraphBuilder</p> <p>A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs.</p> <ul> <li><code>#include &lt;GraphBuilder.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#public-functions","title":"Public Functions","text":"Type Name std::unique_ptr&lt; Graph &gt; CartesianGraph (const CGPGenotype &amp; genotype, const std::vector&lt; InnerFunction &gt; &amp; function_set, const cse491::AgentBase * agent=nullptr) Creates a decision graph from a CGP genotype. GraphBuilder () = default std::unique_ptr&lt; Graph &gt; VerticalPacer () Creates a decision graph for pacing up and down in a MazeWorld. Assumes that the inputs are in the format: prev_action, current_state, above_state, below_state, left_state, right_state. ~GraphBuilder () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#function-cartesiangraph","title":"function CartesianGraph","text":"<p>Creates a decision graph from a CGP genotype. </p> <pre><code>inline std::unique_ptr&lt; Graph &gt; cowboys::GraphBuilder::CartesianGraph (\n    const CGPGenotype &amp; genotype,\n    const std::vector&lt; InnerFunction &gt; &amp; function_set,\n    const cse491::AgentBase * agent=nullptr\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>genotype</code> The genotype to create the decision graph from. </li> <li><code>function_set</code> The set of functions available to the decision graph. </li> <li><code>agent</code> The agent that will be using the decision graph. </li> </ul> <p>Returns:</p> <p>The decision graph. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#function-graphbuilder","title":"function GraphBuilder","text":"<pre><code>cowboys::GraphBuilder::GraphBuilder () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#function-verticalpacer","title":"function VerticalPacer","text":"<p>Creates a decision graph for pacing up and down in a MazeWorld. Assumes that the inputs are in the format: prev_action, current_state, above_state, below_state, left_state, right_state. </p> <pre><code>inline std::unique_ptr&lt; Graph &gt; cowboys::GraphBuilder::VerticalPacer () \n</code></pre> <p>Parameters:</p> <ul> <li><code>action_vec</code> Assumes that the action outputs are in the format: up, down, left, right </li> </ul> <p>Returns:</p> <p>The decision graph for a vertical pacer. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_builder/#function-graphbuilder_1","title":"function ~GraphBuilder","text":"<pre><code>cowboys::GraphBuilder::~GraphBuilder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphBuilder.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/","title":"Class cowboys::GraphNode","text":"<p>ClassList &gt; cowboys &gt; GraphNode</p> <p>A node in a decision graph. More...</p> <ul> <li><code>#include &lt;GraphNode.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::enable_shared_from_this&lt; GraphNode &gt;</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#public-functions","title":"Public Functions","text":"Type Name void AddInput (std::shared_ptr&lt; GraphNode &gt; node) Add an input node to this node. void AddInputs (const std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; &amp; nodes) Append nodes in a vector to this node's list of inputs. double GetDefaultOutput () constGet the default output of this node. std::vector&lt; double &gt; GetInputValues () constGet the output values of the inputs of this node. std::optional&lt; std::vector&lt; double &gt; &gt; GetInputValues (const std::array&lt; size_t, N &gt; &amp; indices) constGet the output values of the inputs of this node given an array of indices. double GetOutput () constGet the output of this node. Performs caching. GraphNode () = default GraphNode (double default_value) TODO: Check guidelines for this. GraphNode (NodeFunction function)  GraphNode (InnerFunction function)  bool IsCacheValid () constCheck if the cached output is valid. void SetDefaultOutput (double value) Set the default output of this node. void SetFunctionPointer (NodeFunction function) Set the function pointer of this node. void SetFunctionPointer (InnerFunction inner_function) Set the function pointer of this node. void SetInputs (std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; nodes) Set the input nodes of this node. ~GraphNode () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#protected-attributes","title":"Protected Attributes","text":"Type Name double cached_output   = {0}The cached output of this node. bool cached_output_valid   = {false}Flag indicating whether the cached output is valid. double default_output   = {0}The default output of this node. NodeFunction function_pointer The function that operates on the outputs from a node's input nodes. std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; inputs The input nodes to this node. std::vector&lt; GraphNode * &gt; outputs The nodes connected to this node's output."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#protected-functions","title":"Protected Functions","text":"Type Name void AddOutput (GraphNode * node) Add an output node to this node. Used for cache invalidation. void RecursiveInvalidateCache () constInvalidates this node's cache and the caches of all nodes that depend on this node."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>This should always be a shared pointer. Caching will not work otherwise. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-addinput","title":"function AddInput","text":"<p>Add an input node to this node. </p> <pre><code>inline void cowboys::GraphNode::AddInput (\n    std::shared_ptr&lt; GraphNode &gt; node\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to add as an input. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-addinputs","title":"function AddInputs","text":"<p>Append nodes in a vector to this node's list of inputs. </p> <pre><code>inline void cowboys::GraphNode::AddInputs (\n    const std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; &amp; nodes\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nodes</code> The nodes to add as inputs. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-getdefaultoutput","title":"function GetDefaultOutput","text":"<p>Get the default output of this node. </p> <pre><code>inline double cowboys::GraphNode::GetDefaultOutput () const\n</code></pre> <p>Returns:</p> <p>The default output. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-getinputvalues-12","title":"function GetInputValues [1/2]","text":"<p>Get the output values of the inputs of this node. </p> <pre><code>inline std::vector&lt; double &gt; cowboys::GraphNode::GetInputValues () const\n</code></pre> <p>Returns:</p> <p>A vector of doubles representing the input values. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-getinputvalues-22","title":"function GetInputValues [2/2]","text":"<p>Get the output values of the inputs of this node given an array of indices. </p> <pre><code>template&lt;size_t N&gt;\ninline std::optional&lt; std::vector&lt; double &gt; &gt; cowboys::GraphNode::GetInputValues (\n    const std::array&lt; size_t, N &gt; &amp; indices\n) const\n</code></pre> <p>Template parameters:</p> <ul> <li><code>N</code> The size of the indices array. </li> </ul> <p>Parameters:</p> <ul> <li><code>indices</code> The indices of the inputs to get the output values of. </li> </ul> <p>Returns:</p> <p>A vector of doubles representing the input values in the same order of the indices. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-getoutput","title":"function GetOutput","text":"<p>Get the output of this node. Performs caching. </p> <pre><code>inline double cowboys::GraphNode::GetOutput () const\n</code></pre> <p>Returns:</p> <p>The output of this node. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode-14","title":"function GraphNode [1/4]","text":"<pre><code>cowboys::GraphNode::GraphNode () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode-24","title":"function GraphNode [2/4]","text":"<pre><code>inline cowboys::GraphNode::GraphNode (\n    double default_value\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode-34","title":"function GraphNode [3/4]","text":"<pre><code>inline cowboys::GraphNode::GraphNode (\n    NodeFunction function\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode-44","title":"function GraphNode [4/4]","text":"<pre><code>inline cowboys::GraphNode::GraphNode (\n    InnerFunction function\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-iscachevalid","title":"function IsCacheValid","text":"<p>Check if the cached output is valid. </p> <pre><code>inline bool cowboys::GraphNode::IsCacheValid () const\n</code></pre> <p>Returns:</p> <p>True if the cached output is valid, false otherwise. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-setdefaultoutput","title":"function SetDefaultOutput","text":"<p>Set the default output of this node. </p> <pre><code>inline void cowboys::GraphNode::SetDefaultOutput (\n    double value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The new default output. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-setfunctionpointer-12","title":"function SetFunctionPointer [1/2]","text":"<p>Set the function pointer of this node. </p> <pre><code>inline void cowboys::GraphNode::SetFunctionPointer (\n    NodeFunction function\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>function</code> The function for this node to use. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-setfunctionpointer-22","title":"function SetFunctionPointer [2/2]","text":"<p>Set the function pointer of this node. </p> <pre><code>inline void cowboys::GraphNode::SetFunctionPointer (\n    InnerFunction inner_function\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>inner_function</code> The inner function for this node to use. Will be wrapped in a NodeFunction. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-setinputs","title":"function SetInputs","text":"<p>Set the input nodes of this node. </p> <pre><code>inline void cowboys::GraphNode::SetInputs (\n    std::vector&lt; std::shared_ptr&lt; GraphNode &gt; &gt; nodes\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>nodes</code> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-graphnode","title":"function ~GraphNode","text":"<pre><code>cowboys::GraphNode::~GraphNode () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-cached_output","title":"variable cached_output","text":"<pre><code>double cached_output;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-cached_output_valid","title":"variable cached_output_valid","text":"<pre><code>bool cached_output_valid;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-default_output","title":"variable default_output","text":"<pre><code>double default_output;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-function_pointer","title":"variable function_pointer","text":"<pre><code>NodeFunction function_pointer;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-inputs","title":"variable inputs","text":"<pre><code>std::vector&lt;std::shared_ptr&lt;GraphNode&gt; &gt; inputs;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#variable-outputs","title":"variable outputs","text":"<pre><code>std::vector&lt;GraphNode *&gt; outputs;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-addoutput","title":"function AddOutput","text":"<p>Add an output node to this node. Used for cache invalidation. </p> <pre><code>inline void cowboys::GraphNode::AddOutput (\n    GraphNode * node\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>node</code> The node to add as an output. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_graph_node/#function-recursiveinvalidatecache","title":"function RecursiveInvalidateCache","text":"<pre><code>inline void cowboys::GraphNode::RecursiveInvalidateCache () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphNode.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/","title":"Class cowboys::LGPAgent","text":"<p>ClassList &gt; cowboys &gt; LGPAgent</p> <p>Inherits the following classes: cowboys::GPAgentBase</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-functions","title":"Public Functions","text":"Type Name void Configure (const LGPAgent &amp; other) Copies the behavior of another LGPAgent into this agent. virtual void Copy (const GPAgentBase &amp; other) overrideCopy the behavior of another agent into this agent. virtual std::string Export () overrideExport the agent to a string. void GenerateRandomActionList () Generate a random list of instructions from a list of possible instructions. virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) overrideGet the action to take. const std::vector&lt; std::tuple&lt; std::string, int, int &gt; &gt; &amp; GetInstructionsList () Get the instruction list for this agent. virtual void Import (const std::string &amp; encodedLists) overrideLoad in the string representation of an LGP agent and configure this agent based on it. bool Initialize () overrideInitialize the agent after being given an action map. LGPAgent (size_t id, const std::string &amp; name)  virtual void MutateAgent (double mutation_rate=0.01) overrideMutate this agent. virtual void PrintAgent () overridePrint the agent. virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) overrideSerialize this agent to XML."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-functions-inherited-from-cowboysgpagentbase","title":"Public Functions inherited from cowboys::GPAgentBase","text":"<p>See cowboys::GPAgentBase</p> Type Name virtual void Copy (const GPAgentBase &amp; other) = 0Copy the behavior of another agent into this agent. virtual std::string Export ()  GPAgentBase (size_t id, const std::string &amp; name)  virtual size_t GetAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) = 0 const std::unordered_map&lt; std::string, double &gt; GetExtraState () constGet a map of extra state information. double GetRandom () Return a uniform random value between 0.0 and 1.0. double GetRandom (double max) Return a uniform random value between 0.0 and max. double GetRandom (double min, double max) Return a uniform random value between min and max. double GetRandomNormal () Return a gaussian random value with mean 0.0 and sd 1.0. double GetRandomNormal (double mean, double sd=1.0) Return a gaussian random value with provided mean and sd. size_t GetRandomULL (size_t max) Return a uniform random unsigned long long between 0 (inclusive) and max (exclusive) unsigned int GetSeed () constGet the seed used to initialize this RNG. virtual void Import (const std::string &amp; genotype) = 0 bool Initialize () overrideSetup graph. virtual void MutateAgent (double mutation_rate=0.8) = 0Mutate this agent. virtual void PrintAgent ()  virtual void Reset (bool=false)  size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_map_t &amp; item_set, const cse491::agent_map_t &amp; agent_set) overrideChoose the action to take a step in the appropriate direction. virtual void SerializeGP (tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement * parentElem, double fitness=-1) = 0 void SetSeed (unsigned int seed) Set the seed used to initialize this RNG. ~GPAgentBase () = default"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-static-functions","title":"Public Static Functions","text":"Type Name std::vector&lt; std::string &gt; EncodeActions (const std::unordered_map&lt; std::string, size_t &gt; &amp; action_map, const std::vector&lt; std::string &gt; &amp; sensorsNamesList, const std::vector&lt; std::string &gt; &amp; operationsList, std::vector&lt; std::string &gt; &amp; actionsList) Encodes the actions from an agent's action map into a vector of string, representing action names."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; std::string &gt; actionsList   = = {} size_t currentInstructionIndex   = = 0 std::mt19937 gen std::vector&lt; std::tuple&lt; std::string, int, int &gt; &gt; instructionsList   = = {} std::vector&lt; std::string &gt; operationsList   = = {\"lessthan\", \"greaterthan\", \"equals\"} std::vector&lt; std::string &gt; possibleInstructionsList   = = {} std::random_device rd std::vector&lt; int &gt; resultsList std::vector&lt; std::string &gt; sensorsNamesList   = = {\"getLeft\", \"getRight\", \"getUp\", \"getDown\"}"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#protected-attributes-inherited-from-cowboysgpagentbase","title":"Protected Attributes inherited from cowboys::GPAgentBase","text":"<p>See cowboys::GPAgentBase</p> Type Name std::unordered_map&lt; std::string, double &gt; extra_state A map of extra state information. std::normal_distribution&lt; double &gt; norm_dist Normal distribution. std::mt19937 rng   = {seed}Random number generator. unsigned int seed   = = 0Seed for the random number generator. std::uniform_real_distribution&lt; double &gt; uni_dist Uniform distribution."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-configure","title":"function Configure","text":"<p>Copies the behavior of another LGPAgent into this agent.</p> <pre><code>inline void cowboys::LGPAgent::Configure (\n    const LGPAgent &amp; other\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The LGPAgent to copy. </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-copy","title":"function Copy","text":"<p>Copy the behavior of another agent into this agent. </p> <pre><code>inline virtual void cowboys::LGPAgent::Copy (\n    const GPAgentBase &amp; other\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>other</code> The agent to copy. </li> </ul> <p>Implements cowboys::GPAgentBase::Copy</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-export","title":"function Export","text":"<p>Export the agent to a string. </p> <pre><code>inline virtual std::string cowboys::LGPAgent::Export () override\n</code></pre> <p>Returns:</p> <p>The string representation of the agent </p> <p>Implements cowboys::GPAgentBase::Export</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-generaterandomactionlist","title":"function GenerateRandomActionList","text":"<p>Generate a random list of instructions from a list of possible instructions. </p> <pre><code>inline void cowboys::LGPAgent::GenerateRandomActionList () \n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-getaction","title":"function GetAction","text":"<p>Get the action to take. </p> <pre><code>inline virtual size_t cowboys::LGPAgent::GetAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_map_t &amp; item_set,\n    const cse491::agent_map_t &amp; agent_set\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> The world grid. </li> <li><code>type_options</code> The available types of cells in the grid. </li> <li><code>item_set</code> The set of items in the world. </li> <li><code>agent_set</code> The set of agents in the world. </li> </ul> <p>Returns:</p> <p>A size_t corresponding to the action chosen </p> <p>Implements cowboys::GPAgentBase::GetAction</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-getinstructionslist","title":"function GetInstructionsList","text":"<p>Get the instruction list for this agent. </p> <pre><code>inline const std::vector&lt; std::tuple&lt; std::string, int, int &gt; &gt; &amp; cowboys::LGPAgent::GetInstructionsList () \n</code></pre> <p>Returns:</p> <p>A const reference to the instruction list for this agent. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-import","title":"function Import","text":"<p>Load in the string representation of an LGP agent and configure this agent based on it. </p> <pre><code>inline virtual void cowboys::LGPAgent::Import (\n    const std::string &amp; encodedLists\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>genotype</code> The string representation of an LGP agent. </li> </ul> <p>Implements cowboys::GPAgentBase::Import</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-initialize","title":"function Initialize","text":"<p>Initialize the agent after being given an action map. </p> <pre><code>inline bool cowboys::LGPAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-lgpagent","title":"function LGPAgent","text":"<pre><code>inline cowboys::LGPAgent::LGPAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-mutateagent","title":"function MutateAgent","text":"<p>Mutate this agent. </p> <pre><code>inline virtual void cowboys::LGPAgent::MutateAgent (\n    double mutation_rate=0.01\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>mutation_rate</code> The probability of any instruction being changed </li> </ul> <p>Implements cowboys::GPAgentBase::MutateAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-printagent","title":"function PrintAgent","text":"<pre><code>inline virtual void cowboys::LGPAgent::PrintAgent () override\n</code></pre> <p>Implements cowboys::GPAgentBase::PrintAgent</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-serializegp","title":"function SerializeGP","text":"<p>Serialize this agent to XML. </p> <pre><code>inline virtual void cowboys::LGPAgent::SerializeGP (\n    tinyxml2::XMLDocument &amp; doc,\n    tinyxml2::XMLElement * parentElem,\n    double fitness=-1\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>doc</code> The XML document to serialize to. </li> <li><code>parentElem</code> The parent element to serialize to. </li> <li><code>fitness</code> The fitness of this agent to write to the XML. </li> </ul> <p>Implements cowboys::GPAgentBase::SerializeGP</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#function-encodeactions","title":"function EncodeActions","text":"<p>Encodes the actions from an agent's action map into a vector of string, representing action names. </p> <pre><code>static inline std::vector&lt; std::string &gt; cowboys::LGPAgent::EncodeActions (\n    const std::unordered_map&lt; std::string, size_t &gt; &amp; action_map,\n    const std::vector&lt; std::string &gt; &amp; sensorsNamesList,\n    const std::vector&lt; std::string &gt; &amp; operationsList,\n    std::vector&lt; std::string &gt; &amp; actionsList\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>action_map</code> The action map from the agent. </li> <li><code>sensorsNamesList</code> The list of sensors from the agent. </li> <li><code>operationsList</code> The list of operations from the agent. </li> <li><code>actionsList</code> The list of actions from the agent. </li> </ul> <p>Returns:</p> <p>A vector of strings, representing action names. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-actionslist","title":"variable actionsList","text":"<pre><code>std::vector&lt;std::string&gt; actionsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-currentinstructionindex","title":"variable currentInstructionIndex","text":"<pre><code>size_t currentInstructionIndex;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-gen","title":"variable gen","text":"<pre><code>std::mt19937 gen;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-instructionslist","title":"variable instructionsList","text":"<pre><code>std::vector&lt;std::tuple&lt;std::string, int, int&gt; &gt; instructionsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-operationslist","title":"variable operationsList","text":"<pre><code>std::vector&lt;std::string&gt; operationsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-possibleinstructionslist","title":"variable possibleInstructionsList","text":"<pre><code>std::vector&lt;std::string&gt; possibleInstructionsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-rd","title":"variable rd","text":"<pre><code>std::random_device rd;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-resultslist","title":"variable resultsList","text":"<pre><code>std::vector&lt;int&gt; resultsList;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_l_g_p_agent/#variable-sensorsnameslist","title":"variable sensorsNamesList","text":"<pre><code>std::vector&lt;std::string&gt; sensorsNamesList;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/LGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/","title":"Struct cowboys::NodeFunction","text":"<p>ClassList &gt; cowboys &gt; NodeFunction</p> <p>A function pointer wrapper that holds extra arguments for the function pointer. </p> <ul> <li><code>#include &lt;GraphNode.hpp&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#public-attributes","title":"Public Attributes","text":"Type Name const cse491::AgentBase * agent   = {nullptr} InnerFunction function   = {nullptr}"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#public-functions","title":"Public Functions","text":"Type Name bool IsNull () const double operator() (const GraphNode &amp; node) const"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#variable-agent","title":"variable agent","text":"<pre><code>const cse491::AgentBase* agent;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#variable-function","title":"variable function","text":"<pre><code>InnerFunction function;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#function-isnull","title":"function IsNull","text":"<pre><code>inline bool cowboys::NodeFunction::IsNull () const\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/structcowboys_1_1_node_function/#function-operator","title":"function operator()","text":"<pre><code>inline double cowboys::NodeFunction::operator() (\n    const GraphNode &amp; node\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphNode.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/","title":"Class cowboys::Sensors","text":"<p>ClassList &gt; cowboys &gt; Sensors</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#public-functions","title":"Public Functions","text":"Type Name Sensors () = defaultConstructor. ~Sensors () = defaultDestructor."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#public-static-functions","title":"Public Static Functions","text":"Type Name SensorDirection getSensorDirectionEnum (const std::string &amp; direction)  int wallDistance (const cse491::WorldGrid &amp; grid, const cse491::AgentBase &amp; agent, SensorDirection direction) returns the distance to the wall in a given direction from the agent"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#function-sensors","title":"function Sensors","text":"<pre><code>cowboys::Sensors::Sensors () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#function-sensors_1","title":"function ~Sensors","text":"<pre><code>cowboys::Sensors::~Sensors () = default\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#function-getsensordirectionenum","title":"function getSensorDirectionEnum","text":"<pre><code>static inline SensorDirection cowboys::Sensors::getSensorDirectionEnum (\n    const std::string &amp; direction\n) \n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classcowboys_1_1_sensors/#function-walldistance","title":"function wallDistance","text":"<p>returns the distance to the wall in a given direction from the agent </p> <pre><code>static inline int cowboys::Sensors::wallDistance (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::AgentBase &amp; agent,\n    SensorDirection direction\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>grid</code> grid maze of the world </li> <li><code>agent</code> agent to find the distance from </li> <li><code>direction</code> direction to find the distance (LEFT, RIGHT, ABOVE, BELOW) </li> </ul> <p>Returns:</p> <p>distance to the wall </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentSensors.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/","title":"Namespace cowboys::base64","text":"<p>Namespace List &gt; cowboys &gt; base64</p> <p>A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x)).</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr char CHARS   = = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/\"The characters used to represent digits in base64 . constexpr std::array&lt; size_t, MAX_CHAR+1 &gt; CHAR_TO_IDX   = =  { std::array&lt;size_t, MAX_CHAR + 1&gt; indices{}; for (size_t i = 0; i &lt; 64; ++i) { indices[CHARS[i]] = i; } return indices; }() constexpr size_t MAX_CHAR   = = *std::max_element(CHARS, CHARS + 64)"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#public-static-functions","title":"Public Static Functions","text":"Type Name std::string B2ToB64 (const std::string &amp; binary) Converts a binary string to a base64 string. std::string B64ToB2 (std::string base64) Converts a base64 string to a binary string. double B64ToDouble (const std::string &amp; value) Converts a base64 string to a double. See DoubleToB64 for precision issues. size_t B64ToULL (std::string num_base64) Converts a number in base64 to base10. std::string DoubleToB64 (double value) Converts a double to a base64 string. Assumes that the stoull(to_string(value)) is possible. Only guarantees that x ~= b64_inv(b64(x)) due to precision errors. Empirically accurate up to 3 decimal places, e.g. round(x, 3) = round(b64_inv(b64(x)), 3). std::string ULLToB64 (size_t ull) Converts a number in base10 to base64 ."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#variable-chars","title":"variable CHARS","text":"<pre><code>constexpr char CHARS[];\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#variable-char_to_idx","title":"variable CHAR_TO_IDX","text":"<pre><code>constexpr std::array&lt;size_t, MAX_CHAR + 1&gt; CHAR_TO_IDX;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#variable-max_char","title":"variable MAX_CHAR","text":"<pre><code>constexpr size_t MAX_CHAR;\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-b2tob64","title":"function B2ToB64","text":"<p>Converts a binary string to a base64 string.</p> <pre><code>static std::string cowboys::base64::B2ToB64 (\n    const std::string &amp; binary\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>binary</code> A string of 1s and 0s representing binary. </li> </ul> <p>Returns:</p> <p>The binary string in base64. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-b64tob2","title":"function B64ToB2","text":"<p>Converts a base64 string to a binary string.</p> <pre><code>static std::string cowboys::base64::B64ToB2 (\n    std::string base64\n) \n</code></pre> <p>Parameters:</p> <ul> <li>base64 A string of base64 characters. </li> </ul> <p>Returns:</p> <p>The base64 string in binary. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-b64todouble","title":"function B64ToDouble","text":"<p>Converts a base64 string to a double. See DoubleToB64 for precision issues.</p> <pre><code>static double cowboys::base64::B64ToDouble (\n    const std::string &amp; value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The base64 string to convert. </li> </ul> <p>Returns:</p> <p>The base64 string as a double. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-b64toull","title":"function B64ToULL","text":"<p>Converts a number in base64 to base10.</p> <pre><code>static size_t cowboys::base64::B64ToULL (\n    std::string num_base64\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>num_base64</code> The number in base64 as a string. </li> </ul> <p>Returns:</p> <p>The number in base10. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-doubletob64","title":"function DoubleToB64","text":"<p>Converts a double to a base64 string. Assumes that the stoull(to_string(value)) is possible. Only guarantees that x ~= b64_inv(b64(x)) due to precision errors. Empirically accurate up to 3 decimal places, e.g. round(x, 3) = round(b64_inv(b64(x)), 3).</p> <pre><code>static std::string cowboys::base64::DoubleToB64 (\n    double value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> The double to convert. </li> </ul> <p>Returns:</p> <p>The double in base64. </p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecowboys_1_1base64/#function-ulltob64","title":"function ULLToB64","text":"<p>Converts a number in base10 to base64 .</p> <pre><code>static std::string cowboys::base64::ULLToB64 (\n    size_t ull\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>ull</code> The number to convert. </li> </ul> <p>Returns:</p> <p>The number in base64 as a string. </p> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Agents <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_425e53e3c77c59c8573ea1fd0ff9622a/","title":"Dir source/Agents","text":"<p>FileList &gt; Agents</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_425e53e3c77c59c8573ea1fd0ff9622a/#directories","title":"Directories","text":"Type Name dir GP <p>The documentation for this class was generated from the following file <code>source/Agents/</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_24320de467b989ce68b31a9ae5cbbd05/","title":"Dir source/Agents/GP","text":"<p>FileList &gt; Agents &gt; GP</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/dir_24320de467b989ce68b31a9ae5cbbd05/#files","title":"Files","text":"Type Name file CGPAgent.hpp file CGPGenotype.hpp file GPAgent.hpp file GPAgentAnalyze.h file GPAgentBase.hpp file GPAgentSensors.hpp file GPAgentsRegisters.hpp file GPTrainingLoop.hpp file Graph.hpp file GraphBuilder.hpp file GraphNode.hpp file LGPAgent.hpp <p>The documentation for this class was generated from the following file <code>source/Agents/GP/</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_agent_8hpp/","title":"File CGPAgent.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; CGPAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"GPAgentBase.hpp\"</code></li> <li><code>#include \"GraphBuilder.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_agent_8hpp/#classes","title":"Classes","text":"Type Name class CGPAgent An agent based on cartesian genetic programming. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_agent_8hpp_source/","title":"File CGPAgent.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; CGPAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;random&gt;\n#include &lt;string&gt;\n\n#include \"GPAgentBase.hpp\"\n#include \"GraphBuilder.hpp\"\n\nnamespace cowboys {\n  constexpr size_t INPUT_SIZE = 9;\n\n  constexpr size_t NUM_LAYERS = 3;\n\n  constexpr size_t NUM_NODES_PER_LAYER = 2;\n\n  constexpr size_t LAYERS_BACK = 2;\n\n  class CGPAgent : public GPAgentBase {\n  protected:\n    CGPGenotype genotype;\n\n    std::unique_ptr&lt;Graph&gt; decision_graph;\n\n\n\n  public:\n    CGPAgent(size_t id, const std::string &amp;name) : GPAgentBase(id, name) {}\n    CGPAgent(size_t id, const std::string &amp;name, const CGPGenotype &amp;genotype)\n        : GPAgentBase(id, name), genotype(genotype) {}\n\n\n    void PrintAgent() override {\n      std::cout &lt;&lt; \"Genotype: \" &lt;&lt; genotype.Export() &lt;&lt; std::endl;\n    }\n\n    void MutateAgent(double mutation = 0.8) override {\n      auto graph_builder = GraphBuilder();\n\n      genotype.MutateDefault(mutation, *this);\n\n      decision_graph = graph_builder.CartesianGraph(genotype, FUNCTION_SET, this);\n    }\n    bool Initialize() override {\n\n      // Create a default genotype if none was provided in the constructor\n      if (genotype.GetNumFunctionalNodes() == 0) {\n        genotype = CGPGenotype({INPUT_SIZE, action_map.size(), NUM_LAYERS, NUM_NODES_PER_LAYER, LAYERS_BACK});\n      }\n\n      // Mutate the beginning genotype, might not want this.\n      MutateAgent(0.2);\n\n      return true;\n    }\n\n    size_t GetAction(const cse491::WorldGrid &amp;grid, const cse491::type_options_t &amp;type_options,\n                     const cse491::item_map_t &amp;item_set, const cse491::agent_map_t &amp;agent_set) override {\n      auto inputs = EncodeState(grid, type_options, item_set, agent_set, this, extra_state);\n      size_t action_to_take = decision_graph-&gt;MakeDecision(inputs, EncodeActions(action_map));\n      return action_to_take;\n    }\n\n    void SerializeGP(tinyxml2::XMLDocument &amp;doc, tinyxml2::XMLElement *parentElem, double fitness = -1) override {\n      auto agentElem = doc.NewElement(\"CGPAgent\");\n      parentElem-&gt;InsertEndChild(agentElem);\n\n      auto genotypeElem = doc.NewElement(\"genotype\");\n      genotypeElem-&gt;SetText(genotype.Export().c_str());\n      if (fitness != -1)\n        genotypeElem-&gt;SetAttribute(\"fitness\", fitness);\n\n      genotypeElem-&gt;SetAttribute(\"seed\" , seed);\n\n      agentElem-&gt;InsertEndChild(genotypeElem);\n\n    }\n\n    std::string Export() override { return genotype.Export(); }\n\n    void Import(const std::string &amp;genotype) override {\n      this-&gt;genotype.Configure(genotype);\n      decision_graph = GraphBuilder().CartesianGraph(this-&gt;genotype, FUNCTION_SET, this);\n    }\n\n    const CGPGenotype &amp;GetGenotype() const { return genotype; }\n\n\n    void Configure(const CGPAgent &amp;other) {\n      genotype = other.GetGenotype();\n      decision_graph = GraphBuilder().CartesianGraph(genotype, FUNCTION_SET, this);\n    }\n\n    void Copy(const GPAgentBase &amp;other) override {\n      assert(dynamic_cast&lt;const CGPAgent *&gt;(&amp;other) != nullptr);\n      Configure(dynamic_cast&lt;const CGPAgent &amp;&gt;(other));\n    }\n\n    double GetComplexity() const {\n      double connection_complexity =\n          static_cast&lt;double&gt;(genotype.GetNumConnections()) / genotype.GetNumPossibleConnections();\n\n      double functional_nodes = genotype.GetNumFunctionalNodes();\n\n      // Just needed some function such that connection_complexity + node_complexity grows as the number of nodes grows, this function makes the increase more gradual.\n      double node_complexity = std::log(functional_nodes) / 5;\n\n      double complexity = connection_complexity + node_complexity;\n      return complexity;\n    }\n  };\n\n} // End of namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_genotype_8hpp/","title":"File CGPGenotype.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; CGPGenotype.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../../core/WorldBase.hpp\"</code></li> <li><code>#include \"GPAgentBase.hpp\"</code></li> <li><code>#include \"GraphNode.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_genotype_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming. namespace base64 A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x))."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_genotype_8hpp/#classes","title":"Classes","text":"Type Name class CGPGenotype Holds all the information that uniquely defines a cartesian graph. struct CGPNodeGene Holds the representation of a cartesian graph node. struct CGPParameters Holds the parameters that define the structure of a cartesian graph. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/CGPGenotype.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_c_g_p_genotype_8hpp_source/","title":"File CGPGenotype.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; CGPGenotype.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;ranges&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"../../core/WorldBase.hpp\"\n#include \"GPAgentBase.hpp\"\n#include \"GraphNode.hpp\"\n\nnamespace cowboys {\n\n  constexpr char HEADER_SEP = ',';\n  constexpr char HEADER_END = ';';\n  constexpr char NODE_GENE_SEP = '.';\n  constexpr char NODE_SEP = ':';\n\n  namespace base64 {\n    static constexpr char CHARS[] = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/\";\n    static constexpr size_t MAX_CHAR = *std::max_element(CHARS, CHARS + 64);\n    static constexpr std::array&lt;size_t, MAX_CHAR + 1&gt; CHAR_TO_IDX = []() {\n      std::array&lt;size_t, MAX_CHAR + 1&gt; indices{};\n      for (size_t i = 0; i &lt; 64; ++i) {\n        indices[CHARS[i]] = i;\n      }\n      return indices;\n    }();\n\n    static std::string ULLToB64(size_t ull) {\n      if (ull == 0)\n        return \"0\";\n      // Range of numbers represented by n digits of base b excluding 0: b^(n-1) &lt;= x &lt;= b^n - 1\n      // -&gt; n-1 &lt;= log_b(x) -&gt; n-1 = floor(log_b(x)) -&gt; n = 1 + floor(log_b(x))\n      // Or x + 1 &lt;= b^n -&gt; log_b(x + 1) &lt;= n -&gt; ceil(log_b(x + 1)) = n; But this can cause an overflow when adding 1 to\n      // the max value of size_t\n      size_t n = 1 + std::floor(std::log(ull) / std::log(64));\n      std::string result(n, ' ');\n      for (size_t i = 0; ull &gt; 0; ++i) {\n        result[n - 1 - i] = CHARS[ull % 64];\n        ull /= 64;\n      }\n      return result;\n    }\n\n    static size_t B64ToULL(std::string num_base64) {\n      size_t result = 0;\n      for (size_t i = 0; i &lt; num_base64.size(); ++i) {\n        const char ch = num_base64[i];\n        const size_t coeff = std::pow(64, num_base64.size() - i - 1);\n        result += CHAR_TO_IDX[ch] * coeff;\n      }\n      return result;\n    }\n\n    static std::string B2ToB64(const std::string &amp;binary) {\n      // 2^6 = 64, so we can encode 6 bits at a time\n\n      size_t remainder = binary.size() % 6;\n      if (remainder != 0) {\n        // Pad the binary string with 0s to make it divisible by 6\n        return B2ToB64(std::string(6 - remainder, '0') + binary);\n      }\n\n      std::string result;\n      result.reserve(binary.size() / 6);\n      bool all_zeros = true;\n      for (size_t i = 0; i &lt; binary.size(); i += 6) {\n        std::string buffer = binary.substr(i, 6);\n        size_t ull = std::bitset&lt;6&gt;(buffer).to_ulong();\n        result += CHARS[ull];\n        if (ull != 0)\n          all_zeros = false;\n      }\n      if (all_zeros) // If all 0s, compress to 1 character\n        return std::string(1, CHARS[0]);\n      return result;\n    }\n\n    static std::string B64ToB2(std::string base64) {\n      std::string result = \"\";\n      for (size_t i = 0; i &lt; base64.size(); ++i) {\n        const char ch = base64[i];\n        const size_t ull = CHAR_TO_IDX[ch];\n        result += std::bitset&lt;6&gt;(ull).to_string();\n      }\n      // Remove leading 0s and return result: https://stackoverflow.com/a/31226728/13430191\n      return result.erase(0, std::min(result.find_first_not_of(CHARS[0]), result.size() - 1));\n    }\n\n    static std::string DoubleToB64(double value) {\n      std::string double_str = std::to_string(value);\n\n      // Sign\n      // Store if it is positive or negative using the first base64 character or the second\n      char sign_b64 = CHARS[0];\n      if (value &lt; 0) {\n        sign_b64 = CHARS[1];\n        // Remove the negative sign\n        double_str.erase(0, 1);\n      }\n\n      // Decimal point\n      size_t decimal_loc = std::min(double_str.find('.'), double_str.size());\n      // Remove the decimal point (does nothing if decimal_loc == double_str.size())\n      double_str.erase(decimal_loc, 1);\n      // Location of the decimal from the right end of the string, so that leading 0s that are dropped can be recovered\n      size_t decimal_loc_from_right = double_str.size() - decimal_loc;\n      // Store decimal location using 1 base64 character (arbitrary choice, assumes decimal_loc &lt; 64)\n      char decimal_loc_b64 = CHARS[decimal_loc_from_right];\n\n      // ULL\n      // Take the rest of the string as a ULL\n      size_t ull = std::stoull(double_str);\n      // Convert to base64\n      std::string ull_b64 = ULLToB64(ull);\n      // Return decimal location and ULL\n      return std::string({decimal_loc_b64, sign_b64}) + ull_b64;\n    }\n\n    static double B64ToDouble(const std::string &amp;value) {\n      assert(value.size() &gt; 0);\n      // Get decimal location\n      size_t decimal_loc_from_right = CHAR_TO_IDX[value[0]];\n      // Get sign\n      double sign = value[1] == CHARS[0] ? 1 : -1;\n      // Get ULL\n      std::string ull = std::to_string(B64ToULL(value.substr(2)));\n      if (ull.size() &lt; decimal_loc_from_right)\n        ull = std::string(decimal_loc_from_right - ull.size() + 1, CHARS[0]) + ull;\n      // Insert decimal point\n      ull.insert(ull.size() - decimal_loc_from_right, \".\");\n      // Return double\n      return sign * std::stod(ull);\n    }\n  } // namespace base64\n\n  struct CGPNodeGene {\n    std::vector&lt;char&gt; input_connections{};\n\n    size_t function_idx{0};\n\n    double default_output{0};\n\n    inline bool operator==(const CGPNodeGene &amp;other) const {\n      return input_connections == other.input_connections &amp;&amp; function_idx == other.function_idx &amp;&amp;\n             default_output == other.default_output;\n    }\n  };\n\n  struct CGPParameters {\n    size_t num_inputs{0};\n    size_t num_outputs{0};\n    size_t num_layers{0};\n    size_t num_nodes_per_layer{0};\n    size_t layers_back{0};\n\n    CGPParameters() = default;\n\n    CGPParameters(size_t num_inputs, size_t num_outputs, size_t num_layers, size_t num_nodes_per_layer,\n                  size_t layers_back)\n        : num_inputs(num_inputs), num_outputs(num_outputs), num_layers(num_layers),\n          num_nodes_per_layer(num_nodes_per_layer), layers_back(layers_back) {}\n\n    size_t GetFunctionalNodeCount() const { return num_layers * num_nodes_per_layer + num_outputs; }\n\n    inline bool operator==(const CGPParameters &amp;other) const {\n      return num_inputs == other.num_inputs &amp;&amp; num_outputs == other.num_outputs &amp;&amp; num_layers == other.num_layers &amp;&amp;\n             num_nodes_per_layer == other.num_nodes_per_layer &amp;&amp; layers_back == other.layers_back;\n    }\n  };\n\n  class CGPGenotype {\n  protected:\n    CGPParameters params;\n\n    std::vector&lt;CGPNodeGene&gt; nodes;\n\n  private:\n\n    std::string EncodeHeader() const {\n      std::string header;\n      header += std::to_string(params.num_inputs);\n      header += HEADER_SEP;\n      header += std::to_string(params.num_outputs);\n      header += HEADER_SEP;\n      header += std::to_string(params.num_layers);\n      header += HEADER_SEP;\n      header += std::to_string(params.num_nodes_per_layer);\n      header += HEADER_SEP;\n      header += std::to_string(params.layers_back);\n      return header;\n    }\n\n    void DecodeHeader(const std::string &amp;header) {\n      // Parse header and save to member variables\n      std::vector&lt;size_t&gt; header_parts;\n      size_t start_pos = 0;\n      size_t comma_pos = header.find(HEADER_SEP, start_pos);\n      while (comma_pos != std::string::npos) {\n        header_parts.push_back(std::stoull(header.substr(start_pos, comma_pos - start_pos)));\n        start_pos = comma_pos + 1;\n        comma_pos = header.find(HEADER_SEP, start_pos);\n      }\n      header_parts.push_back(std::stoull(header.substr(start_pos)));\n\n      if (header_parts.size() != 5) {\n        std::string message;\n        message += \"Invalid genotype: Header should have 5 parameters but found \";\n        message += std::to_string(header_parts.size());\n        message += \".\";\n        throw std::runtime_error(message);\n      }\n      params.num_inputs = header_parts.at(0);\n      params.num_outputs = header_parts.at(1);\n      params.num_layers = header_parts.at(2);\n      params.num_nodes_per_layer = header_parts.at(3);\n      params.layers_back = header_parts.at(4);\n    }\n\n    std::string EncodeGenotype() const {\n      std::string genotype = \"\";\n      for (const CGPNodeGene &amp;node : nodes) {\n        // Input Connections\n        genotype += base64::B2ToB64(std::string(node.input_connections.cbegin(), node.input_connections.cend()));\n        genotype += NODE_GENE_SEP;\n        // Function index\n        genotype += base64::ULLToB64(node.function_idx);\n        genotype += NODE_GENE_SEP;\n        // Default output\n        genotype += base64::DoubleToB64(node.default_output);\n        // End of node\n        genotype += NODE_SEP;\n      }\n      return genotype;\n    }\n\n    std::string EncodeGenotypeRaw() const {\n      std::string genotype = \"\";\n      for (const CGPNodeGene &amp;node : nodes) {\n        // Input Connections\n        genotype += std::string(node.input_connections.cbegin(), node.input_connections.cend());\n        genotype += NODE_GENE_SEP;\n        // Function index\n        genotype += std::to_string(node.function_idx);\n        genotype += NODE_GENE_SEP;\n        // Default output\n        genotype += std::to_string(node.default_output);\n        // End of node\n        genotype += NODE_SEP;\n      }\n      return genotype;\n    }\n\n    void DecodeGenotype(const std::string &amp;genotype) {\n      size_t node_gene_start = 0;\n      size_t node_gene_end = genotype.find(NODE_SEP, node_gene_start);\n      size_t node_idx = 0;\n      while (node_gene_end != std::string::npos) {\n        // Parse the node gene\n        std::string node_gene = genotype.substr(node_gene_start, node_gene_end - node_gene_start);\n        assert(node_idx &lt; nodes.size());\n        auto &amp;current_node = nodes[node_idx];\n\n        //\n        // Input Connections\n        //\n        size_t sep_pos = node_gene.find(NODE_GENE_SEP);\n        assert(sep_pos != std::string::npos);\n        std::string input_connections_b64 = node_gene.substr(0, sep_pos);\n        std::string input_connections_b2 = base64::B64ToB2(input_connections_b64);\n        auto &amp;input_connections = current_node.input_connections;\n        // If there were leading bits that were 0 when converted to base 64, they were dropped. Add them back.\n        std::string input_connections_str = std::string(input_connections.cbegin(), input_connections.cend());\n        assert(input_connections.size() &gt;= input_connections_b2.size()); // Invalid genotype if this fails\n        input_connections_b2 =\n            std::string(input_connections.size() - input_connections_b2.size(), '0') + input_connections_b2;\n        assert(input_connections.size() == input_connections_b2.size());\n        for (size_t i = 0; i &lt; input_connections_b2.size(); ++i) {\n          input_connections[i] = input_connections_b2[i];\n        }\n        node_gene = node_gene.substr(sep_pos + 1);\n\n        //\n        // Function index\n        //\n        sep_pos = node_gene.find(NODE_GENE_SEP);\n        std::string function_idx_str = node_gene.substr(0, std::min(sep_pos, node_gene.size()));\n        current_node.function_idx = base64::B64ToULL(function_idx_str);\n        node_gene = node_gene.substr(sep_pos + 1);\n\n        //\n        // Default output\n        //\n        sep_pos = node_gene.find(NODE_GENE_SEP);\n        assert(sep_pos == std::string::npos); // Should be the last attribute\n        std::string default_output_str = node_gene.substr(0, std::min(sep_pos, node_gene.size()));\n        current_node.default_output = base64::B64ToDouble(default_output_str);\n\n        // Move to next node gene\n        node_gene_start = node_gene_end + 1;\n        node_gene_end = genotype.find(NODE_SEP, node_gene_start);\n        ++node_idx;\n      }\n    }\n\n  public:\n    CGPGenotype() = default;\n    CGPGenotype(const CGPParameters &amp;parameters) : params(parameters) { InitGenotype(); }\n\n    // Rule of 5\n    ~CGPGenotype() = default;\n    CGPGenotype(const CGPGenotype &amp;other) { Configure(other.Export()); }\n    CGPGenotype &amp;operator=(const CGPGenotype &amp;other) {\n      Configure(other.Export());\n      return *this;\n    }\n    CGPGenotype(CGPGenotype &amp;&amp;other) noexcept {\n      params = other.params;\n      nodes = std::move(other.nodes);\n    }\n    CGPGenotype &amp;operator=(CGPGenotype &amp;&amp;other) noexcept {\n      params = other.params;\n      nodes = std::move(other.nodes);\n      return *this;\n    }\n\n    CGPGenotype &amp;Configure(const std::string &amp;encoded_genotype) {\n      // Separate header and genotype\n      size_t newline_pos = encoded_genotype.find(HEADER_END);\n      if (newline_pos == std::string::npos)\n        throw std::runtime_error(\"Invalid genotype: No newline character found.\");\n      std::string header = encoded_genotype.substr(0, newline_pos);\n      std::string genotype = encoded_genotype.substr(newline_pos + 1);\n\n      // Parse header and save to member variables\n      DecodeHeader(header);\n\n      // Initialize the genotype\n      InitGenotype();\n\n      // Decode genotype\n      DecodeGenotype(genotype);\n\n      // Check if the number of functional nodes is correct\n      assert(nodes.size() == params.GetFunctionalNodeCount());\n\n      return *this;\n    }\n\n    std::vector&lt;CGPNodeGene&gt;::iterator begin() { return nodes.begin(); }\n\n    std::vector&lt;CGPNodeGene&gt;::iterator end() { return nodes.end(); }\n\n    std::vector&lt;CGPNodeGene&gt;::const_iterator begin() const { return nodes.begin(); }\n\n    std::vector&lt;CGPNodeGene&gt;::const_iterator end() const { return nodes.end(); }\n\n    std::vector&lt;CGPNodeGene&gt;::const_iterator cbegin() const { return nodes.cbegin(); }\n\n    std::vector&lt;CGPNodeGene&gt;::const_iterator cend() const { return nodes.cend(); }\n\n    size_t GetNumPossibleConnections() const {\n      size_t num_connections = 0;\n      for (const CGPNodeGene &amp;node : nodes) {\n        num_connections += node.input_connections.size();\n      }\n      return num_connections;\n    }\n\n    size_t GetNumConnections() const {\n      size_t num_connections = 0;\n      for (const CGPNodeGene &amp;node : nodes) {\n        for (char con : node.input_connections) {\n          if (con == '1')\n            ++num_connections;\n        }\n      }\n      return num_connections;\n    }\n\n    void SetParameters(const CGPParameters &amp;params) { this-&gt;params = params; }\n\n    size_t GetNumInputs() const { return params.num_inputs; }\n\n    size_t GetNumOutputs() const { return params.num_outputs; }\n\n    size_t GetNumLayers() const { return params.num_layers; }\n\n    size_t GetNumNodesPerLayer() const { return params.num_nodes_per_layer; }\n\n    size_t GetLayersBack() const { return params.layers_back; }\n\n    size_t GetNumFunctionalNodes() const { return nodes.size(); }\n\n    bool HasInputConnections() const {\n      for (auto it = begin(); it != end(); ++it) {\n        if (std::any_of(it-&gt;input_connections.begin(), it-&gt;input_connections.end(), [](char c) { return c != '0'; }))\n          return true;\n      }\n      return false;\n    }\n\n    void InitGenotype() {\n      // Clear node configurations\n      nodes.clear();\n\n      // Input nodes won't have any inputs and no function, so they are skipped\n\n      // Start at 1 to account for the input layer\n      for (size_t i = 1; i &lt;= params.num_layers + 1; ++i) {\n        size_t layer_size = i == params.num_layers + 1 ? params.num_outputs : params.num_nodes_per_layer;\n        for (size_t j = 0; j &lt; layer_size; ++j) {\n          // Count up possible input connections from each layer backwards\n          size_t valid_layers_back = std::min(params.layers_back, i);\n          size_t num_input_connections = valid_layers_back * params.num_nodes_per_layer;\n          if (i &lt;= params.layers_back) {\n            num_input_connections -= params.num_nodes_per_layer;\n            num_input_connections += params.num_inputs;\n          }\n          // Create node gene using empty connections\n          std::vector&lt;char&gt; input_connections(num_input_connections, '0');\n          // Add the node configuration. With default values\n          nodes.push_back({input_connections});\n        }\n      }\n    }\n\n    std::string Export() const {\n      std::string header = EncodeHeader();\n      std::string genotype = EncodeGenotype();\n      return header + HEADER_END + genotype;\n    }\n\n    std::string ExportRaw() const {\n      std::string header = EncodeHeader();\n      std::string genotype = EncodeGenotypeRaw();\n      return header + HEADER_END + genotype;\n    }\n\n    CGPGenotype &amp;Mutate(double mutation_rate, GPAgentBase &amp;agent, std::function&lt;void(CGPNodeGene &amp;)&gt; mutation) {\n      assert(mutation_rate &gt;= 0.0 &amp;&amp; mutation_rate &lt;= 1.0);\n      for (CGPNodeGene &amp;node : nodes)\n        if (agent.GetRandom() &lt; mutation_rate)\n          mutation(node);\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateConnections(double mutation_rate, GPAgentBase &amp;agent) {\n      std::uniform_int_distribution&lt;size_t&gt; dist(0, 1);\n      Mutate(mutation_rate, agent, [&amp;agent](CGPNodeGene &amp;node) {\n        for (char &amp;con : node.input_connections) {\n          con = agent.GetRandomULL(2) == 0 ? '0' : '1';\n        }\n      });\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateFunctions(double mutation_rate, size_t num_functions, GPAgentBase &amp;agent) {\n      Mutate(mutation_rate, agent,\n             [num_functions, &amp;agent](CGPNodeGene &amp;node) { node.function_idx = agent.GetRandomULL(num_functions); });\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateOutputs(double mutation_rate, double mean, double std, GPAgentBase &amp;agent,\n                               bool additive = true) {\n      Mutate(mutation_rate, agent, [mean, std, &amp;agent, additive](CGPNodeGene &amp;node) {\n        double mutation = agent.GetRandomNormal(mean, std);\n        if (additive) {\n          node.default_output += mutation;\n          // Clamp to prevent overflow during genotype export\n          double min = std::numeric_limits&lt;double&gt;::lowest();\n          double max = std::numeric_limits&lt;double&gt;::max();\n          // Wrap random double in stod(to_string(.)) to reliably export and import genotype from string.\n          node.default_output = std::stod(std::to_string(std::clamp(node.default_output, min, max)));\n        } else {\n          node.default_output = std::stod(std::to_string(mutation));\n        }\n      });\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateHeader(double mutation_rate, GPAgentBase &amp;agent) {\n\n      // Must expand the genotype in a way so that the behavior is preserved\n\n      // Can mutate number of inputs and outputs to adapt to changing state and action spaces, but not doing it for\n      // now\n\n      // Mutate layers back\n      if (agent.GetRandom() &lt; mutation_rate) {\n        // Update params\n        params.layers_back += 1;\n        // Add empty connections to each node at the front\n        // Start at 1 to account for the input layer\n        for (size_t i = 1; i &lt;= params.num_layers + 1; ++i) {\n          size_t layer_size = i == params.num_layers + 1 ? params.num_outputs : params.num_nodes_per_layer;\n          for (size_t j = 0; j &lt; layer_size; ++j) {\n\n            // Get the old number of input connections\n            auto &amp;curr_connections = nodes[(i - 1) * params.num_nodes_per_layer + j].input_connections;\n            size_t old_num_input_connections = curr_connections.size();\n\n            // Get the new number of input connections\n            size_t valid_layers_back = std::min(params.layers_back, i);\n            size_t num_input_connections = valid_layers_back * params.num_nodes_per_layer;\n            if (i &lt;= params.layers_back) {\n              num_input_connections -= params.num_nodes_per_layer;\n              num_input_connections += params.num_inputs;\n            }\n\n            // Push empty connections to the front of the vector of input connections\n            size_t num_needed = num_input_connections - old_num_input_connections;\n            if (num_needed &gt; 0) {\n              // Create empty connections\n              std::vector&lt;char&gt; input_connections(num_needed, '0');\n              // Insert the empty connections into the front of the vector\n              curr_connections.insert(curr_connections.cbegin(), input_connections.cbegin(), input_connections.cend());\n            }\n          }\n        }\n      }\n\n      // Mutate number of nodes in each layer\n      if (agent.GetRandom() &lt; mutation_rate) {\n        // Add a node to each middle layer and update connections for middle and output layers\n        std::vector&lt;CGPNodeGene&gt; new_nodes;\n        for (size_t i = 1; i &lt;= params.num_layers + 1; ++i) {\n          // Add the nodes in this layer to the new node vector\n          size_t layer_start = (i - 1) * params.num_nodes_per_layer;\n          size_t layer_size = i == params.num_layers + 1 ? params.num_outputs : params.num_nodes_per_layer;\n          size_t layer_end = layer_start + layer_size;\n          size_t valid_layers_back = std::min(params.layers_back, i);\n\n          // Get the number of connections for the new node\n          size_t new_num_connections = valid_layers_back * (params.num_nodes_per_layer + 1);\n          if (i &lt;= params.layers_back) {\n            new_num_connections -= params.num_nodes_per_layer + 1;\n            new_num_connections += params.num_inputs;\n          }\n          size_t num_needed = new_num_connections - nodes[layer_start].input_connections.size();\n          new_nodes.insert(new_nodes.cend(), nodes.cbegin() + layer_start, nodes.cbegin() + layer_end);\n\n          // For middle layers, add a new node\n          if (i != params.num_layers + 1) {\n            auto newNode = std::vector&lt;char&gt;(new_num_connections, '0');\n            new_nodes.push_back({newNode});\n          }\n\n          // Add the extra connections for each node in this layer\n          if (i == 1)\n            // First layer doesn't have any connections to add because the input layer is unchanged\n            continue;\n\n          size_t new_layer_start = (i - 1) * (params.num_nodes_per_layer + 1);\n          for (size_t j = 0; j &lt; layer_size; ++j) {\n            // Add an empty connection at the end of each layer of connections in the valid layers back\n            assert(new_layer_start + j &lt; new_nodes.size());\n            auto &amp;connections = new_nodes[new_layer_start + j].input_connections;\n            // Only iterate over the valid layers back that are middle layers, not including the input layer\n            for (size_t k = 0; k &lt; num_needed; ++k) {\n              // Insert in reverse order to keep indices correct\n              size_t insert_pos = params.num_nodes_per_layer * (num_needed - k);\n              connections.insert(connections.cbegin() + insert_pos, '0');\n              assert(*(connections.cbegin() + insert_pos) == '0');\n            }\n          }\n        }\n        // Update params\n        params.num_nodes_per_layer += 1;\n        nodes = std::move(new_nodes);\n        // Check if everything is correct\n        assert(nodes.size() == params.GetFunctionalNodeCount());\n        for (size_t i = 1; i &lt; params.num_layers + 1; ++i) {\n          [[maybe_unused]] size_t layer_start = (i - 1) * params.num_nodes_per_layer;\n          size_t layer_size = i == params.num_layers + 1 ? params.num_outputs : params.num_nodes_per_layer;\n          size_t valid_layers_back = std::min(params.layers_back, i);\n          for (size_t j = 0; j &lt; layer_size; ++j) {\n            // Check that the number of connections is correct\n            [[maybe_unused]] size_t num_connections =\n              valid_layers_back * params.num_nodes_per_layer;\n            if (i &lt;= params.layers_back) {\n              num_connections -= params.num_nodes_per_layer;\n              num_connections += params.num_inputs;\n            }\n            assert(nodes[layer_start + j].input_connections.size() == num_connections);\n          }\n        }\n      }\n\n      return *this;\n    }\n\n    CGPGenotype &amp;MutateDefault(double mutation_rate, GPAgentBase &amp;agent, size_t num_functions = FUNCTION_SET.size()) {\n      MutateHeader(mutation_rate, agent);\n      MutateConnections(mutation_rate, agent);\n      MutateFunctions(mutation_rate, num_functions, agent);\n      MutateOutputs(mutation_rate, 0, 1, agent);\n      return *this;\n    }\n\n    inline bool operator==(const CGPGenotype &amp;other) const {\n      if (params != other.params) // Compare CGPParameters for equality\n        return false;\n      if (nodes.size() != other.nodes.size()) // # of genes should be equal\n        return false;\n      bool all_same = true;\n      for (auto it = cbegin(), it2 = other.cbegin(); it != cend(); ++it, ++it2) {\n        all_same = all_same &amp;&amp; (*it == *it2); // Compare CGPNodeGenes for equality\n      }\n      return all_same;\n    }\n\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const CGPGenotype &amp;genotype) {\n      os &lt;&lt; genotype.ExportRaw();\n      return os;\n    }\n  };\n} // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_8hpp/","title":"File GPAgent.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"./GPAgentSensors.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_8hpp/#classes","title":"Classes","text":"Type Name class GPAgent <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_8hpp_source/","title":"File GPAgent.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;random&gt;\n#include &lt;string&gt;\n\n#include \"../../core/AgentBase.hpp\"\n#include \"./GPAgentSensors.hpp\"\n\nnamespace cowboys {\n\nclass GPAgent : public cse491::AgentBase {\n protected:\n  const std::vector&lt;std::string&gt; predefinedMovement = {\n      \"down\",  \"down\",  \"down\",  \"down\",  \"right\", \"right\", \"up\",    \"up\",\n      \"up\",    \"up\",    \"right\", \"right\", \"right\", \"right\", \"right\", \"right\",\n      \"right\", \"right\", \"right\", \"right\", \"right\", \"left\",  \"left\",  \"left\"};\n\n  size_t movementIndex = 0;  \n\n public:\n  GPAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    std::uniform_int_distribution&lt;int&gt; dist(\n        0,\n        3);  // size of the random set to 3 as we only have 4 actions initally\n  }\n  ~GPAgent() override = default;\n\n  bool Initialize() override { return true; }\n\n  size_t SelectAction(\n      [[maybe_unused]] const cse491::WorldGrid &amp;grid,\n      [[maybe_unused]] const cse491::type_options_t &amp;type_options,\n      [[maybe_unused]] const cse491::item_map_t &amp;item_map,\n      [[maybe_unused]] const cse491::agent_map_t &amp;agent_map) override {\n    if (movementIndex &gt;= predefinedMovement.size()) {\n      return 0;  // do nothing if it is out of bound for defined movement\n    }\n\n    Sensors::wallDistance(grid, *this, SensorDirection::LEFT);\n    Sensors::wallDistance(grid, *this, SensorDirection::RIGHT);\n    Sensors::wallDistance(grid, *this, SensorDirection::ABOVE);\n    Sensors::wallDistance(grid, *this, SensorDirection::BELOW);\n\n    auto action = action_map[predefinedMovement[movementIndex++]];\n    return action;\n  }\n};\n\n}  // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_analyze_8h/","title":"File GPAgentAnalyze.h","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgentAnalyze.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_analyze_8h/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_analyze_8h/#classes","title":"Classes","text":"Type Name class GPAgentAnalyzer <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentAnalyze.h</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_analyze_8h_source/","title":"File GPAgentAnalyze.h","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgentAnalyze.h</p> <p>Go to the documentation of this file</p> <pre><code>\n//\n// A class that analyzes the data of the best agent in the GP algorithm\n// and saves it to a csv file\n//\n\n#pragma once\n\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nnamespace cowboys {\n\n    class GPAgentAnalyzer {\n    private:\n        std::vector&lt;double&gt; average_fitness;\n\n        std::vector&lt;double&gt; max_fitness;\n\n        std::vector&lt;double&gt; elite_score;\n\n        std::vector&lt;double&gt; average_score;\n\n        std::vector&lt;double&gt; max_agents;\n\n    public:\n        GPAgentAnalyzer() = default;\n\n        ~GPAgentAnalyzer() = default;\n\n        void addAverageFitness(double fitness) {\n            average_fitness.push_back(fitness);\n        }\n\n        void addMaxFitness(double fitness) {\n            max_fitness.push_back(fitness);\n        }\n\n        void addEliteScore(double score) {\n            elite_score.push_back(score);\n        }\n\n        void addAverageScore(double score) {\n            average_score.push_back(score);\n        }\n\n        void addNumAgentsWithMaxFitness(double num_agents) {\n            max_agents.push_back(num_agents);\n        }\n\n        void saveToFile() {\n            // create a new file\n            std::ofstream file(\"gp_agent_analyzer.csv\");\n\n            // write the data to the file\n            file &lt;&lt; \"average_fitness,max_fitness,average_elite_score,best_agent_weighted_score,agents_with_max_fitness\\n\";\n\n            for (size_t i = 0; i &lt; average_fitness.size(); i++) {\n                file &lt;&lt; average_fitness[i] &lt;&lt; \",\" &lt;&lt; max_fitness[i] &lt;&lt; \",\" &lt;&lt; elite_score[i] &lt;&lt; \",\" &lt;&lt; average_score[i] &lt;&lt; \",\" &lt;&lt; max_agents[i] &lt;&lt; \"\\n\";\n            }\n            std::cout &lt;&lt; \"Saved GP Agent Analyzer data to gp_agent_analyzer.csv\" &lt;&lt; std::endl;\n\n            // close the file\n            file.close();\n        }\n    };\n\n}  // namespace cowboys\n\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_base_8hpp/","title":"File GPAgentBase.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgentBase.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"tinyxml2.h\"</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_base_8hpp/#classes","title":"Classes","text":"Type Name class GPAgentBase <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentBase.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_base_8hpp_source/","title":"File GPAgentBase.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgentBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\n#include \"tinyxml2.h\"\n\n#include \"../../core/AgentBase.hpp\"\n\nnamespace cowboys {\n  class GPAgentBase : public cse491::AgentBase {\n  protected:\n    std::unordered_map&lt;std::string, double&gt; extra_state; \n    unsigned int seed = 0;                               \n    std::mt19937 rng{seed};                              \n    std::uniform_real_distribution&lt;double&gt; uni_dist;     \n    std::normal_distribution&lt;double&gt; norm_dist;          \n\n  public:\n    GPAgentBase(size_t id, const std::string &amp;name) : AgentBase(id, name) {\n      Reset();\n    }\n    ~GPAgentBase() = default;\n\n    bool Initialize() override { return true; }\n\n    size_t SelectAction(const cse491::WorldGrid &amp;grid, const cse491::type_options_t &amp;type_options,\n                        const cse491::item_map_t &amp;item_set, const cse491::agent_map_t &amp;agent_set) override {\n      // Update extra state information before action\n      if (extra_state[\"starting_x\"] == std::numeric_limits&lt;double&gt;::max()) {\n        auto pos = GetPosition();\n        extra_state[\"starting_x\"] = pos.GetX();\n        extra_state[\"starting_y\"] = pos.GetY();\n      }\n\n      size_t action = GetAction(grid, type_options, item_set, agent_set);\n\n      // Update extra state information after action\n      extra_state[\"previous_action\"] = action;\n\n      return action;\n    }\n\n    virtual size_t GetAction(const cse491::WorldGrid &amp;grid, const cse491::type_options_t &amp;type_options,\n                             const cse491::item_map_t &amp;item_set, const cse491::agent_map_t &amp;agent_set) = 0;\n\n    const std::unordered_map&lt;std::string, double&gt; GetExtraState() const { return extra_state; }\n\n    virtual void MutateAgent(double mutation_rate = 0.8) = 0;\n\n    virtual void Copy(const GPAgentBase &amp;other) = 0;\n\n    virtual void PrintAgent(){\n\n    };\n\n    virtual void SerializeGP(tinyxml2::XMLDocument &amp;doc, tinyxml2::XMLElement *parentElem, double fitness = -1) = 0;\n\n    virtual std::string Export() { return \"\"; }\n\n    virtual void Reset(bool /*hard*/ = false) {\n      extra_state[\"previous_action\"] = 0;\n      extra_state[\"starting_x\"] = std::numeric_limits&lt;double&gt;::max();\n      extra_state[\"starting_y\"] = std::numeric_limits&lt;double&gt;::max();\n    };\n\n    //    virtual void crossover(const GPAgentBase &amp;other) {};\n    virtual void Import(const std::string &amp;genotype) = 0;\n\n    // -- Random Number Generation --\n\n    void SetSeed(unsigned int seed) {\n      this-&gt;seed = seed;\n      rng.seed(seed);\n    }\n\n    unsigned int GetSeed() const { return seed; }\n\n    double GetRandom() { return uni_dist(rng); }\n\n    double GetRandom(double max) { return GetRandom() * max; }\n\n    double GetRandom(double min, double max) {\n      assert(max &gt; min);\n      return min + GetRandom(max - min);\n    }\n\n    size_t GetRandomULL(size_t max) { return static_cast&lt;size_t&gt;(GetRandom(max)); }\n\n    double GetRandomNormal() { return norm_dist(rng); }\n\n    double GetRandomNormal(double mean, double sd = 1.0) {\n      assert(sd &gt; 0);\n      return mean + norm_dist(rng) * sd;\n    }\n  };\n\n} // End of namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_sensors_8hpp/","title":"File GPAgentSensors.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgentSensors.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../core/WorldGrid.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_sensors_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_sensors_8hpp/#classes","title":"Classes","text":"Type Name class Sensors <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentSensors.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agent_sensors_8hpp_source/","title":"File GPAgentSensors.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgentSensors.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../../core/WorldGrid.hpp\"\n\n// #define DEBUG\n\nnamespace cowboys {\n\nstatic constexpr int WALL =\n    2;  // TODO: work with world teams to better define impenetrable objects\n// FIXME: Group 1 has made a class that can check if a position is penetrable\n// or not. We This will be used instead\n\nenum SensorDirection { LEFT, RIGHT, ABOVE, BELOW };\n\nclass Sensors {\n private:\n  [[maybe_unused]] static void debugPosition(const std::string &amp;/*printstring*/) {\n#ifndef NDEBUG\n//    std::cout &lt;&lt; printstring &lt;&lt; std::endl;\n#endif\n  }\n\n public:\n  Sensors() = default;\n\n  ~Sensors() = default;\n\n  static int wallDistance(const cse491::WorldGrid &amp;grid,\n                          const cse491::AgentBase &amp;agent,\n                          SensorDirection direction) {\n    int distance = 0;\n    cse491::GridPosition position = agent.GetPosition();\n\n    while (grid.IsValid(position) &amp;&amp; grid.At(position) != WALL) {\n      if (direction == LEFT) {\n        position = position.ToLeft();\n      } else if (direction == RIGHT) {\n        position = position.ToRight();\n      } else if (direction == ABOVE) {\n        position = position.Above();\n      } else if (direction == BELOW) {\n        position = position.Below();\n      }\n      distance++;\n    }\n\n    std::string directionStr;\n    if (direction == LEFT) {\n      directionStr = \"left\";\n    } else if (direction == RIGHT) {\n      directionStr = \"right\";\n    } else if (direction == ABOVE) {\n      directionStr = \"top\";\n    } else if (direction == BELOW) {\n      directionStr = \"bottom\";\n    }\n\n    debugPosition(directionStr +\n                  \" distance to the wall:  \" + std::to_string(distance - 1));\n\n    return distance - 1;\n  }\n\n  // make a function that takes in a string and maps the SensorDirectionEnum\n  static SensorDirection getSensorDirectionEnum(const std::string &amp;direction) {\n    if (direction == \"getLeft\") {\n      return SensorDirection::LEFT;\n    } else if (direction == \"getRight\") {\n      return SensorDirection::RIGHT;\n    } else if (direction == \"getUp\") {\n      return SensorDirection::ABOVE;\n    } else if (direction == \"getDown\") {\n      return SensorDirection::BELOW;\n    }\n\n    throw std::invalid_argument(\"Invalid direction\");\n    return SensorDirection::LEFT;\n  }\n};\n}  // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agents_registers_8hpp/","title":"File GPAgentsRegisters.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPAgentsRegisters.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;assert.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agents_registers_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agents_registers_8hpp/#classes","title":"Classes","text":"Type Name class GPAgentRegisters Class to hold the registers of the agent. class iterator Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPAgentsRegisters.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_agents_registers_8hpp_source/","title":"File GPAgentsRegisters.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPAgentsRegisters.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n// #include &lt;array&gt;\n#include &lt;assert.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nnamespace cowboys {\n\nclass GPAgentRegisters {\n private:\n  std::vector&lt;size_t&gt; registers;\n\n\n public:\n  GPAgentRegisters(int numRegisters = 16) : registers(numRegisters) {}\n  ~GPAgentRegisters() = default;\n\n  bool setRegister(size_t index, size_t value) {\n    if (index &gt;= registers.size()) {\n      assert(index &gt;= registers.size());\n      return false;\n    }\n\n    registers[index] = value;\n    return true;\n  }\n\n  std::optional&lt;size_t&gt; getRegister(size_t index) {\n    if (index &gt;= registers.size()) {\n      return std::nullopt;  // Indicates that the value is absent\n    }\n    return registers[index];\n  }\n\n  size_t getNumRegisters() { return registers.size(); }\n\n  size_t size() { return registers.size(); }\n\n  class iterator {\n   private:\n    size_t index;\n\n    GPAgentRegisters &amp;registers;\n\n   public:\n    iterator(size_t index, GPAgentRegisters &amp;regs)\n        : index(index), registers(regs) {}\n\n    size_t &amp;operator*() { return registers.registers[index]; }\n\n    iterator &amp;operator++() {\n      ++index;\n      return *this;\n    }\n\n    bool operator==(const iterator &amp;other) const {\n      return index == other.index;\n    }\n\n    bool operator!=(const iterator &amp;other) const {\n      return index != other.index;\n    }\n  };\n\n  // Begin iterator\n  iterator begin() { return iterator(0, *this); }\n\n  // End iterator\n  iterator end() { return iterator(size(), *this); }\n};\n\n}  // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_training_loop_8hpp/","title":"File GPTrainingLoop.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GPTrainingLoop.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"../../core/WorldBase.hpp\"</code></li> <li><code>#include \"GPAgentBase.hpp\"</code></li> <li><code>#include \"CGPAgent.hpp\"</code></li> <li><code>#include \"LGPAgent.hpp\"</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"tinyxml2.h\"</code></li> <li><code>#include \"GPAgentAnalyze.h\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_training_loop_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_training_loop_8hpp/#classes","title":"Classes","text":"Type Name class GPTrainingLoop &lt;class AgentType, class EnvironmentType&gt; struct SaveDataParams <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GPTrainingLoop.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_g_p_training_loop_8hpp_source/","title":"File GPTrainingLoop.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GPTrainingLoop.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include \"../../core/AgentBase.hpp\"\n#include \"../../core/WorldBase.hpp\"\n//#include \"GPAgent.hpp\"\n#include \"GPAgentBase.hpp\"\n\n\n#include \"CGPAgent.hpp\"\n#include \"LGPAgent.hpp\"\n\n#include &lt;thread&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;ranges&gt;\n#include &lt;cmath&gt;\n#include &lt;filesystem&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n\n\n#include \"tinyxml2.h\"\n#include \"GPAgentAnalyze.h\"\n\n\nnamespace cowboys {\n\n    constexpr unsigned int TRAINING_SEED = 0; \n\n    template&lt;class AgentType, class EnvironmentType&gt;\n    class GPTrainingLoop {\n    private:\n\n        std::vector&lt;std::unique_ptr&lt;cse491::WorldBase&gt;&gt; environments;\n        std::vector&lt;std::vector&lt;cowboys::GPAgentBase *&gt;&gt; agents;\n        std::vector&lt;std::vector&lt;double&gt;&gt; TEMPAgentFitness;\n\n        GPAgentAnalyzer analyzer;\n\n        tinyxml2::XMLDocument topAgentsDoc;\n        tinyxml2::XMLDocument lastGenerationsTopAgentsDoc; // &lt;- Saves the last 5 generations\n        tinyxml2::XMLDocument allOfLastGeneration;\n        tinyxml2::XMLDocument metaData;\n\n\n        tinyxml2::XMLElement *rootTopAllGenerations = topAgentsDoc.NewElement(\"GPLoopTopOfAllGeneration\");\n        tinyxml2::XMLElement *rootTopLastGenerations = lastGenerationsTopAgentsDoc.NewElement(\"GPLoopLastNGeneration\");\n        tinyxml2::XMLElement *rootAllOfLastGeneration = allOfLastGeneration.NewElement(\"GPLoopAllOfLastGeneration\");\n        tinyxml2::XMLElement *rootMetaData = metaData.NewElement(\"GPLoopMetaData\");\n\n\n        std::vector&lt;std::pair&lt;int, int&gt;&gt; sortedAgents = std::vector&lt;std::pair&lt;int, int&gt;&gt;();\n\n        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,0), cse491::GridPosition(22,5) , cse491::GridPosition(22,1) , cse491::GridPosition(0,8), cse491::GridPosition(22,8)};\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,0), cse491::GridPosition(22,5) };\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(22,5) };\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,0)};\n\n\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,2), cse491::GridPosition(49,2) , cse491::GridPosition(49,19) , cse491::GridPosition(4,19), cse491::GridPosition(28,10)};\n\n\n//        const std::vector&lt;cse491::GridPosition&gt; STARTPOSITIONS = {cse491::GridPosition(0,0), cse491::GridPosition(50,0) , cse491::GridPosition(0,28) , cse491::GridPosition(50,28)};\n\n        std::vector&lt;std::vector&lt;std::vector&lt;cse491::GridPosition&gt;&gt;&gt; endPositions = std::vector&lt;std::vector&lt;std::vector&lt;cse491::GridPosition&gt;&gt;&gt;();\n        std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt; independentAgentFitness = std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;();\n\n        int global_max_threads = std::thread::hardware_concurrency();\n        int rollingRandomSeed = 0;\n\n        double ELITE_POPULATION_PERCENT = 0.1;\n        double UNFIT_POPULATION_PERCENT = 0.2;\n\n    public:\n        bool ScavengerQueuing = false;\n\n        GPTrainingLoop(const bool scavengerQueuing = false) : ScavengerQueuing(scavengerQueuing) {\n\n          topAgentsDoc.InsertFirstChild(rootTopAllGenerations);\n\n          rootMetaData = metaData.NewElement(\"GPLoopMetaData\");\n          metaData.InsertFirstChild(rootMetaData);\n          srand(TRAINING_SEED);\n          ResetMainTagLastGenerations();\n        }\n\n        void ResetMainTagLastGenerations() {\n          rootTopLastGenerations = lastGenerationsTopAgentsDoc.NewElement(\"GPLoop\");\n          lastGenerationsTopAgentsDoc.InsertFirstChild(rootTopLastGenerations);\n\n          rootAllOfLastGeneration = allOfLastGeneration.NewElement(\"GPLoopAllOfLastGeneration\");\n          allOfLastGeneration.InsertFirstChild(rootAllOfLastGeneration);\n        }\n\n        void Initialize(size_t numArenas = 5, size_t NumAgentsForArena = 100) {\n\n          unsigned int seed = TRAINING_SEED;\n          if (seed == 0) {\n            seed = std::random_device()();\n          }\n          std::cout &lt;&lt; \"Using seed: \" &lt;&lt; seed &lt;&lt; std::endl;\n\n\n          for (size_t i = 0; i &lt; numArenas; ++i) {\n            // instantiate a new environment\n            environments.emplace_back(std::make_unique&lt;EnvironmentType&gt;(seed));\n\n\n            agents.push_back(std::vector&lt;cowboys::GPAgentBase *&gt;());\n\n            endPositions.push_back(std::vector&lt;std::vector&lt;cse491::GridPosition&gt;&gt;());\n            independentAgentFitness.push_back(std::vector&lt;std::vector&lt;double&gt;&gt;());\n\n            for (size_t j = 0; j &lt; NumAgentsForArena; ++j) {\n\n              endPositions[i].push_back(std::vector&lt;cse491::GridPosition&gt;());\n              independentAgentFitness[i].push_back(std::vector&lt;double&gt;());\n\n              for (size_t k = 0; k &lt; STARTPOSITIONS.size(); ++k) {\n                endPositions[i][j].push_back(cse491::GridPosition(0, 0));\n                independentAgentFitness[i][j].push_back(0);\n              }\n\n              cowboys::GPAgentBase &amp;addedAgent = static_cast&lt;cowboys::GPAgentBase &amp;&gt;(environments[i]-&gt;template AddAgent&lt;AgentType&gt;(\n                      \"Agent \" + std::to_string(j)));\n              addedAgent.SetPosition(0, 0);\n              addedAgent.SetSeed(seed);\n\n              agents[i].emplace_back(&amp;addedAgent);\n\n            }\n\n          }\n\n          loadLastGeneration();\n\n          Printgrid(STARTPOSITIONS);\n\n\n          const size_t numAgents = numArenas * NumAgentsForArena;\n\n          std::stringstream ss;\n          // ss.imbue(std::locale(\"\"));\n          ss &lt;&lt; std::fixed &lt;&lt; numAgents;\n\n          std::cout &lt;&lt; \"number of agents \" &lt;&lt; std::fixed &lt;&lt; ss.str() &lt;&lt; std::endl;\n\n        }\n\n\n        void loadLastGeneration() {\n          if (ScavengerQueuing)\n          {\n\n            auto lastFile = FullLoadGrabLatestGeneration();\n\n            if (lastFile == \"NOTTAFILE\")\n            {\n              std::cout &lt;&lt; \"No last file found\" &lt;&lt; std::endl;\n              return;\n            }\n\n            allOfLastGeneration.LoadFile(lastFile.string().c_str());\n            rootAllOfLastGeneration = allOfLastGeneration.FirstChildElement(\"GPLoopAllOfLastGeneration\");\n\n            std::cout &lt;&lt; \"Loaded last file\" &lt;&lt; std::endl;\n\n//            if (auto agentType = dynamic_cast&lt;CGPAgent *&gt;(&amp;agents[0][0])) {\n//              std::cout &lt;&lt; \"Agent Type is CGPAgent\" &lt;&lt; std::endl;\n//              agentType-&gt;Import(lastFile.string());\n//            }\n//            else if (auto agentType = dynamic_cast&lt;LGPAgent *&gt;(&amp;agents[0][0])) {\n//              std::cout &lt;&lt; \"Agent Type is LGPAgent\" &lt;&lt; std::endl;\n//              agentType-&gt;Import(lastFile.string());\n//            }\n//            else {\n//              std::cout &lt;&lt; \"Agent Type is not CGPAgent or LGPAgent\" &lt;&lt; std::endl;\n//            }\n//              use typetraits to check the type of the agent\n            if (std::is_same&lt;AgentType, CGPAgent&gt;::value) {\n              std::cout &lt;&lt; \"Agent Type is CGPAgent\" &lt;&lt; std::endl;\n            }\n            else if (std::is_same&lt;AgentType, LGPAgent&gt;::value) {\n              std::cout &lt;&lt; \"Agent Type is LGPAgent\" &lt;&lt; std::endl;\n              assert(false); //TODO: Agent not implemented for import\n            }\n            else {\n              std::cout &lt;&lt; \"Agent Type is not CGPAgent or LGPAgent\" &lt;&lt; std::endl;\n            }\n\n\n            auto *latestGenerationElem = rootAllOfLastGeneration-&gt;FirstChildElement();\n            std::cout &lt;&lt; latestGenerationElem-&gt;Name() &lt;&lt; std::endl;\n            auto *agentElem = latestGenerationElem-&gt;FirstChildElement();\n            tinyxml2::XMLElement* generationElem = nullptr;\n\n            std::cout &lt;&lt; agentElem-&gt;Name() &lt;&lt; std::endl;\n            size_t numArenas = agents.size();\n            size_t NumAgentsForArena = agents.at(0).size();\n            for (size_t i = 0; i &lt; numArenas; ++i) {\n              for (size_t j = 0; j &lt; NumAgentsForArena; ++j) {\n\n                generationElem = agentElem-&gt;FirstChildElement();\n                const char *genotypeData = generationElem-&gt;GetText();\n                agents.at(i).at(j)-&gt;Import(genotypeData);\n                agentElem = agentElem-&gt;NextSiblingElement();\n              }\n            }\n\n            std::cout &lt;&lt; \"Agents LoadComplete\" &lt;&lt; std::endl;\n\n          }\n        }\n\n        std::filesystem::path FullLoadGrabLatestGeneration() {\n          std::filesystem::path normalizedAbsolutePath = getSystemPath();\n\n          std::string lastGenerationsPrefix = \"allAgentData_\";\n          std::string lastGenerationsFilenameExtension = \".xml\";\n\n          std::vector&lt;std::filesystem::path&gt; matchingFiles;\n          for (const auto &amp; entry : std::filesystem::directory_iterator(normalizedAbsolutePath))\n          {\n            if (entry.path().extension() == lastGenerationsFilenameExtension &amp;&amp; entry.path().filename().string().find(lastGenerationsPrefix) != std::string::npos)\n            {\n              matchingFiles.push_back(entry.path());\n            }\n          }\n          std::sort(matchingFiles.begin(), matchingFiles.end());\n\n          if (matchingFiles.empty())\n          {\n            return \"NOTTAFILE\";\n          }\n\n          std::filesystem::path lastFile = matchingFiles.back();\n\n          std::cout &lt;&lt; \"Last File: \" &lt;&lt; lastFile &lt;&lt; std::endl;\n\n          return lastFile;\n        }\n\n\n        double SimpleFitnessFunction(cse491::AgentBase &amp;agent, cse491::GridPosition startPosition) {\n          double fitness = 0;\n\n          // Euclidean distance\n          cse491::GridPosition currentPosition = agent.GetPosition();\n          double distance = std::sqrt(std::pow(currentPosition.GetX() - startPosition.GetX(), 2) +\n                                      std::pow(currentPosition.GetY() - startPosition.GetY(), 2));\n\n          double score = distance;\n\n          fitness += score;\n\n          // Agent complexity, temporarily doing this in a bad way\n          if (auto *cgp = dynamic_cast&lt;CGPAgent *&gt;(&amp;agent)) {\n            fitness -= cgp-&gt;GetComplexity();\n          }\n\n          return fitness;\n        }\n\n//        STARTPOSITIONS[startPos_idx], agents[arena][a]-&gt;GetPosition(), arena, a\n        double AStarFitnessFunction(const cse491::GridPosition  &amp; startpos, const cse491::GridPosition &amp; endpos, int arena, int a)\n        {\n          double fitness = 0;\n\n          // Euclidean distance\n          cse491::GridPosition currentPosition = endpos;\n          double distance = static_cast&lt;double&gt;(\n                  Get_A_StarDistance(startpos, currentPosition, arena, a)\n                  );\n\n\n          double score = distance;\n\n          fitness += score;\n\n          cse491::AgentBase &amp;agent = *agents[arena][a];\n          // Agent complexity, temporarily doing this in a bad way\n          if (auto *cgp = dynamic_cast&lt;CGPAgent *&gt;(&amp;agent)){\n            fitness -= cgp-&gt;GetComplexity();\n          }\n\n          return fitness;\n        }\n\n        static std::filesystem::path getSystemPath() {\n          std::string relativePath = \"../../savedata/GPAgent/\";\n          std::filesystem::path absolutePath = std::filesystem::absolute(relativePath);\n          std::filesystem::path normalizedAbsolutePath = std::filesystem::canonical(absolutePath);\n          return normalizedAbsolutePath;\n        }\n\n        static std::string getDateStr() {\n          auto now = std::chrono::system_clock::now();\n          std::time_t now_time = std::chrono::system_clock::to_time_t(now);\n\n          // Format the date and time as a string (hour-minute-second)\n          std::tm tm_time = *std::localtime(&amp;now_time);\n          std::ostringstream oss;\n          oss &lt;&lt; std::put_time(&amp;tm_time, \"%Y-%m-%d__%H_%M_%S\");\n          std::string dateTimeStr = oss.str();\n\n          return dateTimeStr;\n        }\n\n        void ThreadTrainLoop(size_t maxThreads = 1, int numberOfTurns = 100) {\n          std::vector&lt;std::thread&gt; threads;\n\n          size_t threadsComplete = 0;\n\n\n\n\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            if (maxThreads == 0 || threads.size() &lt; maxThreads) {\n              threads.emplace_back(&amp;GPTrainingLoop::RunArena, this, arena, numberOfTurns);\n\n            } else {\n              // Wait for one of the existing threads to finish\n              threads[0].join();\n              threads.erase(threads.begin());\n              threadsComplete++;\n              threads.emplace_back(&amp;GPTrainingLoop::RunArena, this, arena, numberOfTurns);\n            }\n\n\n            size_t barWidth = 64;\n            float progress = (float) (arena+1) / environments.size();\n            size_t pos = barWidth * progress;\n            std::cout &lt;&lt; \"[\";\n            for (size_t i = 0; i &lt; barWidth; ++i) {\n              if (i &lt; pos) std::cout &lt;&lt; \"=\";\n              else if (i == pos) std::cout &lt;&lt; \"&gt;\";\n              else std::cout &lt;&lt; \" \";\n            }\n            std::cout &lt;&lt; \"] \" &lt;&lt; int(progress * 100.0) &lt;&lt; \" % - \" &lt;&lt; threadsComplete &lt;&lt; \" threads done\\r\";\n            std::cout.flush();\n          }\n\n          // Wait for all threads to finish\n          for (auto &amp;thread: threads) {\n            if (thread.joinable()) {\n              thread.join();\n              threadsComplete+=maxThreads;\n            }\n          }\n\n          std::cout &lt;&lt; std::endl;\n          std::cout &lt;&lt; \"All threads done\" &lt;&lt; std::endl;\n\n\n        }\n\n\n\n        void Run(size_t numGenerations,\n                 size_t numberOfTurns = 100,\n                 size_t maxThreads = 0, bool saveData = false) {\n\n          auto startTime = std::chrono::high_resolution_clock::now();\n\n          global_max_threads = maxThreads;\n\n\n          SaveDataParams saveDataParams(0);\n          saveDataParams.save = saveData;\n          saveDataParams.saveMetaData = true;\n          saveDataParams.saveAllAgentData = true;\n//\n//          saveDataParams.saveTopAgents = true;\n//          saveDataParams.saveLastGenerations = true;\n\n\n\n//          check to see if meta data exists\n          std::filesystem::path normalizedAbsolutePath = getSystemPath();\n          std::string metaDataFilename = \"metaData.xml\";\n//          check to see if the file exists\n          std::filesystem::path metaDataFullPath = normalizedAbsolutePath / metaDataFilename;\n\n\n          size_t generation = 0; // &lt;- the generation to start at\n\n          if (std::filesystem::exists(metaDataFullPath) &amp;&amp; ScavengerQueuing) {\n            std::cout &lt;&lt; \"MetaData file exists\" &lt;&lt; std::endl;\n            metaData.LoadFile(metaDataFullPath.string().c_str());\n            rootMetaData = metaData.FirstChildElement(\"GPLoopMetaData\");\n            auto *generationTag = rootMetaData-&gt;FirstChildElement();\n            generation = generationTag-&gt;UnsignedAttribute(\"generation\") + 1;\n            rollingRandomSeed = generationTag-&gt;UnsignedAttribute(\"randSeed\");\n            std::cout &lt;&lt; \"Starting at generation \" &lt;&lt; generation &lt;&lt; std::endl;\n\n          } else {\n            if (ScavengerQueuing)\n            {\n              std::cout &lt;&lt; \"MetaData file does not exist Starting a new Scavenger Queue\" &lt;&lt; std::endl;\n            }\n            rollingRandomSeed = TRAINING_SEED;\n            rootMetaData = metaData.NewElement(\"GPLoopMetaData\");\n            metaData.InsertFirstChild(rootMetaData);\n          }\n\n          for (; generation &lt; numGenerations; ++generation) {\n            srand(rollingRandomSeed);\n            rollingRandomSeed = rand();\n\n            auto generationStartTime = std::chrono::high_resolution_clock::now();\n            saveDataParams.updateGeneration(generation);\n\n            InitTEMPAgentFitness();\n            ThreadTrainLoop(maxThreads, numberOfTurns);\n\n            std::cout &lt;&lt; std::endl;\n\n            sortedAgents.clear();\n            SortThemAgents();\n\n            int countMaxAgents = AgentsAnalysisComputationsAndPrint(generation);\n\n            saveDataParams.countMaxAgents = countMaxAgents;\n            SaveDataCheckPoint(saveDataParams);\n\n\n            GpLoopMutateHelper();\n            resetEnvironments();\n\n            auto generationEndTime = std::chrono::high_resolution_clock::now();\n            auto generationDuration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(\n                    generationEndTime - generationStartTime);\n            std::cout &lt;&lt; \"Generation \" &lt;&lt; generation &lt;&lt; \" took \" &lt;&lt; generationDuration.count() / 1000000.0 &lt;&lt; \" seconds\"\n                      &lt;&lt; std::endl;\n          analyzer.saveToFile();\n\n          }\n\n          auto endTime = std::chrono::high_resolution_clock::now();\n          auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(endTime - startTime);\n          std::cout &lt;&lt; \"Time taken by run: \" &lt;&lt; duration.count() / 1000000.0 &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n          if (saveData) {\n\n          }\n\n          MemGOBYE();\n        }\n\n        struct SaveDataParams {\n            size_t generation;\n            bool save = false;\n            bool saveAllAgentData = false;\n            bool saveMetaData = true;\n            bool saveTopAgents = false;\n            bool saveLastGenerations = false;\n\n            size_t countMaxAgents = 0;\n\n            std::string dateTimeStr = getDateStr();\n            std::filesystem::path normalizedAbsolutePath = getSystemPath();\n\n            size_t checkPointEvery = 5;\n\n            SaveDataParams(size_t gen) : generation(gen) {}\n\n            void updateGeneration(size_t gen) { generation = gen; }\n        };\n\n\n        void SaveDataCheckPoint(const SaveDataParams &amp;params) {\n          if (!params.save) {\n            return;\n          }\n\n          allOfLastGeneration.Clear();\n          rootAllOfLastGeneration = allOfLastGeneration.NewElement(\"GPLoopAllOfLastGeneration\");\n          allOfLastGeneration.InsertFirstChild(rootAllOfLastGeneration);\n\n          size_t totalNumberOfAgents = agents.size() * agents[0].size();\n\n          SerializeAgents(params.generation, rootAllOfLastGeneration, allOfLastGeneration, totalNumberOfAgents);\n\n          if (params.saveTopAgents) {\n            SerializeAgents(params.generation, rootTopAllGenerations, topAgentsDoc);\n          }\n\n          if (params.saveLastGenerations){\n            SerializeAgents(params.generation, rootTopLastGenerations, lastGenerationsTopAgentsDoc, 5);\n          }\n\n          std::string dateTimeStr = params.dateTimeStr;\n          std::filesystem::path normalizedAbsolutePath = params.normalizedAbsolutePath;\n\n\n          if (params.generation % params.checkPointEvery != 0) {\n            return;\n          }\n\n\n          if (params.saveMetaData) {\n            const std::string metaDataFilename = \"metaData_\" + dateTimeStr + \".xml\";\n            auto metaDataFullPath = normalizedAbsolutePath / metaDataFilename;\n            saveXMLDoc(metaData, metaDataFullPath.string());\n          }\n\n          if (params.saveAllAgentData) {\n            const std::string allAgentDataFilename = \"allAgentData_\" + dateTimeStr + \".xml\";\n            auto allAgentDataFullPath = normalizedAbsolutePath / allAgentDataFilename;\n            saveXMLDoc(allOfLastGeneration, allAgentDataFullPath.string());\n          }\n\n\n\n          if (params.saveTopAgents) {\n            const std::string filename = \"AgentData_\" + dateTimeStr + \".xml\";\n            auto fullPath = normalizedAbsolutePath / filename;\n\n            saveXMLDoc(topAgentsDoc, fullPath.string());\n          }\n\n          if (params.saveLastGenerations) {\n            const std::string lastGenerationsFilename = \"lastGenerations_\" + dateTimeStr + \".xml\";\n            auto lastGenerationsFullPath = normalizedAbsolutePath / lastGenerationsFilename;\n            saveXMLDoc(lastGenerationsTopAgentsDoc, lastGenerationsFullPath.string());\n          }\n\n\n          std::cout &lt;&lt; \"@@@@@@@@@@@@@@@@@@@@@@  \" &lt;&lt; \"DataSaved\" &lt;&lt; \"  @@@@@@@@@@@@@@@@@@@@@@\" &lt;&lt; std::endl;\n\n//            analyzer.saveToFile(getSystemPath() / \"fitness.csv\");\n          lastGenerationsTopAgentsDoc.Clear();\n          ResetMainTagLastGenerations();\n        }\n\n\n        std::string FormatPosition(const cse491::GridPosition &amp; pos, int precision = 0) {\n          std::stringstream ss;\n          ss &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision) &lt;&lt; \"[\" &lt;&lt; pos.GetX() &lt;&lt; \",\" &lt;&lt; pos.GetY() &lt;&lt; \"]\";\n          return ss.str();\n        }\n\n        size_t Get_A_StarDistance(const cse491::GridPosition &amp; startpos, const cse491::GridPosition &amp; endpos, int arenaIDX, int agentIDX) {\n          auto&amp; agent = agents[arenaIDX][agentIDX];\n          auto&amp; world = environments[arenaIDX];\n\n\n          auto distance = walle::GetShortestPath(startpos, endpos, *world, *agent).size() - 1;\n          assert(distance &gt;= 0);\n          return distance;\n        }\n\n\n        int AgentsAnalysisComputationsAndPrint(int generation, double deltaForMaxFitness = 0.1) {\n          // print average fitness\n          double averageFitness = 0;\n          double maxFitness = -10000;\n\n\n          std::pair&lt;int, int&gt; bestAgent = std::make_pair(-1, -1);\n\n          int countMaxAgents = 0;\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n              averageFitness += TEMPAgentFitness[arena][a];\n\n\n              if (abs(TEMPAgentFitness[arena][a] - maxFitness) &gt; deltaForMaxFitness &amp;&amp;\n                  TEMPAgentFitness[arena][a] &gt; maxFitness) {\n                maxFitness = TEMPAgentFitness[arena][a];\n                bestAgent = std::make_pair(arena, a);\n                countMaxAgents = 1;\n              }\n\n              if (abs(TEMPAgentFitness[arena][a] - maxFitness) &lt; deltaForMaxFitness) {\n                countMaxAgents++;\n              }\n            }\n          }\n\n          averageFitness /= (environments.size() * agents[0].size());\n\n\n          std::cout &lt;&lt; \"Generation \" &lt;&lt; generation &lt;&lt; \" complete\" &lt;&lt; std::endl;\n          std::cout &lt;&lt; \"Average fitness: \" &lt;&lt; averageFitness &lt;&lt; \" \";\n          analyzer.addAverageFitness(averageFitness);\n\n          std::cout &lt;&lt; \"Max fitness: \" &lt;&lt; maxFitness &lt;&lt; std::endl;\n          analyzer.addMaxFitness(maxFitness);\n\n\n\n          std::string tagName = \"generation_\" + std::to_string(generation);\n          auto *generationTag = metaData.NewElement(tagName.c_str());\n          generationTag-&gt;SetAttribute(\"generation\", generation);\n\n          generationTag-&gt;SetAttribute(\"averageFitness\", averageFitness);\n          generationTag-&gt;SetAttribute(\"maxFitness\", maxFitness);\n          generationTag-&gt;SetAttribute(\"bestAgentIDX\", bestAgent.second);\n\n          generationTag-&gt;SetAttribute(\"Rand\", rollingRandomSeed);\n\n          rootMetaData-&gt;InsertFirstChild(generationTag);\n\n\n\n\n          std::cout &lt;&lt; \"Best agent: AGENT[\" &lt;&lt; bestAgent.first &lt;&lt; \",\" &lt;&lt; bestAgent.second &lt;&lt; \"] \" &lt;&lt; std::endl;\n\n          std::cout &lt;&lt; \"Best Agent Final Positions\" &lt;&lt; std::endl;\n\n          Printgrid(endPositions[bestAgent.first][bestAgent.second], 'A');\n\n          // auto&amp; agent = agents[bestAgent.first][bestAgent.second];\n          auto&amp; startPosition = STARTPOSITIONS;\n          auto&amp; endPosition = endPositions[bestAgent.first][bestAgent.second];\n\n          // auto&amp; world = environments[bestAgent.first];\n\n\n          auto calculateDistance = [](const cse491::GridPosition&amp; startPosition, const cse491::GridPosition &amp; currentPosition) {\n              return std::sqrt(std::pow(currentPosition.GetX() - startPosition.GetX(), 2) +\n                               std::pow(currentPosition.GetY() - startPosition.GetY(), 2));\n          };\n\n          int columnWidth = 10; // Adjust as needed\n\n          std::cout &lt;&lt; std::left &lt;&lt; std::setw(columnWidth) &lt;&lt; \"Start\"\n                    &lt;&lt; std::setw(columnWidth) &lt;&lt; \"Final\"\n                  &lt;&lt; std::setw(columnWidth) &lt;&lt; \"Distance\"\n                  &lt;&lt; \"A* Distance\\n\";\n          for (size_t i = 0; i &lt; STARTPOSITIONS.size(); ++i) {\n            std::cout &lt;&lt; std::setw(columnWidth) &lt;&lt; FormatPosition(STARTPOSITIONS[i])\n                      &lt;&lt; std::setw(columnWidth) &lt;&lt; FormatPosition(endPositions[bestAgent.first][bestAgent.second][i]);\n\n\n            // Calculate and print Euclidean distance\n            double distance = calculateDistance(STARTPOSITIONS[i], endPositions[bestAgent.first][bestAgent.second][i]);\n            std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; std::setw(12) &lt;&lt; distance;\n\n\n            // Calculate and print A* distance\n            size_t astarDistance = Get_A_StarDistance(startPosition[i], endPosition[i], bestAgent.first, bestAgent.second);\n            std::cout &lt;&lt; std::setw(12) &lt;&lt; astarDistance;\n\n\n            std::cout &lt;&lt; std::endl;\n          }\n\n          std::cout &lt;&lt; \"with best agent weighted score of \" &lt;&lt; TEMPAgentFitness[bestAgent.first][bestAgent.second] &lt;&lt; std::endl;\n          std::cout &lt;&lt; std::endl;\n          analyzer.addAverageScore(TEMPAgentFitness[bestAgent.first][bestAgent.second]);\n\n          std::cout &lt;&lt; \"Number of agents with max fitness: \" &lt;&lt; countMaxAgents &lt;&lt; std::endl;\n          std::cout &lt;&lt; \"------------------------------------------------------------------\" &lt;&lt; std::endl;\n          analyzer.addNumAgentsWithMaxFitness(countMaxAgents);\n          return countMaxAgents;\n        }\n\n        void SortThemAgents() {\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n              sortedAgents.push_back(std::make_pair(arena, a));\n            }\n          }\n\n          std::sort(sortedAgents.begin(), sortedAgents.end(),\n                    [&amp;](const std::pair&lt;int, int&gt; &amp;a, const std::pair&lt;int, int&gt; &amp;b) {\n                        return TEMPAgentFitness[a.first][a.second] &gt; TEMPAgentFitness[b.first][b.second];\n                    });\n        }\n\n\n        void saveXMLDoc(tinyxml2::XMLDocument &amp;paramdoc, std::string fullPath) {\n          if (paramdoc.SaveFile(fullPath.c_str()) == tinyxml2::XML_SUCCESS) {\n            // std::filesystem::path fullPath = std::filesystem::absolute(\"example.xml\");\n            std::cout &lt;&lt; \"XML file saved successfully to: \" &lt;&lt; fullPath &lt;&lt; std::endl;\n          } else {\n            std::cout &lt;&lt; \"Error saving XML file.\" &lt;&lt; std::endl;\n//            std::cout &lt;&lt; \"Error ID: \" &lt;&lt; paramdoc.ErrorID() &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Error for path\" &lt;&lt; fullPath &lt;&lt; std::endl;\n          }\n        }\n\n\n        void SerializeAgents(int generation, tinyxml2::XMLElement *rootElement, tinyxml2::XMLDocument &amp;paramDocument,\n                             size_t topN = 5) {\n\n          std::string tagName = \"generation_\" + std::to_string(generation);\n          auto *generationTag = paramDocument.NewElement(tagName.c_str());\n\n\n          rootElement-&gt;InsertFirstChild(generationTag);\n\n          for (size_t i = 0; i &lt; std::min(sortedAgents.size(), topN); ++i) {\n            auto [arenaIDX, agentIDX] = sortedAgents[i];\n            agents[arenaIDX][agentIDX]-&gt;SerializeGP(paramDocument, generationTag, TEMPAgentFitness[arenaIDX][agentIDX]);\n          }\n\n\n        }\n\n        void InitTEMPAgentFitness() {\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            TEMPAgentFitness.push_back(std::vector&lt;double&gt;(agents[arena].size(), 0));\n          }\n        }\n\n\n        void MutateAgents(int start, int end, const std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;sortedAgents,\n                          std::vector&lt;std::vector&lt;cowboys::GPAgentBase *&gt;&gt; &amp;agents, double mutationRate) {\n          for (int i = start; i &lt; end; i++) {\n            auto [arenaIDX, agentIDX] = sortedAgents[i];\n            agents[arenaIDX][agentIDX]-&gt;MutateAgent(mutationRate);\n\n            if (i % (sortedAgents.size() / 10) == 0) {\n              std::cout &lt;&lt; \" --- mutation complete \" &lt;&lt; (i * 1.0 / sortedAgents.size()) &lt;&lt; std::endl;\n            }\n          }\n        }\n\n        void MutateAndCopyAgents(int start, int end, const std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;sortedAgents,\n                                 std::vector&lt;std::vector&lt;cowboys::GPAgentBase *&gt;&gt; &amp;agents, int elitePopulationSize) {\n          for (int i = start; i &lt; end; i++) {\n            auto [arenaIDX, agentIDX] = sortedAgents[i];\n            auto eliteINDEX = rand() % elitePopulationSize;\n            auto [eliteArenaIDX, eliteAgentIDX] = sortedAgents[eliteINDEX];\n\n            agents[arenaIDX][agentIDX]-&gt;Copy(*agents[eliteArenaIDX][eliteAgentIDX]);\n            agents[arenaIDX][agentIDX]-&gt;MutateAgent(0.01);\n\n            if (i % (sortedAgents.size() / 10) == 0) {\n              std::cout &lt;&lt; \" --- mutation complete \" &lt;&lt; (i * 1.0 / sortedAgents.size()) &lt;&lt; std::endl;\n            }\n          }\n        }\n\n        void GpLoopMutateHelper() {\n\n//          constexpr double ELITE_POPULATION_PERCENT = 0.1;\n//          constexpr double UNFIT_POPULATION_PERCENT = 0.2;\n\n\n          const int ELITE_POPULATION_SIZE = int(ELITE_POPULATION_PERCENT * sortedAgents.size());\n\n\n          double averageEliteFitness = 0;\n          for (int i = 0; i &lt; ELITE_POPULATION_SIZE; i++) {\n            auto [arenaIDX, agentIDX] = sortedAgents[i];\n            averageEliteFitness += TEMPAgentFitness[arenaIDX][agentIDX];\n          }\n          averageEliteFitness /= ELITE_POPULATION_SIZE;\n\n          std::cout &lt;&lt; \" --- average elite score \" &lt;&lt; averageEliteFitness &lt;&lt; \"------ \" &lt;&lt; std::endl;\n          analyzer.addEliteScore(averageEliteFitness);\n\n          const int MIDDLE_MUTATE_ENDBOUND = int(sortedAgents.size() * (1 - UNFIT_POPULATION_PERCENT));\n          const int MIDDLE_MUTATE_STARTBOUND = int(ELITE_POPULATION_PERCENT * sortedAgents.size());\n\n          // Determine the number of threads to use\n          const int num_threads = global_max_threads;\n//          const int num_threads = std::min(static_cast&lt;int&gt;(std::thread::hardware_concurrency()), global_max_threads);\n\n          std::vector&lt;std::thread&gt; threads;\n\n          // Calculate the number of agents per thread\n          int agents_per_thread = (MIDDLE_MUTATE_ENDBOUND - MIDDLE_MUTATE_STARTBOUND) / num_threads;\n\n          // Launch threads for the first loop\n          for (int i = 0; i &lt; num_threads; ++i) {\n            int start = MIDDLE_MUTATE_STARTBOUND + i * agents_per_thread;\n            int end = (i == num_threads - 1) ? MIDDLE_MUTATE_ENDBOUND : start + agents_per_thread;\n            threads.push_back(std::thread([this, start, end] {\n                this-&gt;MutateAgents(start, end, sortedAgents, agents, 0.05);\n            }));\n          }\n\n          // Join the threads\n          for (auto &amp;t: threads) {\n            t.join();\n          }\n\n          threads.clear();\n\n          // Second loop - copy and mutate agents\n          // int unfitAgents = int(sortedAgents.size() * UNFIT_POPULATION_PERCENT);\n          agents_per_thread = (sortedAgents.size() - MIDDLE_MUTATE_ENDBOUND) / num_threads;\n          for (int i = 0; i &lt; num_threads; ++i) {\n            int start = MIDDLE_MUTATE_ENDBOUND + i * agents_per_thread;\n            int end = (i == num_threads - 1) ? sortedAgents.size() : start + agents_per_thread;\n\n            threads.push_back(std::thread([this, start, end, ELITE_POPULATION_SIZE] {\n                this-&gt;MutateAndCopyAgents(start, end, sortedAgents, agents, ELITE_POPULATION_SIZE);\n            }));\n          }\n\n          for (auto &amp;t: threads) {\n            t.join();\n          }\n\n\n        }\n\n        void Printgrid(const std::vector&lt;cse491::GridPosition&gt; &amp;positions, char symbol = 'S') {\n\n          if (environments.empty()) {\n            std::cout &lt;&lt; \"No environments to print\" &lt;&lt; std::endl;\n            return;\n          }\n\n          size_t arena = 0;\n          auto &amp;grid = environments[arena]-&gt;GetGrid();\n          std::vector&lt;std::string&gt; symbol_grid(grid.GetHeight());\n\n\n          const auto &amp;type_options = environments[arena]-&gt;GetCellTypes();\n          // Load the world into the symbol_grid;\n          for (size_t y = 0; y &lt; grid.GetHeight(); ++y) {\n            symbol_grid[y].resize(grid.GetWidth());\n            for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n              symbol_grid[y][x] = type_options[grid.At(x, y)].symbol;\n            }\n          }\n\n\n\n          for (size_t pos_idx = 0; pos_idx &lt; positions.size(); ++pos_idx) {\n\n            assert(positions[pos_idx].CellY() &lt; symbol_grid.size());\n            assert(positions[pos_idx].CellX() &lt; symbol_grid[positions[pos_idx].CellY()].size());\n            symbol_grid[positions[pos_idx].CellY()][positions[pos_idx].CellX()] = symbol;\n          }\n\n\n//          const auto &amp;agent_set = agents[arena];\n//          for (const auto &amp;agent_ptr: agent_set) {\n//            cse491::GridPosition pos = agent_ptr-&gt;GetPosition();\n//            char c = '*';\n//            if (agent_ptr-&gt;HasProperty(\"symbol\")) {\n//              c = agent_ptr-&gt;template GetProperty&lt;char&gt;(\"symbol\");\n//            }\n//            symbol_grid[pos.CellY()][pos.CellX()] = c;\n//          }\n\n          std::cout &lt;&lt; \"    \";\n          for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n            if (x % 10 == 0 &amp;&amp; x != 0) {\n              std::cout &lt;&lt; x / 10; // Print the ten's place of the column number\n            } else {\n              std::cout &lt;&lt; \" \"; // Space for non-marker columns\n            }\n          }\n          std::cout &lt;&lt; \"\\n\";\n\n          // Print column numbers\n          std::cout &lt;&lt; \"    \"; // Space for row numbers\n          for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n            std::cout &lt;&lt; x % 10; // Print only the last digit of the column number\n          }\n          std::cout &lt;&lt; \"\\n\";\n\n          // Print out the symbol_grid with a box around it.\n          std::cout &lt;&lt; \"   +\" &lt;&lt; std::string(grid.GetWidth(), '-') &lt;&lt; \"+\\n\";\n          for (size_t y = 0; y &lt; grid.GetHeight(); ++y) {\n\n            if (y % 10 == 0 &amp;&amp; y != 0) {\n              std::cout &lt;&lt; y / 10 &lt;&lt; \" \"; // Print the ten's place of the row number\n            } else {\n              std::cout &lt;&lt; \"  \"; // Space for non-marker rows\n            }\n\n            // Print row number\n            std::cout &lt;&lt; y % 10 &lt;&lt; \"|\"; // Print only the last digit of the row number\n            for (char cell: symbol_grid[y]) {\n              std::cout &lt;&lt; cell;\n            }\n            std::cout &lt;&lt; \"|\\n\";\n          }\n\n          std::cout &lt;&lt; \"   +\" &lt;&lt; std::string(grid.GetWidth(), '-') &lt;&lt; \"+\\n\";\n          std::cout &lt;&lt; std::endl;\n        }\n\n\n\n        void resetEnvironments() {\n\n          for (size_t arena = 0; arena &lt; environments.size(); ++arena) {\n            for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n              agents[arena][a]-&gt;Reset();\n            }\n          }\n\n          TEMPAgentFitness.clear();\n        }\n\n        void RunArena(size_t arena, size_t numberOfTurns) {\n          for (size_t startPos_idx = 0; startPos_idx &lt; STARTPOSITIONS.size(); ++startPos_idx) {\n            for(size_t a = 0; a &lt; agents[arena].size(); ++a) {\n              // Reset the agent before each run\n              agents[arena][a]-&gt;Reset();\n              // Set the starting position\n              agents[arena][a]-&gt;SetPosition(STARTPOSITIONS[startPos_idx]);\n            }\n\n            for (size_t turn = 0; turn &lt; numberOfTurns; turn++) {\n              environments[arena]-&gt;RunAgents();\n              environments[arena]-&gt;UpdateWorld();\n            }\n            for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n//              double tempscore = SimpleFitnessFunction(*agents[arena][a], STARTPOSITIONS[startPos_idx]);\n              double tempscore = AStarFitnessFunction(STARTPOSITIONS[startPos_idx], agents[arena][a]-&gt;GetPosition(), arena, a);\n              auto tempEndPosition = agents[arena][a]-&gt;GetPosition();\n              endPositions[arena][a][startPos_idx] = tempEndPosition;\n              independentAgentFitness[arena][a][startPos_idx] = tempscore;\n              TEMPAgentFitness[arena][a] += tempscore;\n\n            }\n\n          }\n\n          for (size_t a = 0; a &lt; agents[arena].size(); ++a) {\n            std::vector&lt;double&gt; scores = independentAgentFitness[arena][a];\n            // auto computeMedian = [&amp;scores]() -&gt; double {\n            //     std::vector&lt;double&gt; temp(scores);  // Copy the data\n            //     std::sort(temp.begin(), temp.end());\n\n            //     size_t n = temp.size();\n            //     return n % 2 ? temp[n / 2] : (temp[n / 2 - 1] + temp[n / 2]) / 2.0;\n            // };\n\n\n//            TEMPAgentFitness[arena][a] /= STARTPOSITIONS.size();\n//            TEMPAgentFitness[arena][a] += computeMedian();\n//            double min = *std::min_element(scores.begin(), scores.end());\n            [[maybe_unused]] double avg = TEMPAgentFitness[arena][a] / STARTPOSITIONS.size();\n            //  TEMPAgentFitness[arena][a] = 0.7 * min + 0.3 * avg;\n              // TEMPAgentFitness[arena][a] = min;\n              TEMPAgentFitness[arena][a] = avg;\n          }\n\n        }\n\n        void MemGOBYE() {\n\n          TEMPAgentFitness.clear();\n          environments.clear();\n          agents.clear();\n          sortedAgents.clear();\n\n        }\n\n        ~GPTrainingLoop() = default;\n    };\n}\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_8hpp/","title":"File Graph.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; Graph.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"../AgentLibary.hpp\"</code></li> <li><code>#include \"GraphNode.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_8hpp/#classes","title":"Classes","text":"Type Name class Graph A graph of nodes that can be used to make decisions. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/Graph.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_8hpp_source/","title":"File Graph.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; Graph.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"../../core/AgentBase.hpp\"\n#include \"../AgentLibary.hpp\"\n#include \"GraphNode.hpp\"\n\nnamespace cowboys {\n  using GraphLayer = std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt;;\n\n  class Graph {\n  protected:\n    std::vector&lt;GraphLayer&gt; layers;\n\n  public:\n    Graph() = default;\n    ~Graph() = default;\n\n    size_t GetNodeCount() const {\n      return std::accumulate(layers.cbegin(), layers.cend(), 0,\n                             [](size_t sum, const auto &amp;layer) { return sum + layer.size(); });\n    }\n\n    size_t GetLayerCount() const { return layers.size(); }\n\n    size_t MakeDecision(const std::vector&lt;double&gt; &amp;inputs, const std::vector&lt;size_t&gt; &amp;actions) {\n      if (layers.size() == 0)\n        return actions.at(0);\n\n      // Set inputs of input layer\n      size_t i = 0;\n      for (auto &amp;node : layers[0]) {\n        double input = 0;\n        if (i &lt; inputs.size())\n          input = inputs.at(i);\n        node-&gt;SetDefaultOutput(input);\n        ++i;\n      }\n\n      // Get output of last layer\n      std::vector&lt;double&gt; outputs;\n      for (auto &amp;node : layers.back()) {\n        outputs.push_back(node-&gt;GetOutput());\n      }\n\n      // Choose the action with the highest output\n      auto max_output = std::max_element(outputs.cbegin(), outputs.cend());\n      size_t index = std::distance(outputs.cbegin(), max_output);\n\n      // If index is out of bounds, return the last action\n      size_t action = 0;\n      if (index &gt;= actions.size())\n        action = actions.back();\n      else // Otherwise, return the action at the index\n        action = actions.at(index);\n      return action;\n    }\n\n    void AddLayer(const GraphLayer &amp;layer) { layers.push_back(layer); }\n\n    std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; GetFunctionalNodes() const {\n      std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; functional_nodes;\n      for (size_t i = 1; i &lt; layers.size(); ++i) {\n        functional_nodes.insert(functional_nodes.cend(), layers.at(i).cbegin(), layers.at(i).cend());\n      }\n      return functional_nodes;\n    }\n\n    std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; GetNodes() const {\n      std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; all_nodes;\n      for (auto &amp;layer : layers) {\n        all_nodes.insert(all_nodes.cend(), layer.cbegin(), layer.cend());\n      }\n      return all_nodes;\n    }\n  };\n\n  std::vector&lt;size_t&gt; EncodeActions(const std::unordered_map&lt;std::string, size_t&gt; &amp;action_map) {\n    std::vector&lt;size_t&gt; actions;\n    for (const auto &amp;[action_name, action_id] : action_map) {\n      actions.push_back(action_id);\n    }\n    // Sort the actions so that they are in a consistent order.\n    std::sort(actions.begin(), actions.end());\n    return actions;\n  }\n\n  std::vector&lt;double&gt; EncodeState(const cse491::WorldGrid &amp;grid, const cse491::type_options_t &amp; /*type_options*/,\n                                  const cse491::item_map_t &amp; /*item_set*/, const cse491::agent_map_t &amp; /*agent_set*/,\n                                  const cse491::AgentBase *agent,\n                                  const std::unordered_map&lt;std::string, double&gt; &amp;extra_agent_state) {\n    std::vector&lt;double&gt; inputs;\n\n    auto current_position = agent-&gt;GetPosition();\n\n    double current_state = grid.At(current_position);\n    double above_state = grid.IsValid(current_position.Above()) ? grid.At(current_position.Above()) : 0.;\n    double below_state = grid.IsValid(current_position.Below()) ? grid.At(current_position.Below()) : 0.;\n    double left_state = grid.IsValid(current_position.ToLeft()) ? grid.At(current_position.ToLeft()) : 0.;\n    double right_state = grid.IsValid(current_position.ToRight()) ? grid.At(current_position.ToRight()) : 0.;\n\n    double prev_action = extra_agent_state.at(\"previous_action\");\n    double starting_x = extra_agent_state.at(\"starting_x\");\n    double starting_y = extra_agent_state.at(\"starting_y\");\n    auto starting_pos = cse491::GridPosition(starting_x, starting_y);\n    auto path = walle::GetShortestPath(agent-&gt;GetPosition(), starting_pos, agent-&gt;GetWorld(), *agent);\n    double distance_from_start = path.size();\n\n    inputs.insert(inputs.end(), {prev_action, starting_x, starting_y, distance_from_start, current_state, above_state, below_state, left_state, right_state});\n\n    return inputs;\n  }\n\n} // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_builder_8hpp/","title":"File GraphBuilder.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GraphBuilder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CGPGenotype.hpp\"</code></li> <li><code>#include \"Graph.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_builder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_builder_8hpp/#classes","title":"Classes","text":"Type Name class GraphBuilder A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs. <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphBuilder.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_builder_8hpp_source/","title":"File GraphBuilder.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GraphBuilder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include \"CGPGenotype.hpp\"\n#include \"Graph.hpp\"\n\nnamespace cowboys {\n\n  class GraphBuilder {\n  public:\n    GraphBuilder() = default;\n    ~GraphBuilder() = default;\n\n    std::unique_ptr&lt;Graph&gt; CartesianGraph(const CGPGenotype &amp;genotype, const std::vector&lt;InnerFunction&gt; &amp;function_set,\n                                          const cse491::AgentBase *agent = nullptr) {\n      auto decision_graph = std::make_unique&lt;Graph&gt;();\n\n      //\n      // Add all the nodes\n      //\n      // Input layer\n      GraphLayer input_layer;\n      for (size_t i = 0; i &lt; genotype.GetNumInputs(); ++i) {\n        input_layer.emplace_back(std::make_shared&lt;GraphNode&gt;(0));\n      }\n      decision_graph-&gt;AddLayer(input_layer);\n\n      // Middle Layers\n      for (size_t i = 0; i &lt; genotype.GetNumLayers(); ++i) {\n        GraphLayer layer;\n        for (size_t j = 0; j &lt; genotype.GetNumNodesPerLayer(); ++j) {\n          layer.emplace_back(std::make_shared&lt;GraphNode&gt;(0));\n        }\n        decision_graph-&gt;AddLayer(layer);\n      }\n\n      // Action layer\n      GraphLayer output_layer;\n      for (size_t i = 0; i &lt; genotype.GetNumOutputs(); ++i) {\n        output_layer.emplace_back(std::make_shared&lt;GraphNode&gt;(0));\n      }\n      decision_graph-&gt;AddLayer(output_layer);\n\n      //\n      // Configure graph based on genotype\n      //\n\n      auto functional_nodes = decision_graph-&gt;GetFunctionalNodes();\n      auto all_nodes = decision_graph-&gt;GetNodes();\n      auto nodes_it = functional_nodes.cbegin();\n      auto genes_it = genotype.cbegin();\n      // Iterator distances should be the same\n      assert(std::distance(functional_nodes.cend(), functional_nodes.cbegin()) ==\n             std::distance(genotype.cend(), genotype.cbegin()));\n      // Get the iterator of all nodes and move it to the start of the first functional node\n      auto all_nodes_it = all_nodes.cbegin() + genotype.GetNumInputs();\n      for (; nodes_it != functional_nodes.end() &amp;&amp; genes_it != genotype.cend(); ++nodes_it, ++genes_it) {\n        // Advance the all nodes iterator if we are at the start of a new layer\n        auto dist = std::distance(functional_nodes.cbegin(), nodes_it);\n        if (dist != 0 &amp;&amp; dist % genotype.GetNumNodesPerLayer() == 0) {\n          std::advance(all_nodes_it, genotype.GetNumNodesPerLayer());\n        }\n\n        auto &amp;[connections, function_idx, output] = *genes_it;\n        (*nodes_it)-&gt;SetFunctionPointer(NodeFunction{function_set.at(function_idx), agent});\n        (*nodes_it)-&gt;SetDefaultOutput(output);\n\n        // Copy the all nodes iterator and move it backwards by the number of connections\n        auto nodes_it_copy = all_nodes_it;\n        std::advance(nodes_it_copy, -connections.size());\n        // Add the inputs to the node\n        for (auto &amp;connection : connections) {\n          if (connection != '0') {\n            (*nodes_it)-&gt;AddInput(*nodes_it_copy);\n          }\n          ++nodes_it_copy;\n        }\n      }\n\n      return decision_graph;\n    }\n\n    std::unique_ptr&lt;Graph&gt; VerticalPacer() {\n      auto decision_graph = std::make_unique&lt;Graph&gt;();\n\n      GraphLayer input_layer;\n      std::shared_ptr&lt;GraphNode&gt; prev_action = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; current_state = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; above_state = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; below_state = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; left_state = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; right_state = std::make_shared&lt;GraphNode&gt;(0);\n      input_layer.insert(input_layer.end(),\n                         {prev_action, current_state, above_state, below_state, left_state, right_state});\n      decision_graph-&gt;AddLayer(input_layer);\n\n      // state == 1 =&gt; floor which is walkable\n      GraphLayer obstruction_layer;\n      std::shared_ptr&lt;GraphNode&gt; up_not_blocked = std::make_shared&lt;GraphNode&gt;(AnyEq);\n      up_not_blocked-&gt;AddInputs(GraphLayer{above_state, std::make_shared&lt;GraphNode&gt;(1)});\n      std::shared_ptr&lt;GraphNode&gt; down_not_blocked = std::make_shared&lt;GraphNode&gt;(AnyEq);\n      down_not_blocked-&gt;AddInputs(GraphLayer{below_state, std::make_shared&lt;GraphNode&gt;(1)});\n      obstruction_layer.insert(obstruction_layer.end(), {up_not_blocked, down_not_blocked});\n      decision_graph-&gt;AddLayer(obstruction_layer);\n\n      // Separate previous action into up and down nodes\n      GraphLayer prev_action_layer;\n      std::shared_ptr&lt;GraphNode&gt; up_prev_action = std::make_shared&lt;GraphNode&gt;(AnyEq);\n      up_prev_action-&gt;AddInputs(GraphLayer{prev_action, std::make_shared&lt;GraphNode&gt;(1)});\n      std::shared_ptr&lt;GraphNode&gt; down_prev_action = std::make_shared&lt;GraphNode&gt;(AnyEq);\n      down_prev_action-&gt;AddInputs(GraphLayer{prev_action, std::make_shared&lt;GraphNode&gt;(2)});\n      prev_action_layer.insert(prev_action_layer.end(), {up_prev_action, down_prev_action});\n      decision_graph-&gt;AddLayer(prev_action_layer);\n\n      GraphLayer moving_layer;\n      // If up_not_blocked and up_prev_action ? return 1 : return 0\n      // If down_not_blocked and down_prev_action ? return 1 : return 0\n      std::shared_ptr&lt;GraphNode&gt; keep_up = std::make_shared&lt;GraphNode&gt;(And);\n      keep_up-&gt;AddInputs(GraphLayer{up_not_blocked, up_prev_action});\n      std::shared_ptr&lt;GraphNode&gt; keep_down = std::make_shared&lt;GraphNode&gt;(And);\n      keep_down-&gt;AddInputs(GraphLayer{down_not_blocked, down_prev_action});\n      moving_layer.insert(moving_layer.end(), {keep_up, keep_down});\n      decision_graph-&gt;AddLayer(moving_layer);\n\n      // If down_blocked, turn_up\n      // If up_blocked, turn_down\n      GraphLayer turn_layer;\n      std::shared_ptr&lt;GraphNode&gt; turn_up = std::make_shared&lt;GraphNode&gt;(Not);\n      turn_up-&gt;AddInputs(GraphLayer{down_not_blocked});\n      std::shared_ptr&lt;GraphNode&gt; turn_down = std::make_shared&lt;GraphNode&gt;(Not);\n      turn_down-&gt;AddInputs(GraphLayer{up_not_blocked});\n      turn_layer.insert(turn_layer.end(), {turn_up, turn_down});\n      decision_graph-&gt;AddLayer(turn_layer);\n\n      // Output layer, up, down, left, right\n      GraphLayer action_layer;\n      // move up = keep_up + turn_up,\n      // move down = keep_down + turn_down,\n      std::shared_ptr&lt;GraphNode&gt; up = std::make_shared&lt;GraphNode&gt;(Sum);\n      up-&gt;AddInputs(GraphLayer{keep_up, turn_up});\n      std::shared_ptr&lt;GraphNode&gt; down = std::make_shared&lt;GraphNode&gt;(Sum);\n      down-&gt;AddInputs(GraphLayer{keep_down, turn_down});\n      std::shared_ptr&lt;GraphNode&gt; left = std::make_shared&lt;GraphNode&gt;(0);\n      std::shared_ptr&lt;GraphNode&gt; right = std::make_shared&lt;GraphNode&gt;(0);\n      action_layer.insert(action_layer.end(), {up, down, left, right});\n      decision_graph-&gt;AddLayer(action_layer);\n\n      return decision_graph;\n    }\n  };\n} // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/","title":"File GraphNode.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; GraphNode.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;execution&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"../../core/WorldBase.hpp\"</code></li> <li><code>#include \"../AgentLibary.hpp\"</code></li> <li><code>#include \"GPAgentSensors.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#classes","title":"Classes","text":"Type Name class GraphNode A node in a decision graph. struct NodeFunction A function pointer wrapper that holds extra arguments for the function pointer."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#macros","title":"Macros","text":"Type Name define PAR"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp/#define-par","title":"define PAR","text":"<pre><code>#define PAR \n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Agents/GP/GraphNode.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_graph_node_8hpp_source/","title":"File GraphNode.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; GraphNode.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n// Macro for parallel execution, add -DPARALLEL flag to CMAKE_CXX_FLAGS when building to enable\n#if PARALLEL\n#include &lt;execution&gt;\n#define PAR std::execution::par,\n#else\n#define PAR\n#endif\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;cmath&gt;\n#include &lt;execution&gt;\n#include &lt;functional&gt;\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;numeric&gt;\n#include &lt;optional&gt;\n#include &lt;ranges&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"../../core/AgentBase.hpp\"\n#include \"../../core/WorldBase.hpp\"\n#include \"../AgentLibary.hpp\"\n#include \"GPAgentSensors.hpp\"\n\nnamespace cowboys {\n  class GraphNode; \n  using InnerFunction = double (*)(const GraphNode &amp;, const cse491::AgentBase &amp;);\n  struct NodeFunction {\n    InnerFunction function{nullptr};\n    const cse491::AgentBase *agent{nullptr};\n    double operator()(const GraphNode &amp;node) const { return function(node, *agent); }\n    bool IsNull() const { return function == nullptr; }\n  };\n\n  class GraphNode : public std::enable_shared_from_this&lt;GraphNode&gt; {\n  protected:\n    std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; inputs;\n\n    NodeFunction function_pointer;\n\n    double default_output{0};\n\n    std::vector&lt;GraphNode *&gt; outputs;\n\n    mutable double cached_output{0};\n\n    mutable bool cached_output_valid{false};\n\n    void AddOutput(GraphNode *node) { outputs.push_back(node); }\n\n    void RecursiveInvalidateCache() const {\n      cached_output_valid = false;\n      for (auto &amp;output : outputs) {\n        output-&gt;RecursiveInvalidateCache();\n      }\n    }\n\n  public:\n    GraphNode() = default;\n    ~GraphNode() = default;\n\n    GraphNode(double default_value) : default_output{default_value} {}\n    GraphNode(NodeFunction function) : function_pointer{function} {}\n    GraphNode(InnerFunction function) : function_pointer{function} {}\n\n    double GetOutput() const {\n      if (cached_output_valid)\n        return cached_output;\n\n      double result = default_output;\n      // Invoke function pointer if it exists\n      if (!function_pointer.IsNull()) {\n        result = function_pointer(*this);\n      }\n\n      // Cache the output\n      cached_output = result;\n      cached_output_valid = true;\n\n      return result;\n    }\n\n    std::vector&lt;double&gt; GetInputValues() const {\n      std::vector&lt;double&gt; values;\n      values.reserve(inputs.size());\n      std::transform(inputs.cbegin(), inputs.cend(), std::back_inserter(values),\n                     [](const auto &amp;node) { return node-&gt;GetOutput(); });\n      return values;\n    }\n\n    template &lt;size_t N&gt; std::optional&lt;std::vector&lt;double&gt;&gt; GetInputValues(const std::array&lt;size_t, N&gt; &amp;indices) const {\n      size_t max_index = *std::max_element(indices.cbegin(), indices.cend());\n      if (max_index &gt;= inputs.size())\n        return std::nullopt;\n      std::vector&lt;double&gt; values;\n      values.reserve(N);\n      std::transform(indices.cbegin(), indices.cend(), std::back_inserter(values),\n                     [this](const auto &amp;index) { return inputs.at(index)-&gt;GetOutput(); });\n      return values;\n    }\n\n    void SetFunctionPointer(NodeFunction function) {\n      function_pointer = function;\n      RecursiveInvalidateCache();\n    }\n\n    void SetFunctionPointer(InnerFunction inner_function) {\n      function_pointer = NodeFunction{inner_function};\n      RecursiveInvalidateCache();\n    }\n\n    void AddInput(std::shared_ptr&lt;GraphNode&gt; node) {\n      inputs.push_back(node);\n      // Add a weak pointer to this node to the input node's outputs\n      node-&gt;AddOutput(this);\n      RecursiveInvalidateCache();\n    }\n\n    void AddInputs(const std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; &amp;nodes) {\n      inputs.insert(inputs.cend(), nodes.cbegin(), nodes.cend());\n      RecursiveInvalidateCache();\n    }\n\n    void SetInputs(std::vector&lt;std::shared_ptr&lt;GraphNode&gt;&gt; nodes) {\n      inputs = nodes;\n      RecursiveInvalidateCache();\n    }\n\n    void SetDefaultOutput(double value) {\n      if (default_output != value) {\n        default_output = value;\n        RecursiveInvalidateCache();\n      }\n    }\n\n    double GetDefaultOutput() const { return default_output; }\n\n    bool IsCacheValid() const { return cached_output_valid; }\n  };\n\n  double Sum(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues();\n    return std::reduce(PAR vals.cbegin(), vals.cend(), 0.);\n  }\n\n  double And(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues();\n    return std::any_of(vals.cbegin(), vals.cend(), [](const double val) { return val == 0.; }) ? 0. : 1.;\n  }\n\n  double AnyEq(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    if (vals.size() == 0)\n      return node.GetDefaultOutput();\n    for (size_t i = 1; i &lt; vals.size(); ++i) {\n      if (vals.at(0) == vals.at(i))\n        return 1.;\n    }\n    return 0.;\n  }\n\n  double Not(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues&lt;1&gt;(std::array&lt;size_t, 1&gt;{0});\n    if (!vals.has_value())\n      return node.GetDefaultOutput();\n    return (*vals)[0] == 0. ? 1. : 0.;\n  }\n\n  double Gate(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues&lt;2&gt;(std::array&lt;size_t, 2&gt;{0, 1});\n    if (!vals.has_value())\n      return node.GetDefaultOutput();\n    return (*vals)[1] != 0. ? (*vals)[0] : 0.;\n  }\n\n  double Sin(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::sin(val); });\n  }\n\n  double Cos(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::cos(val); });\n  }\n\n  double Product(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues();\n    return std::reduce(PAR vals.cbegin(), vals.cend(), 1., std::multiplies{});\n  }\n\n  double Reciprocal(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    auto vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return 1. / (val + std::numeric_limits&lt;double&gt;::epsilon()); });\n  }\n\n  double Exp(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::exp(val); });\n  }\n\n  double LessThan(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::is_sorted(vals.begin(), vals.end(), std::less{});\n  }\n\n  double GreaterThan(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::is_sorted(vals.begin(), vals.end(), std::greater{});\n  }\n\n  double Max(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    if (vals.empty())\n      return node.GetDefaultOutput();\n    return *std::max_element(vals.cbegin(), vals.cend());\n  }\n\n  double Min(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    if (vals.empty())\n      return node.GetDefaultOutput();\n    return *std::min_element(vals.cbegin(), vals.cend());\n  }\n\n  double NegSum(const GraphNode &amp;node, const cse491::AgentBase &amp;agent) { return -Sum(node, agent); }\n\n  double Square(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return val * val; });\n  }\n\n  double PosClamp(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::max(0., val); });\n  }\n\n  double NegClamp(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::min(0., val); });\n  }\n\n  double Sqrt(const GraphNode &amp;node, const cse491::AgentBase &amp;) {\n    std::vector&lt;double&gt; vals = node.GetInputValues();\n    return std::transform_reduce(PAR vals.cbegin(), vals.cend(), 0., std::plus{},\n                                 [](const double val) { return std::sqrt(std::max(0., val)); });\n  }\n\n  double WallDistanceUp(const GraphNode &amp;, const cse491::AgentBase &amp;agent) {\n    return Sensors::wallDistance(agent.GetWorld().GetGrid(), agent, SensorDirection::ABOVE);\n  }\n\n  double WallDistanceDown(const GraphNode &amp;, const cse491::AgentBase &amp;agent) {\n    return Sensors::wallDistance(agent.GetWorld().GetGrid(), agent, SensorDirection::BELOW);\n  }\n\n  double WallDistanceLeft(const GraphNode &amp;, const cse491::AgentBase &amp;agent) {\n    return Sensors::wallDistance(agent.GetWorld().GetGrid(), agent, SensorDirection::LEFT);\n  }\n\n  double WallDistanceRight(const GraphNode &amp;, const cse491::AgentBase &amp;agent) {\n    return Sensors::wallDistance(agent.GetWorld().GetGrid(), agent, SensorDirection::RIGHT);\n  }\n\n  double AStarDistance(const GraphNode &amp;node, const cse491::AgentBase &amp;agent) {\n    //\n    // The outputs of the first two connections are the x and y coordinates of the goal position. It'd probably be rare\n    // for agents to randomly use it in a useful way. Most of the time when it IS used, there is no input connections\n    // and thus the default output is used, so it isn't REALLY being used. Other times when it does have input\n    // connections, the agent has a lower fitness, so it probably wasn't making good use of it.\n    //\n    // Decided to make an easier way A* can be used by agents by giving the A* distance from the agent's start position\n    // as an input. This can still be used in the off chance it is useful.\n    auto vals = node.GetInputValues&lt;2&gt;(std::array&lt;size_t, 2&gt;{0, 1});\n    if (!vals.has_value())\n      return node.GetDefaultOutput();\n    auto vals2 = *vals;\n    auto goal_position = cse491::GridPosition(vals2[0], vals2[1]);\n    auto path = walle::GetShortestPath(agent.GetPosition(), goal_position, agent.GetWorld(), agent);\n    return path.size();\n  }\n\n  static const std::vector&lt;InnerFunction&gt; NODE_FUNCTION_SET{\n      nullptr,  Sum,         And, AnyEq, Not,    Gate,   Sin,      Cos,      Product, Exp,\n      LessThan, GreaterThan, Max, Min,   NegSum, Square, PosClamp, NegClamp, Sqrt};\n  static const std::vector&lt;InnerFunction&gt; SENSOR_FUNCTION_SET{WallDistanceUp, WallDistanceDown, WallDistanceLeft,\n                                                              WallDistanceRight, AStarDistance};\n\n  static const std::vector&lt;InnerFunction&gt; FUNCTION_SET = []() {\n    std::vector&lt;InnerFunction&gt; functions;\n    functions.reserve(NODE_FUNCTION_SET.size() + SENSOR_FUNCTION_SET.size());\n    functions.insert(functions.cend(), NODE_FUNCTION_SET.cbegin(), NODE_FUNCTION_SET.cend());\n    functions.insert(functions.cend(), SENSOR_FUNCTION_SET.cbegin(), SENSOR_FUNCTION_SET.cend());\n    return functions;\n  }();\n} // namespace cowboys\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_l_g_p_agent_8hpp/","title":"File LGPAgent.hpp","text":"<p>FileList &gt; Agents &gt; GP &gt; LGPAgent.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"../../core/AgentBase.hpp\"</code></li> <li><code>#include \"GPAgentSensors.hpp\"</code></li> <li><code>#include \"./GPAgentBase.hpp\"</code></li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_l_g_p_agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys An Agent based on genetic programming."},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_l_g_p_agent_8hpp/#classes","title":"Classes","text":"Type Name class LGPAgent <p>The documentation for this class was generated from the following file <code>source/Agents/GP/LGPAgent.hpp</code></p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/_l_g_p_agent_8hpp_source/","title":"File LGPAgent.hpp","text":"<p>File List &gt; Agents &gt; GP &gt; LGPAgent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt;\n#include \"../../core/AgentBase.hpp\"\n#include \"GPAgentSensors.hpp\"\n\n#include \"./GPAgentBase.hpp\"\n\nnamespace cowboys\n{\n    const int LISTSIZE = 100;\n\n    class LGPAgent : public GPAgentBase\n    {\n    protected:\n        // A dictionary of actions and a dictionary of sensors\n        // A sensor is a function that takes in a grid and returns a value (e.g. distance to left wall)\n\n        std::vector&lt;std::string&gt; possibleInstructionsList = {};\n        std::vector&lt;std::string&gt; actionsList = {};\n        std::vector&lt;std::string&gt; operationsList = {\"lessthan\", \"greaterthan\", \"equals\"};\n        std::vector&lt;std::string&gt; sensorsNamesList = {\"getLeft\", \"getRight\", \"getUp\", \"getDown\"};\n\n        // A list that stores the results of executed instructions\n        std::vector&lt;int&gt; resultsList;\n\n        std::vector&lt;std::tuple&lt;std::string, int, int&gt;&gt; instructionsList = {};\n        size_t currentInstructionIndex = 0;\n\n        std::random_device rd;\n        std::mt19937 gen;\n\n    public:\n        LGPAgent(size_t id, const std::string &amp;name) : GPAgentBase(id, name)\n        {\n            gen = std::mt19937(rd());\n\n            for (auto i = 0; i &lt; LISTSIZE; i++)\n            {\n                resultsList.push_back(0);\n            }\n        }\n\n        bool Initialize() override\n        {\n            possibleInstructionsList = EncodeActions(action_map, sensorsNamesList, operationsList, actionsList);\n            GenerateRandomActionList();\n            return true;\n        }\n\n        void GenerateRandomActionList()\n        {\n            std::uniform_int_distribution&lt;size_t&gt; dist(0, possibleInstructionsList.size() - 1);\n            std::uniform_int_distribution&lt;size_t&gt; dist2(0, LISTSIZE - 1);\n            for (int i = 0; i &lt; LISTSIZE; i++)\n            {\n                instructionsList.push_back(std::make_tuple(possibleInstructionsList[dist(gen)], dist2(gen), dist2(gen)));\n            }\n\n        }\n\n        static std::vector&lt;std::string&gt; EncodeActions(const std::unordered_map&lt;std::string, size_t&gt; &amp;action_map, const std::vector&lt;std::string&gt; &amp;sensorsNamesList, \n                                                        const std::vector&lt;std::string&gt; &amp;operationsList, std::vector&lt;std::string&gt; &amp;actionsList)\n        {\n            std::vector&lt;std::string&gt; instructions;\n            for (const auto &amp;[action_name, action_id] : action_map)\n            {\n                instructions.push_back(action_name);\n                actionsList.push_back(action_name);\n            }\n            for (const auto &amp;sensor : operationsList)\n            {\n                instructions.push_back(sensor);\n            }\n\n            for (const auto &amp;sensor : sensorsNamesList)\n            {\n                instructions.push_back(sensor);\n            }\n\n            return instructions;\n        }\n\n        void MutateAgent(double mutation_rate = 0.01) override\n        {\n            std::uniform_int_distribution&lt;size_t&gt; rnd_mutate(1, 100);\n            std::uniform_int_distribution&lt;size_t&gt; dist(0, possibleInstructionsList.size() - 1);\n            std::uniform_int_distribution&lt;size_t&gt; dist2(0, LISTSIZE - 1);\n\n            for (auto i = 0; i &lt; LISTSIZE; i++)\n            {\n                if (rnd_mutate(gen) / 100.0 &lt;= mutation_rate)\n                {\n                    instructionsList[i] = std::make_tuple(possibleInstructionsList[dist(gen)], dist2(gen), dist2(gen));\n                }\n            }\n\n            resultsList.clear();\n            resultsList.resize(LISTSIZE);\n            currentInstructionIndex = 0;\n        }\n\n        const std::vector&lt;std::tuple&lt;std::string, int, int&gt;&gt; &amp;GetInstructionsList(){ return instructionsList; }\n\n        void Configure(const LGPAgent &amp;other) {\n            instructionsList = other.instructionsList;\n            possibleInstructionsList = other.possibleInstructionsList;\n            actionsList = other.actionsList;\n            operationsList = other.operationsList;\n            sensorsNamesList = other.sensorsNamesList;\n            resultsList = other.resultsList;\n            currentInstructionIndex = other.currentInstructionIndex;\n        }\n\n        void Copy(const GPAgentBase &amp;other) override\n        {\n            assert(dynamic_cast&lt;const LGPAgent *&gt;(&amp;other) != nullptr);\n            Configure(dynamic_cast&lt;const LGPAgent &amp;&gt;(other));\n        }\n\n\n        size_t GetAction([[maybe_unused]] const cse491::WorldGrid &amp;grid,\n                            [[maybe_unused]] const cse491::type_options_t &amp;type_options,\n                            [[maybe_unused]] const cse491::item_map_t &amp;item_set,\n                            [[maybe_unused]] const cse491::agent_map_t &amp;agent_set) override\n        {\n            std::string action;\n            std::string sensor;\n            std::string operation;\n            auto instruction = instructionsList[currentInstructionIndex];\n            int i = 0;\n\n            if (currentInstructionIndex != 0)\n            {\n                resultsList[currentInstructionIndex - 1] = action_result;\n            }\n            else\n            {\n                resultsList[LISTSIZE - 1] = action_result;\n            }\n\n            while (i &lt; LISTSIZE * 2 &amp;&amp; action.empty())\n            {\n                if (std::find(actionsList.begin(), actionsList.end(), std::get&lt;0&gt;(instruction)) != actionsList.end())\n                {\n                    // the instruction is in the action list (provided by the world)\n                    action = std::get&lt;0&gt;(instruction);\n                }\n                else if (std::find(sensorsNamesList.begin(), sensorsNamesList.end(), std::get&lt;0&gt;(instruction)) != sensorsNamesList.end())\n                {\n                    // the instruction is in the sensor list (getLeft, getRight, getUp, getDown)\n                    sensor = std::get&lt;0&gt;(instruction);\n\n                    SensorDirection direction = Sensors::getSensorDirectionEnum(sensor);\n                    int distance = Sensors::wallDistance(grid, *this, direction);\n\n\n                    resultsList[currentInstructionIndex] = distance;\n\n\n                }\n                else\n                {\n                    // the instruction is an operation (lessthan, greaterthan, equals)\n                    operation = std::get&lt;0&gt;(instruction);\n                    if (operation == \"lessthan\")\n                    {\n                        if (std::get&lt;1&gt;(instruction) &lt; std::get&lt;2&gt;(instruction))\n                        {\n                            resultsList[currentInstructionIndex] = 1;\n                        }\n                        else\n                        {\n                            resultsList[currentInstructionIndex] = 0;\n                            ++currentInstructionIndex;\n                        }\n                    }\n                    else if (operation == \"greaterthan\")\n                    {\n                        if (std::get&lt;1&gt;(instruction) &gt; std::get&lt;2&gt;(instruction))\n                        {\n                            resultsList[currentInstructionIndex] = 1;\n                        }\n                        else\n                        {\n                            resultsList[currentInstructionIndex] = 0;\n                            ++currentInstructionIndex;\n                        }\n                    }\n                    else if (operation == \"equals\")\n                    {\n                        if (std::get&lt;1&gt;(instruction) == std::get&lt;2&gt;(instruction))\n                        {\n                            resultsList[currentInstructionIndex] = 1;\n                        }\n                        else\n                        {\n                            resultsList[currentInstructionIndex] = 0;\n                            ++currentInstructionIndex;\n                        }\n                    }\n                }\n\n                ++currentInstructionIndex;\n                if (currentInstructionIndex &gt;= LISTSIZE)\n                {\n                    currentInstructionIndex = 0;\n                }\n                ++i;\n                instruction = instructionsList[currentInstructionIndex];\n            }\n            if (!action.empty())\n            {\n                return action_map[action];\n            }\n\n            return 0;\n        }\n\n\n        std::string Export() override {\n            std::string encodedLists = \"\";\n\n            for (auto instruction : instructionsList)\n            {\n                encodedLists += std::get&lt;0&gt;(instruction);\n                encodedLists += \".\";\n                encodedLists += std::to_string(std::get&lt;1&gt;(instruction));\n                encodedLists += \".\";\n                encodedLists += std::to_string(std::get&lt;2&gt;(instruction));\n                encodedLists += \",\";\n            }\n\n            encodedLists += \";\";\n\n            for (auto possInstruction : possibleInstructionsList)\n            {\n                encodedLists += possInstruction;\n                encodedLists += \".\";\n            }\n\n            encodedLists += \";\";\n\n            for (auto action : actionsList)\n            {\n                encodedLists += action;\n                encodedLists += \".\";\n            }\n\n            return encodedLists;\n        }\n\n        void SerializeGP(tinyxml2::XMLDocument &amp; doc, tinyxml2::XMLElement* parentElem, double fitness = -1) override\n        {\n            auto agentElem = doc.NewElement(\"LGPAgent\");\n            parentElem-&gt;InsertEndChild(agentElem);\n\n            auto listElem = doc.NewElement(\"instruction list\");\n            listElem-&gt;SetText(Export().c_str());\n            if (fitness != -1)\n                listElem-&gt;SetAttribute(\"fitness\", fitness);\n            agentElem-&gt;InsertEndChild(listElem);\n        }\n\n        void Import(const std::string &amp; encodedLists) override {\n            std::vector&lt;std::tuple&lt;std::string, int, int&gt;&gt; decodedInstructionsList = {};\n            std::string decodedInstruction;\n            size_t start_pos = 0;\n            size_t first_period_pos;\n            size_t second_period_pos;\n            size_t comma_pos = encodedLists.find(\",\");\n\n            // Load the instruction list\n            while (comma_pos != std::string::npos) {\n                decodedInstruction = encodedLists.substr(start_pos, comma_pos - start_pos);\n                first_period_pos = decodedInstruction.find(\".\");\n                second_period_pos = decodedInstruction.find(\".\", first_period_pos + 1);\n                decodedInstructionsList.push_back(std::make_tuple(decodedInstruction.substr(0, first_period_pos),\n                        std::stoi(decodedInstruction.substr(first_period_pos+1, second_period_pos-first_period_pos+1)), std::stoi(decodedInstruction.substr(second_period_pos+1))));\n\n                start_pos = comma_pos + 1;\n                comma_pos = encodedLists.find(\",\", start_pos);\n            }\n\n            std::vector&lt;std::string&gt; decodedPossInstructionsList = {};\n            std::vector&lt;std::string&gt; decodedActionsList = {};\n            size_t first_semicolon_pos = encodedLists.find(\";\");\n            size_t second_semicolon_pos = encodedLists.find(\";\", first_semicolon_pos+1);\n            std::string unseparated_instruction_list = encodedLists.substr(first_semicolon_pos+1, second_semicolon_pos-first_semicolon_pos+1);\n            std::string unseparated_action_list = encodedLists.substr(second_semicolon_pos+1);\n\n            // Load the list of possible instructions\n            size_t period_pos = unseparated_instruction_list.find(\".\");\n            start_pos = 0;\n            while (period_pos != std::string::npos) {\n                decodedPossInstructionsList.push_back(unseparated_instruction_list.substr(start_pos, period_pos));\n\n                start_pos = period_pos + 1;\n                period_pos = encodedLists.find(\".\", start_pos);\n            }\n\n            // Load the list of actions\n            period_pos = unseparated_action_list.find(\".\");\n            start_pos = 0;\n            while (period_pos != std::string::npos) {\n                decodedActionsList.push_back(unseparated_action_list.substr(start_pos, period_pos));\n\n                start_pos = period_pos + 1;\n                period_pos = encodedLists.find(\".\", start_pos);\n            }\n\n            instructionsList = decodedInstructionsList;\n            possibleInstructionsList = decodedPossInstructionsList;\n            actionsList = decodedActionsList;\n            resultsList.clear();\n            resultsList.resize(LISTSIZE);\n            currentInstructionIndex = 0;\n        }\n\n        void PrintAgent() override {\n            for (auto i = 0; i &lt; LISTSIZE; i++)\n            {\n                std::cout &lt;&lt; std::get&lt;0&gt;(instructionsList[i]) &lt;&lt; \" \";\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n    };\n}\n\n</code></pre>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cowboys An Agent based on genetic programming. <ul> <li>namespace base64 A namespace for base64 encoding and decoding. Does not convert to and frombase64 in the typical way. Only guarantees that x == b64_inv(b64(x)), aside from doubles which have problems with precision, so x ~= b64_inv(b64(x)). </li> </ul> </li> <li>namespace cse491 </li> <li>namespace std </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/","title":"Class Index","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#c","title":"c","text":"<ul> <li>CGPAgent (cowboys)</li> <li>CGPGenotype (cowboys)</li> <li>CGPNodeGene (cowboys)</li> <li>CGPParameters (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#g","title":"g","text":"<ul> <li>GPAgent (cowboys)</li> <li>GPAgentAnalyzer (cowboys)</li> <li>GPAgentBase (cowboys)</li> <li>GPAgentRegisters (cowboys)</li> <li>GPTrainingLoop (cowboys)</li> <li>Graph (cowboys)</li> <li>GraphBuilder (cowboys)</li> <li>GraphNode (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#i","title":"i","text":"<ul> <li>iterator (cowboys::GPAgentRegisters)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#l","title":"l","text":"<ul> <li>LGPAgent (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#n","title":"n","text":"<ul> <li>NodeFunction (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/classes/#s","title":"s","text":"<ul> <li>SaveDataParams (cowboys::GPTrainingLoop)</li> <li>Sensors (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class cowboys::CGPGenotype Holds all the information that uniquely defines a cartesian graph. </li> <li>class cowboys::GPAgentAnalyzer </li> <li>class cowboys::GPAgentRegisters Class to hold the registers of the agent. </li> <li>class cowboys::GPAgentRegisters::iterator Iterator class for GPAgentRegisters TODO: Just pass in the vector Iterator.</li> <li>class cowboys::GPTrainingLoop </li> <li>class cowboys::Graph A graph of nodes that can be used to make decisions. </li> <li>class cowboys::GraphBuilder A class for building graphs. Graphs are a generic representation, so this class is used to build the specific format of a Cartesian Graph , and also preset graphs.</li> <li>class cowboys::Sensors </li> <li>struct cowboys::CGPNodeGene Holds the representation of a cartesian graph node. </li> <li>struct cowboys::CGPParameters Holds the parameters that define the structure of a cartesian graph. </li> <li>struct cowboys::GPTrainingLoop::SaveDataParams </li> <li>struct cowboys::NodeFunction A function pointer wrapper that holds extra arguments for the function pointer. </li> <li>class AgentBase <ul> <li>class cowboys::GPAgentBase <ul> <li>class cowboys::CGPAgent An agent based on cartesian genetic programming. </li> <li>class cowboys::LGPAgent </li> </ul> </li> <li>class cowboys::GPAgent </li> <li>class cowboys::GPAgentBase <ul> <li>class cowboys::CGPAgent An agent based on cartesian genetic programming. </li> <li>class cowboys::LGPAgent </li> </ul> </li> <li>class cowboys::GPAgentBase <ul> <li>class cowboys::CGPAgent An agent based on cartesian genetic programming. </li> <li>class cowboys::LGPAgent </li> </ul> </li> </ul> </li> <li>class std::enable_shared_from_this&lt; GraphNode &gt; <ul> <li>class cowboys::GraphNode A node in a decision graph. </li> </ul> </li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/","title":"Class Members","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#a","title":"a","text":"<ul> <li>addAverageFitness (cowboys::GPAgentAnalyzer)</li> <li>addAverageScore (cowboys::GPAgentAnalyzer)</li> <li>addEliteScore (cowboys::GPAgentAnalyzer)</li> <li>addMaxFitness (cowboys::GPAgentAnalyzer)</li> <li>addNumAgentsWithMaxFitness (cowboys::GPAgentAnalyzer)</li> <li>average_fitness (cowboys::GPAgentAnalyzer)</li> <li>average_score (cowboys::GPAgentAnalyzer)</li> <li>AStarFitnessFunction (cowboys::GPTrainingLoop)</li> <li>AgentsAnalysisComputationsAndPrint (cowboys::GPTrainingLoop)</li> <li>agents (cowboys::GPTrainingLoop)</li> <li>allOfLastGeneration (cowboys::GPTrainingLoop)</li> <li>analyzer (cowboys::GPTrainingLoop)</li> <li>AddLayer (cowboys::Graph)</li> <li>AddInput (cowboys::GraphNode)</li> <li>AddInputs (cowboys::GraphNode)</li> <li>AddOutput (cowboys::GraphNode)</li> <li>actionsList (cowboys::LGPAgent)</li> <li>agent (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#b","title":"b","text":"<ul> <li>begin (cowboys::CGPGenotype, cowboys::GPAgentRegisters)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#c","title":"c","text":"<ul> <li>CGPAgent (cowboys::CGPAgent)</li> <li>Configure (cowboys::CGPAgent, cowboys::CGPGenotype, cowboys::LGPAgent)</li> <li>Copy (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>CGPGenotype (cowboys::CGPGenotype)</li> <li>cbegin (cowboys::CGPGenotype)</li> <li>cend (cowboys::CGPGenotype)</li> <li>CGPParameters (cowboys::CGPParameters)</li> <li>checkPointEvery (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>countMaxAgents (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>CartesianGraph (cowboys::GraphBuilder)</li> <li>cached_output (cowboys::GraphNode)</li> <li>cached_output_valid (cowboys::GraphNode)</li> <li>currentInstructionIndex (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#d","title":"d","text":"<ul> <li>decision_graph (cowboys::CGPAgent)</li> <li>DecodeGenotype (cowboys::CGPGenotype)</li> <li>DecodeHeader (cowboys::CGPGenotype)</li> <li>default_output (cowboys::CGPNodeGene, cowboys::GraphNode)</li> <li>dateTimeStr (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>debugPosition (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#e","title":"e","text":"<ul> <li>Export (cowboys::CGPAgent, cowboys::CGPGenotype, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>EncodeGenotype (cowboys::CGPGenotype)</li> <li>EncodeGenotypeRaw (cowboys::CGPGenotype)</li> <li>EncodeHeader (cowboys::CGPGenotype)</li> <li>ExportRaw (cowboys::CGPGenotype)</li> <li>end (cowboys::CGPGenotype, cowboys::GPAgentRegisters)</li> <li>elite_score (cowboys::GPAgentAnalyzer)</li> <li>extra_state (cowboys::GPAgentBase)</li> <li>ELITE_POPULATION_PERCENT (cowboys::GPTrainingLoop)</li> <li>endPositions (cowboys::GPTrainingLoop)</li> <li>environments (cowboys::GPTrainingLoop)</li> <li>EncodeActions (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#f","title":"f","text":"<ul> <li>function_idx (cowboys::CGPNodeGene)</li> <li>FormatPosition (cowboys::GPTrainingLoop)</li> <li>FullLoadGrabLatestGeneration (cowboys::GPTrainingLoop)</li> <li>function_pointer (cowboys::GraphNode)</li> <li>function (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#g","title":"g","text":"<ul> <li>GetAction (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>GetComplexity (cowboys::CGPAgent)</li> <li>GetGenotype (cowboys::CGPAgent)</li> <li>genotype (cowboys::CGPAgent)</li> <li>GetLayersBack (cowboys::CGPGenotype)</li> <li>GetNumConnections (cowboys::CGPGenotype)</li> <li>GetNumFunctionalNodes (cowboys::CGPGenotype)</li> <li>GetNumInputs (cowboys::CGPGenotype)</li> <li>GetNumLayers (cowboys::CGPGenotype)</li> <li>GetNumNodesPerLayer (cowboys::CGPGenotype)</li> <li>GetNumOutputs (cowboys::CGPGenotype)</li> <li>GetNumPossibleConnections (cowboys::CGPGenotype)</li> <li>GetFunctionalNodeCount (cowboys::CGPParameters)</li> <li>GPAgent (cowboys::GPAgent)</li> <li>GPAgentAnalyzer (cowboys::GPAgentAnalyzer)</li> <li>GPAgentBase (cowboys::GPAgentBase)</li> <li>GetExtraState (cowboys::GPAgentBase)</li> <li>GetRandom (cowboys::GPAgentBase)</li> <li>GetRandomNormal (cowboys::GPAgentBase)</li> <li>GetRandomULL (cowboys::GPAgentBase)</li> <li>GetSeed (cowboys::GPAgentBase)</li> <li>GPAgentRegisters (cowboys::GPAgentRegisters)</li> <li>getNumRegisters (cowboys::GPAgentRegisters)</li> <li>getRegister (cowboys::GPAgentRegisters)</li> <li>GPTrainingLoop (cowboys::GPTrainingLoop)</li> <li>Get_A_StarDistance (cowboys::GPTrainingLoop)</li> <li>GpLoopMutateHelper (cowboys::GPTrainingLoop)</li> <li>generation (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>getDateStr (cowboys::GPTrainingLoop)</li> <li>getSystemPath (cowboys::GPTrainingLoop)</li> <li>global_max_threads (cowboys::GPTrainingLoop)</li> <li>GetFunctionalNodes (cowboys::Graph)</li> <li>GetLayerCount (cowboys::Graph)</li> <li>GetNodeCount (cowboys::Graph)</li> <li>GetNodes (cowboys::Graph)</li> <li>Graph (cowboys::Graph)</li> <li>GraphBuilder (cowboys::GraphBuilder)</li> <li>GetDefaultOutput (cowboys::GraphNode)</li> <li>GetInputValues (cowboys::GraphNode)</li> <li>GetOutput (cowboys::GraphNode)</li> <li>GraphNode (cowboys::GraphNode)</li> <li>GenerateRandomActionList (cowboys::LGPAgent)</li> <li>GetInstructionsList (cowboys::LGPAgent)</li> <li>gen (cowboys::LGPAgent)</li> <li>getSensorDirectionEnum (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#h","title":"h","text":"<ul> <li>HasInputConnections (cowboys::CGPGenotype)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#i","title":"i","text":"<ul> <li>Import (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Initialize (cowboys::CGPAgent, cowboys::GPAgent, cowboys::GPAgentBase, cowboys::GPTrainingLoop, cowboys::LGPAgent)</li> <li>InitGenotype (cowboys::CGPGenotype)</li> <li>input_connections (cowboys::CGPNodeGene)</li> <li>index (cowboys::GPAgentRegisters::iterator)</li> <li>iterator (cowboys::GPAgentRegisters::iterator)</li> <li>InitTEMPAgentFitness (cowboys::GPTrainingLoop)</li> <li>independentAgentFitness (cowboys::GPTrainingLoop)</li> <li>IsCacheValid (cowboys::GraphNode)</li> <li>inputs (cowboys::GraphNode)</li> <li>instructionsList (cowboys::LGPAgent)</li> <li>IsNull (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#l","title":"l","text":"<ul> <li>layers_back (cowboys::CGPParameters)</li> <li>lastGenerationsTopAgentsDoc (cowboys::GPTrainingLoop)</li> <li>loadLastGeneration (cowboys::GPTrainingLoop)</li> <li>layers (cowboys::Graph)</li> <li>LGPAgent (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#m","title":"m","text":"<ul> <li>MutateAgent (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Mutate (cowboys::CGPGenotype)</li> <li>MutateConnections (cowboys::CGPGenotype)</li> <li>MutateDefault (cowboys::CGPGenotype)</li> <li>MutateFunctions (cowboys::CGPGenotype)</li> <li>MutateHeader (cowboys::CGPGenotype)</li> <li>MutateOutputs (cowboys::CGPGenotype)</li> <li>movementIndex (cowboys::GPAgent)</li> <li>max_agents (cowboys::GPAgentAnalyzer)</li> <li>max_fitness (cowboys::GPAgentAnalyzer)</li> <li>MemGOBYE (cowboys::GPTrainingLoop)</li> <li>MutateAgents (cowboys::GPTrainingLoop)</li> <li>MutateAndCopyAgents (cowboys::GPTrainingLoop)</li> <li>metaData (cowboys::GPTrainingLoop)</li> <li>MakeDecision (cowboys::Graph)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#n","title":"n","text":"<ul> <li>nodes (cowboys::CGPGenotype)</li> <li>num_inputs (cowboys::CGPParameters)</li> <li>num_layers (cowboys::CGPParameters)</li> <li>num_nodes_per_layer (cowboys::CGPParameters)</li> <li>num_outputs (cowboys::CGPParameters)</li> <li>norm_dist (cowboys::GPAgentBase)</li> <li>normalizedAbsolutePath (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#o","title":"o","text":"<ul> <li>operator= (cowboys::CGPGenotype)</li> <li>operator== (cowboys::CGPGenotype, cowboys::CGPNodeGene, cowboys::CGPParameters, cowboys::GPAgentRegisters::iterator)</li> <li>operator!= (cowboys::GPAgentRegisters::iterator)</li> <li>operator* (cowboys::GPAgentRegisters::iterator)</li> <li>operator++ (cowboys::GPAgentRegisters::iterator)</li> <li>outputs (cowboys::GraphNode)</li> <li>operationsList (cowboys::LGPAgent)</li> <li>operator() (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#p","title":"p","text":"<ul> <li>PrintAgent (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>params (cowboys::CGPGenotype)</li> <li>predefinedMovement (cowboys::GPAgent)</li> <li>Printgrid (cowboys::GPTrainingLoop)</li> <li>possibleInstructionsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#r","title":"r","text":"<ul> <li>Reset (cowboys::GPAgentBase)</li> <li>rng (cowboys::GPAgentBase)</li> <li>registers (cowboys::GPAgentRegisters::iterator, cowboys::GPAgentRegisters)</li> <li>ResetMainTagLastGenerations (cowboys::GPTrainingLoop)</li> <li>Run (cowboys::GPTrainingLoop)</li> <li>RunArena (cowboys::GPTrainingLoop)</li> <li>resetEnvironments (cowboys::GPTrainingLoop)</li> <li>rollingRandomSeed (cowboys::GPTrainingLoop)</li> <li>rootAllOfLastGeneration (cowboys::GPTrainingLoop)</li> <li>rootMetaData (cowboys::GPTrainingLoop)</li> <li>rootTopAllGenerations (cowboys::GPTrainingLoop)</li> <li>rootTopLastGenerations (cowboys::GPTrainingLoop)</li> <li>RecursiveInvalidateCache (cowboys::GraphNode)</li> <li>rd (cowboys::LGPAgent)</li> <li>resultsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#s","title":"s","text":"<ul> <li>SerializeGP (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>SetParameters (cowboys::CGPGenotype)</li> <li>SelectAction (cowboys::GPAgent, cowboys::GPAgentBase)</li> <li>saveToFile (cowboys::GPAgentAnalyzer)</li> <li>SetSeed (cowboys::GPAgentBase)</li> <li>seed (cowboys::GPAgentBase)</li> <li>setRegister (cowboys::GPAgentRegisters)</li> <li>size (cowboys::GPAgentRegisters)</li> <li>STARTPOSITIONS (cowboys::GPTrainingLoop)</li> <li>SaveDataCheckPoint (cowboys::GPTrainingLoop)</li> <li>ScavengerQueuing (cowboys::GPTrainingLoop)</li> <li>SerializeAgents (cowboys::GPTrainingLoop)</li> <li>SimpleFitnessFunction (cowboys::GPTrainingLoop)</li> <li>SortThemAgents (cowboys::GPTrainingLoop)</li> <li>SaveDataParams (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>save (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveAllAgentData (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveLastGenerations (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveMetaData (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveTopAgents (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveXMLDoc (cowboys::GPTrainingLoop)</li> <li>sortedAgents (cowboys::GPTrainingLoop)</li> <li>SetDefaultOutput (cowboys::GraphNode)</li> <li>SetFunctionPointer (cowboys::GraphNode)</li> <li>SetInputs (cowboys::GraphNode)</li> <li>sensorsNamesList (cowboys::LGPAgent)</li> <li>Sensors (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#t","title":"t","text":"<ul> <li>TEMPAgentFitness (cowboys::GPTrainingLoop)</li> <li>ThreadTrainLoop (cowboys::GPTrainingLoop)</li> <li>topAgentsDoc (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#u","title":"u","text":"<ul> <li>uni_dist (cowboys::GPAgentBase)</li> <li>UNFIT_POPULATION_PERCENT (cowboys::GPTrainingLoop)</li> <li>updateGeneration (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#v","title":"v","text":"<ul> <li>VerticalPacer (cowboys::GraphBuilder)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#w","title":"w","text":"<ul> <li>wallDistance (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_members/#_1","title":"~","text":"<ul> <li>~CGPGenotype (cowboys::CGPGenotype)</li> <li>~GPAgent (cowboys::GPAgent)</li> <li>~GPAgentAnalyzer (cowboys::GPAgentAnalyzer)</li> <li>~GPAgentBase (cowboys::GPAgentBase)</li> <li>~GPAgentRegisters (cowboys::GPAgentRegisters)</li> <li>~GPTrainingLoop (cowboys::GPTrainingLoop)</li> <li>~Graph (cowboys::Graph)</li> <li>~GraphBuilder (cowboys::GraphBuilder)</li> <li>~GraphNode (cowboys::GraphNode)</li> <li>~Sensors (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#a","title":"a","text":"<ul> <li>addAverageFitness (cowboys::GPAgentAnalyzer)</li> <li>addAverageScore (cowboys::GPAgentAnalyzer)</li> <li>addEliteScore (cowboys::GPAgentAnalyzer)</li> <li>addMaxFitness (cowboys::GPAgentAnalyzer)</li> <li>addNumAgentsWithMaxFitness (cowboys::GPAgentAnalyzer)</li> <li>AStarFitnessFunction (cowboys::GPTrainingLoop)</li> <li>AgentsAnalysisComputationsAndPrint (cowboys::GPTrainingLoop)</li> <li>AddLayer (cowboys::Graph)</li> <li>AddInput (cowboys::GraphNode)</li> <li>AddInputs (cowboys::GraphNode)</li> <li>AddOutput (cowboys::GraphNode)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#b","title":"b","text":"<ul> <li>begin (cowboys::CGPGenotype, cowboys::GPAgentRegisters)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#c","title":"c","text":"<ul> <li>CGPAgent (cowboys::CGPAgent)</li> <li>Configure (cowboys::CGPAgent, cowboys::CGPGenotype, cowboys::LGPAgent)</li> <li>Copy (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>CGPGenotype (cowboys::CGPGenotype)</li> <li>cbegin (cowboys::CGPGenotype)</li> <li>cend (cowboys::CGPGenotype)</li> <li>CGPParameters (cowboys::CGPParameters)</li> <li>CartesianGraph (cowboys::GraphBuilder)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#d","title":"d","text":"<ul> <li>DecodeGenotype (cowboys::CGPGenotype)</li> <li>DecodeHeader (cowboys::CGPGenotype)</li> <li>debugPosition (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#e","title":"e","text":"<ul> <li>Export (cowboys::CGPAgent, cowboys::CGPGenotype, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>EncodeGenotype (cowboys::CGPGenotype)</li> <li>EncodeGenotypeRaw (cowboys::CGPGenotype)</li> <li>EncodeHeader (cowboys::CGPGenotype)</li> <li>ExportRaw (cowboys::CGPGenotype)</li> <li>end (cowboys::CGPGenotype, cowboys::GPAgentRegisters)</li> <li>EncodeActions (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#f","title":"f","text":"<ul> <li>FormatPosition (cowboys::GPTrainingLoop)</li> <li>FullLoadGrabLatestGeneration (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#g","title":"g","text":"<ul> <li>GetAction (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>GetComplexity (cowboys::CGPAgent)</li> <li>GetGenotype (cowboys::CGPAgent)</li> <li>GetLayersBack (cowboys::CGPGenotype)</li> <li>GetNumConnections (cowboys::CGPGenotype)</li> <li>GetNumFunctionalNodes (cowboys::CGPGenotype)</li> <li>GetNumInputs (cowboys::CGPGenotype)</li> <li>GetNumLayers (cowboys::CGPGenotype)</li> <li>GetNumNodesPerLayer (cowboys::CGPGenotype)</li> <li>GetNumOutputs (cowboys::CGPGenotype)</li> <li>GetNumPossibleConnections (cowboys::CGPGenotype)</li> <li>GetFunctionalNodeCount (cowboys::CGPParameters)</li> <li>GPAgent (cowboys::GPAgent)</li> <li>GPAgentAnalyzer (cowboys::GPAgentAnalyzer)</li> <li>GPAgentBase (cowboys::GPAgentBase)</li> <li>GetExtraState (cowboys::GPAgentBase)</li> <li>GetRandom (cowboys::GPAgentBase)</li> <li>GetRandomNormal (cowboys::GPAgentBase)</li> <li>GetRandomULL (cowboys::GPAgentBase)</li> <li>GetSeed (cowboys::GPAgentBase)</li> <li>GPAgentRegisters (cowboys::GPAgentRegisters)</li> <li>getNumRegisters (cowboys::GPAgentRegisters)</li> <li>getRegister (cowboys::GPAgentRegisters)</li> <li>GPTrainingLoop (cowboys::GPTrainingLoop)</li> <li>Get_A_StarDistance (cowboys::GPTrainingLoop)</li> <li>GpLoopMutateHelper (cowboys::GPTrainingLoop)</li> <li>getDateStr (cowboys::GPTrainingLoop)</li> <li>getSystemPath (cowboys::GPTrainingLoop)</li> <li>GetFunctionalNodes (cowboys::Graph)</li> <li>GetLayerCount (cowboys::Graph)</li> <li>GetNodeCount (cowboys::Graph)</li> <li>GetNodes (cowboys::Graph)</li> <li>Graph (cowboys::Graph)</li> <li>GraphBuilder (cowboys::GraphBuilder)</li> <li>GetDefaultOutput (cowboys::GraphNode)</li> <li>GetInputValues (cowboys::GraphNode)</li> <li>GetOutput (cowboys::GraphNode)</li> <li>GraphNode (cowboys::GraphNode)</li> <li>GenerateRandomActionList (cowboys::LGPAgent)</li> <li>GetInstructionsList (cowboys::LGPAgent)</li> <li>getSensorDirectionEnum (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#h","title":"h","text":"<ul> <li>HasInputConnections (cowboys::CGPGenotype)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#i","title":"i","text":"<ul> <li>Import (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Initialize (cowboys::CGPAgent, cowboys::GPAgent, cowboys::GPAgentBase, cowboys::GPTrainingLoop, cowboys::LGPAgent)</li> <li>InitGenotype (cowboys::CGPGenotype)</li> <li>iterator (cowboys::GPAgentRegisters::iterator)</li> <li>InitTEMPAgentFitness (cowboys::GPTrainingLoop)</li> <li>IsCacheValid (cowboys::GraphNode)</li> <li>IsNull (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#l","title":"l","text":"<ul> <li>loadLastGeneration (cowboys::GPTrainingLoop)</li> <li>LGPAgent (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#m","title":"m","text":"<ul> <li>MutateAgent (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Mutate (cowboys::CGPGenotype)</li> <li>MutateConnections (cowboys::CGPGenotype)</li> <li>MutateDefault (cowboys::CGPGenotype)</li> <li>MutateFunctions (cowboys::CGPGenotype)</li> <li>MutateHeader (cowboys::CGPGenotype)</li> <li>MutateOutputs (cowboys::CGPGenotype)</li> <li>MemGOBYE (cowboys::GPTrainingLoop)</li> <li>MutateAgents (cowboys::GPTrainingLoop)</li> <li>MutateAndCopyAgents (cowboys::GPTrainingLoop)</li> <li>MakeDecision (cowboys::Graph)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (cowboys::CGPGenotype)</li> <li>operator== (cowboys::CGPGenotype, cowboys::CGPNodeGene, cowboys::CGPParameters, cowboys::GPAgentRegisters::iterator)</li> <li>operator!= (cowboys::GPAgentRegisters::iterator)</li> <li>operator* (cowboys::GPAgentRegisters::iterator)</li> <li>operator++ (cowboys::GPAgentRegisters::iterator)</li> <li>operator() (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#p","title":"p","text":"<ul> <li>PrintAgent (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>Printgrid (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#r","title":"r","text":"<ul> <li>Reset (cowboys::GPAgentBase)</li> <li>ResetMainTagLastGenerations (cowboys::GPTrainingLoop)</li> <li>Run (cowboys::GPTrainingLoop)</li> <li>RunArena (cowboys::GPTrainingLoop)</li> <li>resetEnvironments (cowboys::GPTrainingLoop)</li> <li>RecursiveInvalidateCache (cowboys::GraphNode)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#s","title":"s","text":"<ul> <li>SerializeGP (cowboys::CGPAgent, cowboys::GPAgentBase, cowboys::LGPAgent)</li> <li>SetParameters (cowboys::CGPGenotype)</li> <li>SelectAction (cowboys::GPAgent, cowboys::GPAgentBase)</li> <li>saveToFile (cowboys::GPAgentAnalyzer)</li> <li>SetSeed (cowboys::GPAgentBase)</li> <li>setRegister (cowboys::GPAgentRegisters)</li> <li>size (cowboys::GPAgentRegisters)</li> <li>SaveDataCheckPoint (cowboys::GPTrainingLoop)</li> <li>SerializeAgents (cowboys::GPTrainingLoop)</li> <li>SimpleFitnessFunction (cowboys::GPTrainingLoop)</li> <li>SortThemAgents (cowboys::GPTrainingLoop)</li> <li>SaveDataParams (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveXMLDoc (cowboys::GPTrainingLoop)</li> <li>SetDefaultOutput (cowboys::GraphNode)</li> <li>SetFunctionPointer (cowboys::GraphNode)</li> <li>SetInputs (cowboys::GraphNode)</li> <li>Sensors (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#t","title":"t","text":"<ul> <li>ThreadTrainLoop (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#u","title":"u","text":"<ul> <li>updateGeneration (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#v","title":"v","text":"<ul> <li>VerticalPacer (cowboys::GraphBuilder)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#w","title":"w","text":"<ul> <li>wallDistance (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~CGPGenotype (cowboys::CGPGenotype)</li> <li>~GPAgent (cowboys::GPAgent)</li> <li>~GPAgentAnalyzer (cowboys::GPAgentAnalyzer)</li> <li>~GPAgentBase (cowboys::GPAgentBase)</li> <li>~GPAgentRegisters (cowboys::GPAgentRegisters)</li> <li>~GPTrainingLoop (cowboys::GPTrainingLoop)</li> <li>~Graph (cowboys::Graph)</li> <li>~GraphBuilder (cowboys::GraphBuilder)</li> <li>~GraphNode (cowboys::GraphNode)</li> <li>~Sensors (cowboys::Sensors)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#a","title":"a","text":"<ul> <li>average_fitness (cowboys::GPAgentAnalyzer)</li> <li>average_score (cowboys::GPAgentAnalyzer)</li> <li>agents (cowboys::GPTrainingLoop)</li> <li>allOfLastGeneration (cowboys::GPTrainingLoop)</li> <li>analyzer (cowboys::GPTrainingLoop)</li> <li>actionsList (cowboys::LGPAgent)</li> <li>agent (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#c","title":"c","text":"<ul> <li>checkPointEvery (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>countMaxAgents (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>cached_output (cowboys::GraphNode)</li> <li>cached_output_valid (cowboys::GraphNode)</li> <li>currentInstructionIndex (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#d","title":"d","text":"<ul> <li>decision_graph (cowboys::CGPAgent)</li> <li>default_output (cowboys::CGPNodeGene, cowboys::GraphNode)</li> <li>dateTimeStr (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#e","title":"e","text":"<ul> <li>elite_score (cowboys::GPAgentAnalyzer)</li> <li>extra_state (cowboys::GPAgentBase)</li> <li>ELITE_POPULATION_PERCENT (cowboys::GPTrainingLoop)</li> <li>endPositions (cowboys::GPTrainingLoop)</li> <li>environments (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#f","title":"f","text":"<ul> <li>function_idx (cowboys::CGPNodeGene)</li> <li>function_pointer (cowboys::GraphNode)</li> <li>function (cowboys::NodeFunction)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#g","title":"g","text":"<ul> <li>genotype (cowboys::CGPAgent)</li> <li>generation (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>global_max_threads (cowboys::GPTrainingLoop)</li> <li>gen (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#i","title":"i","text":"<ul> <li>input_connections (cowboys::CGPNodeGene)</li> <li>index (cowboys::GPAgentRegisters::iterator)</li> <li>independentAgentFitness (cowboys::GPTrainingLoop)</li> <li>inputs (cowboys::GraphNode)</li> <li>instructionsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#l","title":"l","text":"<ul> <li>layers_back (cowboys::CGPParameters)</li> <li>lastGenerationsTopAgentsDoc (cowboys::GPTrainingLoop)</li> <li>layers (cowboys::Graph)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#m","title":"m","text":"<ul> <li>movementIndex (cowboys::GPAgent)</li> <li>max_agents (cowboys::GPAgentAnalyzer)</li> <li>max_fitness (cowboys::GPAgentAnalyzer)</li> <li>metaData (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#n","title":"n","text":"<ul> <li>nodes (cowboys::CGPGenotype)</li> <li>num_inputs (cowboys::CGPParameters)</li> <li>num_layers (cowboys::CGPParameters)</li> <li>num_nodes_per_layer (cowboys::CGPParameters)</li> <li>num_outputs (cowboys::CGPParameters)</li> <li>norm_dist (cowboys::GPAgentBase)</li> <li>normalizedAbsolutePath (cowboys::GPTrainingLoop::SaveDataParams)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#o","title":"o","text":"<ul> <li>outputs (cowboys::GraphNode)</li> <li>operationsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#p","title":"p","text":"<ul> <li>params (cowboys::CGPGenotype)</li> <li>predefinedMovement (cowboys::GPAgent)</li> <li>possibleInstructionsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#r","title":"r","text":"<ul> <li>rng (cowboys::GPAgentBase)</li> <li>registers (cowboys::GPAgentRegisters::iterator, cowboys::GPAgentRegisters)</li> <li>rollingRandomSeed (cowboys::GPTrainingLoop)</li> <li>rootAllOfLastGeneration (cowboys::GPTrainingLoop)</li> <li>rootMetaData (cowboys::GPTrainingLoop)</li> <li>rootTopAllGenerations (cowboys::GPTrainingLoop)</li> <li>rootTopLastGenerations (cowboys::GPTrainingLoop)</li> <li>rd (cowboys::LGPAgent)</li> <li>resultsList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#s","title":"s","text":"<ul> <li>seed (cowboys::GPAgentBase)</li> <li>STARTPOSITIONS (cowboys::GPTrainingLoop)</li> <li>ScavengerQueuing (cowboys::GPTrainingLoop)</li> <li>save (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveAllAgentData (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveLastGenerations (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveMetaData (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>saveTopAgents (cowboys::GPTrainingLoop::SaveDataParams)</li> <li>sortedAgents (cowboys::GPTrainingLoop)</li> <li>sensorsNamesList (cowboys::LGPAgent)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#t","title":"t","text":"<ul> <li>TEMPAgentFitness (cowboys::GPTrainingLoop)</li> <li>topAgentsDoc (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_variables/#u","title":"u","text":"<ul> <li>uni_dist (cowboys::GPAgentBase)</li> <li>UNFIT_POPULATION_PERCENT (cowboys::GPTrainingLoop)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/","title":"Namespace Members","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#a","title":"a","text":"<ul> <li>AStarDistance (cowboys)</li> <li>And (cowboys)</li> <li>AnyEq (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#b","title":"b","text":"<ul> <li>B2ToB64 (cowboys::base64)</li> <li>B64ToB2 (cowboys::base64)</li> <li>B64ToDouble (cowboys::base64)</li> <li>B64ToULL (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#c","title":"c","text":"<ul> <li>Cos (cowboys)</li> <li>CHARS (cowboys::base64)</li> <li>CHAR_TO_IDX (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#d","title":"d","text":"<ul> <li>DoubleToB64 (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#e","title":"e","text":"<ul> <li>EncodeActions (cowboys)</li> <li>EncodeState (cowboys)</li> <li>Exp (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#f","title":"f","text":"<ul> <li>FUNCTION_SET (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#g","title":"g","text":"<ul> <li>Gate (cowboys)</li> <li>GraphLayer (cowboys)</li> <li>GreaterThan (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#h","title":"h","text":"<ul> <li>HEADER_END (cowboys)</li> <li>HEADER_SEP (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#i","title":"i","text":"<ul> <li>INPUT_SIZE (cowboys)</li> <li>InnerFunction (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#l","title":"l","text":"<ul> <li>LAYERS_BACK (cowboys)</li> <li>LISTSIZE (cowboys)</li> <li>LessThan (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#m","title":"m","text":"<ul> <li>Max (cowboys)</li> <li>Min (cowboys)</li> <li>MAX_CHAR (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#n","title":"n","text":"<ul> <li>NODE_FUNCTION_SET (cowboys)</li> <li>NODE_GENE_SEP (cowboys)</li> <li>NODE_SEP (cowboys)</li> <li>NUM_LAYERS (cowboys)</li> <li>NUM_NODES_PER_LAYER (cowboys)</li> <li>NegClamp (cowboys)</li> <li>NegSum (cowboys)</li> <li>Not (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#p","title":"p","text":"<ul> <li>PosClamp (cowboys)</li> <li>Product (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#r","title":"r","text":"<ul> <li>Reciprocal (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#s","title":"s","text":"<ul> <li>SENSOR_FUNCTION_SET (cowboys)</li> <li>SensorDirection (cowboys)</li> <li>Sin (cowboys)</li> <li>Sqrt (cowboys)</li> <li>Square (cowboys)</li> <li>Sum (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#t","title":"t","text":"<ul> <li>TRAINING_SEED (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#u","title":"u","text":"<ul> <li>ULLToB64 (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_members/#w","title":"w","text":"<ul> <li>WALL (cowboys)</li> <li>WallDistanceDown (cowboys)</li> <li>WallDistanceLeft (cowboys)</li> <li>WallDistanceRight (cowboys)</li> <li>WallDistanceUp (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#a","title":"a","text":"<ul> <li>AStarDistance (cowboys)</li> <li>And (cowboys)</li> <li>AnyEq (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#b","title":"b","text":"<ul> <li>B2ToB64 (cowboys::base64)</li> <li>B64ToB2 (cowboys::base64)</li> <li>B64ToDouble (cowboys::base64)</li> <li>B64ToULL (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#c","title":"c","text":"<ul> <li>Cos (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#d","title":"d","text":"<ul> <li>DoubleToB64 (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#e","title":"e","text":"<ul> <li>EncodeActions (cowboys)</li> <li>EncodeState (cowboys)</li> <li>Exp (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#g","title":"g","text":"<ul> <li>Gate (cowboys)</li> <li>GreaterThan (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#l","title":"l","text":"<ul> <li>LessThan (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#m","title":"m","text":"<ul> <li>Max (cowboys)</li> <li>Min (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#n","title":"n","text":"<ul> <li>NegClamp (cowboys)</li> <li>NegSum (cowboys)</li> <li>Not (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#p","title":"p","text":"<ul> <li>PosClamp (cowboys)</li> <li>Product (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#r","title":"r","text":"<ul> <li>Reciprocal (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#s","title":"s","text":"<ul> <li>Sin (cowboys)</li> <li>Sqrt (cowboys)</li> <li>Square (cowboys)</li> <li>Sum (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#u","title":"u","text":"<ul> <li>ULLToB64 (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_functions/#w","title":"w","text":"<ul> <li>WallDistanceDown (cowboys)</li> <li>WallDistanceLeft (cowboys)</li> <li>WallDistanceRight (cowboys)</li> <li>WallDistanceUp (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#c","title":"c","text":"<ul> <li>CHARS (cowboys::base64)</li> <li>CHAR_TO_IDX (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#f","title":"f","text":"<ul> <li>FUNCTION_SET (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#h","title":"h","text":"<ul> <li>HEADER_END (cowboys)</li> <li>HEADER_SEP (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#i","title":"i","text":"<ul> <li>INPUT_SIZE (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#l","title":"l","text":"<ul> <li>LAYERS_BACK (cowboys)</li> <li>LISTSIZE (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_CHAR (cowboys::base64)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#n","title":"n","text":"<ul> <li>NODE_FUNCTION_SET (cowboys)</li> <li>NODE_GENE_SEP (cowboys)</li> <li>NODE_SEP (cowboys)</li> <li>NUM_LAYERS (cowboys)</li> <li>NUM_NODES_PER_LAYER (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#s","title":"s","text":"<ul> <li>SENSOR_FUNCTION_SET (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#t","title":"t","text":"<ul> <li>TRAINING_SEED (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_variables/#w","title":"w","text":"<ul> <li>WALL (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_typedefs/#g","title":"g","text":"<ul> <li>GraphLayer (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>InnerFunction (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/namespace_member_enums/#s","title":"s","text":"<ul> <li>SensorDirection (cowboys)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/macros/","title":"Macros","text":""},{"location":"Genetic%20Programing%20Agents%28Group%207%29/macros/#p","title":"p","text":"<ul> <li>PAR (GraphNode.hpp)</li> </ul>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Genetic%20Programing%20Agents%28Group%207%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cse491 A World that consists only of walls and open cells. <ul> <li>class MazeWorld </li> </ul> </li> <li>namespace cse491_team8 A World that consists of trees, water, and grass cells. <ul> <li>class ManualWorld </li> </ul> </li> <li>namespace group4 <ul> <li>class SecondWorld </li> </ul> </li> <li>namespace group6 A World that consists only of walls and open cells. <ul> <li>class BiomeGenerator </li> <li>class GenerativeWorld </li> </ul> </li> <li>namespace siv <ul> <li>class BasicPerlinNoise </li> <li>namespace perlin_detail </li> </ul> </li> <li>namespace std </li> <li>namespace tao <ul> <li>namespace pegtl </li> </ul> </li> <li>namespace worldlang Namespace for scripting language stuff. <ul> <li>class ProgramExecutor Class that manages program execution. <ul> <li>struct Identifier </li> </ul> </li> <li>struct Unit </li> <li>struct add </li> <li>struct add_a </li> <li>struct assignment </li> <li>struct code_block </li> <li>struct comment </li> <li>struct comp </li> <li>struct comp_a </li> <li>struct element </li> <li>struct expression </li> <li>struct expression_list </li> <li>struct function </li> <li>struct identifier </li> <li>struct identifier_list </li> <li>struct mul </li> <li>struct mul_a </li> <li>struct number </li> <li>struct op_prio_add </li> <li>struct op_prio_comp </li> <li>struct op_prio_mul </li> <li>struct program </li> <li>struct statement </li> <li>struct statement_list </li> <li>struct string </li> </ul> </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Worlds <ul> <li>file BiomeGenerator.cpp </li> <li>file BiomeGenerator.hpp </li> <li>file GenerativeWorld.hpp </li> <li>file Language.hpp </li> <li>file ManualWorld.hpp </li> <li>file MazeWorld.hpp </li> <li>file PerlinNoise.hpp </li> <li>file ProgramExecutor.hpp </li> <li>file SecondWorld.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>A World that consists only of walls and open cells. More...</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491/#classes","title":"Classes","text":"Type Name class MazeWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/MazeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/","title":"Class cse491::MazeWorld","text":"<p>ClassList &gt; cse491 &gt; MazeWorld</p> <p>Inherits the following classes: WorldBase</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#public-functions","title":"Public Functions","text":"Type Name void ConfigAgent (AgentBase &amp; agent) override const void ConfigAgent (AgentBase &amp; agent) override int DoAction (AgentBase &amp; agent, size_t action_id) overrideAllow the agents to move around the maze. bool IsTraversable (const AgentBase &amp;, cse491::GridPosition pos) override const MazeWorld (unsigned int seed=0)  ~MazeWorld () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#protected-types","title":"Protected Types","text":"Type Name enum ActionType"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t floor_id Easy access to floor CellType ID. size_t wall_id Easy access to wall CellType ID."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-configagent-12","title":"function ConfigAgent [1/2]","text":"<pre><code>inline void cse491::MazeWorld::ConfigAgent (\n    AgentBase &amp; agent\n) override const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-configagent-22","title":"function ConfigAgent [2/2]","text":"<pre><code>inline void cse491::MazeWorld::ConfigAgent (\n    AgentBase &amp; agent\n) override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-doaction","title":"function DoAction","text":"<pre><code>inline int cse491::MazeWorld::DoAction (\n    AgentBase &amp; agent,\n    size_t action_id\n) override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-istraversable","title":"function IsTraversable","text":"<pre><code>inline bool cse491::MazeWorld::IsTraversable (\n    const AgentBase &amp;,\n    cse491::GridPosition pos\n) override const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-mazeworld","title":"function MazeWorld","text":"<pre><code>inline cse491::MazeWorld::MazeWorld (\n    unsigned int seed=0\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#function-mazeworld_1","title":"function ~MazeWorld","text":"<pre><code>cse491::MazeWorld::~MazeWorld () = default\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#enum-actiontype","title":"enum ActionType","text":"<pre><code>enum cse491::MazeWorld::ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    MOVE_ARBITRARY\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#variable-floor_id","title":"variable floor_id","text":"<pre><code>size_t floor_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491_1_1_maze_world/#variable-wall_id","title":"variable wall_id","text":"<pre><code>size_t wall_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/MazeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491__team8/","title":"Namespace cse491_team8","text":"<p>Namespace List &gt; cse491_team8</p> <p>A World that consists of trees, water, and grass cells. More...</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491__team8/#classes","title":"Classes","text":"Type Name class ManualWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacecse491__team8/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p> <p>Author:</p> <p>Evan Orvis </p> <p>Author:</p> <p>Grant Carr </p> <p>Author:</p> <p>Lauren Garvey </p> <p>Author:</p> <p>Nate Gu REVIEW UPDATES * Many functions that used to take item or agent pointers now take references! </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/ManualWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/","title":"Class cse491_team8::ManualWorld","text":"<p>ClassList &gt; cse491_team8 &gt; ManualWorld</p> <p>Inherits the following classes: WorldBase</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#public-functions","title":"Public Functions","text":"Type Name void AddMove (cse491::AgentBase &amp; agent, std::string &amp; move, char stat, double modification) adds a move to the move set for an agent int DoAction (cse491::AgentBase &amp; agent, size_t action_id) overrideCentral function for an agent to take any action. void DoActionAttemptItemPickup (cse491::AgentBase &amp; agent, const cse491::GridPosition &amp; new_position) Attempt to pick up an item for the agent. cse491::GridPosition DoActionFindNewPosition (cse491::AgentBase &amp; agent, size_t action_id) Updates agent's position and direction. void DoActionTestNewPositionTree (cse491::AgentBase &amp; agent, const cse491::GridPosition &amp; new_position) Attempt to interact with a tree If the agent can interact with the tree, prompts the user if they want to use one of their chops. bool DoActionTestNewPositionWater (cse491::AgentBase &amp; agent) Attempt to float on a water tile If the agent has a boat, prompts the user if they want to use the boat once. void DoBattle (cse491::AgentBase &amp; other_agent, cse491::AgentBase &amp; agent, char attack_type) Checks the strength between two agents. void DropItems (cse491::AgentBase &amp; agent, cse491::AgentBase &amp; other_agent) Removes all items from other agent. size_t FindItem (cse491::AgentBase &amp; agent, const std::string &amp; item_name) Check if an agent owns an item. void GenerateMoveSets () Generates move sets for all the agents Sets the move sets as a property for each agent. void HealAction (cse491::AgentBase &amp; agent) Heals an Agent. bool IsTraversable (const cse491::AgentBase &amp;, cse491::GridPosition pos) override constDetermine if this tile can be walked on, defaults to every tile is walkable. cse491::GridPosition LookAhead (cse491::AgentBase &amp; agent) looks one tile ahead of the agent based on facing direction ManualWorld ()  void MoveSetAction (cse491::AgentBase &amp; agent) Displays the moveset for the agent. int OtherAction (cse491::AgentBase &amp; other_agent, cse491::AgentBase &amp; agent) Determines the damage of the other agent. bool RemoveMove (cse491::AgentBase &amp; agent, std::string &amp; move) removes a move from the move set for an agent void Run () overrideRuns agents, updates the world. void RunAgents () overrideStep through each agent giving them a chance to take an action. void StatsAction (cse491::AgentBase &amp; agent) Displays the items and properties that the player has. void UpdateWorld () overrideLooks for adjacencies. ~ManualWorld () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-types","title":"Protected Types","text":"Type Name enum ActionType enum FacingDirection"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t bridge_id Easy access to bridge CellType ID. size_t grass_id Easy access to floor CellType ID. size_t portal_id_a Easy access to first portal CellType ID. size_t portal_id_b Easy access to second portal CellType ID. size_t portal_id_c Easy access to third portal CellType ID. size_t portal_id_d Easy access to fourth portal CellType ID. size_t rock_id Easy access to rock CellType ID. size_t tree_id Easy access to tree CellType ID. size_t water_id Easy access to water CellType ID."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-functions","title":"Protected Functions","text":"Type Name void ConfigAgent (cse491::AgentBase &amp; agent) overrideProvide the agent with movement actions."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-addmove","title":"function AddMove","text":"<p>adds a move to the move set for an agent </p> <pre><code>inline void cse491_team8::ManualWorld::AddMove (\n    cse491::AgentBase &amp; agent,\n    std::string &amp; move,\n    char stat,\n    double modification\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> the agent to add the move to </li> <li><code>move</code> the name of the move to add </li> <li><code>stat</code> the stat that the move affects </li> <li><code>modification</code> the modification percent of the move to that stat Adds a move to the move set map </li> </ul> <p>Returns:</p> <p>None </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doaction","title":"function DoAction","text":"<p>Central function for an agent to take any action. </p> <pre><code>inline int cse491_team8::ManualWorld::DoAction (\n    cse491::AgentBase &amp; agent,\n    size_t action_id\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The specific agent taking the action </li> <li><code>action</code> The id of the action to take </li> </ul> <p>Returns:</p> <p>The result of this action (usually 0/1 to indicate success) </p> <p>Note:</p> <p>Thus function must be overridden in any derived world. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doactionattemptitempickup","title":"function DoActionAttemptItemPickup","text":"<p>Attempt to pick up an item for the agent. </p> <pre><code>inline void cse491_team8::ManualWorld::DoActionAttemptItemPickup (\n    cse491::AgentBase &amp; agent,\n    const cse491::GridPosition &amp; new_position\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that is picking up the item. </li> <li><code>new_position</code> New position of the agent to check if an item is there. </li> </ul> <p>Returns:</p> <p>Nothing </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doactionfindnewposition","title":"function DoActionFindNewPosition","text":"<p>Updates agent's position and direction. </p> <pre><code>inline cse491::GridPosition cse491_team8::ManualWorld::DoActionFindNewPosition (\n    cse491::AgentBase &amp; agent,\n    size_t action_id\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent that is moving its position </li> <li><code>action_id</code> A size_t representing the direction the agent moved </li> </ul> <p>Returns:</p> <p>The agent's new position </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doactiontestnewpositiontree","title":"function DoActionTestNewPositionTree","text":"<p>Attempt to interact with a tree If the agent can interact with the tree, prompts the user if they want to use one of their chops. </p> <pre><code>inline void cse491_team8::ManualWorld::DoActionTestNewPositionTree (\n    cse491::AgentBase &amp; agent,\n    const cse491::GridPosition &amp; new_position\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent trying to interact </li> <li><code>new_position</code> The position being interacted with </li> </ul> <p>Returns:</p> <p>Nothing, the tree gets chopped if possible but the agent doesn't move </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-doactiontestnewpositionwater","title":"function DoActionTestNewPositionWater","text":"<p>Attempt to float on a water tile If the agent has a boat, prompts the user if they want to use the boat once. </p> <pre><code>inline bool cse491_team8::ManualWorld::DoActionTestNewPositionWater (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent trying to interact </li> </ul> <p>Returns:</p> <p>True if the agent is able to (and chooses) to move to the new spot, else false </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-dobattle","title":"function DoBattle","text":"<p>Checks the strength between two agents. </p> <pre><code>inline void cse491_team8::ManualWorld::DoBattle (\n    cse491::AgentBase &amp; other_agent,\n    cse491::AgentBase &amp; agent,\n    char attack_type\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other_agent</code> The autonomous agent to compare </li> <li><code>agent</code> The interface (player) agent to compare </li> <li><code>attack_type</code> The attack that is being used by the player Prints the stronger agent and removes the weaker </li> </ul> <p>See also: RemoveAgent </p> <p>Returns:</p> <p>None </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-dropitems","title":"function DropItems","text":"<p>Removes all items from other agent. </p> <pre><code>inline void cse491_team8::ManualWorld::DropItems (\n    cse491::AgentBase &amp; agent,\n    cse491::AgentBase &amp; other_agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> Agent that won the battle </li> <li><code>other_agent</code> Agent that is dropping items </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-finditem","title":"function FindItem","text":"<p>Check if an agent owns an item. </p> <pre><code>inline size_t cse491_team8::ManualWorld::FindItem (\n    cse491::AgentBase &amp; agent,\n    const std::string &amp; item_name\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The agent to see if is an owner </li> <li><code>item_name</code> Name of the item </li> </ul> <p>Returns:</p> <p>item_id </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-generatemovesets","title":"function GenerateMoveSets","text":"<p>Generates move sets for all the agents Sets the move sets as a property for each agent. </p> <pre><code>inline void cse491_team8::ManualWorld::GenerateMoveSets () \n</code></pre> <p>Returns:</p> <p>None </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-healaction","title":"function HealAction","text":"<p>Heals an Agent. </p> <pre><code>inline void cse491_team8::ManualWorld::HealAction (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> The Agent getting healed Calculates the healing of the agent </li> </ul> <p>Returns:</p> <p>None </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-istraversable","title":"function IsTraversable","text":"<p>Determine if this tile can be walked on, defaults to every tile is walkable. </p> <pre><code>inline bool cse491_team8::ManualWorld::IsTraversable (\n    const cse491::AgentBase &amp;,\n    cse491::GridPosition pos\n) override const\n</code></pre> <p>Parameters:</p> <ul> <li><code>pos</code> The grid position we are checking </li> </ul> <p>Returns:</p> <p>If an agent should be allowed on this square </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-lookahead","title":"function LookAhead","text":"<p>looks one tile ahead of the agent based on facing direction </p> <pre><code>inline cse491::GridPosition cse491_team8::ManualWorld::LookAhead (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> Agent that is looking ahead </li> </ul> <p>Returns:</p> <p>the grid position </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-manualworld","title":"function ManualWorld","text":"<pre><code>inline cse491_team8::ManualWorld::ManualWorld () \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-movesetaction","title":"function MoveSetAction","text":"<p>Displays the moveset for the agent. </p> <pre><code>inline void cse491_team8::ManualWorld::MoveSetAction (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> Agent moveset being displayed. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-otheraction","title":"function OtherAction","text":"<p>Determines the damage of the other agent. </p> <pre><code>inline int cse491_team8::ManualWorld::OtherAction (\n    cse491::AgentBase &amp; other_agent,\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>other_agent</code> The NPC agent </li> <li><code>agent</code> The player agent Gets the damage of the NPC agent </li> </ul> <p>Returns:</p> <p>The damage of the NPC </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-removemove","title":"function RemoveMove","text":"<p>removes a move from the move set for an agent </p> <pre><code>inline bool cse491_team8::ManualWorld::RemoveMove (\n    cse491::AgentBase &amp; agent,\n    std::string &amp; move\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> the agent to remove a move from </li> <li><code>move</code> the name of the move to remove Removes a move from the move set map </li> </ul> <p>Returns:</p> <p>true for success, false for failure </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-run","title":"function Run","text":"<pre><code>inline void cse491_team8::ManualWorld::Run () override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-runagents","title":"function RunAgents","text":"<pre><code>inline void cse491_team8::ManualWorld::RunAgents () override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-statsaction","title":"function StatsAction","text":"<p>Displays the items and properties that the player has. </p> <pre><code>inline void cse491_team8::ManualWorld::StatsAction (\n    cse491::AgentBase &amp; agent\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>agent</code> Agent stats being showed. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-updateworld","title":"function UpdateWorld","text":"<pre><code>inline void cse491_team8::ManualWorld::UpdateWorld () override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-manualworld_1","title":"function ~ManualWorld","text":"<pre><code>cse491_team8::ManualWorld::~ManualWorld () = default\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#enum-actiontype","title":"enum ActionType","text":"<pre><code>enum cse491_team8::ManualWorld::ActionType {\n    REMAIN_STILL =0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    USE_AXE,\n    USE_BOAT,\n    STATS,\n    HEAL,\n    RUN,\n    ATTACK,\n    SPECIAL,\n    BUFF,\n    HELP\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#enum-facingdirection","title":"enum FacingDirection","text":"<pre><code>enum cse491_team8::ManualWorld::FacingDirection {\n    UP =0,\n    RIGHT,\n    DOWN,\n    LEFT\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-bridge_id","title":"variable bridge_id","text":"<pre><code>size_t bridge_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-grass_id","title":"variable grass_id","text":"<pre><code>size_t grass_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-portal_id_a","title":"variable portal_id_a","text":"<pre><code>size_t portal_id_a;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-portal_id_b","title":"variable portal_id_b","text":"<pre><code>size_t portal_id_b;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-portal_id_c","title":"variable portal_id_c","text":"<pre><code>size_t portal_id_c;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-portal_id_d","title":"variable portal_id_d","text":"<pre><code>size_t portal_id_d;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-rock_id","title":"variable rock_id","text":"<pre><code>size_t rock_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-tree_id","title":"variable tree_id","text":"<pre><code>size_t tree_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#variable-water_id","title":"variable water_id","text":"<pre><code>size_t water_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classcse491__team8_1_1_manual_world/#function-configagent","title":"function ConfigAgent","text":"<pre><code>inline void cse491_team8::ManualWorld::ConfigAgent (\n    cse491::AgentBase &amp; agent\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/ManualWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/","title":"Namespace group4","text":"<p>Namespace List &gt; group4</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#classes","title":"Classes","text":"Type Name class SecondWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#public-attributes","title":"Public Attributes","text":"Type Name const std::string COMBAT_SCRIPT   = = \"../assets/scripts/g4_agent_attack.ws\"Filename for agent combat script. const std::string FINAL_FLOOR_FILENAME   = = \"../assets/grids/third_floor.grid\"Filename for the last floor grid file. const std::string FIRST_FLOOR_FILENAME   = = \"../assets/grids/group4_maze.grid\"Filename for the first floor grid file. const std::string ITEM_PICKUP_SCRIPT   = = \"../assets/scripts/g4_item_pickup.ws\"Filename for item pickup script. const size_t MAX_INVENTORY_SIZE   = = 30Maximum inventory size for an agent. const cse491::GridPosition OffGrid   = = {-1, -1}Off the grid position. const std::string SECOND_FLOOR_FILENAME   = = \"../assets/grids/second_floor.grid\"Filename for the second floor grid file. const std::string WORLD_LOAD_SCRIPT   = = \"../assets/scripts/g4_world_load.ws\"Filename for world initialization script. const std::string WORLD_LOAD_SCRIPT_2   = = \"../assets/scripts/g4_world_2_load.ws\"Filename for second floor initialization script. const std::string WORLD_LOAD_SCRIPT_3   = = \"../assets/scripts/g4_world_3_load.ws\"Filename for final floor initialization script."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-combat_script","title":"variable COMBAT_SCRIPT","text":"<p>Filename for agent combat script. </p> <pre><code>const std::string COMBAT_SCRIPT;\n</code></pre> <p>When an agent attempts to move into another agent, this attack script runs. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-final_floor_filename","title":"variable FINAL_FLOOR_FILENAME","text":"<pre><code>const std::string FINAL_FLOOR_FILENAME;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-first_floor_filename","title":"variable FIRST_FLOOR_FILENAME","text":"<pre><code>const std::string FIRST_FLOOR_FILENAME;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-item_pickup_script","title":"variable ITEM_PICKUP_SCRIPT","text":"<p>Filename for item pickup script. </p> <pre><code>const std::string ITEM_PICKUP_SCRIPT;\n</code></pre> <p>This script modifies properties of the agent collecting the item. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-max_inventory_size","title":"variable MAX_INVENTORY_SIZE","text":"<pre><code>const size_t MAX_INVENTORY_SIZE;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-offgrid","title":"variable OffGrid","text":"<pre><code>const cse491::GridPosition OffGrid;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-second_floor_filename","title":"variable SECOND_FLOOR_FILENAME","text":"<pre><code>const std::string SECOND_FLOOR_FILENAME;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-world_load_script","title":"variable WORLD_LOAD_SCRIPT","text":"<pre><code>const std::string WORLD_LOAD_SCRIPT;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-world_load_script_2","title":"variable WORLD_LOAD_SCRIPT_2","text":"<pre><code>const std::string WORLD_LOAD_SCRIPT_2;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup4/#variable-world_load_script_3","title":"variable WORLD_LOAD_SCRIPT_3","text":"<pre><code>const std::string WORLD_LOAD_SCRIPT_3;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/SecondWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/","title":"Class group4::SecondWorld","text":"<p>ClassList &gt; group4 &gt; SecondWorld</p> <p>More...</p> <ul> <li><code>#include &lt;SecondWorld.hpp&gt;</code></li> </ul> <p>Inherits the following classes: WorldBase</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#public-functions","title":"Public Functions","text":"Type Name bool CheckPosition (cse491::AgentBase &amp; agent, cse491::GridPosition &amp; pos)  int DoAction (cse491::AgentBase &amp; agent, size_t action_id) override void DropItem (cse491::AgentBase &amp; agent, cse491::GridPosition &amp; pos)  bool IsTraversable (const AgentBase &amp; agent, cse491::GridPosition pos) override const void LoadFromFile (const std::string &amp; input_filename)  void PrintEntities ()  virtual void Run () override void SaveToFile ()  SecondWorld ()  SecondWorld (std::string grid_filename, std::string agent_filename)  ~SecondWorld () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-types","title":"Protected Types","text":"Type Name enum ActionType"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-attributes","title":"Protected Attributes","text":"Type Name std::map&lt; size_t, std::unique_ptr&lt; cse491::ItemBase &gt; &gt; inventory Vector of the items in this world. worldlang::ProgramExecutor pe Script executor object."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-functions","title":"Protected Functions","text":"Type Name void ConfigAgent (cse491::AgentBase &amp; agent) overrideProvide the agent with movement actions."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#detailed-description","title":"Detailed Description","text":"<p>Creates a world with agents and a win flag </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-checkposition","title":"function CheckPosition","text":"<pre><code>inline bool group4::SecondWorld::CheckPosition (\n    cse491::AgentBase &amp; agent,\n    cse491::GridPosition &amp; pos\n) \n</code></pre> <p>Checks to see if there is a flag or item at the agent's current position </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent </li> <li><code>pos</code> The position </li> </ul> <p>Returns:</p> <p>true if agent should update position on return </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-doaction","title":"function DoAction","text":"<pre><code>inline int group4::SecondWorld::DoAction (\n    cse491::AgentBase &amp; agent,\n    size_t action_id\n) override\n</code></pre> <p>Allows agents to perform an action and sets each agent's new position </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent performing the action </li> <li><code>action_id</code> The id that represents the move </li> </ul> <p>Returns:</p> <p>An int that declares if the move is legal or illegal (true / false) </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-dropitem","title":"function DropItem","text":"<pre><code>inline void group4::SecondWorld::DropItem (\n    cse491::AgentBase &amp; agent,\n    cse491::GridPosition &amp; pos\n) \n</code></pre> <p>Drops the item in the agent's inventory </p> <p>Parameters:</p> <ul> <li><code>agent</code> This agent's item we're dropping </li> <li><code>pos</code> The position where the item will be dropped </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-istraversable","title":"function IsTraversable","text":"<pre><code>inline bool group4::SecondWorld::IsTraversable (\n    const AgentBase &amp; agent,\n    cse491::GridPosition pos\n) override const\n</code></pre> <p>Can walk on all tiles except for walls and water (unless agent has property set) </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-loadfromfile","title":"function LoadFromFile","text":"<pre><code>inline void group4::SecondWorld::LoadFromFile (\n    const std::string &amp; input_filename\n) \n</code></pre> <p>Loads data from a JSON file and adds agents with specified properties into the world. </p> <p>Parameters:</p> <ul> <li><code>input_filename</code> Relative path to input.json file </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-printentities","title":"function PrintEntities","text":"<pre><code>inline void group4::SecondWorld::PrintEntities () \n</code></pre> <p>Prints the entities in item_set (testing) </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-run","title":"function Run","text":"<pre><code>inline virtual void group4::SecondWorld::Run () override\n</code></pre> <p>This function gives us an output.json file </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-savetofile","title":"function SaveToFile","text":"<pre><code>inline void group4::SecondWorld::SaveToFile () \n</code></pre> <p>This function gives us an output.json file using nlohmann::json library </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-secondworld-12","title":"function SecondWorld [1/2]","text":"<pre><code>inline group4::SecondWorld::SecondWorld () \n</code></pre> <p>Constructor with no arguments </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-secondworld-22","title":"function SecondWorld [2/2]","text":"<pre><code>inline group4::SecondWorld::SecondWorld (\n    std::string grid_filename,\n    std::string agent_filename\n) \n</code></pre> <p>Constructor with grid and agent file names </p> <p>Parameters:</p> <ul> <li><code>grid_filename</code> Relative path to grid file </li> <li><code>agent_filename</code> Relative path to agent input.json file </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-secondworld","title":"function ~SecondWorld","text":"<pre><code>group4::SecondWorld::~SecondWorld () = default\n</code></pre> <p>Destructor </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#enum-actiontype","title":"enum ActionType","text":"<pre><code>enum group4::SecondWorld::ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    DROP_ITEM\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#variable-inventory","title":"variable inventory","text":"<pre><code>std::map&lt;size_t, std::unique_ptr&lt;cse491::ItemBase&gt; &gt; inventory;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#variable-pe","title":"variable pe","text":"<pre><code>worldlang::ProgramExecutor pe;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup4_1_1_second_world/#function-configagent","title":"function ConfigAgent","text":"<pre><code>inline void group4::SecondWorld::ConfigAgent (\n    cse491::AgentBase &amp; agent\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/SecondWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/","title":"Namespace group6","text":"<p>Namespace List &gt; group6</p> <p>A World that consists only of walls and open cells. More...</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#classes","title":"Classes","text":"Type Name class BiomeGenerator class GenerativeWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#public-types","title":"Public Types","text":"Type Name enum BiomeType"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project. </p> <p>Note:</p> <p>Status: PROPOSAL </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacegroup6/#enum-biometype","title":"enum BiomeType","text":"<pre><code>enum group6::BiomeType {\n    Maze,\n    Grasslands,\n    Ocean\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/BiomeGenerator.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/","title":"Class group6::BiomeGenerator","text":"<p>ClassList &gt; group6 &gt; BiomeGenerator</p> <p>More...</p> <ul> <li><code>#include &lt;BiomeGenerator.hpp&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#public-functions","title":"Public Functions","text":"Type Name BiomeGenerator (BiomeType biome, unsigned int width, unsigned int height, unsigned int seed)  void applyPathToGrid (const std::vector&lt; GridPosition &gt; &amp; path)  std::vector&lt; GridPosition &gt; clearPath () const void generate ()  BiomeType getBiome () const unsigned int getSeed () const void oceanHandler ()  void placeDoorTile (const size_t &amp; doorTile)  void placeSpecialTiles (const size_t &amp; genericTile, const size_t &amp; specialTile, double percentage)  void placeTileRandom (const size_t &amp; tile, const size_t &amp; spawnTile)  void placeTrees ()  void saveToFile (const std::string &amp; filename) const void setTiles (const size_t &amp; firstTile, const size_t &amp; secondTile)  void setWorld (WorldBase * world)  ~BiomeGenerator () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#detailed-description","title":"Detailed Description","text":"<p>Generates a new grid based on a specified biome </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-biomegenerator","title":"function BiomeGenerator","text":"<pre><code>group6::BiomeGenerator::BiomeGenerator (\n    BiomeType biome,\n    unsigned int width,\n    unsigned int height,\n    unsigned int seed\n) \n</code></pre> <p>Creates a generator with a grid of the given size and using the given seed </p> <p>Parameters:</p> <ul> <li><code>biome</code> The biome of the grid </li> <li><code>width</code> The width of the grid </li> <li><code>height</code> The height of the grid </li> <li><code>seed</code> The seed used for random number generation </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-applypathtogrid","title":"function applyPathToGrid","text":"<pre><code>void group6::BiomeGenerator::applyPathToGrid (\n    const std::vector&lt; GridPosition &gt; &amp; path\n) \n</code></pre> <p>Clears the walls out of the grid, guaranteeing a path from the left of the grid, to any point on the rightmost side of the map </p> <p>Parameters:</p> <ul> <li><code>path</code> A vector of GridPositions necessary for this path </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-clearpath","title":"function clearPath","text":"<pre><code>std::vector&lt; GridPosition &gt; group6::BiomeGenerator::clearPath () const\n</code></pre> <p>Clears a randomized path from the top left of the grid, to any point on the rightmost side of the map </p> <p>Returns:</p> <p>A vector of GridPositions necessary for this path </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-generate","title":"function generate","text":"<pre><code>void group6::BiomeGenerator::generate () \n</code></pre> <p>Generates the grid with two types of tiles </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-getbiome","title":"function getBiome","text":"<pre><code>inline BiomeType group6::BiomeGenerator::getBiome () const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-getseed","title":"function getSeed","text":"<pre><code>inline unsigned int group6::BiomeGenerator::getSeed () const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-oceanhandler","title":"function oceanHandler","text":"<pre><code>void group6::BiomeGenerator::oceanHandler () \n</code></pre> <p>Handles logic for Ocean biome </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-placedoortile","title":"function placeDoorTile","text":"<pre><code>void group6::BiomeGenerator::placeDoorTile (\n    const size_t &amp; doorTile\n) \n</code></pre> <p>Generates door tile on grid at [1][1] </p> <p>Parameters:</p> <ul> <li><code>doorTile</code> Door Tile </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-placespecialtiles","title":"function placeSpecialTiles","text":"<pre><code>void group6::BiomeGenerator::placeSpecialTiles (\n    const size_t &amp; genericTile,\n    const size_t &amp; specialTile,\n    double percentage\n) \n</code></pre> <p>Generates special tiles on the grid </p> <p>Parameters:</p> <ul> <li><code>genericTile</code> The tile that the special tile can spawn on </li> <li><code>specialTile</code> The special tile to generate </li> <li><code>percentage</code> Chance of special tile generating on the generic tile </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-placetilerandom","title":"function placeTileRandom","text":"<pre><code>void group6::BiomeGenerator::placeTileRandom (\n    const size_t &amp; tile,\n    const size_t &amp; spawnTile\n) \n</code></pre> <p>Generates random coordinates to place the given tile</p> <p>Parameters:</p> <ul> <li><code>tile</code> The tile being placed </li> <li><code>spawnTile</code> The type of tile allowed to be replaced </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-placetrees","title":"function placeTrees","text":"<pre><code>void group6::BiomeGenerator::placeTrees () \n</code></pre> <p>Places trees on the grid </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-savetofile","title":"function saveToFile","text":"<pre><code>void group6::BiomeGenerator::saveToFile (\n    const std::string &amp; filename\n) const\n</code></pre> <p>Saves the grid to the given filepath </p> <p>Parameters:</p> <ul> <li><code>filename</code> The filename the grid will be saved to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-settiles","title":"function setTiles","text":"<pre><code>void group6::BiomeGenerator::setTiles (\n    const size_t &amp; firstTile,\n    const size_t &amp; secondTile\n) \n</code></pre> <p>Sets the tile vector for the biome </p> <p>Parameters:</p> <ul> <li><code>firstTile</code> Tile #1 for the biome </li> <li><code>secondTile</code> Tile #2 for the biome </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-setworld","title":"function setWorld","text":"<pre><code>void group6::BiomeGenerator::setWorld (\n    WorldBase * world\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_biome_generator/#function-biomegenerator_1","title":"function ~BiomeGenerator","text":"<pre><code>group6::BiomeGenerator::~BiomeGenerator () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/BiomeGenerator.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/","title":"Class group6::GenerativeWorld","text":"<p>ClassList &gt; group6 &gt; GenerativeWorld</p> <p>Inherits the following classes: WorldBase</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#public-functions","title":"Public Functions","text":"Type Name void AStarAgentHelper (AgentBase &amp; agent)  void AddArmory ()  void AddTeleporters ()  void AgentCollisionHelper (AgentBase &amp; agent)  void ArmoryTileHelper (AgentBase &amp; agent)  int DoAction (AgentBase &amp; agent, size_t action_id) override void DoorTileHelper (AgentBase &amp; agent)  void EndGame (bool win)  GenerativeWorld (BiomeType biome, unsigned int width, unsigned int height, unsigned int seed)  void HoleTileHelper (AgentBase &amp; agent, GridPosition &amp; new_position)  bool IsTraversable (const AgentBase &amp;, cse491::GridPosition pos) override const void ItemHelper (AgentBase &amp; agent, GridPosition &amp; new_position)  void KeyTileHelper (AgentBase &amp; agent, GridPosition &amp; new_position)  void SpikeTileHelper (AgentBase &amp; agent)  void TarTileHelper (AgentBase &amp; agent)  void TeleporterHelper (GridPosition &amp; new_position)  ~GenerativeWorld () override"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#public-static-functions","title":"Public Static Functions","text":"Type Name vector&lt; GridPosition &gt; FindTiles (WorldGrid grid, size_t tile_id)"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-types","title":"Protected Types","text":"Type Name enum ActionType"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t armory_id Easy access to armory CellTypeID. size_t dirt_id Easy access to dirt CellTypeID. size_t door_id Easy access to door CellTypeID. size_t floor_id Easy access to floor CellType ID. size_t grass_id Easy access to grass CellTypeID. size_t hole_id Easy access to hole CellTypeID. size_t key_id Easy access to key CellTypeID. size_t sand_id Easy access to sand CellTypeID. size_t spike_id Easy access to spike CellType ID. size_t tar_id Easy access to tar CellTypeID. size_t teleporter_id Easy access to teleporter CellTypeId. size_t tree_id Easy access to tree CellTypeID. size_t wall_id Easy access to wall CellType ID. size_t water_id Easy access to water CellTypeID. unsigned int world_height unsigned int world_width"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-functions","title":"Protected Functions","text":"Type Name void ConfigAgent (AgentBase &amp; agent) override void CreateGrid (BiomeType biome, unsigned int width, unsigned int height, unsigned int seed, const string &amp; file)  void DamageAgent (AgentBase &amp; agent)"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-astaragenthelper","title":"function AStarAgentHelper","text":"<pre><code>inline void group6::GenerativeWorld::AStarAgentHelper (\n    AgentBase &amp; agent\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-addarmory","title":"function AddArmory","text":"<pre><code>inline void group6::GenerativeWorld::AddArmory () \n</code></pre> <p>Adds armory tiles to grid </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-addteleporters","title":"function AddTeleporters","text":"<pre><code>inline void group6::GenerativeWorld::AddTeleporters () \n</code></pre> <p>Adds teleporters to map </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-agentcollisionhelper","title":"function AgentCollisionHelper","text":"<pre><code>inline void group6::GenerativeWorld::AgentCollisionHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Collision testing functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-armorytilehelper","title":"function ArmoryTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::ArmoryTileHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Helper function for armory functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-doaction","title":"function DoAction","text":"<pre><code>inline int group6::GenerativeWorld::DoAction (\n    AgentBase &amp; agent,\n    size_t action_id\n) override\n</code></pre> <p>Handles logic for agent movement </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent attempting to do an action </li> <li><code>action_id</code> The action being performed </li> </ul> <p>Returns:</p> <p>1 if the action was successful. 0 if it was not </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-doortilehelper","title":"function DoorTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::DoorTileHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Helper function for door tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-endgame","title":"function EndGame","text":"<pre><code>inline void group6::GenerativeWorld::EndGame (\n    bool win\n) \n</code></pre> <p>Ends the game </p> <p>Parameters:</p> <ul> <li><code>win</code> True if the game is ending in a win. False if it is a loss </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-generativeworld","title":"function GenerativeWorld","text":"<pre><code>inline explicit group6::GenerativeWorld::GenerativeWorld (\n    BiomeType biome,\n    unsigned int width,\n    unsigned int height,\n    unsigned int seed\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-holetilehelper","title":"function HoleTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::HoleTileHelper (\n    AgentBase &amp; agent,\n    GridPosition &amp; new_position\n) \n</code></pre> <p>Helper function for hole tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>new_position</code> new position agent is moving to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-istraversable","title":"function IsTraversable","text":"<pre><code>inline bool group6::GenerativeWorld::IsTraversable (\n    const AgentBase &amp;,\n    cse491::GridPosition pos\n) override const\n</code></pre> <p>Boolean function for traversable tiles in maze </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>pos</code> position of tile </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-itemhelper","title":"function ItemHelper","text":"<pre><code>inline void group6::GenerativeWorld::ItemHelper (\n    AgentBase &amp; agent,\n    GridPosition &amp; new_position\n) \n</code></pre> <p>Helper function for item pickup functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>new_position</code> new position agent is moving to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-keytilehelper","title":"function KeyTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::KeyTileHelper (\n    AgentBase &amp; agent,\n    GridPosition &amp; new_position\n) \n</code></pre> <p>Helper function for key tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>new_position</code> new position agent is moving to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-spiketilehelper","title":"function SpikeTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::SpikeTileHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Helper function for spike tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-tartilehelper","title":"function TarTileHelper","text":"<pre><code>inline void group6::GenerativeWorld::TarTileHelper (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Helper function for tar tile functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-teleporterhelper","title":"function TeleporterHelper","text":"<pre><code>inline void group6::GenerativeWorld::TeleporterHelper (\n    GridPosition &amp; new_position\n) \n</code></pre> <p>Helper function for armory functionality </p> <p>Parameters:</p> <ul> <li><code>agent</code> agent performing action </li> <li><code>new_position</code> new position agent is moving to </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-generativeworld_1","title":"function ~GenerativeWorld","text":"<pre><code>group6::GenerativeWorld::~GenerativeWorld () override\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-findtiles","title":"function FindTiles","text":"<pre><code>static inline vector&lt; GridPosition &gt; group6::GenerativeWorld::FindTiles (\n    WorldGrid grid,\n    size_t tile_id\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#enum-actiontype","title":"enum ActionType","text":"<pre><code>enum group6::GenerativeWorld::ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT\n};\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-armory_id","title":"variable armory_id","text":"<pre><code>size_t armory_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-dirt_id","title":"variable dirt_id","text":"<pre><code>size_t dirt_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-door_id","title":"variable door_id","text":"<pre><code>size_t door_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-floor_id","title":"variable floor_id","text":"<pre><code>size_t floor_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-grass_id","title":"variable grass_id","text":"<pre><code>size_t grass_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-hole_id","title":"variable hole_id","text":"<pre><code>size_t hole_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-key_id","title":"variable key_id","text":"<pre><code>size_t key_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-sand_id","title":"variable sand_id","text":"<pre><code>size_t sand_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-spike_id","title":"variable spike_id","text":"<pre><code>size_t spike_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-tar_id","title":"variable tar_id","text":"<pre><code>size_t tar_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-teleporter_id","title":"variable teleporter_id","text":"<pre><code>size_t teleporter_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-tree_id","title":"variable tree_id","text":"<pre><code>size_t tree_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-wall_id","title":"variable wall_id","text":"<pre><code>size_t wall_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-water_id","title":"variable water_id","text":"<pre><code>size_t water_id;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-world_height","title":"variable world_height","text":"<pre><code>unsigned int world_height;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#variable-world_width","title":"variable world_width","text":"<pre><code>unsigned int world_width;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-configagent","title":"function ConfigAgent","text":"<pre><code>inline void group6::GenerativeWorld::ConfigAgent (\n    AgentBase &amp; agent\n) override\n</code></pre> <p>Provide the agent with movement actions. </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent being configured </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-creategrid","title":"function CreateGrid","text":"<pre><code>inline void group6::GenerativeWorld::CreateGrid (\n    BiomeType biome,\n    unsigned int width,\n    unsigned int height,\n    unsigned int seed,\n    const string &amp; file\n) \n</code></pre> <p>Creates a new grid with the given parameters</p> <p>Parameters:</p> <ul> <li><code>biome</code> The BiomeType being used </li> <li><code>width</code> The width of the grid </li> <li><code>height</code> The height of the grid </li> <li><code>seed</code> The seed used for random generation </li> <li><code>file</code> The file to save the grid to. Full path is \"../assets/grids/generated_[file].grid\" </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classgroup6_1_1_generative_world/#function-damageagent","title":"function DamageAgent","text":"<pre><code>inline void group6::GenerativeWorld::DamageAgent (\n    AgentBase &amp; agent\n) \n</code></pre> <p>Ends game if agent is the player </p> <p>Parameters:</p> <ul> <li><code>agent</code> The agent being damaged </li> </ul> <p>The documentation for this class was generated from the following file <code>source/Worlds/GenerativeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/","title":"Namespace siv","text":"<p>Namespace List &gt; siv</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#namespaces","title":"Namespaces","text":"Type Name namespace perlin_detail"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#classes","title":"Classes","text":"Type Name class BasicPerlinNoise &lt;class Float&gt;"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#public-types","title":"Public Types","text":"Type Name typedef BasicPerlinNoise&lt; double &gt; PerlinNoise"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv/#typedef-perlinnoise","title":"typedef PerlinNoise","text":"<pre><code>using PerlinNoise =  BasicPerlinNoise&lt;double&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/PerlinNoise.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/","title":"Class siv::BasicPerlinNoise","text":"<p>template &lt;class Float class Float&gt;</p> <p>ClassList &gt; siv &gt; BasicPerlinNoise</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#public-types","title":"Public Types","text":"Type Name typedef std::mt19937 default_random_engine typedef typename default_random_engine::result_type seed_type typedef std::array&lt; std::uint8_t, 256 &gt; state_type typedef Float value_type"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#public-functions","title":"Public Functions","text":"Type Name SIVPERLIN_NODISCARD_CXX20 constexpr BasicPerlinNoise () noexcept SIVPERLIN_NODISCARD_CXX20 BasicPerlinNoise (seed_type seed)  SIVPERLIN_CONCEPT_URBG SIVPERLIN_NODISCARD_CXX20 BasicPerlinNoise (URBG &amp;&amp; urbg)  constexpr void deserialize (const state_type &amp; state) noexcept value_type noise1D (value_type x) noexcept const value_type noise1D_01 (value_type x) noexcept const value_type noise2D (value_type x, value_type y) noexcept const value_type noise2D_01 (value_type x, value_type y) noexcept const value_type noise3D (value_type x, value_type y, value_type z) noexcept const value_type noise3D_01 (value_type x, value_type y, value_type z) noexcept const value_type normalizedOctave1D (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave1D_01 (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave2D (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave2D_01 (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave3D (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type normalizedOctave3D_01 (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave1D (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave1D_01 (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave1D_11 (value_type x, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave2D (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave2D_01 (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave2D_11 (value_type x, value_type y, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave3D (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave3D_01 (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const value_type octave3D_11 (value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence=value_type(0.5)) noexcept const void reseed (seed_type seed)  SIVPERLIN_CONCEPT_URBG void reseed (URBG &amp;&amp; urbg)  constexpr const state_type &amp; serialize () noexcept const"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#typedef-default_random_engine","title":"typedef default_random_engine","text":"<pre><code>using default_random_engine =  std::mt19937;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#typedef-seed_type","title":"typedef seed_type","text":"<pre><code>using seed_type =  typename default_random_engine::result_type;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#typedef-state_type","title":"typedef state_type","text":"<pre><code>using state_type =  std::array&lt;std::uint8_t, 256&gt;;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using value_type =  Float;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-basicperlinnoise-13","title":"function BasicPerlinNoise [1/3]","text":"<pre><code>inline SIVPERLIN_NODISCARD_CXX20 constexpr siv::BasicPerlinNoise::BasicPerlinNoise () noexcept\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-basicperlinnoise-23","title":"function BasicPerlinNoise [2/3]","text":"<pre><code>inline explicit SIVPERLIN_NODISCARD_CXX20 siv::BasicPerlinNoise::BasicPerlinNoise (\n    seed_type seed\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-basicperlinnoise-33","title":"function BasicPerlinNoise [3/3]","text":"<pre><code>inline explicit SIVPERLIN_CONCEPT_URBG SIVPERLIN_NODISCARD_CXX20 siv::BasicPerlinNoise::BasicPerlinNoise (\n    URBG &amp;&amp; urbg\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-deserialize","title":"function deserialize","text":"<pre><code>inline constexpr void siv::BasicPerlinNoise::deserialize (\n    const state_type &amp; state\n) noexcept\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise1d","title":"function noise1D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise1D (\n    value_type x\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise1d_01","title":"function noise1D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise1D_01 (\n    value_type x\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise2d","title":"function noise2D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise2D (\n    value_type x,\n    value_type y\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise2d_01","title":"function noise2D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise2D_01 (\n    value_type x,\n    value_type y\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise3d","title":"function noise3D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise3D (\n    value_type x,\n    value_type y,\n    value_type z\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-noise3d_01","title":"function noise3D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::noise3D_01 (\n    value_type x,\n    value_type y,\n    value_type z\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave1d","title":"function normalizedOctave1D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave1D (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave1d_01","title":"function normalizedOctave1D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave1D_01 (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave2d","title":"function normalizedOctave2D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave2D (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave2d_01","title":"function normalizedOctave2D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave2D_01 (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave3d","title":"function normalizedOctave3D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave3D (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-normalizedoctave3d_01","title":"function normalizedOctave3D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::normalizedOctave3D_01 (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave1d","title":"function octave1D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave1D (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave1d_01","title":"function octave1D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave1D_01 (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave1d_11","title":"function octave1D_11","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave1D_11 (\n    value_type x,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave2d","title":"function octave2D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave2D (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave2d_01","title":"function octave2D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave2D_01 (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave2d_11","title":"function octave2D_11","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave2D_11 (\n    value_type x,\n    value_type y,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave3d","title":"function octave3D","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave3D (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave3d_01","title":"function octave3D_01","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave3D_01 (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-octave3d_11","title":"function octave3D_11","text":"<pre><code>inline value_type siv::BasicPerlinNoise::octave3D_11 (\n    value_type x,\n    value_type y,\n    value_type z,\n    std::int32_t octaves,\n    value_type persistence=value_type(0.5)\n) noexcept const\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-reseed-12","title":"function reseed [1/2]","text":"<pre><code>inline void siv::BasicPerlinNoise::reseed (\n    seed_type seed\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-reseed-22","title":"function reseed [2/2]","text":"<pre><code>inline SIVPERLIN_CONCEPT_URBG void siv::BasicPerlinNoise::reseed (\n    URBG &amp;&amp; urbg\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classsiv_1_1_basic_perlin_noise/#function-serialize","title":"function serialize","text":"<pre><code>inline constexpr const state_type &amp; siv::BasicPerlinNoise::serialize () noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/PerlinNoise.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacesiv_1_1perlin__detail/","title":"Namespace siv::perlin_detail","text":"<p>Namespace List &gt; siv &gt; perlin_detail</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/PerlinNoise.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacetao/","title":"Namespace tao","text":"<p>Namespace List &gt; tao</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacetao/#namespaces","title":"Namespaces","text":"Type Name namespace pegtl <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespacetao_1_1pegtl/","title":"Namespace tao::pegtl","text":"<p>Namespace List &gt; tao &gt; pegtl</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/","title":"Namespace worldlang","text":"<p>Namespace List &gt; worldlang</p> <p>Namespace for scripting language stuff. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#classes","title":"Classes","text":"Type Name class ProgramExecutor Class that manages program execution. struct Unit struct add struct add_a struct assignment struct code_block struct comment struct comp struct comp_a struct element struct expression struct expression_list struct function struct identifier struct identifier_list struct mul struct mul_a struct number struct op_prio_add struct op_prio_comp struct op_prio_mul struct program struct statement struct statement_list struct string"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#public-types","title":"Public Types","text":"Type Name typedef tao::pegtl::parse_tree::selector&lt; Rule, tao::pegtl::parse_tree::store_content::on&lt; number, string, function, identifier, identifier_list, expression, expression_list, statement, statement_list, code_block, program, assignment, op_prio_add, op_prio_mul, op_prio_comp &gt;, tao::pegtl::parse_tree::fold_one::on&lt; add_a, mul_a &gt; &gt; selector"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; Unit &gt; parse_to_code (std::string program)  std::string stripWhitespace (const std::string &amp; input)"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#typedef-selector","title":"typedef selector","text":"<pre><code>using selector =  tao::pegtl::parse_tree::selector&lt; Rule, tao::pegtl::parse_tree::store_content::on&lt; number, string, function, identifier, identifier_list, expression, expression_list, statement, statement_list, code_block, program, assignment, op_prio_add, op_prio_mul, op_prio_comp &gt;, tao::pegtl::parse_tree::fold_one::on&lt; add_a, mul_a &gt; &gt;;\n</code></pre> <p>Selector for tree generation This is used by PEGTL's parse_tree function to determine which nodes are kept, which are folded into their parent when possible, and which are ignored (these are not listed here). </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#function-parse_to_code","title":"function parse_to_code","text":"<pre><code>std::vector&lt; Unit &gt; worldlang::parse_to_code (\n    std::string program\n) \n</code></pre> <p>Converts a program string into code units using PEGTL </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaceworldlang/#function-stripwhitespace","title":"function stripWhitespace","text":"<pre><code>std::string worldlang::stripWhitespace (\n    const std::string &amp; input\n) \n</code></pre> <p>function to strip whitespace </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/","title":"Class worldlang::ProgramExecutor","text":"<p>ClassList &gt; worldlang &gt; ProgramExecutor</p> <p>Class that manages program execution. More...</p> <ul> <li><code>#include &lt;ProgramExecutor.hpp&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#classes","title":"Classes","text":"Type Name struct Identifier"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; void(ProgramExecutor &amp;)&gt; Callable typedef std::variant&lt; size_t, double, std::string, Callable, Identifier &gt; Value Variant type containing all possible values types for variables."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#public-functions","title":"Public Functions","text":"Type Name ProgramExecutor () Constructor. ProgramExecutor (cse491::WorldBase &amp; world) Constructor with function registration. T as (const Value &amp; a) Get a value of type T from provided Value. void error (const std::string &amp; error) Sets the error message and end interpreter execution. std::string getErrorMessage () Gets the error message stored. bool has (const Value &amp; a) Check whether or not this Value contains the expected type. std::vector&lt; Value &gt; popArgs () Returns all arguments passed to an interpreter function. Value popStack () Retrieves a single value from the interpreter value stack. void pushStack (Value value) Pushes a single Value onto the interpreter value stack. void registerFunction (std::string name, Callable callable) Registers a function on this ProgramExecutor object. bool run (const std::string &amp; program) Executes a program from a string. bool run ()  bool runFile (const std::string &amp; filename) Executes a program from a file. void setVariable (const std::string &amp; name, Value value)  void skipBlock (int nest=0)  T var (const std::string &amp; name) Gets the value of a variable as type T. virtual ~ProgramExecutor () = default"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#detailed-description","title":"Detailed Description","text":"<p>Handles run-time state of program and contains the interpreter function.</p> <p>Native C++ functions can be registered on this object to extend the functionality. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#typedef-callable","title":"typedef Callable","text":"<pre><code>using Callable =  std::function&lt;void(ProgramExecutor&amp;)&gt;;\n</code></pre> <p>This is the signature interpreter functions should have.</p> <p>To read the arguments passed to the function, use ProgramExecutor::popArgs(). To return values from a function, use ProgramExecutor::pushStack(). </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#typedef-value","title":"typedef Value","text":"<pre><code>using Value =  std::variant &lt; size_t, double, std::string, Callable, Identifier &gt;;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-programexecutor-12","title":"function ProgramExecutor [1/2]","text":"<pre><code>inline worldlang::ProgramExecutor::ProgramExecutor () \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-programexecutor-22","title":"function ProgramExecutor [2/2]","text":"<pre><code>inline worldlang::ProgramExecutor::ProgramExecutor (\n    cse491::WorldBase &amp; world\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-as","title":"function as","text":"<p>Get a value of type T from provided Value. </p> <pre><code>template&lt;typename T typename T&gt;\ninline T worldlang::ProgramExecutor::as (\n    const Value &amp; a\n) \n</code></pre> <p>Gets the value of type T from given Value whether it contains a value or an identifier storing that value.</p> <p>If the value cannot be accessed, sets the error message and returns a default-constructed value.</p> <p>For example, if your program consists of <code>a=5</code> and <code>b=a</code> then as&lt;double&gt; will handle both 5 and a correctly as arguments std::get&lt;double&gt; is longer and only handles 5.</p> <p>Parameters:</p> <ul> <li><code>a</code> Value to retrieve value from </li> </ul> <p>Returns:</p> <p>Value of type T </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-error","title":"function error","text":"<p>Sets the error message and end interpreter execution. </p> <pre><code>inline void worldlang::ProgramExecutor::error (\n    const std::string &amp; error\n) \n</code></pre> <p>Sets the stored error message for the interpreter. Only the first error set is saved.</p> <p>Parameters:</p> <ul> <li><code>error</code> Message to store </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-geterrormessage","title":"function getErrorMessage","text":"<p>Gets the error message stored. </p> <pre><code>inline std::string worldlang::ProgramExecutor::getErrorMessage () \n</code></pre> <p>Gets the error message from the interpreter. If no error was set, this will be the empty string.</p> <p>Returns:</p> <p>Error message </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-has","title":"function has","text":"<p>Check whether or not this Value contains the expected type. </p> <pre><code>template&lt;typename T typename T&gt;\ninline bool worldlang::ProgramExecutor::has (\n    const Value &amp; a\n) \n</code></pre> <p>Checks the type of the given Value. If the type does not match and cannot be obtained, sets the interpreter error message and returns false. Otherwise, returns true.</p> <p>Parameters:</p> <ul> <li><code>a</code> Value to validate type of. </li> </ul> <p>Returns:</p> <p>true if type is usable </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-popargs","title":"function popArgs","text":"<p>Returns all arguments passed to an interpreter function. </p> <pre><code>inline std::vector&lt; Value &gt; worldlang::ProgramExecutor::popArgs () \n</code></pre> <p>This function retrieves the arguments of the function in the same order as in the source code. The end of the argument list is determined by an internal special Identifier</p> <p>This function should be called once for any Callable to get the arguments passed.</p> <p>Returns:</p> <p>Vector of Values provided to an interpreter function. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-popstack","title":"function popStack","text":"<p>Retrieves a single value from the interpreter value stack. </p> <pre><code>inline Value worldlang::ProgramExecutor::popStack () \n</code></pre> <p>Returns:</p> <p>Value object from stack. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-pushstack","title":"function pushStack","text":"<p>Pushes a single Value onto the interpreter value stack. </p> <pre><code>inline void worldlang::ProgramExecutor::pushStack (\n    Value value\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> Value to push to interpreter stack </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-registerfunction","title":"function registerFunction","text":"<p>Registers a function on this ProgramExecutor object.</p> <pre><code>inline void worldlang::ProgramExecutor::registerFunction (\n    std::string name,\n    Callable callable\n) \n</code></pre> <p>This allows the given function to be called from the interpreter via a function called <code>name</code>.</p> <p>Note:</p> <p>Names can be overridden by the user's program if they overwrite <code>name</code>.</p> <p>Parameters:</p> <ul> <li><code>name</code> Function name </li> <li><code>callable</code> Function accepting a ProgramExecutor&amp; with no return. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-run-12","title":"function run [1/2]","text":"<p>Executes a program from a string. </p> <pre><code>inline bool worldlang::ProgramExecutor::run (\n    const std::string &amp; program\n) \n</code></pre> <p>Executes a program from a string. This is the main interpreter function. See Language.hpp for most interesting syntax and parsing details.</p> <p>Parameters:</p> <ul> <li><code>program</code> Program to run. </li> </ul> <p>Returns:</p> <p>true if program ran successfully, false if an error occured </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-run-22","title":"function run [2/2]","text":"<pre><code>inline bool worldlang::ProgramExecutor::run () \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-runfile","title":"function runFile","text":"<p>Executes a program from a file. </p> <pre><code>inline bool worldlang::ProgramExecutor::runFile (\n    const std::string &amp; filename\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> File to load </li> </ul> <p>Returns:</p> <p>true if program ran successfully, false if an error occured </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-setvariable","title":"function setVariable","text":"<pre><code>inline void worldlang::ProgramExecutor::setVariable (\n    const std::string &amp; name,\n    Value value\n) \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-skipblock","title":"function skipBlock","text":"<pre><code>inline void worldlang::ProgramExecutor::skipBlock (\n    int nest=0\n) \n</code></pre> <p>Moves the interpreter's program counter to the end of the current block.</p> <p>Parameters:</p> <ul> <li><code>nest</code> Optional starting nest value (defaults to zero) Begins as if it was nested within this many <code>start_block</code> operations. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-var","title":"function var","text":"<p>Gets the value of a variable as type T. </p> <pre><code>template&lt;typename T typename T&gt;\ninline T worldlang::ProgramExecutor::var (\n    const std::string &amp; name\n) \n</code></pre> <p>Exception:</p> <ul> <li><code>std::out_of_range</code> if it is not defined </li> <li><code>std::bad_variant_access</code> if variable is wrong type </li> </ul> <p>Parameters:</p> <ul> <li><code>name</code> Variable name to check </li> </ul> <p>Returns:</p> <p>Value of variable as type T </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classworldlang_1_1_program_executor/#function-programexecutor","title":"function ~ProgramExecutor","text":"<pre><code>virtual worldlang::ProgramExecutor::~ProgramExecutor () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/ProgramExecutor.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_program_executor_1_1_identifier/","title":"Struct worldlang::ProgramExecutor::Identifier","text":"<p>ClassList &gt; worldlang &gt; ProgramExecutor &gt; Identifier</p> <p>Inherits the following classes: string</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/ProgramExecutor.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/","title":"Struct worldlang::Unit","text":"<p>ClassList &gt; worldlang &gt; Unit</p> <p>More...</p> <ul> <li><code>#include &lt;Language.hpp&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#public-types","title":"Public Types","text":"Type Name enum Type"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#public-attributes","title":"Public Attributes","text":"Type Name Type type std::string value The value of this code unit. What it means depends on the type."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#detailed-description","title":"Detailed Description","text":"<p>A singular code unit. Will have some specific meaning within the interpreter itself. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#enum-type","title":"enum Type","text":"<pre><code>enum worldlang::Unit::Type {\n    number,\n    string,\n    identifier,\n    function,\n    operation,\n    function_decl\n};\n</code></pre> <p>Various types of code Units. </p> <p>Note:</p> <p>that most internal interpreter functions all fall under <code>operation</code>. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#variable-type","title":"variable type","text":"<pre><code>Type type;\n</code></pre> <p>This determines how this unit is used within the interpreter. The type of this code unit. </p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1_unit/#variable-value","title":"variable value","text":"<pre><code>std::string value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1add/","title":"Struct worldlang::add","text":"<p>ClassList &gt; worldlang &gt; add</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; add_a, op_prio_add, add &gt;, add_a &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1add__a/","title":"Struct worldlang::add_a","text":"<p>ClassList &gt; worldlang &gt; add_a</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; mul, op_prio_add, mul &gt;, mul &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1assignment/","title":"Struct worldlang::assignment","text":"<p>ClassList &gt; worldlang &gt; assignment</p> <p>Inherits the following classes: tao::pegtl::seq&lt; identifier_list, pegtl::one&lt; '=' &gt;, expression_list &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1code__block/","title":"Struct worldlang::code_block","text":"<p>ClassList &gt; worldlang &gt; code_block</p> <p>Inherits the following classes: tao::pegtl::seq&lt; pegtl::one&lt; '{' &gt;, pegtl::eol, statement_list, pegtl::one&lt; '}' &gt;, pegtl::eol &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1comment/","title":"Struct worldlang::comment","text":"<p>ClassList &gt; worldlang &gt; comment</p> <p>Inherits the following classes: tao::pegtl::seq&lt; pegtl::one&lt; '#' &gt;, pegtl::until&lt; pegtl::eol &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1comp/","title":"Struct worldlang::comp","text":"<p>ClassList &gt; worldlang &gt; comp</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; comp_a, op_prio_comp, comp &gt;, comp_a &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1comp__a/","title":"Struct worldlang::comp_a","text":"<p>ClassList &gt; worldlang &gt; comp_a</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; add, op_prio_comp, add &gt;, add &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1element/","title":"Struct worldlang::element","text":"<p>ClassList &gt; worldlang &gt; element</p> <p>Inherits the following classes: tao::pegtl::sor&lt; function, identifier, number, string, pegtl::seq&lt; pegtl::one&lt; '(' &gt;, expression, pegtl::one&lt; ')' &gt; &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1expression/","title":"Struct worldlang::expression","text":"<p>ClassList &gt; worldlang &gt; expression</p> <p>Inherits the following classes: tao::pegtl::sor&lt; comp &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1expression__list/","title":"Struct worldlang::expression_list","text":"<p>ClassList &gt; worldlang &gt; expression_list</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; expression, pegtl::one&lt; ',' &gt;, expression_list &gt;, expression &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1function/","title":"Struct worldlang::function","text":"<p>ClassList &gt; worldlang &gt; function</p> <p>Inherits the following classes: tao::pegtl::seq&lt; identifier, pegtl::one&lt; '(' &gt;, pegtl::opt&lt; expression_list &gt;, pegtl::one&lt; ')' &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1identifier/","title":"Struct worldlang::identifier","text":"<p>ClassList &gt; worldlang &gt; identifier</p> <p>Inherits the following classes: identifier</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1identifier__list/","title":"Struct worldlang::identifier_list","text":"<p>ClassList &gt; worldlang &gt; identifier_list</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; identifier, pegtl::one&lt; ',' &gt;, identifier_list &gt;, identifier &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1mul/","title":"Struct worldlang::mul","text":"<p>ClassList &gt; worldlang &gt; mul</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; mul_a, op_prio_mul, mul &gt;, mul_a &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1mul__a/","title":"Struct worldlang::mul_a","text":"<p>ClassList &gt; worldlang &gt; mul_a</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; element, op_prio_mul, element &gt;, element &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1number/","title":"Struct worldlang::number","text":"<p>ClassList &gt; worldlang &gt; number</p> <p>Inherits the following classes: tao::pegtl::seq&lt; pegtl::opt&lt; pegtl::one&lt; '-' &gt; &gt;, pegtl::plus&lt; pegtl::digit &gt;, pegtl::opt&lt; pegtl::one&lt; '.' &gt;, pegtl::plus&lt; pegtl::digit &gt; &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1op__prio__add/","title":"Struct worldlang::op_prio_add","text":"<p>ClassList &gt; worldlang &gt; op_prio_add</p> <p>Inherits the following classes: tao::pegtl::one&lt; '+', '-' &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1op__prio__comp/","title":"Struct worldlang::op_prio_comp","text":"<p>ClassList &gt; worldlang &gt; op_prio_comp</p> <p>Inherits the following classes: tao::pegtl::sor&lt; TAO_PEGTL_STRING(\"==\"), TAO_PEGTL_STRING(\"!=\"), TAO_PEGTL_STRING(\"&lt;=\"), TAO_PEGTL_STRING(\"&gt;=\"), pegtl::one&lt; '&lt;' &gt;, pegtl::one&lt; '&gt;' &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1op__prio__mul/","title":"Struct worldlang::op_prio_mul","text":"<p>ClassList &gt; worldlang &gt; op_prio_mul</p> <p>Inherits the following classes: tao::pegtl::one&lt; ' *', '/' &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1program/","title":"Struct worldlang::program","text":"<p>ClassList &gt; worldlang &gt; program</p> <p>Inherits the following classes: tao::pegtl::seq&lt; statement_list, pegtl::eolf &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1statement/","title":"Struct worldlang::statement","text":"<p>ClassList &gt; worldlang &gt; statement</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; function, pegtl::opt&lt; code_block &gt;, pegtl::opt&lt; pegtl::eol &gt; &gt;, pegtl::seq&lt; assignment, pegtl::opt&lt; pegtl::eol &gt; &gt;, comment, pegtl::eol &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1statement__list/","title":"Struct worldlang::statement_list","text":"<p>ClassList &gt; worldlang &gt; statement_list</p> <p>Inherits the following classes: tao::pegtl::sor&lt; pegtl::seq&lt; statement, statement_list &gt;, statement &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/structworldlang_1_1string/","title":"Struct worldlang::string","text":"<p>ClassList &gt; worldlang &gt; string</p> <p>Inherits the following classes: tao::pegtl::seq&lt; pegtl::one&lt; '\"' &gt;, pegtl::star&lt; pegtl::not_one&lt;'\"'&gt; &gt;, pegtl::one&lt; '\"' &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Worlds <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/dir_9813a27ecb6dbdc5ed22cda8cf865019/","title":"Dir source/Worlds","text":"<p>FileList &gt; source &gt; Worlds</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/dir_9813a27ecb6dbdc5ed22cda8cf865019/#files","title":"Files","text":"Type Name file BiomeGenerator.cpp file BiomeGenerator.hpp file GenerativeWorld.hpp file Language.hpp file ManualWorld.hpp file MazeWorld.hpp file PerlinNoise.hpp file ProgramExecutor.hpp file SecondWorld.hpp <p>The documentation for this class was generated from the following file <code>source/Worlds/</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8cpp/","title":"File BiomeGenerator.cpp","text":"<p>FileList &gt; source &gt; Worlds &gt; BiomeGenerator.cpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include \"BiomeGenerator.hpp\"</code></li> <li><code>#include \"Agents/AgentLibary.hpp\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8cpp/#detailed-description","title":"Detailed Description","text":"<p>This file is part of the Fall 2023, CSE 491 course project.</p> <p>Author:</p> <p>Paul Schulte, Milan Mihailovic (some code assisted with ChatGPT) </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/BiomeGenerator.cpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8cpp_source/","title":"File BiomeGenerator.cpp","text":"<p>File List &gt; source &gt; Worlds &gt; BiomeGenerator.cpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#include \"BiomeGenerator.hpp\"\n#include \"Agents/AgentLibary.hpp\"\n\n#include &lt;cmath&gt;\n#include &lt;tuple&gt;\n#include &lt;queue&gt;\n\nusing namespace group6;\nusing namespace cse491;\n\nusing std::vector;\n\nBiomeGenerator::BiomeGenerator(BiomeType biome, unsigned int width, unsigned int height, unsigned int seed) : biome(biome), width(width), height(height), seed(seed) {\n    if (biome == BiomeType::Maze) {\n        setTiles(floor_id, wall_id);\n    } else if (biome == BiomeType::Grasslands) {\n        setTiles(grass_id, dirt_id);\n    }\n    else if (biome == BiomeType::Ocean) {\n        setTiles(water_id, sand_id);\n    }\n\n    perlinNoise = PerlinNoise(seed);\n    grid.Resize(width, height);\n}\n\nvoid BiomeGenerator::setWorld(WorldBase *world) {\n    worldPtr = world;\n}\n\nvoid BiomeGenerator::generate() {\n    size_t tile1 = tiles[0];\n    size_t tile2 = tiles[1];\n\n    for (unsigned int y = 0; y &lt; height; y++) {\n        for (unsigned int x = 0; x &lt; width; x++) {\n            // Give 5x5 clear space in top left corner\n            // TODO: Replace with putting player in valid room instead of 0,0\n            if (x &gt; 4 || y &gt; 4) {\n                const double val = perlinNoise.noise2D(x * frequency / width, y * frequency / height);\n                grid.At(x, y) = val &lt; 0 ? tile1 : tile2;\n            }\n        }\n    }\n\n\n    if (biome == BiomeType::Maze) {\n        placeSpecialTiles(tile1, spike_id, 0.05); // Placing spike tiles\n        placeSpecialTiles(tile1, tar_id, 0.08); // Placing tar tiles\n        placeTileRandom(key_id, floor_id); // placing key tile\n\n        vector&lt;GridPosition&gt; path = clearPath();\n        applyPathToGrid(path);\n        placeDoorTile(door_id); // placing door tile\n        grid.At(keyLocation) = key_id;\n\n    }\n\n    if (biome == BiomeType::Grasslands) {\n        placeTileRandom(hole_id, grass_id); // placing hole tile\n    }\n\n    if (biome == BiomeType::Ocean) {\n        oceanHandler();\n        placeTileRandom(hole_id, sand_id);\n    }\n\n}\n\nvoid BiomeGenerator::placeTileRandom(const size_t &amp;tile, const size_t &amp;spawnTile) {\n    bool counter = false;\n    while (!counter) {\n        int random_x = (int)worldPtr-&gt;GetRandom(width / 2.0, width - 1);\n        int random_y = (int)worldPtr-&gt;GetRandom(height / 2.0, height - 1);\n\n        if (grid.At(random_x, random_y) == spawnTile) {\n            grid.At(random_x, random_y) = tile;\n\n            if (tile == key_id) {\n                keyLocation = GridPosition(random_x, random_y);\n            }\n\n            counter = true;\n        }\n    }\n}\n\nvoid BiomeGenerator::placeDoorTile(const size_t &amp;doorTile) {\n    grid.At(2, 2) = doorTile;\n}\n\nvoid BiomeGenerator::placeSpecialTiles(const size_t &amp;genericTile, const size_t &amp;specialTile, double percentage) {\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; floorPositions;\n    for (unsigned int x = 0; x &lt; width; ++x) {\n        for (unsigned int y = 0; y &lt; height; ++y) {\n            if (grid.At(x, y) == genericTile) {\n                floorPositions.emplace_back(x, y);\n            }\n        }\n    }\n\n    int numSpikes = (int)round((int)floorPositions.size() * percentage);\n\n    // Convert some generic floor tiles to special tiles\n    for (int i = 0; i &lt; numSpikes; ++i) {\n        int pos = (int)round(worldPtr-&gt;GetRandom((int)floorPositions.size() - 1));\n        grid.At(floorPositions [pos].first, floorPositions[pos].second) = specialTile;\n\n        floorPositions.erase(floorPositions.begin() + pos);\n    }\n}\n\nvector&lt;GridPosition&gt; BiomeGenerator::clearPath() const {\n    vector&lt;GridPosition&gt; path;\n\n    GridPosition current(0, 0); // Starting point\n    path.push_back(current);\n\n    // Continue until we reach the KeyLocation\n    while (current != keyLocation) {\n        std::vector&lt;GridPosition&gt; possibleMoves;\n\n        // Always add right movement if not aligned horizontally\n        if (current.GetX() &lt; keyLocation.GetX()) {\n            possibleMoves.push_back(current.ToRight());\n        }\n\n        // Add down movement if above the target and within grid bounds\n        if (current.GetY() &lt; keyLocation.GetY() &amp;&amp; current.GetY() &lt; height - 1) {\n            possibleMoves.push_back(current.Below());\n        }\n\n        // Add up movement if below the target and within grid bounds\n        if (current.GetY() &gt; keyLocation.GetY() &amp;&amp; current.GetY() &gt; 0) {\n            possibleMoves.push_back(current.Above());\n        }\n\n        // Randomly choose one of the possible moves\n        if (!possibleMoves.empty()) {\n            GridPosition next = possibleMoves[int(worldPtr-&gt;GetRandom(0, 2)) % possibleMoves.size()];\n\n            // Check if we have made a valid move, if so, update the path and current position\n            if (next != current) {\n                path.push_back(next);\n                current = next;\n            }\n        }\n    }\n\n    return path;\n}\n\n\n\nvoid BiomeGenerator::applyPathToGrid(const vector&lt;GridPosition&gt; &amp;path) {\n    for (const GridPosition &amp;p: path) {\n        grid.At(p) = floor_id;\n    }\n}\n\nvoid BiomeGenerator::saveToFile(const std::string &amp;filename) const {\n    type_options_t types = type_options_t();\n\n    types.push_back(CellType{\"floor\", \"Floor that you can easily walk over.\", ' '});\n    types.push_back(CellType{\"wall\", \"Impenetrable wall that you must find a way around.\", '#'});\n    types.push_back(CellType{\"spike\", \"Dangerous spike that resets the game.\", 'X'});\n    types.push_back(CellType{\"tar\", \"Slow tile that makes you take two steps to get through it\", 'O'});\n    types.push_back(CellType{\"key\", \"item that can be picked up to unlock door and escape maze\", 'K'});\n    types.push_back(CellType{\"door\", \"Door that can be walked through only with possession of key to leave maze\", 'D'});\n    types.push_back(CellType{\"grass\", \"Grass you can walk on.\", 'M'});\n    types.push_back(CellType{\"dirt\", \"Dirt you can walk on.\", '~'});\n    types.push_back(CellType{\"tree\", \"A tree that blocks the way.\", 't'});\n    types.push_back(CellType{\"hole\", \"A hole that you can fall into the maze from.\", '8'});\n\n    types.push_back(CellType{\"water\",\"Water that you may be able to swim on.\", 'W'});\n    types.push_back(CellType{\"sand\", \"Sand you can walk on.\", '-'});\n\n\n    grid.Write(filename, types);\n\n}\n\nvoid BiomeGenerator::setTiles(const size_t &amp;firstTile, const size_t &amp;secondTile) {\n    tiles.clear();\n    tiles.push_back(firstTile);\n    tiles.push_back(secondTile);\n}\n\nvoid BiomeGenerator::placeTrees() {\n    // Iterates through each tile in the grid with a margin of 1 tile to prevent out of bounds access\n    for (unsigned int y = 1; y &lt; height - 1; ++y) {\n        for (unsigned int x = 1; x &lt; width - 1; ++x) {\n            // Only place trees on grass tiles and ensure we have space for a 3x3 tree\n            if (grid.At(x, y) == grass_id &amp;&amp;\n                    grid.At(x-1, y) == grass_id &amp;&amp; grid.At(x+1, y) == grass_id &amp;&amp;\n                    grid.At(x, y-1) == grass_id &amp;&amp; grid.At(x, y+1) == grass_id &amp;&amp;\n                    grid.At(x-1, y-1) == grass_id &amp;&amp; grid.At(x+1, y-1) == grass_id &amp;&amp;\n                    grid.At(x-1, y+1) == grass_id &amp;&amp; grid.At(x+1, y+1) == grass_id) {\n                // Use a random chance to place a tree\n                if (worldPtr-&gt;GetRandom( 100) &lt; 10) { // 10% chance to place a tree\n                    // Place a 3x3 block of tree tile characters for the tree\n                    for (int i = -1; i &lt;= 1; ++i) {\n                        for (int j = -1; j &lt;= 1; ++j) {\n                            grid.At(x + i, y + j) = tree_id;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid BiomeGenerator::oceanHandler(){\n    for (unsigned int y = 1; y &lt; height - 1; ++y) {\n        for (unsigned int x = 1; x &lt; width - 1; ++x) {\n            if (grid.At(x, y) == water_id) {\n                if (worldPtr-&gt;GetRandom(100) &lt; 15) {\n                    for (int i = -1; i &lt;= 1; ++i) {\n                        for (int j = -1; j &lt;= 1; ++j) {\n                            if (x + i &gt; 0 &amp;&amp; x + i &lt; width - 1 &amp;&amp; y + j &gt; 0 &amp;&amp; y + j &lt; height - 1) {\n                                grid.At(x + i, y + j) = sand_id;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp/","title":"File BiomeGenerator.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; BiomeGenerator.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"PerlinNoise.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> <li><code>#include \"../core/WorldGrid.hpp\"</code></li> <li><code>#include \"../core/Data.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace group6 A World that consists only of walls and open cells."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp/#classes","title":"Classes","text":"Type Name class BiomeGenerator"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Paul Schulte, Milan Mihailovic, ChatGPT</p> <p>Uses perlin noise to create dirt and grass on a grid </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/BiomeGenerator.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_biome_generator_8hpp_source/","title":"File BiomeGenerator.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; BiomeGenerator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;queue&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n\n#include \"PerlinNoise.hpp\"\n#include \"../core/WorldBase.hpp\"\n#include \"../core/WorldGrid.hpp\"\n#include \"../core/Data.hpp\"\n\nnamespace group6 {\n    using siv::PerlinNoise;\n    using cse491::WorldGrid, cse491::WorldBase, cse491::GridPosition;\n\n    enum class BiomeType {\n        Maze,\n        Grasslands,\n        Ocean\n    };\n\n    class BiomeGenerator {\n    private:\n        const double frequency = 8.0;         \n        // const int octaves = 8;                ///&lt; [1, 16]\n\n        PerlinNoise perlinNoise;              \n\n        BiomeType biome;                      \n\n        unsigned int width;                   \n        unsigned int height;                  \n        WorldGrid grid;                       \n\n        WorldBase *worldPtr = nullptr;        \n\n        unsigned int seed;                    \n\n        GridPosition keyLocation;\n\n        std::vector&lt;size_t&gt; tiles;            \n\n        size_t floor_id = 0;\n        size_t wall_id = 1;\n\n        size_t spike_id = 2;\n        size_t tar_id = 3;\n        size_t key_id = 4;\n        size_t door_id = 5;\n\n        size_t grass_id = 6;\n        size_t dirt_id = 7;\n\n        size_t tree_id = 8;\n\n        size_t sand_id = 11;\n        size_t water_id = 10;\n\n        size_t hole_id = 9;\n\n    public:\n        BiomeGenerator(BiomeType biome, unsigned int width, unsigned int height, unsigned int seed);\n        ~BiomeGenerator() = default;\n\n        void setWorld(WorldBase *world);\n\n        void generate();\n        void saveToFile(const std::string &amp;filename) const;\n        void placeSpecialTiles(const size_t &amp;genericTile, const size_t &amp;specialTile, double percentage);\n\n        [[nodiscard]] unsigned int getSeed() const { return  seed; }\n\n        void setTiles(const size_t &amp;firstTile, const size_t &amp;secondTile);\n        [[nodiscard]] BiomeType getBiome() const { return biome; }\n\n        void placeDoorTile(const size_t &amp;doorTile);\n        void placeTileRandom(const size_t&amp; tile, const size_t&amp; spawnTile);\n\n        [[nodiscard]] std::vector&lt;GridPosition&gt; clearPath() const;\n        void applyPathToGrid(const std::vector&lt;GridPosition&gt;&amp; path);\n\n        void placeTrees();\n\n        void oceanHandler();\n    };\n}\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_generative_world_8hpp/","title":"File GenerativeWorld.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; GenerativeWorld.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"BiomeGenerator.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> <li><code>#include \"../Agents/AStarAgent.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_generative_world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace group6 A World that consists only of walls and open cells."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_generative_world_8hpp/#classes","title":"Classes","text":"Type Name class GenerativeWorld <p>The documentation for this class was generated from the following file <code>source/Worlds/GenerativeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_generative_world_8hpp_source/","title":"File GenerativeWorld.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; GenerativeWorld.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"BiomeGenerator.hpp\"\n#include \"../core/WorldBase.hpp\"\n#include \"../Agents/AStarAgent.hpp\"\n\nnamespace group6 {\n    using namespace cse491;\n    using std::vector, std::string;\n\n    class GenerativeWorld : public WorldBase {\n    protected:\n        enum ActionType {\n            REMAIN_STILL = 0, MOVE_UP, MOVE_DOWN, MOVE_LEFT, MOVE_RIGHT\n        };\n\n        size_t floor_id; \n        size_t wall_id;  \n\n        size_t spike_id;      \n        size_t tar_id;        \n        size_t key_id;        \n        size_t door_id;       \n        size_t teleporter_id; \n        size_t armory_id;     \n\n        size_t tree_id;       \n        size_t grass_id;      \n        size_t dirt_id;       \n        size_t hole_id;       \n\n        size_t water_id;      \n        size_t sand_id;       \n\n        unsigned int world_width;\n        unsigned int world_height;\n\n        void ConfigAgent(AgentBase &amp;agent) override {\n            agent.AddAction(\"up\", MOVE_UP);\n            agent.AddAction(\"down\", MOVE_DOWN);\n            agent.AddAction(\"left\", MOVE_LEFT);\n            agent.AddAction(\"right\", MOVE_RIGHT);\n            agent.SetProperty(\"key_property\",0.0); \n            agent.SetProperty(\"tar_property\",5.0); \n        }\n\n        void DamageAgent(AgentBase &amp;agent) {\n            if (agent.IsInterface()) {\n                EndGame(false);\n            }\n        }\n\n        void CreateGrid(BiomeType biome, unsigned int width, unsigned int height, unsigned int seed, const string &amp;file) {\n            BiomeGenerator biomeGenerator(biome, width, height, seed);\n            biomeGenerator.setWorld(this);\n            biomeGenerator.generate();\n\n            string filePath = \"../assets/grids/generated_\" + file + \".grid\";\n\n            biomeGenerator.saveToFile(filePath);\n\n            main_grid.Read(filePath, type_options);\n        }\n\n    public:\n        explicit GenerativeWorld(BiomeType biome, unsigned int width, unsigned int height, unsigned int seed)\n                : WorldBase(seed) {\n            floor_id = AddCellType(\"floor\", \"Floor that you can easily walk over.\", ' ');\n            wall_id = AddCellType(\"wall\", \"Impenetrable wall that you must find a way around.\", '#');\n\n            spike_id = AddCellType(\"spike\", \"Dangerous spike that resets the game.\", 'X');\n\n            tar_id = AddCellType(\"tar\", \"Slow tile that makes you take two steps to get through it\", 'O');\n            key_id = AddCellType(\"key\", \"item that can be picked up to unlock door and escape maze\", 'K');\n            door_id = AddCellType(\"door\", \"Door that can be walked through only with possession of key to leave maze\",'D');\n            teleporter_id = AddCellType(\"teleporter\", \"Teleports agent to other teleporter\", 'T');\n\n            armory_id = AddCellType(\"armory\", \"Armory tile that repairs damaged inventory items\", 'A');\n            tree_id = AddCellType(\"tree\", \"A tree that blocks the way.\", 't');\n            grass_id = AddCellType(\"grass\", \"Grass you can walk on.\", 'M');\n            dirt_id = AddCellType(\"dirt\", \"Dirt you can walk on.\", '~');\n            hole_id = AddCellType(\"hole\", \"A hole that you can fall into the maze from.\", '8');\n\n            water_id = AddCellType(\"water\", \"Water that you may be able to swim on.\", 'W');\n            sand_id = AddCellType(\"sand\", \"Sand you can walk on.\", '-');\n\n            world_width = width;\n            world_height = height;\n\n            CreateGrid(biome, width, height, seed, \"maze\");\n        }\n\n        ~GenerativeWorld() override = default;\n\n        void AddTeleporters() {\n            main_grid.At(53, 6) = teleporter_id;\n            main_grid.At(18, 18) = teleporter_id;\n        }\n\n        [[noreturn]] void EndGame(bool win) {\n            run_over = true;\n\n            if (win) {\n                std::cout &lt;&lt; \"You successfully exited maze!\" &lt;&lt; std::endl;\n            } else {\n                std::cout &lt;&lt; \"Game over, try again!\" &lt;&lt; std::endl;\n            }\n            std::exit(0);\n        }\n\n        void AddArmory() {\n            bool counter = false;\n            while (!counter) {\n                //generate random location in bottom left quarter of map\n                int random_y = (int)GetRandom((double)main_grid.GetHeight() / 2, (double)main_grid.GetHeight() - 1);\n                int random_x = (int)GetRandom(0, (double)main_grid.GetWidth() / 2);\n\n                if (main_grid.At(random_x, random_y) == floor_id) {\n                    main_grid.At(random_x, random_y) = armory_id;\n                    counter = true;\n                }\n            }\n\n            counter = false;\n            while (!counter) {\n                //generate random location in top right quarter of map\n                int random_y = (int)GetRandom(0, (double)main_grid.GetHeight() / 2);\n                int random_x = (int)GetRandom((double)main_grid.GetWidth() / 2, (double)main_grid.GetWidth() - 1);\n\n                if (main_grid.At(random_x, random_y) == floor_id) {\n                    main_grid.At(random_x, random_y) = armory_id;\n                    counter = true;\n                }\n            }\n        }\n\n        [[nodiscard]] static vector&lt;GridPosition&gt; FindTiles(WorldGrid grid, size_t tile_id) {\n            vector&lt;GridPosition&gt; result;\n\n            for (size_t x = 0; x &lt; grid.GetWidth(); ++x) {\n                for (size_t y = 0; y &lt; grid.GetHeight(); ++y) {\n                    if (grid.At(x, y) == tile_id) {\n                        result.emplace_back(x, y);\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        int DoAction(AgentBase &amp;agent, size_t action_id) override {\n            AgentCollisionHelper(agent);\n\n            // Skip turn if stuck on tar\n            if (agent.GetProperty(\"tar_property\") == 6.0) {\n                agent.SetProperty(\"tar_property\", 5.0);\n                return true;\n            }\n\n            // Determine where the agent is trying to move.\n            GridPosition new_position;\n            switch (action_id) {\n                case REMAIN_STILL:\n                    new_position = agent.GetPosition();\n                    break;\n                case MOVE_UP:\n                    new_position = agent.GetPosition().Above();\n                    break;\n                case MOVE_DOWN:\n                    new_position = agent.GetPosition().Below();\n                    break;\n                case MOVE_LEFT:\n                    new_position = agent.GetPosition().ToLeft();\n                    break;\n                case MOVE_RIGHT:\n                    new_position = agent.GetPosition().ToRight();\n                    break;\n            }\n\n            // Don't let the agent move off the world or into a wall.\n            if (!main_grid.IsValid(new_position)) { return false; }\n            if (main_grid.At(new_position) == wall_id) { return false; }\n\n            //check to see if player is going onto armory tile\n            if (main_grid.At(new_position) == armory_id) {\n                ArmoryTileHelper(agent);\n            }\n            // check to see if player is moving onto spike tile\n            if (main_grid.At(new_position) == spike_id) {\n                SpikeTileHelper(agent);\n            }\n            // check to see if player is moving onto a tar tile\n            else if (main_grid.At(new_position) == tar_id) {\n                TarTileHelper(agent);\n            }\n            // check to see if player is moving onto teleporter\n            else if (main_grid.At(new_position) == teleporter_id) {\n                TeleporterHelper(new_position);\n            }\n            // check to see if player is moving onto key tile\n            else if (main_grid.At(new_position) == key_id) {\n                KeyTileHelper(agent, new_position);\n            }\n            // check to see if the player is moving onto door tile\n            else if (main_grid.At(new_position) == door_id) {\n                DoorTileHelper(agent);\n            }\n            // check to see if player is moving onto a hole tile\n            else if (main_grid.At(new_position) == hole_id) {\n                HoleTileHelper(agent, new_position);\n            }\n\n            //recalculate AStarAgent's path when player moves\n            AStarAgentHelper(agent);\n\n            //check to see if agent is walking on an item\n            ItemHelper(agent, new_position);\n\n            // Set the agent to its new position.\n            agent.SetPosition(new_position);\n\n            return true;\n        }\n\n        void ArmoryTileHelper(AgentBase &amp;agent) {\n            for (const auto &amp;pair: item_map) {\n                //if agent has the item in its inventory, heal it back to full health\n                if (agent.HasItem(pair.first)) {\n                    pair.second-&gt;SetProperty(\"Health\", 4.0);\n                }\n            }\n        }\n\n        void SpikeTileHelper(AgentBase &amp;agent) {\n            bool spike_immune = false;\n\n            //check to see if player has shield on\n            for (const auto &amp;pair: item_map) {\n                if (agent.HasItem(pair.first) &amp;&amp; pair.second-&gt;GetName() == \"Shield\") {\n                    //agent's shield has enough health and will protect player from spike tile\n                    if (pair.second-&gt;GetProperty(\"Health\") &gt; 0) {\n                        pair.second-&gt;SetProperty(\"Health\", pair.second-&gt;GetProperty(\"Health\") - 1);\n                        spike_immune = true;\n\n                        break;\n                    }\n                }\n            }\n\n            // Damage agent if not immune to spike\n            if (!spike_immune) {\n                DamageAgent(agent);\n            }\n        }\n\n        void TarTileHelper(AgentBase &amp;agent) {\n            bool tar_immune = false;\n\n            //check to see if player has boots on\n            for (const auto &amp;pair: item_map) {\n                if (agent.HasItem(pair.first) &amp;&amp; pair.second-&gt;GetName() == \"Boots\") {\n                    //agent's boots have enough health and will protect player from tar\n                    if (pair.second-&gt;GetProperty(\"Health\") &gt; 0) {\n                        pair.second-&gt;SetProperty(\"Health\", pair.second-&gt;GetProperty(\"Health\") - 1);\n                        tar_immune = true;\n\n                        break;\n                    }\n                }\n            }\n\n            // Slow agent if not immune to tar\n            if (!tar_immune) {\n                agent.SetProperty(\"tar_property\", 6.0);\n            }\n        }\n\n        void TeleporterHelper(GridPosition &amp;new_position) {\n            vector&lt;GridPosition&gt; teleporters = FindTiles(main_grid, teleporter_id);\n\n            for (GridPosition teleporter: teleporters) {\n                if (new_position != teleporter) {\n                    new_position = teleporter;\n\n                    break;\n                }\n            }\n        }\n\n        void KeyTileHelper(AgentBase &amp;agent, GridPosition &amp;new_position) {\n            // Only player can pick up keys\n            if (agent.IsInterface()) {\n                agent.SetProperty(\"key_property\", 1.0);\n                main_grid.At(new_position) = floor_id;\n            }\n        }\n\n        void DoorTileHelper(AgentBase &amp;agent) {\n            // Only player with key can win game\n            if (agent.IsInterface() &amp;&amp; agent.GetProperty(\"key_property\") == 1.0) {\n                EndGame(true);\n            }\n        }\n\n        void HoleTileHelper(AgentBase &amp;agent, GridPosition &amp;new_position) {\n            if (agent.IsInterface()) {\n                CreateGrid(BiomeType::Maze, world_width, world_height, ++seed, \"maze2\");\n                new_position.Set(0, 0);\n            }\n        }\n\n        void ItemHelper(AgentBase &amp;agent, GridPosition &amp;new_position) {\n            for (const auto &amp;pair: item_map) {\n                //check to see if items position is same as the position the player is moving to\n                if (pair.second-&gt;GetPosition() == new_position) {\n                    //Add item to inventory\n                    agent.AddItem(pair.first);\n                    break;\n                }\n            }\n        }\n\n        void AgentCollisionHelper(AgentBase &amp;agent) {\n            //if player is on same position as agent, game ends\n            for (const auto &amp;temp_agent: agent_map) {\n                //check to see if the two agents positions being compared are equal,\n                //as well as if one agent is a player and one agent is an enemy\n                if (temp_agent.second-&gt;GetPosition() == agent.GetPosition() &amp;&amp;\n                    ((agent.GetName() == \"Player\" &amp;&amp; temp_agent.second-&gt;GetName() != \"Player\") ||\n                     (agent.GetName() != \"Player\" &amp;&amp; temp_agent.second-&gt;GetName() == \"Player\")))\n                    EndGame(false);\n            }\n        }\n\n\n        bool IsTraversable(const AgentBase &amp; /*agent*/, cse491::GridPosition pos) const override {\n            size_t tileType = main_grid.At(pos);\n            return !(tileType == wall_id || tileType == spike_id || tileType == tar_id || tileType == armory_id || tileType == teleporter_id);\n        }\n\n        void AStarAgentHelper(AgentBase &amp;agent)\n        {\n            if( agent.GetName() == \"AStar1\" )\n            {\n                for( const auto &amp;temp_agent : agent_map )\n                {\n                    //updating AStarAgent's path to the players current location\n                    if( temp_agent.second-&gt;GetName() == \"Player\" )\n                    {\n                        auto &amp;astar_agent = dynamic_cast&lt;walle::AStarAgent&amp;&gt;(agent);\n                        astar_agent.SetGoalPosition(temp_agent.second-&gt;GetPosition());\n                        astar_agent.RecalculatePath();\n                        astar_agent.SetActionResult(1);\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n} // End of namespace group6\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_language_8hpp/","title":"File Language.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; Language.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;tao/pegtl.hpp&gt;</code></li> <li><code>#include &lt;tao/pegtl/contrib/parse_tree.hpp&gt;</code></li> <li><code>#include \"core/EasyLogging.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_language_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace worldlang Namespace for scripting language stuff."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_language_8hpp/#classes","title":"Classes","text":"Type Name struct Unit struct add struct add_a struct assignment struct code_block struct comment struct comp struct comp_a struct element struct expression struct expression_list struct function struct identifier struct identifier_list struct mul struct mul_a struct number struct op_prio_add struct op_prio_comp struct op_prio_mul struct program struct statement struct statement_list struct string <p>The documentation for this class was generated from the following file <code>source/Worlds/Language.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_language_8hpp_source/","title":"File Language.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; Language.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n// Debug\n#include &lt;iostream&gt;\n\n#include &lt;functional&gt;\n\n#include &lt;tao/pegtl.hpp&gt;\n#include &lt;tao/pegtl/contrib/parse_tree.hpp&gt;\n\n#include \"core/EasyLogging.hpp\"\n\nusing clogged::Logger;\nusing clogged::Team;\nusing clogged::LogLevel;\n\nnamespace pegtl = tao::pegtl;\n\nnamespace worldlang{\n    std::string stripWhitespace(const std::string&amp; input) {\n        std::string result;\n        bool insideString = false;\n\n        for (char c : input) {\n            if (c == '\\\"') {\n                insideString = !insideString;\n            }\n            // https://en.cppreference.com/w/cpp/string/byte/isspace\n            if (!insideString &amp;&amp; std::isspace(c) &amp;&amp; c != '\\n') {\n                // Skip whitespace outside of strings, excluding newlines\n                continue;\n            }\n            result += c;\n        }\n        return result;\n    }\n\n    // Equivalent regex\n    // \\-?[0-9]+(.[0-9]+)?\n    struct number : pegtl::seq &lt; \n        pegtl::opt&lt;\n            pegtl::one&lt; '-' &gt;\n        &gt;,\n        pegtl::plus&lt; pegtl::digit &gt;,\n        pegtl::opt&lt;\n            pegtl::one&lt; '.' &gt;,\n            pegtl::plus&lt; pegtl::digit &gt;\n        &gt;\n    &gt;\n    {};\n\n    struct string : pegtl::seq&lt;\n        pegtl::one&lt; '\"' &gt;,\n        pegtl::star&lt;\n            pegtl::not_one&lt;'\"'&gt;\n        &gt;,\n        pegtl::one&lt; '\"' &gt;\n    &gt;\n    {};\n\n    //[_a-zA-Z][_a-zA-Z0-9]*\n    // (C-style identifier, case sensitive)\n    struct identifier : pegtl::identifier\n    {};\n\n    // identifier list\n    // Contains one or more identifiers.\n    // This matches expressions such as\n    // \"name\" or \"a,b,c\".\n    struct identifier_list; \n    struct identifier_list : pegtl::sor&lt;\n        pegtl::seq&lt;\n            identifier,\n            pegtl::one&lt; ',' &gt;,\n            identifier_list\n        &gt;,\n        identifier\n    &gt;\n    {};\n\n    // Match operators of same priority as addition\n    struct op_prio_add : pegtl::one&lt; '+', '-' &gt;\n    {};\n\n    // Match operators of same priority as multiplication\n    struct op_prio_mul : pegtl::one&lt; '*', '/' &gt;\n    {};\n\n    // Match operators of same priority as comparison ops\n    struct op_prio_comp : pegtl::sor&lt; \n        TAO_PEGTL_STRING(\"==\"),\n        TAO_PEGTL_STRING(\"!=\"),\n        TAO_PEGTL_STRING(\"&lt;=\"),\n        TAO_PEGTL_STRING(\"&gt;=\"),\n        pegtl::one&lt; '&lt;' &gt;,\n        pegtl::one&lt; '&gt;' &gt;\n    &gt;\n    {};\n\n    // Must forward-declare for recursion\n    struct expression;\n    struct expression_list; \n\n    // Function call\n    // Matches expressions of form\n    // \"id(arg1,arg2,...)\" or \"id()\"\n    struct function : pegtl::seq&lt;\n        identifier,\n        pegtl::one&lt; '(' &gt;,\n        pegtl::opt&lt;expression_list&gt;,\n        pegtl::one&lt; ')' &gt;\n    &gt;\n    {};\n\n    // Match an expression or element representing a single value\n    // examples: 5,(-38),myvar1,myfunc1(7)\n    // Note that functions can technically return multiple values or none,\n    // so this isn't perfect.\n    // Expressions within parentheses is also counted as an element to allow\n    // for recursion, so \"(3+5+8)\" is a valid element\n    struct element : pegtl::sor&lt;\n        function,\n        identifier,\n        number,\n        string,\n        pegtl::seq&lt;\n            pegtl::one&lt; '(' &gt;,\n            expression,\n            pegtl::one&lt; ')' &gt;\n        &gt;\n    &gt;\n    {};\n\n    // Matches one multiplication expression or a single element\n    // \"a*b\" or \"c\"\n    struct mul_a : pegtl::sor&lt;\n        pegtl::seq&lt;\n            element,\n            op_prio_mul,\n            element\n        &gt;,\n        element\n    &gt;\n    {};\n\n    struct mul;\n    // Recursively matches multiplication operations\n    // Ex. \"1*4\", \"a*b*c\"\n    struct mul : pegtl::sor&lt;\n        pegtl::seq&lt;\n            mul_a,\n            op_prio_mul,\n            mul\n        &gt;,\n        mul_a\n    &gt;\n    {};\n\n    // Matches one addition expression or a multiplication subexpression\n    // \"a+b\" or \"a+b*c\", with \"b*c\" as the subexpression\n    struct add_a : pegtl::sor&lt;\n        pegtl::seq&lt;\n            mul,\n            op_prio_add,\n            mul\n        &gt;,\n        mul\n    &gt;\n    {}; \n\n    // Matches entire addition expression\n    struct add;\n    struct add : pegtl::sor&lt;\n        pegtl::seq&lt;\n            add_a,\n            op_prio_add,\n            add\n        &gt;,\n        add_a\n    &gt;\n    {};\n\n    struct comp_a : pegtl::sor&lt;\n        pegtl::seq&lt;\n            add,\n            op_prio_comp,\n            add\n        &gt;,\n        add\n    &gt;\n    {}; \n\n    // Matches entire comparison expression\n    struct comp;\n    struct comp : pegtl::sor&lt;\n        pegtl::seq&lt;\n            comp_a,\n            op_prio_comp,\n            comp\n        &gt;,\n        comp_a\n    &gt;\n    {};\n\n    // Match an expression intended to evaluate to a single value.\n    struct expression : pegtl::sor&lt;\n        comp\n    &gt;\n    {};\n\n    struct expression_list;\n    // A list of expressions. Can contain one or more expressions (not zero!)\n    // \"123,345+456,func(3)+6*8\"\n    struct expression_list : pegtl::sor&lt;\n        pegtl::seq&lt;\n            expression,\n            pegtl::one&lt; ',' &gt;,\n            expression_list\n        &gt;,\n        expression\n    &gt;\n    {};\n\n    // Assignment expression\n    // \"var=value\", or \"var,vars=val1,val2\", etc.\n    struct assignment : pegtl::seq&lt;\n        identifier_list,\n        pegtl::one&lt; '=' &gt;,\n        expression_list\n    &gt;\n    {};\n\n    // Comment\n    // # Comment text goes here\n    struct comment : pegtl::seq&lt;\n        pegtl::one&lt; '#' &gt;,\n        pegtl::until&lt;\n            pegtl::eol\n        &gt;\n    &gt;\n    {};\n\n    struct statement_list;\n\n    // Matches a block of code\n    // ex. { /*code*/ }\n    struct code_block : pegtl::seq&lt;\n        pegtl::one&lt; '{' &gt;,\n        pegtl::eol,\n        statement_list,\n        pegtl::one&lt; '}' &gt;,\n        pegtl::eol\n    &gt;\n    {};\n\n    struct statement : pegtl::sor&lt;\n        pegtl::seq&lt;\n            function,\n            pegtl::opt&lt;code_block&gt;,\n            pegtl::opt&lt;pegtl::eol&gt;\n        &gt;,\n        pegtl::seq&lt;\n            assignment,\n            pegtl::opt&lt;pegtl::eol&gt;\n        &gt;,\n        comment,\n        pegtl::eol\n    &gt;\n    {};\n\n    struct statement_list;  \n    // function()\\nfunction()...\n    struct statement_list : pegtl::sor&lt;\n        pegtl::seq&lt;\n            statement,\n            statement_list\n        &gt;,\n        statement\n    &gt;\n    {};\n\n    struct program : pegtl::seq&lt;\n        statement_list,\n        pegtl::eolf\n    &gt;\n    {};\n\n    template&lt; typename Rule &gt;\n    using selector = tao::pegtl::parse_tree::selector&lt; Rule,\n        tao::pegtl::parse_tree::store_content::on&lt;\n            number,\n            string,\n            function,\n            identifier,\n            identifier_list,\n            expression,\n            expression_list,\n            statement,\n            statement_list,\n            code_block,\n            program,\n            assignment,\n            op_prio_add,\n            op_prio_mul,\n            op_prio_comp\n        &gt;,\n        tao::pegtl::parse_tree::fold_one::on&lt;\n            add_a,\n            mul_a\n        &gt;\n    &gt;;\n\n    struct Unit {\n        enum class Type {\n            number,\n            string,\n            identifier,\n            function,\n            operation,\n            function_decl,\n        };\n        Type type;\n\n        std::string value;\n    };\n\n\n    std::vector&lt;Unit&gt; parse_to_code(std::string program){\n        program = stripWhitespace(program);\n        pegtl::string_input in(program, \"program\");\n        std::vector&lt;Unit&gt; out{};\n\n        auto log = Logger::Log() &lt;&lt; Team::TEAM_4 &lt;&lt; LogLevel::DEBUG;\n        log &lt;&lt; \"Entering parser\" &lt;&lt; std::endl;\n\n        std::function&lt;void(const std::unique_ptr&lt;pegtl::parse_tree::node&gt;&amp;)&gt; traverse =\n        [&amp;out, &amp;traverse, &amp;log](const std::unique_ptr&lt;pegtl::parse_tree::node&gt;&amp; node) -&gt; void{\n            const std::string_view&amp; type = node-&gt;type;\n            // visit:\n            if (type == \"worldlang::number\"){\n                out.push_back(Unit{Unit::Type::number, node-&gt;string()});\n            } else if (type == \"worldlang::identifier\"){\n                out.push_back(Unit{Unit::Type::identifier, node-&gt;string()});\n            } else if (type == \"worldlang::string\"){\n                // trim quotes off\n                out.push_back(Unit{Unit::Type::string, node-&gt;string().substr(1,node-&gt;string().size()-2)});\n            } else if (type == \"worldlang::function\"){\n                // (operator_endargs) arg arg arg function_name\n                out.push_back(Unit{Unit::Type::operation, \"endargs\"});\n                if (node-&gt;children.size() &gt; 1)\n                    traverse(node-&gt;children[1]);\n\n//              out.push_back(Unit{Unit::Type::number, std::to_string(argcount)});\n                out.push_back(Unit{Unit::Type::function, node-&gt;children.at(0)-&gt;string()});\n            } else if (type == \"worldlang::assignment\"){\n                // identifier_list\n//              auto identifier_count = count(node-&gt;children.at(0));\n                out.push_back(Unit{Unit::Type::operation, \"endargs\"});\n                traverse(node-&gt;children.at(0));\n                // value\n                // Can't check expression count here: must be done at runtime\n                // since functions may have multiple returns\n                out.push_back(Unit{Unit::Type::operation, \"endargs\"});\n                traverse(node-&gt;children.at(1));\n                // expression\n//              out.push_back(Unit{Unit::Type::number, std::to_string(identifier_count)});\n                out.push_back(Unit{Unit::Type::operation, \"=\"});\n            } else if (type == \"worldlang::mul_a\"\n                    || type == \"worldlang::add_a\"\n                    || type == \"worldlang::expression\"){\n                traverse(node-&gt;children.at(0));\n                if (node-&gt;children.size() &gt; 1){\n                    traverse(node-&gt;children.at(2));\n                    out.push_back(Unit{Unit::Type::operation, node-&gt;children.at(1)-&gt;string()});\n                }\n            } else if (type == \"worldlang::expression_list\"\n                    || type == \"worldlang::identifier_list\"){\n                log &lt;&lt; \"Traversing \" &lt;&lt; type &lt;&lt; \"\\n\";\n                if (node-&gt;children.size()){\n                    for (const auto&amp; c : node-&gt;children){\n                        traverse(c);\n                    }\n                }\n            } else if (type == \"worldlang::code_block\"){\n                log &lt;&lt; \"Traversing \" &lt;&lt; type &lt;&lt; \"\\n\";\n                out.push_back(Unit{Unit::Type::operation, \"start_block\"});\n                traverse(node-&gt;children.at(0));\n                out.push_back(Unit{Unit::Type::operation, \"end_block\"});\n            } else if (type == \"worldlang::statement\"){\n                if (node-&gt;children.size()){\n//                  auto value = node-&gt;children.at(0)-&gt;string();\n                    auto&amp; first = node-&gt;children.at(0);\n                    if (first-&gt;type == \"worldlang::function\" \n                        &amp;&amp; first-&gt;children.at(0)-&gt;string() != \"if\"\n                        &amp;&amp; first-&gt;children.at(0)-&gt;string() != \"for\"\n                        &amp;&amp; node-&gt;children.size() &gt; 1\n                        &amp;&amp; node-&gt;children.at(1)-&gt;type == \"worldlang::code_block\"){\n                        // encode differently here to use for definitions\n                        // &lt;values&gt; . a b c d e funcname(decl)\n                        // funcname assigns variables, then jumps to code\n                        traverse(node-&gt;children.at(0)); // function\n                        out.back().type = Unit::Type::function_decl;\n                        traverse(node-&gt;children.at(1)); // function code\n                    } else {\n                        for (const auto&amp; child : node-&gt;children){\n                            traverse(child);\n                        }\n                    }\n                }\n                out.push_back(Unit{Unit::Type::operation, \"endline\"});\n            } else {\n                log &lt;&lt; \"Type: \" &lt;&lt; type;\n                if (node-&gt;has_content())\n                    log &lt;&lt; \" Content: \" &lt;&lt; node-&gt;string();\n                log &lt;&lt; std::endl;\n                // visit all children\n                for (const auto&amp; child : node-&gt;children){\n                    traverse(child);\n                }\n            }\n        };\n\n        auto root = pegtl::parse_tree::parse &lt; worldlang::program, worldlang::selector &gt; (in);\n\n        if (root){\n            traverse(root-&gt;children[0]);\n            return out;\n        } else {\n            // parse error lol\n            log &lt;&lt; LogLevel::WARNING &lt;&lt; \"Parse error!!\" &lt;&lt; std::endl;\n            return {};\n        }\n    }\n\n} //worldlang\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_manual_world_8hpp/","title":"File ManualWorld.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; ManualWorld.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_manual_world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491_team8 A World that consists of trees, water, and grass cells."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_manual_world_8hpp/#classes","title":"Classes","text":"Type Name class ManualWorld <p>The documentation for this class was generated from the following file <code>source/Worlds/ManualWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_manual_world_8hpp_source/","title":"File ManualWorld.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; ManualWorld.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;map&gt;\n#include &lt;tuple&gt;\n\n#include \"../core/WorldBase.hpp\"\n#include \"../core/AgentBase.hpp\"\n\nnamespace cse491_team8 {\n\n  class ManualWorld : public cse491::WorldBase {\n  protected:\n    enum ActionType { REMAIN_STILL=0, MOVE_UP, MOVE_DOWN, MOVE_LEFT, MOVE_RIGHT, USE_AXE, USE_BOAT, STATS, HEAL, RUN,\n            ATTACK, SPECIAL, BUFF, HELP };\n    enum FacingDirection { UP=0, RIGHT, DOWN, LEFT};\n\n    size_t grass_id;  \n    size_t tree_id;   \n    size_t water_id;  \n    size_t bridge_id; \n    size_t rock_id;   \n    size_t portal_id_a; \n    size_t portal_id_b; \n    size_t portal_id_c; \n    size_t portal_id_d; \n\n    void ConfigAgent(cse491::AgentBase &amp; agent) override {\n      agent.AddAction(\"up\", MOVE_UP);\n      agent.AddAction(\"down\", MOVE_DOWN);\n      agent.AddAction(\"left\", MOVE_LEFT);\n      agent.AddAction(\"right\", MOVE_RIGHT);\n      agent.AddAction(\"use_axe\", USE_AXE);\n      agent.AddAction(\"use_boat\", USE_BOAT);\n      agent.AddAction(\"stats\", STATS);\n      agent.AddAction(\"heal\", HEAL);\n      agent.AddAction(\"run\", RUN);\n      agent.AddAction(\"attack\", ATTACK);\n      agent.AddAction(\"special\", SPECIAL);\n      agent.AddAction(\"buff\", BUFF);\n      agent.AddAction(\"help\", HELP);\n      agent.SetProperties(\"Strength\", 10, \"Health\", 100, \"Max_Health\", 150, \"Direction\", 0, \"Battling\", false);\n    }\n\n  public:\n    ManualWorld() {\n      grass_id = AddCellType(\"grass\", \"Grass that you can easily walk over.\", ' ');\n      tree_id = AddCellType(\"tree\", \"Tree that you cannot pass without an axe.\", '^');\n      water_id = AddCellType(\"water\", \"Water that cannot be crossed without a boat.\", '~');\n      bridge_id = AddCellType(\"bridge\", \"Bridge that allows the playerto cross water.\", '#');\n      rock_id = AddCellType(\"rock\", \"Rock that the player cannot cross\", '$');\n      portal_id_a = AddCellType(\"portal_a\", \"Portal that teleports player to another a-portal spot.\", '}');\n      portal_id_b = AddCellType(\"portal_b\", \"Portal that teleports player to another b-portal spot.\", '{');\n      portal_id_c = AddCellType(\"portal_c\", \"Portal that teleports player to another c-portal spot.\", '(');\n      portal_id_d = AddCellType(\"portal_d\", \"Portal that teleports player to another d-portal spot.\", ')');\n      main_grid.Read(\"../assets/grids/team8_grid_v2.grid\", type_options);\n    }\n    ~ManualWorld() = default;\n\n    void GenerateMoveSets()\n    {\n        for (auto &amp; [id, agent_ptr] : agent_map)\n        {\n          auto agent_strength = agent_ptr-&gt;GetProperty&lt;int&gt;(\"Strength\");\n          if (agent_ptr-&gt;GetName() == \"Interface\")\n          {\n            std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = {\n                {\"Attack\", std::make_tuple('d', 1.0)},\n                {\"Special\", std::make_tuple('d', 1.5)}, {\"Run\", std::make_tuple('d', 0.0)},\n                {\"Heal\", std::make_tuple('h', 0.25)}};\n            // agent_ptr-&gt;SetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\", move_set);\n            agent_ptr-&gt;SetProperty(\"MoveSet\", move_set);\n            continue;\n          }\n          std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = {{\"Attack\", std::make_tuple('d', 1.0)}};\n          if (agent_strength &gt;= 10)\n          {\n            move_set[\"Special\"] = std::make_tuple('d', 1.5);\n          }\n          if (agent_strength &gt;= 15)\n          {\n            move_set[\"Heal\"] = std::make_tuple('h', 0);\n          }\n          if (agent_strength &gt;= 20)\n          {\n            move_set[\"Buff\"] = std::make_tuple('s', 0.5);\n          }\n          agent_ptr-&gt;SetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\", move_set);\n        }\n    }\n\n    void AddMove(cse491::AgentBase&amp; agent, std::string&amp; move, char stat, double modification)\n    {\n      if (!agent.HasProperty(\"MoveSet\")) {\n        agent.Notify(\"Error: Agent does not have a Move Set\\n\");\n        return;\n      }\n      else\n      {\n        std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = agent.GetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\");\n        move_set[move] = std::make_tuple(stat, modification);\n        agent.SetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\", move_set);\n      }\n    }\n    bool RemoveMove(cse491::AgentBase&amp; agent, std::string&amp; move)\n    {\n      if (!agent.HasProperty(\"MoveSet\")) {\n        agent.Notify(\"Error: Agent does not have a Move Set\\n\");\n        return false;\n      }\n      else\n      {\n        std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = agent.GetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\");\n        move_set.erase(move);\n        agent.SetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\", move_set);\n        return true;\n      }\n    }\n\n    void HealAction(cse491::AgentBase &amp; agent)\n    {\n      size_t can_heal = FindItem(agent, \"Health Potion\");\n      if (can_heal != SIZE_MAX) {\n        int healing_req = agent.GetProperty&lt;int&gt;(\"Max_Health\") - agent.GetProperty&lt;int&gt;(\"Health\");\n        int healing = item_map[can_heal]-&gt;GetProperty&lt;int&gt;(\"Healing\");\n        if (healing_req &gt;= healing) {\n          agent.Notify(\"You healed \" + std::to_string(healing) + \" health!\\n\");\n          agent.SetProperty(\"Health\", agent.GetProperty&lt;int&gt;(\"Health\") + healing);\n          agent.RemoveItem(can_heal);\n          RemoveItem(can_heal);\n        }\n        else if (healing_req == 0) {\n          agent.Notify(\"You already have max health\");\n        } else {\n          agent.Notify(\"You healed \" + std::to_string(healing_req) + \" health!\\n\");\n          agent.SetProperty(\"Health\", agent.GetProperty&lt;int&gt;(\"Health\") + healing_req);\n          item_map[can_heal]-&gt;SetProperty(\"Healing\", healing - healing_req);\n        }\n      } else {\n        agent.Notify(\"You do not have any health potions!\\n\");\n      }\n\n    }\n\n    void StatsAction(cse491::AgentBase &amp; agent)\n    {\n        std::string output = \"\";\n        output += \"Items owned by the player:\\n\";\n        for (const auto &amp; [item_id, item] : item_map)\n        {\n            if (item-&gt;IsOwnedBy(agent.GetID()))\n            {\n                for (const auto &amp; [name, entity] : item-&gt;GetPropertyMap())\n                {\n                    if (name == \"Uses\" || name == \"Strength\" || name == \"Healing\")\n                    {\n                        size_t value = item-&gt;GetProperty&lt;int&gt;(name);\n                        output += item-&gt;GetName() + \": \" + name + \": \" + std::to_string(value) + \"\\n\";\n                    }\n                }\n            }\n        }\n        output += \"\\nProperties of the player:\\n\";\n        for (const auto &amp; [name, entity] : agent.GetPropertyMap())\n        {\n            if (name == \"Strength\" || name == \"Health\" || name == \"Max_Health\")\n            {\n                size_t value = agent.GetProperty&lt;int&gt;(name);\n                output += name + \": \" + std::to_string(value) + \"\\n\";\n            }\n        }\n        agent.Notify(output);\n    }\n\n    void MoveSetAction(cse491::AgentBase &amp; agent)\n    {\n        agent.Notify(\"Your Moveset is:\\nMove Up: W\\nMove Down: S\\nMove Left: A\\nMove Right: D\\nUse Axe: C\\nUse Boat: V\\nDisplay Stats: T\\nHeal: H\\nAttack: F\\nSpecial: G\\nRun: R\\nBuff: B\\nDisplay Moveset: Y\");\n    }\n\n    cse491::GridPosition LookAhead(cse491::AgentBase &amp; agent)\n    {\n        size_t direction = agent.GetProperty&lt;int&gt;(\"Direction\");\n        cse491::GridPosition look_position;\n\n        switch (direction)\n        {\n        case (0):\n          look_position = agent.GetPosition().Above();\n          break;\n        case (1):\n          look_position = agent.GetPosition().ToRight();\n          break;\n        case (2):\n          look_position = agent.GetPosition().Below();\n          break;\n        case (3):\n          look_position = agent.GetPosition().ToLeft();\n          break;\n\n        default:\n          agent.Notify(\"Invalid Position: Returning Current Position\");\n          look_position = agent.GetPosition();\n          break;\n        }\n\n        return look_position;\n    }\n\n    void DropItems(cse491::AgentBase &amp; agent, cse491::AgentBase &amp; other_agent)\n    {\n        for (const auto&amp; [id, item] : item_map)\n        {\n            if (item-&gt;IsOwnedBy(other_agent.GetID()))\n            {\n                if (item-&gt;HasProperty(\"Strength\") &amp;&amp; other_agent.HasProperty(\"Strength\"))\n                {\n                    auto agent_health = other_agent.GetProperty&lt;int&gt;(\"Strength\");\n                    auto item_strength = item-&gt;GetProperty&lt;int&gt;(\"Strength\");\n                    other_agent.SetProperty&lt;int&gt;(\"Strength\", (int)(agent_health - item_strength));\n                }\n                other_agent.RemoveItem(item-&gt;GetID());\n                item-&gt;SetPosition(other_agent.GetPosition());\n                agent.Notify(other_agent.GetName() + \" dropped their \" + item-&gt;GetName() + \"!\");\n            }\n        }\n    }\n\n    int OtherAction(cse491::AgentBase &amp; other_agent, cse491::AgentBase &amp; agent)\n    {\n        int other_damage = 0;\n        std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt; move_set = other_agent.GetProperty&lt;std::map&lt;std::string, std::tuple&lt;char, double&gt;&gt;&gt;(\"MoveSet\");\n        auto iterator = move_set.begin();\n        int random = GetRandom(move_set.size());\n        std::advance(iterator, random);\n        std::string random_key = iterator-&gt;first;\n        agent.Notify(\"\\nThe enemy has used: \" + random_key);\n        std::tuple&lt;char, double&gt; move_info = iterator-&gt;second;\n        char stat_char = std::get&lt;0&gt;(move_info);\n        double stat_modification = std::get&lt;1&gt;(move_info);\n        if (stat_char == 'd') {\n            other_damage = static_cast&lt;int&gt;(other_agent.GetProperty&lt;int&gt;(\"Strength\") * stat_modification);\n        }\n        if (stat_char == 'h') {\n            HealAction(other_agent);\n        }\n        if (stat_char == 's') {\n          if (stat_modification &lt; 0) {\n            int agent_strength = agent.GetProperty&lt;int&gt;(\"Strength\");\n            int new_strength = static_cast&lt;int&gt;(agent_strength - abs(stat_modification) * agent_strength);\n            agent.SetProperty&lt;int&gt;(\"Strength\", new_strength);\n          }\n          else {\n            int other_agent_strength = other_agent.GetProperty&lt;int&gt;(\"Strength\");\n            int new_strength_other = static_cast&lt;int&gt;(other_agent_strength + abs(stat_modification) * other_agent_strength);\n            other_agent.SetProperty&lt;int&gt;(\"Strength\", new_strength_other);\n          }\n        }\n        return other_damage;\n    }\n\n    void DoBattle(cse491::AgentBase &amp; other_agent, cse491::AgentBase &amp; agent, char attack_type) {\n        // User Input for Player Decision\n        bool won = false;\n        bool run = false;\n        int damage = 0;\n        switch (attack_type) {\n        case 'a': case 'A': damage = agent.GetProperty&lt;int&gt;(\"Strength\");    break;\n        case 's': case 'S': damage = static_cast&lt;int&gt;(agent.GetProperty&lt;int&gt;(\"Strength\") * 1.5);  break;\n        case 'r': case 'R': won = false; run = true; break;\n        case 'b': case 'B': agent.SetProperty&lt;int&gt;(\"Strength\", static_cast&lt;int&gt;(1.5 * agent.GetProperty&lt;int&gt;(\"Strength\"))); break;\n        case 'h': case 'H': HealAction(agent); break;\n        default: break;\n        }\n\n        // Other Agent Move Choice, will modify strength of player agent or NPC agent based on the move selected\n        int other_damage = OtherAction(other_agent, agent);\n\n        // Process the Player's Move and the Agent's Move\n        if (run)\n        {\n            agent.SetProperty&lt;int&gt;(\"Health\", agent.GetProperty&lt;int&gt;(\"Health\") - other_damage);\n        }\n        else\n        {\n            other_agent.SetProperty&lt;int&gt;(\"Health\", other_agent.GetProperty&lt;int&gt;(\"Health\") - damage);\n            if (other_agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 0)\n            {\n                won = true;\n                other_damage = 0;\n            }\n            agent.SetProperty&lt;int&gt;(\"Health\", agent.GetProperty&lt;int&gt;(\"Health\") - other_damage);\n            if (agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 0)\n            {\n                won = false;\n                // run_over = true;\n            }\n        }\n\n        agent.Notify(\"Player Health: \" + std::to_string(agent.GetProperty&lt;int&gt;(\"Health\"))+\"\\n\"+\n                \"Player Strength: \" + std::to_string(agent.GetProperty&lt;int&gt;(\"Strength\"))+\"\\n\"+\n                \"Enemy Health: \" + std::to_string(other_agent.GetProperty&lt;int&gt;(\"Health\"))+\"\\n\"+\n                \"Enemy Strength: \" + std::to_string(other_agent.GetProperty&lt;int&gt;(\"Strength\")));\n\n        std::string other_agent_name = other_agent.GetName();\n        DataCollection::DataManager::GetInstance().GetAgentInteractionCollector().RecordInteraction(other_agent_name);\n\n        if (!won) {\n          if (run)\n          {\n            agent.Notify(\"You ran away, this means you don't gain health or strength and any battle damage stays!\\n\");\n          }\n          std::cout &lt;&lt; agent.GetName()  &lt;&lt; \": \" &lt;&lt;  agent.GetProperty&lt;int&gt;(\"Health\") &lt;&lt; std::endl;\n          if (agent.IsInterface() &amp;&amp; agent.GetProperty&lt;int&gt;(\"Health\") &lt;= 0)\n          {\n            agent.Notify(other_agent_name + \" has beat \" + agent.GetName() + \"\\nYou Lost...\\n\");\n\n            DropItems(agent, agent);\n\n            agent.SetProperty&lt;int&gt;(\"Health\", 100);\n            agent.SetProperty&lt;int&gt;(\"Direction\", 0);\n\n            agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n            other_agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n\n            agent.SetPosition(80, 63);\n            agent.Notify(\"You Have died and dropped all your items\");\n          }\n        }\n        else\n        {\n          agent.Notify(agent.GetName() + \" has beat \" + other_agent.GetName());\n          agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n          other_agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n          DropItems(agent, other_agent);\n          other_agent.SetProperty&lt;bool&gt;(\"deleted\", true);\n        }\n    }\n\n    void UpdateWorld() override\n    {\n\n    }\n\n    void Run() override\n    {\n      run_over = false;\n      while (!run_over) {\n        RunAgents();\n        CollectData();\n        UpdateWorld();\n      }\n    }\n\n    void RunAgents() override {\n      for (auto &amp; [id, agent_ptr] : agent_map) {\n        if (agent_ptr-&gt;HasProperty(\"deleted\")) {\n          continue;\n        }\n        size_t action_id = agent_ptr-&gt;SelectAction(main_grid, type_options, item_map, agent_map);\n        agent_ptr-&gt;storeActionMap(agent_ptr-&gt;GetName());\n        int result = DoAction(*agent_ptr, action_id);\n        agent_ptr-&gt;SetActionResult(result);\n      }\n    }\n\n    void DoActionAttemptItemPickup(cse491::AgentBase &amp; agent, const cse491::GridPosition &amp; new_position) {\n      for (const auto &amp; [id, item_ptr] : item_map) {\n        if (item_ptr-&gt;GetPosition() == new_position &amp;&amp; item_ptr-&gt;GetOwnerID() == 0)\n        {\n          std::string uses_property = \"\";\n          if (item_ptr-&gt;GetName() == \"Stick\" || item_ptr-&gt;GetName() == \"Sword\") { uses_property = \"Strength\"; }\n          if (item_ptr-&gt;GetName() == \"Boat\" || item_ptr-&gt;GetName() == \"Axe\")  { uses_property = \"Uses\"; }\n          if (item_ptr-&gt;GetName() == \"Health Potion\") { uses_property = \"Healing\"; }\n\n          if (uses_property == \"Strength\")\n          {\n            if (agent.HasProperty(uses_property))\n            {\n              agent.SetProperty(uses_property, item_ptr-&gt;GetProperty&lt;int&gt;(uses_property) + agent.GetProperty&lt;int&gt;(uses_property));\n            }\n            else\n            {\n              agent.SetProperty(uses_property, item_ptr-&gt;GetProperty&lt;int&gt;(uses_property));\n            }\n          }\n\n          DataCollection::DataManager::GetInstance().GetItemUseCollector().IncrementItemUsage(item_ptr-&gt;GetName());\n          agent.Notify(\"Picked up the \" + item_ptr-&gt;GetName() + \"!\\nYou gained \" +\n                        std::to_string(item_ptr-&gt;GetProperty&lt;int&gt;(uses_property)) + \" \" +\n                        uses_property + \"!\\n\");\n\n          // remove it from the board\n          agent.AddItem(item_ptr-&gt;GetID());\n          break;\n        }\n      }\n    }\n\n\n    cse491::GridPosition DoActionFindNewPosition(cse491::AgentBase&amp; agent, size_t action_id) {\n        // Determine where the agent is trying to move.\n        cse491::GridPosition new_position, look_position;\n        char move = ' ';\n\n        bool battling = agent.GetProperty&lt;bool&gt;(\"Battling\");\n        // Update Direction property and get new position.\n        switch (action_id) {\n        case REMAIN_STILL:\n        {\n            new_position = agent.GetPosition();\n            break;\n        }\n        case MOVE_UP:\n        {\n            if (battling)\n            {\n                new_position = agent.GetPosition();\n            }\n            else\n            {\n                agent.SetProperty&lt;int&gt;(\"Direction\", UP);\n                new_position = agent.GetPosition().Above();\n            }\n            break;\n        }\n        case MOVE_DOWN:\n        {\n            if (battling)\n            {\n                new_position = agent.GetPosition();\n            }\n            else\n            {\n                agent.SetProperty&lt;int&gt;(\"Direction\", DOWN);\n                new_position = agent.GetPosition().Below();\n            }\n            break;\n        }\n        case MOVE_LEFT:\n        {\n            if (battling)\n            {\n                new_position = agent.GetPosition();\n            }\n            else\n            {\n                agent.SetProperty&lt;int&gt;(\"Direction\", LEFT);\n                new_position = agent.GetPosition().ToLeft();\n            }\n            break;\n        }\n        case MOVE_RIGHT:\n        {\n            if (battling)\n            {\n                new_position = agent.GetPosition();\n            }\n            else\n            {\n                agent.SetProperty&lt;int&gt;(\"Direction\", RIGHT);\n                new_position = agent.GetPosition().ToRight();\n            }\n            break;\n        }\n        case USE_AXE:\n        {\n            new_position = agent.GetPosition();\n            look_position = LookAhead(agent);\n            if (main_grid.IsValid(look_position) &amp;&amp; main_grid.At(look_position) == tree_id)\n            {\n                DoActionTestNewPositionTree(agent, look_position);\n            } else {\n                agent.Notify(\"You can not use an Axe here!\");\n            }\n            break;\n        }\n        case USE_BOAT:\n        {\n            new_position = agent.GetPosition();\n            if (main_grid.At(new_position) == water_id)\n            {\n              agent.Notify(\"Already on Water\");\n              break;\n            }\n            look_position = LookAhead(agent);\n            if (main_grid.IsValid(look_position) &amp;&amp; main_grid.At(look_position) == water_id)\n            {\n                if (DoActionTestNewPositionWater(agent))\n                {\n                    new_position = look_position;\n                }\n            } else {\n                agent.Notify(\"You can not use a Boat here!\");\n            }\n            break;\n        }\n        case STATS:\n        {\n            new_position = agent.GetPosition();\n            StatsAction(agent);\n            break;\n        }\n        case HEAL:\n        {\n            new_position = agent.GetPosition();\n            if (battling)\n            {\n                move = 'h';\n            }\n            else\n            {\n                HealAction(agent);\n            }\n            break;\n        }\n        case RUN:\n        {\n            if (!battling)\n            {\n                new_position = agent.GetPosition();\n                break;\n            }\n            new_position = agent.GetPosition();\n            agent.SetProperty&lt;bool&gt;(\"Battling\", false);\n\n            auto agents = FindAgentsNear(agent.GetPosition(), 1);\n            for (auto agent_id : agents)\n            {\n                if (!agent_map[agent_id]-&gt;IsInterface() &amp;&amp; !agent_map[agent_id]-&gt;HasProperty(\"deleted\"))\n                {\n                    agent.Notify(\"You are running away\");\n                    agent_map[agent_id]-&gt;SetProperty&lt;bool&gt;(\"Battling\", false);\n                    DoBattle(*agent_map[agent_id], agent, 'r');\n                }\n            }\n            break;\n        }\n        case ATTACK:\n        {\n            move = 'a';\n            break;\n        }\n        case SPECIAL:\n        {\n            move = 's';\n            break;\n        }\n        case BUFF:\n        {\n            move = 'b';\n            break;\n        }\n        case HELP:\n        {\n            new_position = agent.GetPosition();\n            MoveSetAction(agent);\n            break;\n        }\n      }\n\n      if (move != ' ')\n      {\n          if (agent.GetProperty&lt;bool&gt;(\"Battling\") == false)\n          {\n              agent.Notify(\"You are in a battle! Use Y and choose battling moves!\");\n          }\n          auto agents = FindAgentsNear(agent.GetPosition(), 1);\n          for (auto agent_id : agents)\n          {\n              // Battle other agent near the player\n              if (!agent_map[agent_id]-&gt;IsInterface() &amp;&amp; !agent_map[agent_id]-&gt;HasProperty(\"deleted\"))\n              {\n                  agent.SetProperty&lt;bool&gt;(\"Battling\", true);\n                  agent_map[agent_id]-&gt;SetProperty&lt;bool&gt;(\"Battling\", true);\n                  DoBattle(*agent_map[agent_id], agent, move);\n                  break;\n              }\n          }\n          new_position = agent.GetPosition();\n      }\n\n      // assume new position is valid\n      return new_position;\n\n    }\n\n    size_t FindItem(cse491::AgentBase &amp; agent, const std::string &amp; item_name) {\n      size_t item_id = SIZE_MAX;\n      for (auto &amp; item : item_map)\n      {\n        if (item.second-&gt;GetName() == item_name &amp;&amp; item.second-&gt;IsOwnedBy(agent.GetID()))\n        {\n          item_id = item.second-&gt;GetID();\n          break;\n        }\n      }\n      return item_id;\n    }\n\n    void DoActionTestNewPositionTree(cse491::AgentBase &amp; agent, const cse491::GridPosition &amp; new_position) {\n        size_t item_id = FindItem(agent, \"Axe\");\n        if (item_id != SIZE_MAX)\n        {\n          agent.Notify(\"You have used your Axe to chop down this tree. You have \" +\n                        std::to_string(item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") - 1) + \" uses remaining\");\n\n          // decrement uses by 1, change the tree to grass\n          item_map[item_id]-&gt;SetProperty(\"Uses\", item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") - 1);\n          if (item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") == 0)\n          {\n            agent.RemoveItem(item_id);\n            RemoveItem(item_id);\n          }\n          main_grid[new_position] = grass_id;\n        }\n    }\n\n\n    bool DoActionTestNewPositionWater(cse491::AgentBase&amp; agent) {\n        size_t item_id = FindItem(agent, \"Boat\");\n        if (item_id != SIZE_MAX)\n        {\n            agent.Notify(\"You have used your Boat to float on the water. You have \" +\n                          std::to_string(item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") - 1) + \" uses remaining\");\n\n            // decrement uses by 1\n            item_map[item_id]-&gt;SetProperty(\"Uses\", item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") - 1);\n            if (item_map[item_id]-&gt;GetProperty&lt;int&gt;(\"Uses\") == 0)\n            {\n                agent.RemoveItem(item_id);\n                RemoveItem(item_id);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    int DoAction(cse491::AgentBase &amp; agent, size_t action_id) override {\n\n      cse491::GridPosition new_position = DoActionFindNewPosition(agent, action_id);\n\n      // Don't let the agent move off the world or into a wall.\n      if (!main_grid.IsValid(new_position)) { return false; }\n\n      DoActionAttemptItemPickup(agent, new_position);\n\n      if (main_grid.At(new_position) == tree_id)\n      {\n          return false;\n      }\n\n      if (main_grid.At(new_position) == water_id)\n      {\n          if (agent.HasProperty(\"OnlyWater\"))\n          {\n              agent.SetPosition(new_position);\n              return true;\n          }\n          if (action_id != USE_BOAT &amp;&amp; main_grid.At(agent.GetPosition()) != water_id) { return false; }\n      }\n\n      if (main_grid.At(new_position) == grass_id)\n      {\n        if (agent.HasProperty(\"OnlyWater\")) { return false; }\n      }\n\n      if (main_grid.At(new_position) == rock_id)\n      {\n        return false;\n      }\n\n      if (main_grid.At(new_position) == portal_id_a)\n      {\n          // which portal should we go to - for medium grid\n          if (new_position.GetX() == 33)\n              new_position = cse491::GridPosition(3, 1);\n          else if (new_position.GetX() == 3)\n              new_position = cse491::GridPosition(33, 0);\n\n          // for large grid, big right sand patch (x=137) to circle lake island (x=41)\n          else if (new_position.GetX() == 137)\n              new_position = cse491::GridPosition(41, 98);\n          else if (new_position.GetX() == 41)\n              new_position = cse491::GridPosition(137, 40);\n      }\n\n      if (main_grid.At(new_position) == portal_id_b)\n      {\n          // for medium grid\n          if (new_position.GetX() == 44)\n              new_position = cse491::GridPosition(2, 10);\n          else if (new_position.GetX() == 2)\n              new_position = cse491::GridPosition(44, 17);\n\n          // for large grid, tree-locked upper left sand patch(x=32) to lower right along water (x=114)\n          else if (new_position.GetX() == 32)\n              new_position = cse491::GridPosition(114, 132);\n          else if (new_position.GetX() == 114)\n              new_position = cse491::GridPosition(32, 36);\n\n      }\n\n      if (main_grid.At(new_position) == portal_id_c)\n      {\n          // above top right lake (x=120) to left of circle lake (x=16)\n          if (new_position.GetX() == 120)\n              new_position = cse491::GridPosition(16, 140);\n          else if (new_position.GetX() == 16)\n              new_position = cse491::GridPosition(120, 25);\n      }\n\n      if (main_grid.At(new_position) == portal_id_d)\n      {\n          // from circle lake island (x=36) to very bottom right corner (x=146)\n          if (new_position.GetX() == 36)\n              new_position = cse491::GridPosition(146, 147);\n          else if (new_position.GetX() == 146)\n              new_position = cse491::GridPosition(36, 94);\n      }\n\n      // Set the agent to its new postion.\n      agent.SetPosition(new_position);\n\n      return true;\n    }\n\n    [[nodiscard]] bool IsTraversable(const cse491::AgentBase &amp; /*agent*/, cse491::GridPosition pos) const override {\n      return main_grid.At(pos) == grass_id;\n    }\n\n  };\n\n} // End of namespace cse491_team8\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_maze_world_8hpp/","title":"File MazeWorld.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; MazeWorld.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"../Agents/PathAgent.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_maze_world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cse491 A World that consists only of walls and open cells."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_maze_world_8hpp/#classes","title":"Classes","text":"Type Name class MazeWorld <p>The documentation for this class was generated from the following file <code>source/Worlds/MazeWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_maze_world_8hpp_source/","title":"File MazeWorld.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; MazeWorld.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"../Agents/PathAgent.hpp\"\n#include \"../core/WorldBase.hpp\"\n\nnamespace cse491 {\n\nclass MazeWorld : public WorldBase {\n protected:\n  enum ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    MOVE_ARBITRARY\n  };\n\n  size_t floor_id; \n  size_t wall_id;  \n\n public:\n  MazeWorld(unsigned int seed = 0) : WorldBase(seed) {\n    // Create cell types\n\n    floor_id =\n        AddCellType(\"floor\", \"Floor that you can easily walk over.\", ' ');\n    wall_id = AddCellType(\n        \"wall\", \"Impenetrable wall that you must find a way around.\", '#');\n    // Set cell type properties\n    type_options.at(floor_id).SetProperty(CellType::CELL_WALL);\n    // Load map\n    main_grid.Read(\"../assets/grids/default_maze.grid\", type_options);\n  }\n  ~MazeWorld() = default;\n\n  using WorldBase::ConfigAgent;\n  void ConfigAgent(AgentBase &amp;agent) const override {\n    agent.AddAction(\"up\", MOVE_UP);\n    agent.AddAction(\"down\", MOVE_DOWN);\n    agent.AddAction(\"left\", MOVE_LEFT);\n    agent.AddAction(\"right\", MOVE_RIGHT);\n    agent.AddAction(\"move_arbitrary\", MOVE_ARBITRARY);\n  }\n\n  void ConfigAgent(AgentBase &amp;agent) override {\n    agent.AddAction(\"up\", MOVE_UP);\n    agent.AddAction(\"down\", MOVE_DOWN);\n    agent.AddAction(\"left\", MOVE_LEFT);\n    agent.AddAction(\"right\", MOVE_RIGHT);\n    agent.AddAction(\"move_arbitrary\", MOVE_ARBITRARY);\n  }\n\n  int DoAction(AgentBase &amp;agent, size_t action_id) override {\n      // Determine where the agent is trying to move.\n      GridPosition new_position;\n      switch (action_id) {\n          case REMAIN_STILL:new_position = agent.GetPosition();\n              break;\n          case MOVE_UP:new_position = agent.GetPosition().Above();\n              break;\n          case MOVE_DOWN:new_position = agent.GetPosition().Below();\n              break;\n          case MOVE_LEFT:new_position = agent.GetPosition().ToLeft();\n              break;\n          case MOVE_RIGHT:new_position = agent.GetPosition().ToRight();\n              break;\n          case MOVE_ARBITRARY:new_position = agent.GetNextPosition();\n              break;\n      }\n\n    // Don't let the agent move off the world or into a wall.\n    if (!main_grid.IsValid(new_position)) { return false; }\n    if (!IsTraversable(agent, new_position)) { return false; }\n\n      // Set the agent to its new position.\n      agent.SetPosition(new_position);\n      return true;\n  }\n\n\n  [[nodiscard]] bool IsTraversable(const AgentBase &amp; /*agent*/, cse491::GridPosition pos) const override {\n    //return !GetCellTypes().at(main_grid.At(pos)).HasProperty(CellType::CELL_WALL);\n    // ^ This doesn't work because we're not assigning any properties to the cell types, so a band-aid solution is to use name\n    return !(GetCellTypes().at(main_grid.At(pos)).name == CellType::CELL_WALL);\n  }\n};\n\n} // End of namespace cse491\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/","title":"File PerlinNoise.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; PerlinNoise.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace siv namespace perlin_detail"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#classes","title":"Classes","text":"Type Name class BasicPerlinNoise &lt;class Float&gt;"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#macros","title":"Macros","text":"Type Name define SIVPERLIN_CONCEPT_URBG  template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;* = nullptr&gt; define SIVPERLIN_CONCEPT_URBG_  template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;*&gt; define SIVPERLIN_DEFAULT_Y  (0.12345) define SIVPERLIN_DEFAULT_Z  (0.34567) define SIVPERLIN_NODISCARD_CXX20 define SIVPERLIN_VERSION  ((SIVPERLIN_VERSION_MAJOR * 100 * 100) + (SIVPERLIN_VERSION_MINOR * 100) + (SIVPERLIN_VERSION_REVISION)) define SIVPERLIN_VERSION_MAJOR  3 define SIVPERLIN_VERSION_MINOR  0 define SIVPERLIN_VERSION_REVISION  0"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_concept_urbg","title":"define SIVPERLIN_CONCEPT_URBG","text":"<pre><code>#define SIVPERLIN_CONCEPT_URBG template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;* = nullptr&gt;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_concept_urbg_","title":"define SIVPERLIN_CONCEPT_URBG_","text":"<pre><code>#define SIVPERLIN_CONCEPT_URBG_ template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;*&gt;\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_default_y","title":"define SIVPERLIN_DEFAULT_Y","text":"<pre><code>#define SIVPERLIN_DEFAULT_Y (0.12345)\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_default_z","title":"define SIVPERLIN_DEFAULT_Z","text":"<pre><code>#define SIVPERLIN_DEFAULT_Z (0.34567)\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_nodiscard_cxx20","title":"define SIVPERLIN_NODISCARD_CXX20","text":"<pre><code>#define SIVPERLIN_NODISCARD_CXX20 \n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_version","title":"define SIVPERLIN_VERSION","text":"<pre><code>#define SIVPERLIN_VERSION ((SIVPERLIN_VERSION_MAJOR * 100 * 100) + (SIVPERLIN_VERSION_MINOR * 100) + (SIVPERLIN_VERSION_REVISION))\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_version_major","title":"define SIVPERLIN_VERSION_MAJOR","text":"<pre><code>#define SIVPERLIN_VERSION_MAJOR 3\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_version_minor","title":"define SIVPERLIN_VERSION_MINOR","text":"<pre><code>#define SIVPERLIN_VERSION_MINOR 0\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp/#define-sivperlin_version_revision","title":"define SIVPERLIN_VERSION_REVISION","text":"<pre><code>#define SIVPERLIN_VERSION_REVISION 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Worlds/PerlinNoise.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_perlin_noise_8hpp_source/","title":"File PerlinNoise.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; PerlinNoise.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n//----------------------------------------------------------------------------------------\n//\n//  siv::PerlinNoise\n//  Perlin noise library for modern C++\n//\n//  Copyright (C) 2013-2021 Ryo Suzuki &lt;reputeless@gmail.com&gt;\n//\n//  Permission is hereby granted, free of charge, to any person obtaining a copy\n//  of this software and associated documentation files(the \"Software\"), to deal\n//  in the Software without restriction, including without limitation the rights\n//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n//  copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions :\n//\n//  The above copyright notice and this permission notice shall be included in\n//  all copies or substantial portions of the Software.\n//\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n//  THE SOFTWARE.\n//\n//----------------------------------------------------------------------------------------\n\n# pragma once\n# include &lt;cstdint&gt;\n# include &lt;algorithm&gt;\n# include &lt;array&gt;\n# include &lt;iterator&gt;\n# include &lt;numeric&gt;\n# include &lt;random&gt;\n# include &lt;type_traits&gt;\n\n# if __has_include(&lt;concepts&gt;) &amp;&amp; defined(__cpp_concepts)\n#   include &lt;concepts&gt;\n# endif\n\n\n// Library major version\n# define SIVPERLIN_VERSION_MAJOR            3\n\n// Library minor version\n# define SIVPERLIN_VERSION_MINOR            0\n\n// Library revision version\n# define SIVPERLIN_VERSION_REVISION         0\n\n// Library version\n# define SIVPERLIN_VERSION          ((SIVPERLIN_VERSION_MAJOR * 100 * 100) + (SIVPERLIN_VERSION_MINOR * 100) + (SIVPERLIN_VERSION_REVISION))\n\n\n// [[nodiscard]] for constructors\n# if (201907L &lt;= __has_cpp_attribute(nodiscard))\n#   define SIVPERLIN_NODISCARD_CXX20 [[nodiscard]]\n# else\n#   define SIVPERLIN_NODISCARD_CXX20\n# endif\n\n\n// std::uniform_random_bit_generator concept\n# if __cpp_lib_concepts\n#   define SIVPERLIN_CONCEPT_URBG  template &lt;std::uniform_random_bit_generator URBG&gt;\n#   define SIVPERLIN_CONCEPT_URBG_ template &lt;std::uniform_random_bit_generator URBG&gt;\n# else\n#   define SIVPERLIN_CONCEPT_URBG  template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;* = nullptr&gt;\n#   define SIVPERLIN_CONCEPT_URBG_ template &lt;class URBG, std::enable_if_t&lt;std::conjunction_v&lt;std::is_invocable&lt;URBG&amp;&gt;, std::is_unsigned&lt;std::invoke_result_t&lt;URBG&amp;&gt;&gt;&gt;&gt;*&gt;\n# endif\n\n\n// arbitrary value for increasing entropy\n# ifndef SIVPERLIN_DEFAULT_Y\n#   define SIVPERLIN_DEFAULT_Y (0.12345)\n# endif\n\n// arbitrary value for increasing entropy\n# ifndef SIVPERLIN_DEFAULT_Z\n#   define SIVPERLIN_DEFAULT_Z (0.34567)\n# endif\n\n\nnamespace siv\n{\n    template &lt;class Float&gt;\n    class BasicPerlinNoise\n    {\n    public:\n\n        static_assert(std::is_floating_point_v&lt;Float&gt;);\n\n        //\n        //  Typedefs\n        //\n\n        using state_type = std::array&lt;std::uint8_t, 256&gt;;\n\n        using value_type = Float;\n\n        using default_random_engine = std::mt19937;\n\n        using seed_type = typename default_random_engine::result_type;\n\n        //\n        //  Constructors\n        //\n\n        SIVPERLIN_NODISCARD_CXX20\n        constexpr BasicPerlinNoise() noexcept;\n\n        SIVPERLIN_NODISCARD_CXX20\n        explicit BasicPerlinNoise(seed_type seed);\n\n        SIVPERLIN_CONCEPT_URBG\n        SIVPERLIN_NODISCARD_CXX20\n        explicit BasicPerlinNoise(URBG&amp;&amp; urbg);\n\n        //\n        //  Reseed\n        //\n\n        void reseed(seed_type seed);\n\n        SIVPERLIN_CONCEPT_URBG\n        void reseed(URBG&amp;&amp; urbg);\n\n        //\n        //  Serialization\n        //\n\n        [[nodiscard]]\n        constexpr const state_type&amp; serialize() const noexcept;\n\n        constexpr void deserialize(const state_type&amp; state) noexcept;\n\n        //\n        //  Noise (The result is in the range [-1, 1])\n        //\n\n        [[nodiscard]]\n        value_type noise1D(value_type x) const noexcept;\n\n        [[nodiscard]]\n        value_type noise2D(value_type x, value_type y) const noexcept;\n\n        [[nodiscard]]\n        value_type noise3D(value_type x, value_type y, value_type z) const noexcept;\n\n        //\n        //  Noise (The result is remapped to the range [0, 1])\n        //\n\n        [[nodiscard]]\n        value_type noise1D_01(value_type x) const noexcept;\n\n        [[nodiscard]]\n        value_type noise2D_01(value_type x, value_type y) const noexcept;\n\n        [[nodiscard]]\n        value_type noise3D_01(value_type x, value_type y, value_type z) const noexcept;\n\n        //\n        //  Octave noise (The result can be out of the range [-1, 1])\n        //\n\n        [[nodiscard]]\n        value_type octave1D(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave2D(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave3D(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        //\n        //  Octave noise (The result is clamped to the range [-1, 1])\n        //\n\n        [[nodiscard]]\n        value_type octave1D_11(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave2D_11(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave3D_11(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        //\n        //  Octave noise (The result is clamped and remapped to the range [0, 1])\n        //\n\n        [[nodiscard]]\n        value_type octave1D_01(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave2D_01(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type octave3D_01(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        //\n        //  Octave noise (The result is normalized to the range [-1, 1])\n        //\n\n        [[nodiscard]]\n        value_type normalizedOctave1D(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type normalizedOctave2D(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type normalizedOctave3D(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        //\n        //  Octave noise (The result is normalized and remapped to the range [0, 1])\n        //\n\n        [[nodiscard]]\n        value_type normalizedOctave1D_01(value_type x, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type normalizedOctave2D_01(value_type x, value_type y, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n        [[nodiscard]]\n        value_type normalizedOctave3D_01(value_type x, value_type y, value_type z, std::int32_t octaves, value_type persistence = value_type(0.5)) const noexcept;\n\n    private:\n\n        state_type m_permutation;\n    };\n\n    using PerlinNoise = BasicPerlinNoise&lt;double&gt;;\n\n    namespace perlin_detail\n    {\n        //\n        //  These functions are provided for consistency.\n        //  You may get different results from std::shuffle() with different standard library implementations.\n        //\n        SIVPERLIN_CONCEPT_URBG\n        [[nodiscard]]\n        inline std::uint64_t Random(const std::uint64_t max, URBG&amp;&amp; urbg)\n        {\n            return (urbg() % (max + 1));\n        }\n\n        template &lt;class RandomIt, class URBG&gt;\n        inline void Shuffle(RandomIt first, RandomIt last, URBG&amp;&amp; urbg)\n        {\n            if (first == last)\n            {\n                return;\n            }\n\n            using difference_type = typename std::iterator_traits&lt;RandomIt&gt;::difference_type;\n\n            for (RandomIt it = first + 1; it &lt; last; ++it)\n            {\n                const std::uint64_t n = static_cast&lt;std::uint64_t&gt;(it - first);\n                std::iter_swap(it, first + static_cast&lt;difference_type&gt;(Random(n, std::forward&lt;URBG&gt;(urbg))));\n            }\n        }\n        //\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Fade(const Float t) noexcept\n        {\n            return t * t * t * (t * (t * 6 - 15) + 10);\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Lerp(const Float a, const Float b, const Float t) noexcept\n        {\n            return (a + (b - a) * t);\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Grad(const std::uint8_t hash, const Float x, const Float y, const Float z) noexcept\n        {\n            const std::uint8_t h = hash &amp; 15;\n            const Float u = h &lt; 8 ? x : y;\n            const Float v = h &lt; 4 ? y : h == 12 || h == 14 ? x : z;\n            return ((h &amp; 1) == 0 ? u : -u) + ((h &amp; 2) == 0 ? v : -v);\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Remap_01(const Float x) noexcept\n        {\n            return (x * Float(0.5) + Float(0.5));\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float Clamp_11(const Float x) noexcept\n        {\n            return std::clamp(x, Float(-1.0), Float(1.0));\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float RemapClamp_01(const Float x) noexcept\n        {\n            if (x &lt;= Float(-1.0))\n            {\n                return Float(0.0);\n            }\n            else if (Float(1.0) &lt;= x)\n            {\n                return Float(1.0);\n            }\n\n            return (x * Float(0.5) + Float(0.5));\n        }\n\n        template &lt;class Noise, class Float&gt;\n        [[nodiscard]]\n        inline auto Octave1D(const Noise&amp; noise, Float x, const std::int32_t octaves, const Float persistence) noexcept\n        {\n            using value_type = Float;\n            value_type result = 0;\n            value_type amplitude = 1;\n\n            for (std::int32_t i = 0; i &lt; octaves; ++i)\n            {\n                result += (noise.noise1D(x) * amplitude);\n                x *= 2;\n                amplitude *= persistence;\n            }\n\n            return result;\n        }\n\n        template &lt;class Noise, class Float&gt;\n        [[nodiscard]]\n        inline auto Octave2D(const Noise&amp; noise, Float x, Float y, const std::int32_t octaves, const Float persistence) noexcept\n        {\n            using value_type = Float;\n            value_type result = 0;\n            value_type amplitude = 1;\n\n            for (std::int32_t i = 0; i &lt; octaves; ++i)\n            {\n                result += (noise.noise2D(x, y) * amplitude);\n                x *= 2;\n                y *= 2;\n                amplitude *= persistence;\n            }\n\n            return result;\n        }\n\n        template &lt;class Noise, class Float&gt;\n        [[nodiscard]]\n        inline auto Octave3D(const Noise&amp; noise, Float x, Float y, Float z, const std::int32_t octaves, const Float persistence) noexcept\n        {\n            using value_type = Float;\n            value_type result = 0;\n            value_type amplitude = 1;\n\n            for (std::int32_t i = 0; i &lt; octaves; ++i)\n            {\n                result += (noise.noise3D(x, y, z) * amplitude);\n                x *= 2;\n                y *= 2;\n                z *= 2;\n                amplitude *= persistence;\n            }\n\n            return result;\n        }\n\n        template &lt;class Float&gt;\n        [[nodiscard]]\n        inline constexpr Float MaxAmplitude(const std::int32_t octaves, const Float persistence) noexcept\n        {\n            using value_type = Float;\n            value_type result = 0;\n            value_type amplitude = 1;\n\n            for (std::int32_t i = 0; i &lt; octaves; ++i)\n            {\n                result += amplitude;\n                amplitude *= persistence;\n            }\n\n            return result;\n        }\n    }\n\n\n    template &lt;class Float&gt;\n    inline constexpr BasicPerlinNoise&lt;Float&gt;::BasicPerlinNoise() noexcept\n            : m_permutation{ 151,160,137,91,90,15,\n                             131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n                             190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n                             88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n                             77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n                             102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n                             135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n                             5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n                             223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n                             129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n                             251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n                             49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n                             138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 } {}\n\n    template &lt;class Float&gt;\n    inline BasicPerlinNoise&lt;Float&gt;::BasicPerlinNoise(const seed_type seed)\n    {\n        reseed(seed);\n    }\n\n    template &lt;class Float&gt;\n    SIVPERLIN_CONCEPT_URBG_\n    inline BasicPerlinNoise&lt;Float&gt;::BasicPerlinNoise(URBG&amp;&amp; urbg)\n    {\n        reseed(std::forward&lt;URBG&gt;(urbg));\n    }\n\n\n    template &lt;class Float&gt;\n    inline void BasicPerlinNoise&lt;Float&gt;::reseed(const seed_type seed)\n    {\n        reseed(default_random_engine{ seed });\n    }\n\n    template &lt;class Float&gt;\n    SIVPERLIN_CONCEPT_URBG_\n    inline void BasicPerlinNoise&lt;Float&gt;::reseed(URBG&amp;&amp; urbg)\n    {\n        std::iota(m_permutation.begin(), m_permutation.end(), uint8_t{ 0 });\n\n        perlin_detail::Shuffle(m_permutation.begin(), m_permutation.end(), std::forward&lt;URBG&gt;(urbg));\n    }\n\n\n    template &lt;class Float&gt;\n    inline constexpr const typename BasicPerlinNoise&lt;Float&gt;::state_type&amp; BasicPerlinNoise&lt;Float&gt;::serialize() const noexcept\n    {\n        return m_permutation;\n    }\n\n    template &lt;class Float&gt;\n    inline constexpr void BasicPerlinNoise&lt;Float&gt;::deserialize(const state_type&amp; state) noexcept\n    {\n        m_permutation = state;\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise1D(const value_type x) const noexcept\n    {\n        return noise3D(x,\n                       static_cast&lt;value_type&gt;(SIVPERLIN_DEFAULT_Y),\n                       static_cast&lt;value_type&gt;(SIVPERLIN_DEFAULT_Z));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise2D(const value_type x, const value_type y) const noexcept\n    {\n        return noise3D(x,\n                       y,\n                       static_cast&lt;value_type&gt;(SIVPERLIN_DEFAULT_Z));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise3D(const value_type x, const value_type y, const value_type z) const noexcept\n    {\n        const value_type _x = std::floor(x);\n        const value_type _y = std::floor(y);\n        const value_type _z = std::floor(z);\n\n        const std::int32_t ix = static_cast&lt;std::int32_t&gt;(_x) &amp; 255;\n        const std::int32_t iy = static_cast&lt;std::int32_t&gt;(_y) &amp; 255;\n        const std::int32_t iz = static_cast&lt;std::int32_t&gt;(_z) &amp; 255;\n\n        const value_type fx = (x - _x);\n        const value_type fy = (y - _y);\n        const value_type fz = (z - _z);\n\n        const value_type u = perlin_detail::Fade(fx);\n        const value_type v = perlin_detail::Fade(fy);\n        const value_type w = perlin_detail::Fade(fz);\n\n        const std::uint8_t A = (m_permutation[ix &amp; 255] + iy) &amp; 255;\n        const std::uint8_t B = (m_permutation[(ix + 1) &amp; 255] + iy) &amp; 255;\n\n        const std::uint8_t AA = (m_permutation[A] + iz) &amp; 255;\n        const std::uint8_t AB = (m_permutation[(A + 1) &amp; 255] + iz) &amp; 255;\n\n        const std::uint8_t BA = (m_permutation[B] + iz) &amp; 255;\n        const std::uint8_t BB = (m_permutation[(B + 1) &amp; 255] + iz) &amp; 255;\n\n        const value_type p0 = perlin_detail::Grad(m_permutation[AA], fx, fy, fz);\n        const value_type p1 = perlin_detail::Grad(m_permutation[BA], fx - 1, fy, fz);\n        const value_type p2 = perlin_detail::Grad(m_permutation[AB], fx, fy - 1, fz);\n        const value_type p3 = perlin_detail::Grad(m_permutation[BB], fx - 1, fy - 1, fz);\n        const value_type p4 = perlin_detail::Grad(m_permutation[(AA + 1) &amp; 255], fx, fy, fz - 1);\n        const value_type p5 = perlin_detail::Grad(m_permutation[(BA + 1) &amp; 255], fx - 1, fy, fz - 1);\n        const value_type p6 = perlin_detail::Grad(m_permutation[(AB + 1) &amp; 255], fx, fy - 1, fz - 1);\n        const value_type p7 = perlin_detail::Grad(m_permutation[(BB + 1) &amp; 255], fx - 1, fy - 1, fz - 1);\n\n        const value_type q0 = perlin_detail::Lerp(p0, p1, u);\n        const value_type q1 = perlin_detail::Lerp(p2, p3, u);\n        const value_type q2 = perlin_detail::Lerp(p4, p5, u);\n        const value_type q3 = perlin_detail::Lerp(p6, p7, u);\n\n        const value_type r0 = perlin_detail::Lerp(q0, q1, v);\n        const value_type r1 = perlin_detail::Lerp(q2, q3, v);\n\n        return perlin_detail::Lerp(r0, r1, w);\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise1D_01(const value_type x) const noexcept\n    {\n        return perlin_detail::Remap_01(noise1D(x));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise2D_01(const value_type x, const value_type y) const noexcept\n    {\n        return perlin_detail::Remap_01(noise2D(x, y));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::noise3D_01(const value_type x, const value_type y, const value_type z) const noexcept\n    {\n        return perlin_detail::Remap_01(noise3D(x, y, z));\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave1D(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Octave1D(*this, x, octaves, persistence);\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave2D(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Octave2D(*this, x, y, octaves, persistence);\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave3D(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Octave3D(*this, x, y, z, octaves, persistence);\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave1D_11(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Clamp_11(octave1D(x, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave2D_11(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Clamp_11(octave2D(x, y, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave3D_11(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Clamp_11(octave3D(x, y, z, octaves, persistence));\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave1D_01(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::RemapClamp_01(octave1D(x, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave2D_01(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::RemapClamp_01(octave2D(x, y, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::octave3D_01(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::RemapClamp_01(octave3D(x, y, z, octaves, persistence));\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave1D(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return (octave1D(x, octaves, persistence) / perlin_detail::MaxAmplitude(octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave2D(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return (octave2D(x, y, octaves, persistence) / perlin_detail::MaxAmplitude(octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave3D(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return (octave3D(x, y, z, octaves, persistence) / perlin_detail::MaxAmplitude(octaves, persistence));\n    }\n\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave1D_01(const value_type x, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Remap_01(normalizedOctave1D(x, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave2D_01(const value_type x, const value_type y, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Remap_01(normalizedOctave2D(x, y, octaves, persistence));\n    }\n\n    template &lt;class Float&gt;\n    inline typename BasicPerlinNoise&lt;Float&gt;::value_type BasicPerlinNoise&lt;Float&gt;::normalizedOctave3D_01(const value_type x, const value_type y, const value_type z, const std::int32_t octaves, const value_type persistence) const noexcept\n    {\n        return perlin_detail::Remap_01(normalizedOctave3D(x, y, z, octaves, persistence));\n    }\n}\n\n# undef SIVPERLIN_NODISCARD_CXX20\n# undef SIVPERLIN_CONCEPT_URBG\n# undef SIVPERLIN_CONCEPT_URBG_\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_program_executor_8hpp/","title":"File ProgramExecutor.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; ProgramExecutor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Language.hpp\"</code></li> <li><code>#include \"core/WorldBase.hpp\"</code></li> <li><code>#include \"core/EasyLogging.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;stack&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include \"core/AgentBase.hpp\"</code></li> <li><code>#include \"Interfaces/TrashInterface.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_program_executor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace worldlang Namespace for scripting language stuff."},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_program_executor_8hpp/#classes","title":"Classes","text":"Type Name class ProgramExecutor Class that manages program execution. struct Identifier <p>The documentation for this class was generated from the following file <code>source/Worlds/ProgramExecutor.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_program_executor_8hpp_source/","title":"File ProgramExecutor.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; ProgramExecutor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n#pragma once\n\n#include \"Language.hpp\"\n\n#include \"core/WorldBase.hpp\"\n#include \"core/EasyLogging.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;stack&gt;\n#include &lt;variant&gt;\n\n#include \"core/AgentBase.hpp\"\n#include \"Interfaces/TrashInterface.hpp\"\n\n#ifdef USE_SFML_INTERFACE\n#include \"Interfaces/MainInterface.hpp\"\n#endif\n\nusing cse491::AgentBase;\nusing cse491::Entity;\nusing cse491::CellType;\nusing clogged::Logger;\nusing clogged::Team;\nusing clogged::LogLevel;\n\nnamespace worldlang {\n\n    class ProgramExecutor {\n    // Internal types\n    public:\n        using Callable = std::function&lt;void(ProgramExecutor&amp;)&gt;;\n\n        struct Identifier : std::string {};\n\n        using Value = std::variant &lt; size_t, double, std::string, Callable, Identifier &gt;;\n\n    // Execution state\n    private:\n        std::map&lt;std::string, std::vector&lt;Unit&gt;&gt; scripts;\n\n        std::vector&lt;Unit&gt;* code = nullptr;\n\n        size_t index = 0;\n\n        std::map &lt; std::string, Value &gt; variables{};\n\n        std::stack &lt; Value &gt; stack{};\n\n        std::stack &lt; std::vector&lt; Value &gt; &gt; call_stack{};\n\n        std::string error_message{};\n\n    // Public methods\n    public:\n        ProgramExecutor(){\n            // if function\n            // skips a block if value is false\n            registerFunction(\"if\", [this](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 1) { error(\"Wrong number of arguments!\"); return; }\n                // jump to end of block if false\n\n                if (pe.as&lt;double&gt;(args.at(0)) == 0){\n                    skipBlock();\n                } else {\n                    // advance to start of block automatically\n                }\n                // mark type of block entered\n                call_stack.push({\"__IF_BLOCK\"});\n            });\n            // for function\n            registerFunction(\"for\", [this](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 3 &amp;&amp; args.size() != 4) { error(\"Wrong number of arguments!\"); return; }\n                auto var = pe.as&lt;Identifier&gt;(args.at(0));\n                auto start = pe.as&lt;double&gt;(args.at(1));\n                auto end = pe.as&lt;double&gt;(args.at(2));\n                auto step = args.size() == 4 ? pe.as&lt;double&gt;(args.at(3)) : 1.0;\n\n                variables.insert_or_assign(static_cast&lt;std::string&gt;(var), start);\n\n                auto value = pe.as&lt;double&gt;(args.at(0));\n                if ((start &lt; end &amp;&amp; step &gt; 0 &amp;&amp; value &lt;= end)\n                    || (start &gt;= end &amp;&amp; step &lt; 0 &amp;&amp; value &gt;= end)){\n                    // enter the loop if conditions are met\n                    call_stack.push({\"__FOR_BLOCK\", var, start, end, step, static_cast&lt;double&gt;(index)});\n                    index++; // skip start_block which checks condition + increments\n                } else {\n                    // skip loop entirely\n                    skipBlock();\n                    index++; // skip end_block or else it tries to jump to beginning\n                }\n            });\n            // Log some values\n            registerFunction(\"print\", [](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                for (auto a : args){\n                    if (pe.has&lt;double&gt;(a)){\n                        std::cout &lt;&lt; pe.as&lt;double&gt;(a);\n                    } else if (pe.has&lt;size_t&gt;(a)){\n                        std::cout &lt;&lt; pe.as&lt;size_t&gt;(a);\n                    } else if (pe.has&lt;std::string&gt;(a)){\n                        std::cout &lt;&lt; pe.as&lt;std::string&gt;(a);\n                    } else if (pe.has&lt;Callable&gt;(a)){\n                        std::cout &lt;&lt; \"&lt;Callable&gt;\";\n                    }\n                }\n                std::cout &lt;&lt; std::endl;\n            });\n        }\n\n        ProgramExecutor(cse491::WorldBase&amp; world) : ProgramExecutor(){\n            // Load world grid from file\n            registerFunction(\"loadWorld\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 1) { error(\"Wrong number of arguments!\"); return; }\n                world.GetGrid().Read(as&lt;std::string&gt;(args.at(0)), world.GetCellTypes());\n            });\n            // Get the size of the world\n            registerFunction(\"getWorldSize\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 0) { error(\"Wrong number of arguments!\"); return; }\n                pe.pushStack(static_cast&lt;double&gt;(world.GetGrid().GetWidth()));\n                pe.pushStack(static_cast&lt;double&gt;(world.GetGrid().GetHeight()));\n            });\n            // Create an agent\n            registerFunction(\"addAgent\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() &lt; 5) { error(\"Wrong number of arguments!\"); return; }\n                // type, name, symbol, x, y\n                auto type = pe.as&lt;std::string&gt;(args[0]);\n                auto name = pe.as&lt;std::string&gt;(args[1]);\n                auto symbol = pe.as&lt;std::string&gt;(args[2]);\n                auto x = pe.as&lt;double&gt;(args[3]);\n                auto y = pe.as&lt;double&gt;(args[4]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n                if (!symbol.size()) { error(\"Symbol cannot be empty!\"); return; }\n\n                //TODO:Use the agent Factory class here, see if that works better.\n                AgentBase* agent;\n                if (type == \"Player\"){\n                    agent = &amp;world.AddAgent&lt;cse491::TrashInterface&gt;(name, \"symbol\", symbol[0]);\n                    agent-&gt;SetPosition(x, y);\n                } \n#ifdef USE_SFML_INTERFACE\n        else if (type == \"Player2D\") {\n                    agent = &amp;world.AddAgent&lt;i_2D::MainInterface&gt;(name, \"symbol\", symbol[0]);\n                    agent-&gt;SetPosition(x, y);\n        } \n#endif \n        else {\n                    error(\"Unknown agent type!\"); return;\n                }\n\n                pe.pushStack(agent-&gt;GetID());\n            });\n            // Set agent property\n            registerFunction(\"setProperty\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 3) { error(\"Wrong number of arguments!\"); return; }\n                auto id = pe.as&lt;size_t&gt;(args[0]);\n                auto prop = pe.as&lt;std::string&gt;(args[1]);\n                auto value = args[2];\n\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                Entity&amp; agent = world.HasAgent(id) ? static_cast&lt;Entity&amp;&gt;(world.GetAgent(id)) : world.GetItem(id);\n                if (pe.has&lt;double&gt;(value)){\n                    agent.SetProperty(prop, as&lt;double&gt;(value));\n                } else if (pe.has&lt;std::string&gt;(value)){\n                    auto s = as&lt;std::string&gt;(value);\n                    // silly hack\n                    if (s.size() == 1){\n                        agent.SetProperty(prop, s[0]);\n                    } else {\n                        agent.SetProperty(prop, s);\n                    }\n                } else {\n                    error(\"Unsupported property type!\");\n                }\n            });\n            // Get agent property\n            registerFunction(\"getProperty\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto id = pe.as&lt;size_t&gt;(args[0]);\n                auto prop = pe.as&lt;std::string&gt;(args[1]);\n\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                Entity&amp; agent = world.HasAgent(id) ? static_cast&lt;Entity&amp;&gt;(world.GetAgent(id)) : world.GetItem(id);\n                if(agent.HasProperty(prop)){\n                    // property exists but type is unknown\n                    // assume double, as there is no way to determine the type currently\n                    // TODO: Fix this if types are ever stored\n                    pushStack(agent.GetProperty&lt;double&gt;(prop));\n                } else {\n                    error(\"Undefined property:\" + prop);\n                }\n            });\n            // Check if property exists\n            registerFunction(\"hasProperty\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto id = pe.as&lt;size_t&gt;(args[0]);\n                auto prop = pe.as&lt;std::string&gt;(args[1]);\n\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                Entity&amp; agent = world.HasAgent(id) ? static_cast&lt;Entity&amp;&gt;(world.GetAgent(id)) : world.GetItem(id);\n                if(agent.HasProperty(prop)){\n                    pushStack(1.0);\n                } else {\n                    pushStack(0.0);\n                }\n            });\n            // Get agent position\n            registerFunction(\"getAgentPosition\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 1) { error(\"Wrong number of arguments!\"); return; }\n                auto id = pe.as&lt;size_t&gt;(args[0]);\n\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                AgentBase&amp; agent = world.GetAgent(id);\n                auto x = agent.GetPosition().GetX();\n                auto y = agent.GetPosition().GetY();\n                pushStack(x);\n                pushStack(y);\n            });\n            // Set agent position\n            registerFunction(\"setAgentPosition\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 3) { error(\"Wrong number of arguments!\"); return; }\n                auto agent_id = pe.as&lt;size_t&gt;(args[0]);\n                auto x = pe.as&lt;double&gt;(args[1]);\n                auto y = pe.as&lt;double&gt;(args[2]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                AgentBase&amp; agent = world.GetAgent(agent_id);\n                agent.SetPosition(x, y);\n            });\n            // Get agent at this position\n            registerFunction(\"findAgentAt\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto x = pe.as&lt;double&gt;(args[0]);\n                auto y = pe.as&lt;double&gt;(args[1]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                auto res = world.FindAgentsAt({x, y});\n                if (res.size()){\n                    pe.pushStack(res[0]);\n                } else {\n                    pe.pushStack(0u);\n                }\n            });\n            // Get item at this position\n            registerFunction(\"findItemAt\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto x = pe.as&lt;double&gt;(args[0]);\n                auto y = pe.as&lt;double&gt;(args[1]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                auto res = world.FindItemsAt({x, y});\n                if (res.size()){\n                    pe.pushStack(res[0]);\n                } else {\n                    pe.pushStack(0u);\n                }\n            });\n            // Get size of the agent's inventory\n            registerFunction(\"getInventorySize\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 1) { error(\"Wrong number of arguments!\"); return; }\n                auto agent_id = pe.as&lt;size_t&gt;(args[0]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                AgentBase&amp; agent = world.GetAgent(agent_id);\n                pe.pushStack(static_cast&lt;double&gt;(agent.GetInventory().size()));\n            });\n            // Gets an item from the inventory\n            registerFunction(\"getInventoryItem\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto agent_id = pe.as&lt;size_t&gt;(args[0]);\n                auto item_index = pe.as&lt;double&gt;(args[1]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                AgentBase&amp; agent = world.GetAgent(agent_id);\n                if (item_index &gt;= agent.GetInventory().size()) {\n                    error(\"Item index out of range!\"); return;\n                }\n\n                pe.pushStack(agent.GetInventory()[item_index]);\n            });\n            // Add an item to the world\n            registerFunction(\"addItem\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                // name,symbol,x,y,prop1,val1,prop2,val2...\n                if (args.size() &lt; 4) { error(\"Wrong number of arguments!\"); return; }\n                auto name = pe.as&lt;std::string&gt;(args[0]);\n                auto symbol = pe.as&lt;std::string&gt;(args[1]);\n                auto x = pe.as&lt;double&gt;(args[2]);\n                auto y = pe.as&lt;double&gt;(args[3]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n                if (symbol.empty()) { error(\"Symbol can't be empty!\"); return; }\n\n                auto item = std::make_unique&lt;cse491::ItemBase&gt;(world.NextEntityID(), name);\n                item-&gt;SetProperties(\"symbol\",symbol.at(0));\n                item-&gt;SetPosition(x,y);\n                item-&gt;SetGrid();\n                for (size_t i = 4; i &lt; args.size(); i += 2){\n                    item-&gt;SetProperty(pe.as&lt;std::string&gt;(args[i]), pe.as&lt;double&gt;(args[i+1]));\n                }\n                pe.pushStack(item-&gt;GetID());\n\n                world.AddItem(std::move(item));\n            });\n            // Gets an item from the inventory\n            registerFunction(\"addInventoryItem\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() != 2) { error(\"Wrong number of arguments!\"); return; }\n                auto owner_id = pe.as&lt;size_t&gt;(args[0]);\n                auto item_id = pe.as&lt;size_t&gt;(args[1]);\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n\n                world.GetItem(item_id).SetPosition(-1,-1);\n                Entity&amp; entity = world.HasAgent(owner_id) ? static_cast&lt;Entity&amp;&gt;(world.GetAgent(owner_id)) : world.GetItem(owner_id);\n                entity.AddItem(item_id);\n            });\n            // Create a new cell type\n            registerFunction(\"addCellType\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() &lt; 3) { error(\"Wrong number of arguments!\"); return; }\n                // name, desc, symbol, props (ignored: TODO later)\n                auto name = pe.as&lt;std::string&gt;(args[0]);\n                auto desc = pe.as&lt;std::string&gt;(args[1]);\n                auto symbol = pe.as&lt;std::string&gt;(args[2]);\n                std::cout &lt;&lt; desc &lt;&lt; \",\" &lt;&lt; name &lt;&lt; \",\" &lt;&lt; symbol &lt;&lt; \",\";\n                if (!symbol.size()) { error(\"Symbol cannot be empty!\"); return; }\n                std::cout &lt;&lt; (int)symbol[0] &lt;&lt; \"\\n\";\n\n                auto id = world.AddCellType(name, desc, symbol[0]);\n                for (size_t i = 3; i &lt; args.size(); ++i){\n                    world.type_options[id].SetProperty(pe.as&lt;std::string&gt;(args[i]));\n                }\n\n                pe.pushStack(id);\n            });\n            // Get a random number\n            registerFunction(\"rand\", [this, &amp;world](ProgramExecutor&amp; pe){\n                auto args = pe.popArgs();\n                if (args.size() &gt; 2) { error(\"Wrong number of arguments!\"); return; }\n                if (args.size() == 0){\n                    // random double in [0,1]\n                    pushStack(world.GetRandom());\n                } else if (args.size() == 1){\n                    // random int in [0,max]\n                    auto max = pe.as&lt;double&gt;(args[0]) + 1;\n                    pushStack((double)(int)world.GetRandom(max)); // casts for rounding\n                } else if (args.size() == 2){\n                    // random int in [min,max]\n                    auto min = pe.as&lt;double&gt;(args[0]);\n                    auto max = pe.as&lt;double&gt;(args[1]) + 1;\n                    pushStack((double)(int)world.GetRandom(min,max)); // casts for rounding\n                }\n                // check for argument errors\n                if (!pe.getErrorMessage().empty()){ return; }\n            });\n            // Set constants\n            setVariable(\"ID_NONE\",0u);\n            setVariable(\"CELL_WALL\", CellType::CELL_WALL);\n            setVariable(\"CELL_WATER\", CellType::CELL_WATER);\n        }\n\n        virtual ~ProgramExecutor() = default;\n\n        void skipBlock(int nest = 0){\n            do {\n                auto&amp; unit = code-&gt;at(++index);\n                if (unit.type == Unit::Type::operation &amp;&amp; unit.value == \"start_block\") nest++;\n                if (unit.type == Unit::Type::operation &amp;&amp; unit.value == \"end_block\") nest--;\n            } while(nest);\n            // points to one past end_block\n            index--;\n            // points to end_block\n        }\n\n        void registerFunction(std::string name, Callable callable){\n            variables.insert_or_assign(name, callable);\n        }\n\n        Value popStack(){\n            auto v = stack.top();\n            stack.pop();\n            return v;\n        }\n\n        std::vector&lt;Value&gt; popArgs(){\n            std::vector&lt; Value &gt; values;\n            do {\n                values.push_back(popStack());\n            } while (!(has&lt;Identifier&gt;(values.back()) \n                    &amp;&amp; static_cast&lt;std::string&gt;(as&lt;Identifier&gt;(values.back())) == \"__INTERNAL_ENDARGS\"));\n            values.pop_back(); // don't keep that one\n            std::reverse(values.begin(), values.end());\n            return values;\n        }\n\n        void pushStack(Value value){\n            stack.push(value);\n        }\n\n        template &lt;typename T&gt;\n        bool has(const Value&amp; a){\n            if (std::holds_alternative&lt;T&gt;(a)){\n                return true;\n            } else if (std::holds_alternative&lt;Identifier&gt;(a)){\n                try {\n                    auto val = variables.at(static_cast&lt;std::string&gt;(std::get&lt;Identifier&gt;(a)));\n                    return std::holds_alternative&lt;T&gt;(val);\n                } catch(const std::out_of_range&amp; e) {\n                    error(\"Variable does not exist!\");\n                }\n            }\n            return false;\n        }\n\n        template &lt;typename T&gt;\n        T as(const Value&amp; a){\n            if (std::holds_alternative&lt;T&gt;(a)){\n                return std::get&lt;T&gt;(a);\n            } else if (std::holds_alternative&lt;Identifier&gt;(a)){\n                auto val = variables.at(static_cast&lt;std::string&gt;(std::get&lt;Identifier&gt;(a)));\n                if (std::holds_alternative&lt;T&gt;(val)){\n                    return std::get&lt;T&gt;(val);\n                }\n            }\n            // error if conversion fails\n            error(std::string{\"Type error in as()! Expected \"}+typeid(T).name());\n            return T{};\n        }\n\n        template &lt;typename T&gt;\n        T var(const std::string&amp; name){\n            auto val = variables.at(name);\n            return std::get&lt;T&gt;(val);\n        }\n\n        void setVariable(const std::string&amp; name, Value value){\n            variables.insert_or_assign(name, value);\n        }\n\n        void error(const std::string&amp; error){\n            if (error_message.empty()){\n                error_message = error;\n            }\n        }\n\n        std::string getErrorMessage(){\n            return error_message;\n        }\n\n        bool runFile(const std::string&amp; filename){\n            //TODO: program preprocessing (add newline to end, remove spaces)\n            if (!scripts.count(filename)){\n                std::ifstream in{filename};\n                std::string s;\n                std::string filedata;\n                while (getline(in, s))\n                    filedata += s + '\\n';\n\n                scripts[filename] = parse_to_code(filedata);\n                if (scripts[filename].empty()){\n                    // implies a parse error\n                    error(\"Error parsing program from file\");\n                    return false;\n                }\n            }\n            code = &amp;scripts[filename];\n            return run();\n        }\n\n        bool run(const std::string&amp; program){\n            scripts[\"__STRING_PROGRAM\"] = parse_to_code(program);\n            code = &amp;scripts[\"__STRING_PROGRAM\"];\n            if (code-&gt;empty()){\n                error(\"Error parsing program from string\");\n                return false;\n            }\n            return run();\n        }\n\n        bool run(){\n            auto log = Logger::Log();\n            log &lt;&lt; Team::TEAM_4 &lt;&lt; LogLevel::INFO &lt;&lt; \"Entering program execution\" &lt;&lt; std::endl;\n\n            error_message = \"\";\n\n            log &lt;&lt; LogLevel::DEBUG;\n\n            index = 0;\n            while (error_message.empty() &amp;&amp; index &lt; code-&gt;size()){\n                auto&amp; unit = code-&gt;at(index);\n                switch (unit.type){\n                    case Unit::Type::number:\n                        log &lt;&lt; \"Push number \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        try {\n                            pushStack(std::stod(unit.value));\n                        } catch (const std::invalid_argument&amp; e) {\n                            error(\"Failed to convert number!\");\n                        } catch (const std::out_of_range&amp; e){\n                            error(\"Number too big!\");\n                        }\n                        break;\n\n                    case Unit::Type::string:\n                        log &lt;&lt; \"Push string \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        pushStack(unit.value);\n                        break;\n\n                    case Unit::Type::identifier:\n                        log &lt;&lt; \"Push identifier \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        pushStack(Identifier{unit.value});\n                        break;\n\n                    case Unit::Type::operation:\n                        // perform operation!\n                        log &lt;&lt; \"Perform operation \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        if (unit.value == \"=\"){\n                            // values to assign\n                            std::vector&lt; Value &gt; values = popArgs();\n                            // identifiers to assign to\n                            auto identifier_values = popArgs();\n                            if (values.size() &gt; identifier_values.size()){\n                                error(\"Too many values!\");\n                                break;\n                            } else if (values.size() &lt; identifier_values.size()){\n                                error(\"Not enough values!\");\n                                break;\n                            }\n                            // Convert to identifiers specifically\n                            std::vector&lt; Identifier &gt; identifiers;\n                            std::transform(\n                identifier_values.begin(), identifier_values.end(),\n                std::back_inserter(identifiers),\n                [this](const Value&amp; v){ return as&lt;Identifier&gt;(v); }\n              );\n                            //ex. a,b,c=1,2,3 becomes the following units\n                            // . a b c . 1 2 3 =\n                            // v: 3 2 1\n                            // i: c b a\n                            if (!getErrorMessage().empty()){\n                                // transform failed in some way \n                                break;\n                            }\n\n                            // upon reaching this point, values and identifiers\n                            // are the same length and contain valid items.\n                            for (size_t i = 0; i &lt; identifiers.size(); ++i){\n                                auto a = identifiers[i];\n                                auto b = values[i];\n\n                                if (!std::holds_alternative&lt;Identifier&gt;(b)){\n                                    setVariable(static_cast&lt;std::string&gt;(a), b);\n                                } else {\n                                    // exception if variable b does not exist\n                                    try {\n                                        auto&amp; b_var = variables.at(static_cast&lt;std::string&gt;(as&lt;Identifier&gt;(b)));\n                                        setVariable(static_cast&lt;std::string&gt;(a), b_var);\n                                    } catch (const std::out_of_range&amp; e){\n                                        error(\"Variable did not exist!\");\n                                    }\n                                }\n                            }\n                        } else if (std::string{\"+ - * / == != &lt;= &gt;= &lt; &gt;\"}.find(unit.value) != std::string::npos){\n                            // binary expressions\n                            auto b = popStack();\n                            auto a = popStack();\n                            if (unit.value == \"+\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(as&lt;double&gt;(a) + as&lt;double&gt;(b));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(as&lt;std::string&gt;(a) + as&lt;std::string&gt;(b));\n                                } else {\n                                    error(\"Runtime type error (plus)\");\n                                }\n                            } else if (unit.value == \"-\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(as&lt;double&gt;(a) - as&lt;double&gt;(b));\n                                } else {\n                                    error(\"Runtime type error (minus)\");\n                                }\n                            } else if (unit.value == \"*\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(as&lt;double&gt;(a) * as&lt;double&gt;(b));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    std::string n;\n                                    double c = as&lt;double&gt;(b);\n                                    for (int i = 0; i &lt; c; ++i){\n                                        n += as&lt;std::string&gt;(a);\n                                    }\n                                    pushStack(n);\n                                } else {\n                                    error(\"Runtime type error (times)\");\n                                }\n                            } else if (unit.value == \"/\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(as&lt;double&gt;(a) / as&lt;double&gt;(b));\n                                } else {\n                                    error(\"Runtime type error (divide)\");\n                                }\n                            } else if (unit.value == \"==\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) == as&lt;double&gt;(b)));\n                                } else if (has&lt;size_t&gt;(a) &amp;&amp; has&lt;size_t&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;size_t&gt;(a) == as&lt;size_t&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) == as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (==)\");\n                                }\n                            } else if (unit.value == \"!=\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) != as&lt;double&gt;(b)));\n                                } else if (has&lt;size_t&gt;(a) &amp;&amp; has&lt;size_t&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;size_t&gt;(a) != as&lt;size_t&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) != as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (!=)\");\n                                }\n                            } else if (unit.value == \"&lt;\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) &lt; as&lt;double&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) &lt; as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (&lt;)\");\n                                }\n                            } else if (unit.value == \"&gt;\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) &gt; as&lt;double&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) &gt; as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (&gt;)\");\n                                }\n                            } else if (unit.value == \"&lt;=\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) &lt;= as&lt;double&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) &lt;= as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (&lt;=)\");\n                                }\n                            } else if (unit.value == \"&gt;=\"){\n                                if (has&lt;double&gt;(a) &amp;&amp; has&lt;double&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;double&gt;(a) &gt;= as&lt;double&gt;(b)));\n                                } else if (has&lt;std::string&gt;(a) &amp;&amp; has&lt;std::string&gt;(b)){\n                                    pushStack(static_cast&lt;double&gt;(as&lt;std::string&gt;(a) &gt;= as&lt;std::string&gt;(b)));\n                                } else {\n                                    error(\"Runtime type error (&gt;=)\");\n                                }\n                            }\n                        } else if (unit.value == \"endline\"){\n                            // clear stack on end of line\n                            while (stack.size())\n                                popStack();\n                        } else if (unit.value == \"endargs\"){\n                            // this could absolutely be broken but that's OK\n                            pushStack(Identifier{\"__INTERNAL_ENDARGS\"});\n                        } else if (unit.value == \"start_block\"){\n                            auto type = as&lt;std::string&gt;(call_stack.top().at(0));\n                            if (type == \"__FOR_BLOCK\"){\n                                auto info = call_stack.top();\n\n                                double value = as&lt;double&gt;(info.at(1));\n                                double start = as&lt;double&gt;(info.at(2));\n                                double end = as&lt;double&gt;(info.at(3));\n                                double step = as&lt;double&gt;(info.at(4));\n\n                                if ((start &lt; end &amp;&amp; step &gt; 0 &amp;&amp; value + step &lt;= end)\n                                    || (start &gt;= end &amp;&amp; step &lt; 0 &amp;&amp; value + step &gt;= end)){\n                                    // continue\n                                    variables.insert_or_assign(static_cast&lt;std::string&gt;(as&lt;Identifier&gt;(info.at(1))), value + step);\n                                    // jump back to the beginning to check the condiiton\n//                                  index = static_cast&lt;int&gt;(as&lt;double&gt;(call_stack.top().at(5)));\n                                } else {\n                                    // end loop\n                                    call_stack.pop();\n                                    skipBlock(1);\n                                    index++; // skip end_block or else it tries to jump to beginning\n                                    break;\n                                }\n                            }\n                        } else if (unit.value == \"end_block\"){\n                            // check for for loop if needed \n                            auto type = as&lt;std::string&gt;(call_stack.top().at(0));\n                            if (type == \"__FOR_BLOCK\"){\n                                // jump back to the beginning to check the condiiton\n                                index = static_cast&lt;int&gt;(as&lt;double&gt;(call_stack.top().at(5)));\n                            } else if (type == \"__IF_BLOCK\"){\n                                // this only runs once, don't really need to save this\n                                call_stack.pop();\n                            } else if (type == \"__FUNCTION_BLOCK\"){\n                                // return from function\n                                index = static_cast&lt;int&gt;(as&lt;double&gt;(call_stack.top().at(1)));\n                                call_stack.pop();\n                            }\n                        } else {\n                            error(\"Unknown operation '\" + unit.value + \"'\");\n                        }\n                        break;\n\n                    case Unit::Type::function:\n                        log &lt;&lt; \"Perform function \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        if (variables.count(unit.value)){\n                            auto&amp; func = variables.at(unit.value);\n                            if (std::holds_alternative&lt;Callable&gt;(func)){\n                                std::get&lt;Callable&gt;(func)(*this);\n                            } else {\n                                error(unit.value + \" is not a callable object!\");\n                            }\n                            break;\n                        } else {\n                            error(\"Function \" + unit.value + \" does not exist!\");\n                        }\n                        break;\n\n                    case Unit::Type::function_decl:\n                        {\n                        log &lt;&lt; \"Create function \" &lt;&lt; unit.value &lt;&lt; std::endl;\n                        auto vars = popArgs(); // should consist of variable names only\n                        for (auto&amp; v : vars){\n                            if (!std::holds_alternative&lt;Identifier&gt;(v)){\n                                error(\"Function definition only accepts identifiers!\");\n                            }\n                        }\n\n                        if (!getErrorMessage().empty()) break;\n                        // args are all vars\n                        auto func_body_index = index;\n                        auto func = [this, vars, func_body_index](ProgramExecutor&amp; pe){\n                            // first: assign to all vars the values on the stack\n                            auto values = pe.popArgs();\n                            if (values.size() != vars.size()){\n                                error(\"Invalid number of arguments (to user-defined function)!\");\n                                return;\n                            }\n\n                            for (size_t i = 0; i &lt; vars.size(); ++i){\n                                auto a = static_cast&lt;std::string&gt;(std::get&lt;Identifier&gt;(vars[i]));\n                                auto b = values[i];\n\n                                if (!std::holds_alternative&lt;Identifier&gt;(b)){\n                                    setVariable(a, b);\n                                } else {\n                                    // exception if variable b does not exist\n                                    try {\n                                        auto&amp; b_var = variables.at(static_cast&lt;std::string&gt;(as&lt;Identifier&gt;(b)));\n                                        setVariable(a, b_var);\n                                    } catch (const std::out_of_range&amp; e){\n                                        error(\"Variable did not exist!\");\n                                    }\n                                }\n                            }\n                            // Assigned stack values to vars (as best as possible)\n                            // Store return index\n                            call_stack.push({\"__FUNCTION_BLOCK\", static_cast&lt;double&gt;(this-&gt;index)});\n                            // Assign PC to start of code block\n                            this-&gt;index = func_body_index;\n                        };\n\n                        // Assign this created function to this name\n                        setVariable(unit.value, func);\n                        skipBlock(); // skip past the function definition\n                        ++index;\n                        }\n                        break;\n\n                    default:\n                        error(\"Unknown code unit '\" + unit.value +\"'!\");\n                }\n                index++;\n            }\n\n            log &lt;&lt; \"Program execution ends\" &lt;&lt; std::endl;\n            if (!error_message.empty()){\n                log &lt;&lt; LogLevel::WARNING &lt;&lt; \"With error: \" &lt;&lt; error_message &lt;&lt; std::endl;\n            }\n\n            return error_message.empty();\n        }\n    };\n} //worldlang\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp/","title":"File SecondWorld.hpp","text":"<p>FileList &gt; source &gt; Worlds &gt; SecondWorld.hpp</p> <p>Go to the source code of this file</p> <p>More...</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include \"../Agents/PacingAgent.hpp\"</code></li> <li><code>#include \"../core/WorldBase.hpp\"</code></li> <li><code>#include \"ProgramExecutor.hpp\"</code></li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace group4"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp/#classes","title":"Classes","text":"Type Name class SecondWorld"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Jayson Van Dam </p> <p>Author:</p> <p>Kurt LaBlanc </p> <p>Author:</p> <p>Satvik Ravipati </p> <p>The documentation for this class was generated from the following file <code>source/Worlds/SecondWorld.hpp</code></p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/_second_world_8hpp_source/","title":"File SecondWorld.hpp","text":"<p>File List &gt; source &gt; Worlds &gt; SecondWorld.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n#include &lt;algorithm&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n#include \"../Agents/PacingAgent.hpp\"\n#include \"../core/WorldBase.hpp\"\n#include \"ProgramExecutor.hpp\"  //&lt; for attack, item scripts\n\nusing cse491::CellType;\n\nnamespace group4 {\nconst std::string FIRST_FLOOR_FILENAME = \"../assets/grids/group4_maze.grid\";\n\nconst std::string SECOND_FLOOR_FILENAME = \"../assets/grids/second_floor.grid\";\n\nconst std::string FINAL_FLOOR_FILENAME = \"../assets/grids/third_floor.grid\";\n\nconst std::string ITEM_PICKUP_SCRIPT = \"../assets/scripts/g4_item_pickup.ws\";\n\nconst std::string COMBAT_SCRIPT = \"../assets/scripts/g4_agent_attack.ws\";\n\nconst std::string WORLD_LOAD_SCRIPT = \"../assets/scripts/g4_world_load.ws\";\n\nconst std::string WORLD_LOAD_SCRIPT_2 = \"../assets/scripts/g4_world_2_load.ws\";\n\nconst std::string WORLD_LOAD_SCRIPT_3 = \"../assets/scripts/g4_world_3_load.ws\";\n\nconst size_t MAX_INVENTORY_SIZE = 30;\n\nconst cse491::GridPosition OffGrid = {-1, -1};\n\nclass SecondWorld : public cse491::WorldBase {\n private:\n  std::string world_filename = \"\";\n\n  std::string agents_filename = \"\";\n\n\n  void LoadWorldScript(std::string source){\n    // Clear items on the current grid, unless held by a player\n    for (auto it = item_map.begin(); it != item_map.end();) {\n      auto&amp; item = it-&gt;second;\n      if (item-&gt;IsOnGrid()) {\n        // clear this item\n        it = item_map.erase(it);\n      } else if (item-&gt;IsOwnedByItem()) {\n        // it's owned by a chest: this is currently the only item containing\n        // items\n        it = item_map.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    // Clear agents, unless they are the player (an interface)\n    std::vector&lt;size_t&gt; agents_to_remove = {};\n    for (auto&amp; [agent_id, agent_ptr] : agent_map) {\n      if (!agent_ptr-&gt;IsInterface()) {\n        agents_to_remove.push_back(agent_id);\n      }\n    }\n\n    for (auto agent_id : agents_to_remove) {\n      RemoveAgent(agent_id);\n    }\n\n    // Initialize level\n    pe.runFile(source);\n  }\n\n\n  void SwitchGrid(cse491::AgentBase&amp; agent) {\n\n    // This value initialized by each world load script to point to the next level\n    auto next_world_script = pe.var&lt;std::string&gt;(\"next_world\");\n\n    agent.Notify(\"Going to \" + world_filename, \"world_switched\");\n    if (next_world_script == \"GAME_END\") {\n      agent.Notify(\"Congrats, you won the game!\", \"congrats_msg\");\n      run_over = true;\n      return;\n    }\n\n    LoadWorldScript(next_world_script);\n  }\n\n protected:\n  enum ActionType {\n    REMAIN_STILL = 0,\n    MOVE_UP,\n    MOVE_DOWN,\n    MOVE_LEFT,\n    MOVE_RIGHT,\n    DROP_ITEM,\n//    WARP_TO_FLOOR_3  // New action for hidden warp tile\n  };\n\n  worldlang::ProgramExecutor pe;\n\n  std::map&lt;size_t, std::unique_ptr&lt;cse491::ItemBase&gt;&gt; inventory;\n\n  void ConfigAgent(cse491::AgentBase&amp; agent) override {\n    agent.AddAction(\"up\", MOVE_UP);\n    agent.AddAction(\"down\", MOVE_DOWN);\n    agent.AddAction(\"left\", MOVE_LEFT);\n    agent.AddAction(\"right\", MOVE_RIGHT);\n    agent.AddAction(\"drop\", DROP_ITEM);\n//    agent.AddAction(\"warp\", WARP_TO_FLOOR_3);\n  }\n\n public:\n  SecondWorld() : world_filename(FIRST_FLOOR_FILENAME), pe{*this} {\n    pe.registerFunction(\"loadAgents\", [this](worldlang::ProgramExecutor&amp; pe){\n      auto args = pe.popArgs();\n      if (args.size() != 1) { pe.error(\"Wrong number of arguments!\"); return; }\n      auto path = pe.as&lt;std::string&gt;(args[0]);\n\n      this-&gt;LoadFromFile(path);\n    });\n\n    LoadWorldScript(WORLD_LOAD_SCRIPT);\n  }\n\n  SecondWorld(std::string grid_filename, std::string agent_filename)\n      : world_filename(grid_filename),\n        agents_filename(agent_filename),\n        pe{*this} {\n    AddCellType(\"floor\", \"Floor that you can easily walk over.\", ' ');\n    AddCellType(\"flag\", \"Goal flag for a game end state\", 'g');\n    AddCellType(\"wall\", \"Impenetrable wall that you must find a way around.\", '#');\n    AddCellType(\"hidden_warp\", \"Hidden warp tile that warps to floor 3.\", 'u');\n    AddCellType(\"water\", \"Water that distinguishes fire.\", 'w');\n\n    main_grid.Read(grid_filename, type_options);\n    LoadFromFile(agent_filename);\n  }\n\n  ~SecondWorld() = default;\n\n  void LoadFromFile(const std::string&amp; input_filename) {\n    std::ifstream input_file(input_filename);\n\n    if (!input_file.is_open()) {\n      std::cerr &lt;&lt; \"Error: could not open file \" &lt;&lt; input_filename &lt;&lt; std::endl;\n      return;\n    }\n\n    nlohmann::json data;\n    try {\n      input_file &gt;&gt; data;\n    } catch (const nlohmann::json::parse_error&amp; err) {\n      std::cerr &lt;&lt; \"JSON parsing error: \" &lt;&lt; err.what() &lt;&lt; std::endl;\n      return;\n    }\n\n//    const int BASE_MAX_HEALTH = 100;\n    for (const auto&amp; agent : data) {\n      // May get a json.exception.type_error here if you assign to the wrong C++\n      // type, so make sure to nail down what types things are in JSON first! My\n      // intuition is that each agent object will have: name: string (C++\n      // std::string) x: number (C++ int) y: number (C++ int) entities:\n      // array&lt;string&gt; (C++ std::vector&lt;std::string&gt;)\n      std::string agent_name = agent.at(\"name\");\n      int x_pos = agent.at(\"x\");\n      int y_pos = agent.at(\"y\");\n\n//      int additional_max_health = 0;\n//      std::vector&lt;std::string&gt; entities = agent.at(\"entities\");\n\n\n//      for (const auto&amp; entity : entities) {\n        // TODO: How should we set the entity properties here?\n        // Just adding to MaxHealth now, but this doesn't seem very scalable.\n/*        if (entity == \"chocolate_bar\") {\n          additional_max_health = 10;\n        }*/\n//      }\n\n      auto&amp; a = AddAgent&lt;cse491::PacingAgent&gt;(agent_name)\n          .SetPosition(x_pos, y_pos);\n//          .SetProperty(\"MaxHealth\", BASE_MAX_HEALTH + additional_max_health);\n\n      auto properties = agent.at(\"properties\");\n      for (const auto&amp; p : properties.items()){\n        std::cout &lt;&lt; p.value().is_number() &lt;&lt; std::endl;\n        a.SetProperty(p.key(), p.value().get&lt;double&gt;());\n      }\n\n    }\n  }\n\n  virtual void Run() override {\n    while (!run_over) {\n      RunAgents();\n    }\n\n    SaveToFile();\n  }\n\n  void SaveToFile() {\n    nlohmann::json output_data;  // json to store the data being outputted\n\n    for (const auto&amp; [agent_id, agent_ptr] : agent_map) {\n      auto new_position = agent_ptr-&gt;GetPosition();\n      std::string agent_name = agent_ptr-&gt;GetName();\n      double x_pos = new_position.GetX();\n      double y_pos = new_position.GetY();\n\n      nlohmann::json agent_data;  // json for each agent\n      agent_data[\"name\"] = agent_name;\n      agent_data[\"x\"] = x_pos;\n      agent_data[\"y\"] = y_pos;\n\n      output_data.push_back(agent_data);  // add it to the json array\n    }\n\n    std::ofstream ofs(\"output.json\");  // save it to a file called output.json\n    ofs &lt;&lt; output_data.dump(2);        // indentation\n  }\n\n  void DropItem(cse491::AgentBase&amp; agent, cse491::GridPosition&amp; pos) {\n    // Cannot drop\n    if (agent.GetInventory().empty()) {\n      agent.Notify(\"Cannot drop any items, inventory is empty.\", \"item_alert\");\n      return;\n    }\n\n    auto items_found = FindItemsAt(pos, 0);\n    auto&amp; item_drop = GetItem(agent.GetInventory().at(0));\n\n    // Transfer ownership to chest\n    if (!items_found.empty()) {\n      auto&amp; target_item = GetItem(items_found.at(0));\n      if (target_item.HasProperty(\"Chest\")) {\n        item_drop.SetPosition(OffGrid);\n        target_item.AddItem(item_drop);\n\n        // Set the position and remove item from agent's inventory\n        agent.RemoveItem(item_drop.GetID());\n\n        // Must set the grid back because RemoveItem() doesn't account for that\n        item_drop.SetGrid();\n        agent.Notify(\"Dropping \" + item_drop.GetName() + \" into the chest!\",\n                     \"item_alert\");\n        return;\n\n        // Item already on player's position\n      } else {\n        agent.Notify(\n            \"Cannot drop the item, there is already an item on this cell.\",\n            \"item_alert\");\n        return;\n      }\n    }\n    // Transfer ownership to grid\n    agent.RemoveItem(item_drop.GetID());\n    item_drop.SetGrid();\n    item_drop.SetPosition(pos);\n\n    agent.Notify(\"Dropping \" + item_drop.GetName() + \" onto the ground!\",\n                 \"item_alert\");\n  }\n\n  bool CheckPosition(cse491::AgentBase&amp; agent, cse491::GridPosition&amp; pos) {\n    // First check to see if agent is on win flag\n    if ((type_options[main_grid.At(pos)].HasProperty(\"Goal\")) &amp;&amp;\n        (agent.IsInterface())) {\n      agent.Notify(\"Flag found \", \"item_alert\");\n\n      agent.Notify(\"Leaving \" + world_filename, \"world_switched\");\n\n      SwitchGrid(agent);\n\n      return false;\n\n      // then checks if agent is on any items\n    } else if ((type_options[main_grid.At(pos)].HasProperty(\"Warp\")) &amp;&amp;\n               (agent.IsInterface())) {\n      // Agent used the hidden warp tile action\n      agent.Notify(\"Hidden warp tile activated! Warping to floor 3.\",\n                   \"hidden_warp\");\n\n      agent.Notify(\"Leaving \" + world_filename, \"world_switched\");\n\n      LoadWorldScript(WORLD_LOAD_SCRIPT_3); // skip right to the end\n      return false;\n    } else {\n      auto items_found = FindItemsAt(pos, 0);\n      // If there are items at this position\n      if (!items_found.empty() &amp;&amp; agent.IsInterface()) {\n        auto&amp; item_found = GetItem(items_found.at(0));\n\n        // Item is a chest\n        if (item_found.HasProperty(\"Chest\")) {\n          // Check to see if the chest owns any items\n          if (!item_found.GetInventory().empty()) {\n            auto temp_inventory = item_found.GetInventory();\n            agent.Notify(\"This is inside the chest: \", \"item_alert\");\n\n            // Display the items found\n            for (auto x : temp_inventory) {\n              agent.Notify(\"You found the \" + GetItem(x).GetName() +\n                           \" in the \" + item_found.GetName());\n              agent.AddItem(GetItem(x));\n              item_found.RemoveItem(GetItem(x));\n            }\n\n            // Check agent's inventory size\n            if (agent.GetInventory().size() == MAX_INVENTORY_SIZE) {\n              agent.Notify(\n                  \"It looks like your inventory is full, please drop items or \"\n                  \"place them in chests!\",\n                  \"item_alert\");\n            }\n          } else {\n            agent.Notify(\"The chest is empty! You can store items with 't'!\",\n                         \"item_alert\");\n          }\n\n          // Item is not a chest\n        } else {\n          if (agent.GetInventory().size() == MAX_INVENTORY_SIZE) {\n            agent.Notify(\n                \"It looks like your inventory is full, please drop items or \"\n                \"place them in chests!\",\n                \"item_alert\");\n\n          } else {\n            agent.Notify(\"You found \" + item_found.GetName() + \"!\",\n                         \"item_alert\");\n\n            // Set the position off the grid, so it doesn't render\n            // Note: Setting the position with a GridPosition SETS THE OWNER\n            item_found.SetPosition(OffGrid);\n            // Add item to the agent's inventory\n            agent.AddItem(item_found.GetID());\n\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  int DoAction(cse491::AgentBase&amp; agent, size_t action_id) override {\n    if (agent.HasProperty(\"Dead\")){\n      return false; // Can't move when dead!\n    }\n\n    cse491::GridPosition new_position;\n    bool IsDropped = false;\n    switch (action_id) {\n      case REMAIN_STILL:\n        new_position = agent.GetPosition();\n        break;\n      case MOVE_UP:\n        new_position = agent.GetPosition().Above();\n        break;\n      case MOVE_DOWN:\n        new_position = agent.GetPosition().Below();\n        break;\n      case MOVE_LEFT:\n        new_position = agent.GetPosition().ToLeft();\n        break;\n      case MOVE_RIGHT:\n        new_position = agent.GetPosition().ToRight();\n        break;\n      case DROP_ITEM:\n        new_position = agent.GetPosition();\n        DropItem(agent, new_position);\n//        IsDropped = true;\n        return true;\n        break;\n    }\n\n    if (!main_grid.IsValid(new_position)) {\n      return false;\n    }\n    if (!IsTraversable(agent, new_position)) {\n      return false;\n    }\n\n    // At this point, new_position is valid and not going into a wall.\n    // Check if there are any agents on this tile:\n    auto res = this-&gt;FindAgentsAt(new_position);\n    if (res.size() &amp;&amp; res[0] != agent.GetID()) {\n      // At least one agent was found (and isn't the player)\n      // Take the first agent and attack it.\n      pe.setVariable(\"agent\", agent.GetID());\n      pe.setVariable(\"opponent\", res[0]);\n      pe.runFile(COMBAT_SCRIPT);\n\n      auto&amp; opponent = GetAgent(res[0]);\n      if (opponent.HasProperty(\"Dead\") &amp;&amp; opponent.IsInterface()){\n        // game over!\n        opponent.Notify(\"You have died.\", \"game_over\");\n        run_over = true;\n      } else if (opponent.HasProperty(\"Dead\") &amp;&amp; opponent.HasProperty(\"Boss\")){\n        // level up: i.e. you can go on water now\n        agent.Notify(\"You have defeated the boss! You now can walk on water.\", \"message\");\n        agent.SetProperty(\"Swimmer\", true);\n      }\n\n      // The movement was not legal, so we return false.\n      // TODO: Should this return a status indicating that an attack occured,\n      // to distinguish moves that do nothing from attacks?\n      return false;\n    }\n\n    if (!IsDropped) {\n      if (!CheckPosition(agent, new_position))\n        //does not set position if grid changed, but move is considered successful\n        return true; \n    }\n\n    IsDropped = false;\n    agent.SetPosition(new_position);\n    return true;\n  }\n\n  void PrintEntities() {\n    for (const auto&amp; [id, item_ptr] : item_map) {\n      if (!item_ptr) {\n        continue;\n      }\n      std::cout &lt;&lt; item_ptr-&gt;GetName() &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n\n  bool IsTraversable(const AgentBase&amp; agent,\n                     cse491::GridPosition pos) const override {\n    if (GetCellTypes().at(main_grid.At(pos)).HasProperty(CellType::CELL_WALL))\n      return false;\n    else if (GetCellTypes()\n                 .at(main_grid.At(pos))\n                 .HasProperty(CellType::CELL_WATER))\n      return agent.HasProperty(\"Swimmer\");\n    else\n      return true;\n  }\n};\n}  // namespace group4\n\n</code></pre>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cse491 A World that consists only of walls and open cells. </li> <li>namespace cse491_team8 A World that consists of trees, water, and grass cells. </li> <li>namespace group4 </li> <li>namespace group6 A World that consists only of walls and open cells. </li> <li>namespace siv <ul> <li>namespace perlin_detail </li> </ul> </li> <li>namespace std </li> <li>namespace tao <ul> <li>namespace pegtl </li> </ul> </li> <li>namespace worldlang Namespace for scripting language stuff. </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/","title":"Class Index","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#a","title":"a","text":"<ul> <li>add (worldlang)</li> <li>add_a (worldlang)</li> <li>assignment (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#b","title":"b","text":"<ul> <li>BasicPerlinNoise (siv)</li> <li>BiomeGenerator (group6)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#c","title":"c","text":"<ul> <li>code_block (worldlang)</li> <li>comment (worldlang)</li> <li>comp (worldlang)</li> <li>comp_a (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#e","title":"e","text":"<ul> <li>element (worldlang)</li> <li>expression (worldlang)</li> <li>expression_list (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#f","title":"f","text":"<ul> <li>function (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#g","title":"g","text":"<ul> <li>GenerativeWorld (group6)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#i","title":"i","text":"<ul> <li>Identifier (worldlang::ProgramExecutor)</li> <li>identifier (worldlang)</li> <li>identifier_list (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#m","title":"m","text":"<ul> <li>ManualWorld (cse491_team8)</li> <li>MazeWorld (cse491)</li> <li>mul (worldlang)</li> <li>mul_a (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#n","title":"n","text":"<ul> <li>number (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#o","title":"o","text":"<ul> <li>op_prio_add (worldlang)</li> <li>op_prio_comp (worldlang)</li> <li>op_prio_mul (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#p","title":"p","text":"<ul> <li>program (worldlang)</li> <li>ProgramExecutor (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#s","title":"s","text":"<ul> <li>SecondWorld (group4)</li> <li>statement (worldlang)</li> <li>statement_list (worldlang)</li> <li>string (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/classes/#u","title":"u","text":"<ul> <li>Unit (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class group6::BiomeGenerator </li> <li>class siv::BasicPerlinNoise </li> <li>class worldlang::ProgramExecutor Class that manages program execution. </li> <li>struct worldlang::Unit </li> <li>class WorldBase <ul> <li>class cse491::MazeWorld </li> <li>class cse491_team8::ManualWorld </li> <li>class group4::SecondWorld </li> <li>class group6::GenerativeWorld </li> </ul> </li> <li>class string <ul> <li>struct worldlang::ProgramExecutor::Identifier </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; add_a, op_prio_add, add &gt;, add_a &gt; <ul> <li>struct worldlang::add </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; mul, op_prio_add, mul &gt;, mul &gt; <ul> <li>struct worldlang::add_a </li> </ul> </li> <li>class tao::pegtl::seq&lt; identifier_list, pegtl::one&lt; '=' &gt;, expression_list &gt; <ul> <li>struct worldlang::assignment </li> </ul> </li> <li>class tao::pegtl::seq&lt; pegtl::one&lt; '{' &gt;, pegtl::eol, statement_list, pegtl::one&lt; '}' &gt;, pegtl::eol &gt; <ul> <li>struct worldlang::code_block </li> </ul> </li> <li>class tao::pegtl::seq&lt; pegtl::one&lt; '#' &gt;, pegtl::until&lt; pegtl::eol &gt; &gt; <ul> <li>struct worldlang::comment </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; comp_a, op_prio_comp, comp &gt;, comp_a &gt; <ul> <li>struct worldlang::comp </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; add, op_prio_comp, add &gt;, add &gt; <ul> <li>struct worldlang::comp_a </li> </ul> </li> <li>class tao::pegtl::sor&lt; function, identifier, number, string, pegtl::seq&lt; pegtl::one&lt; '(' &gt;, expression, pegtl::one&lt; ')' &gt; &gt; &gt; <ul> <li>struct worldlang::element </li> </ul> </li> <li>class tao::pegtl::sor&lt; comp &gt; <ul> <li>struct worldlang::expression </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; expression, pegtl::one&lt; ',' &gt;, expression_list &gt;, expression &gt; <ul> <li>struct worldlang::expression_list </li> </ul> </li> <li>class tao::pegtl::seq&lt; identifier, pegtl::one&lt; '(' &gt;, pegtl::opt&lt; expression_list &gt;, pegtl::one&lt; ')' &gt; &gt; <ul> <li>struct worldlang::function </li> </ul> </li> <li>class identifier <ul> <li>struct worldlang::identifier </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; identifier, pegtl::one&lt; ',' &gt;, identifier_list &gt;, identifier &gt; <ul> <li>struct worldlang::identifier_list </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; mul_a, op_prio_mul, mul &gt;, mul_a &gt; <ul> <li>struct worldlang::mul </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; element, op_prio_mul, element &gt;, element &gt; <ul> <li>struct worldlang::mul_a </li> </ul> </li> <li>class tao::pegtl::seq&lt; pegtl::opt&lt; pegtl::one&lt; '-' &gt; &gt;, pegtl::plus&lt; pegtl::digit &gt;, pegtl::opt&lt; pegtl::one&lt; '.' &gt;, pegtl::plus&lt; pegtl::digit &gt; &gt; &gt; <ul> <li>struct worldlang::number </li> </ul> </li> <li>class tao::pegtl::one&lt; '+', '-' &gt; <ul> <li>struct worldlang::op_prio_add </li> </ul> </li> <li>class tao::pegtl::sor&lt; TAO_PEGTL_STRING(\"==\"), TAO_PEGTL_STRING(\"!=\"), TAO_PEGTL_STRING(\"&lt;=\"), TAO_PEGTL_STRING(\"&gt;=\"), pegtl::one&lt; '&lt;' &gt;, pegtl::one&lt; '&gt;' &gt; &gt; <ul> <li>struct worldlang::op_prio_comp </li> </ul> </li> <li>class tao::pegtl::one&lt; ' *', '/' &gt; <ul> <li>struct worldlang::op_prio_mul </li> </ul> </li> <li>class tao::pegtl::seq&lt; statement_list, pegtl::eolf &gt; <ul> <li>struct worldlang::program </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; function, pegtl::opt&lt; code_block &gt;, pegtl::opt&lt; pegtl::eol &gt; &gt;, pegtl::seq&lt; assignment, pegtl::opt&lt; pegtl::eol &gt; &gt;, comment, pegtl::eol &gt; <ul> <li>struct worldlang::statement </li> </ul> </li> <li>class tao::pegtl::sor&lt; pegtl::seq&lt; statement, statement_list &gt;, statement &gt; <ul> <li>struct worldlang::statement_list </li> </ul> </li> <li>class tao::pegtl::seq&lt; pegtl::one&lt; '\"' &gt;, pegtl::star&lt; pegtl::not_one&lt;'\"'&gt; &gt;, pegtl::one&lt; '\"' &gt; &gt; <ul> <li>struct worldlang::string </li> </ul> </li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/","title":"Class Members","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#a","title":"a","text":"<ul> <li>ActionType (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>AddMove (cse491_team8::ManualWorld)</li> <li>agents_filename (group4::SecondWorld)</li> <li>applyPathToGrid (group6::BiomeGenerator)</li> <li>AStarAgentHelper (group6::GenerativeWorld)</li> <li>AddArmory (group6::GenerativeWorld)</li> <li>AddTeleporters (group6::GenerativeWorld)</li> <li>AgentCollisionHelper (group6::GenerativeWorld)</li> <li>ArmoryTileHelper (group6::GenerativeWorld)</li> <li>armory_id (group6::GenerativeWorld)</li> <li>as (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#b","title":"b","text":"<ul> <li>bridge_id (cse491_team8::ManualWorld)</li> <li>BiomeGenerator (group6::BiomeGenerator)</li> <li>biome (group6::BiomeGenerator)</li> <li>BasicPerlinNoise (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#c","title":"c","text":"<ul> <li>ConfigAgent (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>CheckPosition (group4::SecondWorld)</li> <li>clearPath (group6::BiomeGenerator)</li> <li>CreateGrid (group6::GenerativeWorld)</li> <li>Callable (worldlang::ProgramExecutor)</li> <li>call_stack (worldlang::ProgramExecutor)</li> <li>code (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#d","title":"d","text":"<ul> <li>DoAction (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>DoActionAttemptItemPickup (cse491_team8::ManualWorld)</li> <li>DoActionFindNewPosition (cse491_team8::ManualWorld)</li> <li>DoActionTestNewPositionTree (cse491_team8::ManualWorld)</li> <li>DoActionTestNewPositionWater (cse491_team8::ManualWorld)</li> <li>DoBattle (cse491_team8::ManualWorld)</li> <li>DropItems (cse491_team8::ManualWorld)</li> <li>DropItem (group4::SecondWorld)</li> <li>dirt_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>door_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>DamageAgent (group6::GenerativeWorld)</li> <li>DoorTileHelper (group6::GenerativeWorld)</li> <li>default_random_engine (siv::BasicPerlinNoise)</li> <li>deserialize (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#e","title":"e","text":"<ul> <li>EndGame (group6::GenerativeWorld)</li> <li>error (worldlang::ProgramExecutor)</li> <li>error_message (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#f","title":"f","text":"<ul> <li>floor_id (cse491::MazeWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>FacingDirection (cse491_team8::ManualWorld)</li> <li>FindItem (cse491_team8::ManualWorld)</li> <li>frequency (group6::BiomeGenerator)</li> <li>FindTiles (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#g","title":"g","text":"<ul> <li>GenerateMoveSets (cse491_team8::ManualWorld)</li> <li>grass_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>generate (group6::BiomeGenerator)</li> <li>getBiome (group6::BiomeGenerator)</li> <li>getSeed (group6::BiomeGenerator)</li> <li>grid (group6::BiomeGenerator)</li> <li>GenerativeWorld (group6::GenerativeWorld)</li> <li>getErrorMessage (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#h","title":"h","text":"<ul> <li>HealAction (cse491_team8::ManualWorld)</li> <li>height (group6::BiomeGenerator)</li> <li>hole_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>HoleTileHelper (group6::GenerativeWorld)</li> <li>has (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#i","title":"i","text":"<ul> <li>IsTraversable (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>inventory (group4::SecondWorld)</li> <li>ItemHelper (group6::GenerativeWorld)</li> <li>index (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#k","title":"k","text":"<ul> <li>keyLocation (group6::BiomeGenerator)</li> <li>key_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>KeyTileHelper (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#l","title":"l","text":"<ul> <li>LookAhead (cse491_team8::ManualWorld)</li> <li>LoadFromFile (group4::SecondWorld)</li> <li>LoadWorldScript (group4::SecondWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#m","title":"m","text":"<ul> <li>MazeWorld (cse491::MazeWorld)</li> <li>ManualWorld (cse491_team8::ManualWorld)</li> <li>MoveSetAction (cse491_team8::ManualWorld)</li> <li>m_permutation (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#n","title":"n","text":"<ul> <li>noise1D (siv::BasicPerlinNoise)</li> <li>noise1D_01 (siv::BasicPerlinNoise)</li> <li>noise2D (siv::BasicPerlinNoise)</li> <li>noise2D_01 (siv::BasicPerlinNoise)</li> <li>noise3D (siv::BasicPerlinNoise)</li> <li>noise3D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave1D (siv::BasicPerlinNoise)</li> <li>normalizedOctave1D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave2D (siv::BasicPerlinNoise)</li> <li>normalizedOctave2D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave3D (siv::BasicPerlinNoise)</li> <li>normalizedOctave3D_01 (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#o","title":"o","text":"<ul> <li>OtherAction (cse491_team8::ManualWorld)</li> <li>oceanHandler (group6::BiomeGenerator)</li> <li>octave1D (siv::BasicPerlinNoise)</li> <li>octave1D_01 (siv::BasicPerlinNoise)</li> <li>octave1D_11 (siv::BasicPerlinNoise)</li> <li>octave2D (siv::BasicPerlinNoise)</li> <li>octave2D_01 (siv::BasicPerlinNoise)</li> <li>octave2D_11 (siv::BasicPerlinNoise)</li> <li>octave3D (siv::BasicPerlinNoise)</li> <li>octave3D_01 (siv::BasicPerlinNoise)</li> <li>octave3D_11 (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#p","title":"p","text":"<ul> <li>portal_id_a (cse491_team8::ManualWorld)</li> <li>portal_id_b (cse491_team8::ManualWorld)</li> <li>portal_id_c (cse491_team8::ManualWorld)</li> <li>portal_id_d (cse491_team8::ManualWorld)</li> <li>PrintEntities (group4::SecondWorld)</li> <li>pe (group4::SecondWorld)</li> <li>perlinNoise (group6::BiomeGenerator)</li> <li>placeDoorTile (group6::BiomeGenerator)</li> <li>placeSpecialTiles (group6::BiomeGenerator)</li> <li>placeTileRandom (group6::BiomeGenerator)</li> <li>placeTrees (group6::BiomeGenerator)</li> <li>ProgramExecutor (worldlang::ProgramExecutor)</li> <li>popArgs (worldlang::ProgramExecutor)</li> <li>popStack (worldlang::ProgramExecutor)</li> <li>pushStack (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#r","title":"r","text":"<ul> <li>RemoveMove (cse491_team8::ManualWorld)</li> <li>Run (cse491_team8::ManualWorld, group4::SecondWorld)</li> <li>RunAgents (cse491_team8::ManualWorld)</li> <li>rock_id (cse491_team8::ManualWorld)</li> <li>reseed (siv::BasicPerlinNoise)</li> <li>registerFunction (worldlang::ProgramExecutor)</li> <li>run (worldlang::ProgramExecutor)</li> <li>runFile (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#s","title":"s","text":"<ul> <li>StatsAction (cse491_team8::ManualWorld)</li> <li>SaveToFile (group4::SecondWorld)</li> <li>SecondWorld (group4::SecondWorld)</li> <li>SwitchGrid (group4::SecondWorld)</li> <li>sand_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>saveToFile (group6::BiomeGenerator)</li> <li>seed (group6::BiomeGenerator)</li> <li>setTiles (group6::BiomeGenerator)</li> <li>setWorld (group6::BiomeGenerator)</li> <li>spike_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>SpikeTileHelper (group6::GenerativeWorld)</li> <li>seed_type (siv::BasicPerlinNoise)</li> <li>serialize (siv::BasicPerlinNoise)</li> <li>state_type (siv::BasicPerlinNoise)</li> <li>scripts (worldlang::ProgramExecutor)</li> <li>setVariable (worldlang::ProgramExecutor)</li> <li>skipBlock (worldlang::ProgramExecutor)</li> <li>stack (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#t","title":"t","text":"<ul> <li>tree_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>tar_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>tiles (group6::BiomeGenerator)</li> <li>TarTileHelper (group6::GenerativeWorld)</li> <li>TeleporterHelper (group6::GenerativeWorld)</li> <li>teleporter_id (group6::GenerativeWorld)</li> <li>Type (worldlang::Unit)</li> <li>type (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#u","title":"u","text":"<ul> <li>UpdateWorld (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#v","title":"v","text":"<ul> <li>value_type (siv::BasicPerlinNoise)</li> <li>Value (worldlang::ProgramExecutor)</li> <li>var (worldlang::ProgramExecutor)</li> <li>variables (worldlang::ProgramExecutor)</li> <li>value (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#w","title":"w","text":"<ul> <li>wall_id (cse491::MazeWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>water_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>world_filename (group4::SecondWorld)</li> <li>width (group6::BiomeGenerator)</li> <li>worldPtr (group6::BiomeGenerator)</li> <li>world_height (group6::GenerativeWorld)</li> <li>world_width (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_members/#_1","title":"~","text":"<ul> <li>~MazeWorld (cse491::MazeWorld)</li> <li>~ManualWorld (cse491_team8::ManualWorld)</li> <li>~SecondWorld (group4::SecondWorld)</li> <li>~BiomeGenerator (group6::BiomeGenerator)</li> <li>~GenerativeWorld (group6::GenerativeWorld)</li> <li>~ProgramExecutor (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/","title":"Class Member Functions","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#a","title":"a","text":"<ul> <li>AddMove (cse491_team8::ManualWorld)</li> <li>applyPathToGrid (group6::BiomeGenerator)</li> <li>AStarAgentHelper (group6::GenerativeWorld)</li> <li>AddArmory (group6::GenerativeWorld)</li> <li>AddTeleporters (group6::GenerativeWorld)</li> <li>AgentCollisionHelper (group6::GenerativeWorld)</li> <li>ArmoryTileHelper (group6::GenerativeWorld)</li> <li>as (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#b","title":"b","text":"<ul> <li>BiomeGenerator (group6::BiomeGenerator)</li> <li>BasicPerlinNoise (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#c","title":"c","text":"<ul> <li>ConfigAgent (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>CheckPosition (group4::SecondWorld)</li> <li>clearPath (group6::BiomeGenerator)</li> <li>CreateGrid (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#d","title":"d","text":"<ul> <li>DoAction (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>DoActionAttemptItemPickup (cse491_team8::ManualWorld)</li> <li>DoActionFindNewPosition (cse491_team8::ManualWorld)</li> <li>DoActionTestNewPositionTree (cse491_team8::ManualWorld)</li> <li>DoActionTestNewPositionWater (cse491_team8::ManualWorld)</li> <li>DoBattle (cse491_team8::ManualWorld)</li> <li>DropItems (cse491_team8::ManualWorld)</li> <li>DropItem (group4::SecondWorld)</li> <li>DamageAgent (group6::GenerativeWorld)</li> <li>DoorTileHelper (group6::GenerativeWorld)</li> <li>deserialize (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#e","title":"e","text":"<ul> <li>EndGame (group6::GenerativeWorld)</li> <li>error (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#f","title":"f","text":"<ul> <li>FindItem (cse491_team8::ManualWorld)</li> <li>FindTiles (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#g","title":"g","text":"<ul> <li>GenerateMoveSets (cse491_team8::ManualWorld)</li> <li>generate (group6::BiomeGenerator)</li> <li>getBiome (group6::BiomeGenerator)</li> <li>getSeed (group6::BiomeGenerator)</li> <li>GenerativeWorld (group6::GenerativeWorld)</li> <li>getErrorMessage (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#h","title":"h","text":"<ul> <li>HealAction (cse491_team8::ManualWorld)</li> <li>HoleTileHelper (group6::GenerativeWorld)</li> <li>has (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#i","title":"i","text":"<ul> <li>IsTraversable (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> <li>ItemHelper (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#k","title":"k","text":"<ul> <li>KeyTileHelper (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#l","title":"l","text":"<ul> <li>LookAhead (cse491_team8::ManualWorld)</li> <li>LoadFromFile (group4::SecondWorld)</li> <li>LoadWorldScript (group4::SecondWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#m","title":"m","text":"<ul> <li>MazeWorld (cse491::MazeWorld)</li> <li>ManualWorld (cse491_team8::ManualWorld)</li> <li>MoveSetAction (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#n","title":"n","text":"<ul> <li>noise1D (siv::BasicPerlinNoise)</li> <li>noise1D_01 (siv::BasicPerlinNoise)</li> <li>noise2D (siv::BasicPerlinNoise)</li> <li>noise2D_01 (siv::BasicPerlinNoise)</li> <li>noise3D (siv::BasicPerlinNoise)</li> <li>noise3D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave1D (siv::BasicPerlinNoise)</li> <li>normalizedOctave1D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave2D (siv::BasicPerlinNoise)</li> <li>normalizedOctave2D_01 (siv::BasicPerlinNoise)</li> <li>normalizedOctave3D (siv::BasicPerlinNoise)</li> <li>normalizedOctave3D_01 (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#o","title":"o","text":"<ul> <li>OtherAction (cse491_team8::ManualWorld)</li> <li>oceanHandler (group6::BiomeGenerator)</li> <li>octave1D (siv::BasicPerlinNoise)</li> <li>octave1D_01 (siv::BasicPerlinNoise)</li> <li>octave1D_11 (siv::BasicPerlinNoise)</li> <li>octave2D (siv::BasicPerlinNoise)</li> <li>octave2D_01 (siv::BasicPerlinNoise)</li> <li>octave2D_11 (siv::BasicPerlinNoise)</li> <li>octave3D (siv::BasicPerlinNoise)</li> <li>octave3D_01 (siv::BasicPerlinNoise)</li> <li>octave3D_11 (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#p","title":"p","text":"<ul> <li>PrintEntities (group4::SecondWorld)</li> <li>placeDoorTile (group6::BiomeGenerator)</li> <li>placeSpecialTiles (group6::BiomeGenerator)</li> <li>placeTileRandom (group6::BiomeGenerator)</li> <li>placeTrees (group6::BiomeGenerator)</li> <li>ProgramExecutor (worldlang::ProgramExecutor)</li> <li>popArgs (worldlang::ProgramExecutor)</li> <li>popStack (worldlang::ProgramExecutor)</li> <li>pushStack (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#r","title":"r","text":"<ul> <li>RemoveMove (cse491_team8::ManualWorld)</li> <li>Run (cse491_team8::ManualWorld, group4::SecondWorld)</li> <li>RunAgents (cse491_team8::ManualWorld)</li> <li>reseed (siv::BasicPerlinNoise)</li> <li>registerFunction (worldlang::ProgramExecutor)</li> <li>run (worldlang::ProgramExecutor)</li> <li>runFile (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#s","title":"s","text":"<ul> <li>StatsAction (cse491_team8::ManualWorld)</li> <li>SaveToFile (group4::SecondWorld)</li> <li>SecondWorld (group4::SecondWorld)</li> <li>SwitchGrid (group4::SecondWorld)</li> <li>saveToFile (group6::BiomeGenerator)</li> <li>setTiles (group6::BiomeGenerator)</li> <li>setWorld (group6::BiomeGenerator)</li> <li>SpikeTileHelper (group6::GenerativeWorld)</li> <li>serialize (siv::BasicPerlinNoise)</li> <li>setVariable (worldlang::ProgramExecutor)</li> <li>skipBlock (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#t","title":"t","text":"<ul> <li>TarTileHelper (group6::GenerativeWorld)</li> <li>TeleporterHelper (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#u","title":"u","text":"<ul> <li>UpdateWorld (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#v","title":"v","text":"<ul> <li>var (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_functions/#_1","title":"~","text":"<ul> <li>~MazeWorld (cse491::MazeWorld)</li> <li>~ManualWorld (cse491_team8::ManualWorld)</li> <li>~SecondWorld (group4::SecondWorld)</li> <li>~BiomeGenerator (group6::BiomeGenerator)</li> <li>~GenerativeWorld (group6::GenerativeWorld)</li> <li>~ProgramExecutor (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#a","title":"a","text":"<ul> <li>agents_filename (group4::SecondWorld)</li> <li>armory_id (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#b","title":"b","text":"<ul> <li>bridge_id (cse491_team8::ManualWorld)</li> <li>biome (group6::BiomeGenerator)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#c","title":"c","text":"<ul> <li>call_stack (worldlang::ProgramExecutor)</li> <li>code (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#d","title":"d","text":"<ul> <li>dirt_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>door_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#e","title":"e","text":"<ul> <li>error_message (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#f","title":"f","text":"<ul> <li>floor_id (cse491::MazeWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>frequency (group6::BiomeGenerator)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#g","title":"g","text":"<ul> <li>grass_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>grid (group6::BiomeGenerator)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#h","title":"h","text":"<ul> <li>height (group6::BiomeGenerator)</li> <li>hole_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#i","title":"i","text":"<ul> <li>inventory (group4::SecondWorld)</li> <li>index (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#k","title":"k","text":"<ul> <li>keyLocation (group6::BiomeGenerator)</li> <li>key_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#m","title":"m","text":"<ul> <li>m_permutation (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#p","title":"p","text":"<ul> <li>portal_id_a (cse491_team8::ManualWorld)</li> <li>portal_id_b (cse491_team8::ManualWorld)</li> <li>portal_id_c (cse491_team8::ManualWorld)</li> <li>portal_id_d (cse491_team8::ManualWorld)</li> <li>pe (group4::SecondWorld)</li> <li>perlinNoise (group6::BiomeGenerator)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#r","title":"r","text":"<ul> <li>rock_id (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#s","title":"s","text":"<ul> <li>sand_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>seed (group6::BiomeGenerator)</li> <li>spike_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>scripts (worldlang::ProgramExecutor)</li> <li>stack (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#t","title":"t","text":"<ul> <li>tree_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>tar_id (group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>tiles (group6::BiomeGenerator)</li> <li>teleporter_id (group6::GenerativeWorld)</li> <li>type (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#v","title":"v","text":"<ul> <li>variables (worldlang::ProgramExecutor)</li> <li>value (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_variables/#w","title":"w","text":"<ul> <li>wall_id (cse491::MazeWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>water_id (cse491_team8::ManualWorld, group6::BiomeGenerator, group6::GenerativeWorld)</li> <li>world_filename (group4::SecondWorld)</li> <li>width (group6::BiomeGenerator)</li> <li>worldPtr (group6::BiomeGenerator)</li> <li>world_height (group6::GenerativeWorld)</li> <li>world_width (group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/#c","title":"c","text":"<ul> <li>Callable (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/#d","title":"d","text":"<ul> <li>default_random_engine (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/#s","title":"s","text":"<ul> <li>seed_type (siv::BasicPerlinNoise)</li> <li>state_type (siv::BasicPerlinNoise)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (siv::BasicPerlinNoise)</li> <li>Value (worldlang::ProgramExecutor)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_enums/","title":"Class Member Enums","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_enums/#a","title":"a","text":"<ul> <li>ActionType (cse491::MazeWorld, cse491_team8::ManualWorld, group4::SecondWorld, group6::GenerativeWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_enums/#f","title":"f","text":"<ul> <li>FacingDirection (cse491_team8::ManualWorld)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/class_member_enums/#t","title":"t","text":"<ul> <li>Type (worldlang::Unit)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/","title":"Namespace Members","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#b","title":"b","text":"<ul> <li>BiomeType (group6)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#c","title":"c","text":"<ul> <li>COMBAT_SCRIPT (group4)</li> <li>Clamp_11 (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#f","title":"f","text":"<ul> <li>FINAL_FLOOR_FILENAME (group4)</li> <li>FIRST_FLOOR_FILENAME (group4)</li> <li>Fade (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#g","title":"g","text":"<ul> <li>Grad (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#i","title":"i","text":"<ul> <li>ITEM_PICKUP_SCRIPT (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#l","title":"l","text":"<ul> <li>Lerp (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#m","title":"m","text":"<ul> <li>MAX_INVENTORY_SIZE (group4)</li> <li>MaxAmplitude (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#o","title":"o","text":"<ul> <li>OffGrid (group4)</li> <li>Octave1D (siv::perlin_detail)</li> <li>Octave2D (siv::perlin_detail)</li> <li>Octave3D (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#p","title":"p","text":"<ul> <li>PerlinNoise (siv)</li> <li>parse_to_code (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#r","title":"r","text":"<ul> <li>Random (siv::perlin_detail)</li> <li>RemapClamp_01 (siv::perlin_detail)</li> <li>Remap_01 (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#s","title":"s","text":"<ul> <li>SECOND_FLOOR_FILENAME (group4)</li> <li>Shuffle (siv::perlin_detail)</li> <li>selector (worldlang)</li> <li>stripWhitespace (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_members/#w","title":"w","text":"<ul> <li>WORLD_LOAD_SCRIPT (group4)</li> <li>WORLD_LOAD_SCRIPT_2 (group4)</li> <li>WORLD_LOAD_SCRIPT_3 (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#c","title":"c","text":"<ul> <li>Clamp_11 (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#f","title":"f","text":"<ul> <li>Fade (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#g","title":"g","text":"<ul> <li>Grad (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#l","title":"l","text":"<ul> <li>Lerp (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#m","title":"m","text":"<ul> <li>MaxAmplitude (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#o","title":"o","text":"<ul> <li>Octave1D (siv::perlin_detail)</li> <li>Octave2D (siv::perlin_detail)</li> <li>Octave3D (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#p","title":"p","text":"<ul> <li>parse_to_code (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#r","title":"r","text":"<ul> <li>Random (siv::perlin_detail)</li> <li>RemapClamp_01 (siv::perlin_detail)</li> <li>Remap_01 (siv::perlin_detail)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_functions/#s","title":"s","text":"<ul> <li>Shuffle (siv::perlin_detail)</li> <li>stripWhitespace (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#c","title":"c","text":"<ul> <li>COMBAT_SCRIPT (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#f","title":"f","text":"<ul> <li>FINAL_FLOOR_FILENAME (group4)</li> <li>FIRST_FLOOR_FILENAME (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#i","title":"i","text":"<ul> <li>ITEM_PICKUP_SCRIPT (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_INVENTORY_SIZE (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#o","title":"o","text":"<ul> <li>OffGrid (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#s","title":"s","text":"<ul> <li>SECOND_FLOOR_FILENAME (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_variables/#w","title":"w","text":"<ul> <li>WORLD_LOAD_SCRIPT (group4)</li> <li>WORLD_LOAD_SCRIPT_2 (group4)</li> <li>WORLD_LOAD_SCRIPT_3 (group4)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>PerlinNoise (siv)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>selector (worldlang)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/namespace_member_enums/#b","title":"b","text":"<ul> <li>BiomeType (group6)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/macros/","title":"Macros","text":""},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/macros/#s","title":"s","text":"<ul> <li>SIVPERLIN_CONCEPT_URBG (PerlinNoise.hpp)</li> <li>SIVPERLIN_CONCEPT_URBG_ (PerlinNoise.hpp)</li> <li>SIVPERLIN_DEFAULT_Y (PerlinNoise.hpp)</li> <li>SIVPERLIN_DEFAULT_Z (PerlinNoise.hpp)</li> <li>SIVPERLIN_NODISCARD_CXX20 (PerlinNoise.hpp)</li> <li>SIVPERLIN_VERSION (PerlinNoise.hpp)</li> <li>SIVPERLIN_VERSION_MAJOR (PerlinNoise.hpp)</li> <li>SIVPERLIN_VERSION_MINOR (PerlinNoise.hpp)</li> <li>SIVPERLIN_VERSION_REVISION (PerlinNoise.hpp)</li> </ul>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Worlds%20%28Group%204%2C%206%2C%208%29/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}